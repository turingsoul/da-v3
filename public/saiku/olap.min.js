/*! jQuery v1.10.2 | (c) 2005, 2013 jQuery Foundation, Inc. | jquery.org/license
//@ sourceMappingURL=jquery-1.10.2.min.map
*/
(function(e, t) {
    var n, r, i = typeof t, o = e.location, a = e.document, s = a.documentElement, l = e.jQuery, u = e.$, c = {}, p = [], f = "1.10.2", d = p.concat, h = p.push, g = p.slice, m = p.indexOf, y = c.toString, v = c.hasOwnProperty, b = f.trim, x = function(e, t) {
        return new x.fn.init(e,t,r)
    }, w = /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source, T = /\S+/g, C = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, N = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]*))$/, k = /^<(\w+)\s*\/?>(?:<\/\1>|)$/, E = /^[\],:{}\s]*$/, S = /(?:^|:|,)(?:\s*\[)+/g, A = /\\(?:["\\\/bfnrt]|u[\da-fA-F]{4})/g, j = /"[^"\\\r\n]*"|true|false|null|-?(?:\d+\.|)\d+(?:[eE][+-]?\d+|)/g, D = /^-ms-/, L = /-([\da-z])/gi, H = function(e, t) {
        return t.toUpperCase()
    }, q = function(e) {
        (a.addEventListener || "load" === e.type || "complete" === a.readyState) && (_(),
        x.ready())
    }, _ = function() {
        a.addEventListener ? (a.removeEventListener("DOMContentLoaded", q, !1),
        e.removeEventListener("load", q, !1)) : (a.detachEvent("onreadystatechange", q),
        e.detachEvent("onload", q))
    };
    x.fn = x.prototype = {
        jquery: f,
        constructor: x,
        init: function(e, n, r) {
            var i, o;
            if (!e)
                return this;
            if ("string" == typeof e) {
                if (i = "<" === e.charAt(0) && ">" === e.charAt(e.length - 1) && e.length >= 3 ? [null, e, null] : N.exec(e),
                !i || !i[1] && n)
                    return !n || n.jquery ? (n || r).find(e) : this.constructor(n).find(e);
                if (i[1]) {
                    if (n = n instanceof x ? n[0] : n,
                    x.merge(this, x.parseHTML(i[1], n && n.nodeType ? n.ownerDocument || n : a, !0)),
                    k.test(i[1]) && x.isPlainObject(n))
                        for (i in n)
                            x.isFunction(this[i]) ? this[i](n[i]) : this.attr(i, n[i]);
                    return this
                }
                if (o = a.getElementById(i[2]),
                o && o.parentNode) {
                    if (o.id !== i[2])
                        return r.find(e);
                    this.length = 1,
                    this[0] = o
                }
                return this.context = a,
                this.selector = e,
                this
            }
            return e.nodeType ? (this.context = this[0] = e,
            this.length = 1,
            this) : x.isFunction(e) ? r.ready(e) : (e.selector !== t && (this.selector = e.selector,
            this.context = e.context),
            x.makeArray(e, this))
        },
        selector: "",
        length: 0,
        toArray: function() {
            return g.call(this)
        },
        get: function(e) {
            return null == e ? this.toArray() : 0 > e ? this[this.length + e] : this[e]
        },
        pushStack: function(e) {
            var t = x.merge(this.constructor(), e);
            return t.prevObject = this,
            t.context = this.context,
            t
        },
        each: function(e, t) {
            return x.each(this, e, t)
        },
        ready: function(e) {
            return x.ready.promise().done(e),
            this
        },
        slice: function() {
            return this.pushStack(g.apply(this, arguments))
        },
        first: function() {
            return this.eq(0)
        },
        last: function() {
            return this.eq(-1)
        },
        eq: function(e) {
            var t = this.length
              , n = +e + (0 > e ? t : 0);
            return this.pushStack(n >= 0 && t > n ? [this[n]] : [])
        },
        map: function(e) {
            return this.pushStack(x.map(this, function(t, n) {
                return e.call(t, n, t)
            }))
        },
        end: function() {
            return this.prevObject || this.constructor(null)
        },
        push: h,
        sort: [].sort,
        splice: [].splice
    },
    x.fn.init.prototype = x.fn,
    x.extend = x.fn.extend = function() {
        var e, n, r, i, o, a, s = arguments[0] || {}, l = 1, u = arguments.length, c = !1;
        for ("boolean" == typeof s && (c = s,
        s = arguments[1] || {},
        l = 2),
        "object" == typeof s || x.isFunction(s) || (s = {}),
        u === l && (s = this,
        --l); u > l; l++)
            if (null != (o = arguments[l]))
                for (i in o)
                    e = s[i],
                    r = o[i],
                    s !== r && (c && r && (x.isPlainObject(r) || (n = x.isArray(r))) ? (n ? (n = !1,
                    a = e && x.isArray(e) ? e : []) : a = e && x.isPlainObject(e) ? e : {},
                    s[i] = x.extend(c, a, r)) : r !== t && (s[i] = r));
        return s
    }
    ,
    x.extend({
        expando: "jQuery" + (f + Math.random()).replace(/\D/g, ""),
        noConflict: function(t) {
            return e.$ === x && (e.$ = u),
            t && e.jQuery === x && (e.jQuery = l),
            x
        },
        isReady: !1,
        readyWait: 1,
        holdReady: function(e) {
            e ? x.readyWait++ : x.ready(!0)
        },
        ready: function(e) {
            if (e === !0 ? !--x.readyWait : !x.isReady) {
                if (!a.body)
                    return setTimeout(x.ready);
                x.isReady = !0,
                e !== !0 && --x.readyWait > 0 || (n.resolveWith(a, [x]),
                x.fn.trigger && x(a).trigger("ready").off("ready"))
            }
        },
        isFunction: function(e) {
            return "function" === x.type(e)
        },
        isArray: Array.isArray || function(e) {
            return "array" === x.type(e)
        }
        ,
        isWindow: function(e) {
            return null != e && e == e.window
        },
        isNumeric: function(e) {
            return !isNaN(parseFloat(e)) && isFinite(e)
        },
        type: function(e) {
            return null == e ? e + "" : "object" == typeof e || "function" == typeof e ? c[y.call(e)] || "object" : typeof e
        },
        isPlainObject: function(e) {
            var n;
            if (!e || "object" !== x.type(e) || e.nodeType || x.isWindow(e))
                return !1;
            try {
                if (e.constructor && !v.call(e, "constructor") && !v.call(e.constructor.prototype, "isPrototypeOf"))
                    return !1
            } catch (r) {
                return !1
            }
            if (x.support.ownLast)
                for (n in e)
                    return v.call(e, n);
            for (n in e)
                ;
            return n === t || v.call(e, n)
        },
        isEmptyObject: function(e) {
            var t;
            for (t in e)
                return !1;
            return !0
        },
        error: function(e) {
            throw Error(e)
        },
        parseHTML: function(e, t, n) {
            if (!e || "string" != typeof e)
                return null;
            "boolean" == typeof t && (n = t,
            t = !1),
            t = t || a;
            var r = k.exec(e)
              , i = !n && [];
            return r ? [t.createElement(r[1])] : (r = x.buildFragment([e], t, i),
            i && x(i).remove(),
            x.merge([], r.childNodes))
        },
        parseJSON: function(n) {
            return e.JSON && e.JSON.parse ? e.JSON.parse(n) : null === n ? n : "string" == typeof n && (n = x.trim(n),
            n && E.test(n.replace(A, "@").replace(j, "]").replace(S, ""))) ? Function("return " + n)() : (x.error("Invalid JSON: " + n),
            t)
        },
        parseXML: function(n) {
            var r, i;
            if (!n || "string" != typeof n)
                return null;
            try {
                e.DOMParser ? (i = new DOMParser,
                r = i.parseFromString(n, "text/xml")) : (r = new ActiveXObject("Microsoft.XMLDOM"),
                r.async = "false",
                r.loadXML(n))
            } catch (o) {
                r = t
            }
            return r && r.documentElement && !r.getElementsByTagName("parsererror").length || x.error("Invalid XML: " + n),
            r
        },
        noop: function() {},
        globalEval: function(t) {
            t && x.trim(t) && (e.execScript || function(t) {
                e.eval.call(e, t)
            }
            )(t)
        },
        camelCase: function(e) {
            return e.replace(D, "ms-").replace(L, H)
        },
        nodeName: function(e, t) {
            return e.nodeName && e.nodeName.toLowerCase() === t.toLowerCase()
        },
        each: function(e, t, n) {
            var r, i = 0, o = e.length, a = M(e);
            if (n) {
                if (a) {
                    for (; o > i; i++)
                        if (r = t.apply(e[i], n),
                        r === !1)
                            break
                } else
                    for (i in e)
                        if (r = t.apply(e[i], n),
                        r === !1)
                            break
            } else if (a) {
                for (; o > i; i++)
                    if (r = t.call(e[i], i, e[i]),
                    r === !1)
                        break
            } else
                for (i in e)
                    if (r = t.call(e[i], i, e[i]),
                    r === !1)
                        break;
            return e
        },
        trim: b && !b.call("\ufeff\u00a0") ? function(e) {
            return null == e ? "" : b.call(e)
        }
        : function(e) {
            return null == e ? "" : (e + "").replace(C, "")
        }
        ,
        makeArray: function(e, t) {
            var n = t || [];
            return null != e && (M(Object(e)) ? x.merge(n, "string" == typeof e ? [e] : e) : h.call(n, e)),
            n
        },
        inArray: function(e, t, n) {
            var r;
            if (t) {
                if (m)
                    return m.call(t, e, n);
                for (r = t.length,
                n = n ? 0 > n ? Math.max(0, r + n) : n : 0; r > n; n++)
                    if (n in t && t[n] === e)
                        return n
            }
            return -1
        },
        merge: function(e, n) {
            var r = n.length
              , i = e.length
              , o = 0;
            if ("number" == typeof r)
                for (; r > o; o++)
                    e[i++] = n[o];
            else
                while (n[o] !== t)
                    e[i++] = n[o++];
            return e.length = i,
            e
        },
        grep: function(e, t, n) {
            var r, i = [], o = 0, a = e.length;
            for (n = !!n; a > o; o++)
                r = !!t(e[o], o),
                n !== r && i.push(e[o]);
            return i
        },
        map: function(e, t, n) {
            var r, i = 0, o = e.length, a = M(e), s = [];
            if (a)
                for (; o > i; i++)
                    r = t(e[i], i, n),
                    null != r && (s[s.length] = r);
            else
                for (i in e)
                    r = t(e[i], i, n),
                    null != r && (s[s.length] = r);
            return d.apply([], s)
        },
        guid: 1,
        proxy: function(e, n) {
            var r, i, o;
            return "string" == typeof n && (o = e[n],
            n = e,
            e = o),
            x.isFunction(e) ? (r = g.call(arguments, 2),
            i = function() {
                return e.apply(n || this, r.concat(g.call(arguments)))
            }
            ,
            i.guid = e.guid = e.guid || x.guid++,
            i) : t
        },
        access: function(e, n, r, i, o, a, s) {
            var l = 0
              , u = e.length
              , c = null == r;
            if ("object" === x.type(r)) {
                o = !0;
                for (l in r)
                    x.access(e, n, l, r[l], !0, a, s)
            } else if (i !== t && (o = !0,
            x.isFunction(i) || (s = !0),
            c && (s ? (n.call(e, i),
            n = null) : (c = n,
            n = function(e, t, n) {
                return c.call(x(e), n)
            }
            )),
            n))
                for (; u > l; l++)
                    n(e[l], r, s ? i : i.call(e[l], l, n(e[l], r)));
            return o ? e : c ? n.call(e) : u ? n(e[0], r) : a
        },
        now: function() {
            return (new Date).getTime()
        },
        swap: function(e, t, n, r) {
            var i, o, a = {};
            for (o in t)
                a[o] = e.style[o],
                e.style[o] = t[o];
            i = n.apply(e, r || []);
            for (o in t)
                e.style[o] = a[o];
            return i
        }
    }),
    x.ready.promise = function(t) {
        if (!n)
            if (n = x.Deferred(),
            "complete" === a.readyState)
                setTimeout(x.ready);
            else if (a.addEventListener)
                a.addEventListener("DOMContentLoaded", q, !1),
                e.addEventListener("load", q, !1);
            else {
                a.attachEvent("onreadystatechange", q),
                e.attachEvent("onload", q);
                var r = !1;
                try {
                    r = null == e.frameElement && a.documentElement
                } catch (i) {}
                r && r.doScroll && function o() {
                    if (!x.isReady) {
                        try {
                            r.doScroll("left")
                        } catch (e) {
                            return setTimeout(o, 50)
                        }
                        _(),
                        x.ready()
                    }
                }()
            }
        return n.promise(t)
    }
    ,
    x.each("Boolean Number String Function Array Date RegExp Object Error".split(" "), function(e, t) {
        c["[object " + t + "]"] = t.toLowerCase()
    });
    function M(e) {
        var t = e.length
          , n = x.type(e);
        return x.isWindow(e) ? !1 : 1 === e.nodeType && t ? !0 : "array" === n || "function" !== n && (0 === t || "number" == typeof t && t > 0 && t - 1 in e)
    }
    r = x(a),
    function(e, t) {
        var n, r, i, o, a, s, l, u, c, p, f, d, h, g, m, y, v, b = "sizzle" + -new Date, w = e.document, T = 0, C = 0, N = st(), k = st(), E = st(), S = !1, A = function(e, t) {
            return e === t ? (S = !0,
            0) : 0
        }, j = typeof t, D = 1 << 31, L = {}.hasOwnProperty, H = [], q = H.pop, _ = H.push, M = H.push, O = H.slice, F = H.indexOf || function(e) {
            var t = 0
              , n = this.length;
            for (; n > t; t++)
                if (this[t] === e)
                    return t;
            return -1
        }
        , B = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped", P = "[\\x20\\t\\r\\n\\f]", R = "(?:\\\\.|[\\w-]|[^\\x00-\\xa0])+", W = R.replace("w", "w#"), $ = "\\[" + P + "*(" + R + ")" + P + "*(?:([*^$|!~]?=)" + P + "*(?:(['\"])((?:\\\\.|[^\\\\])*?)\\3|(" + W + ")|)|)" + P + "*\\]", I = ":(" + R + ")(?:\\(((['\"])((?:\\\\.|[^\\\\])*?)\\3|((?:\\\\.|[^\\\\()[\\]]|" + $.replace(3, 8) + ")*)|.*)\\)|)", z = RegExp("^" + P + "+|((?:^|[^\\\\])(?:\\\\.)*)" + P + "+$", "g"), X = RegExp("^" + P + "*," + P + "*"), U = RegExp("^" + P + "*([>+~]|" + P + ")" + P + "*"), V = RegExp(P + "*[+~]"), Y = RegExp("=" + P + "*([^\\]'\"]*)" + P + "*\\]", "g"), J = RegExp(I), G = RegExp("^" + W + "$"), Q = {
            ID: RegExp("^#(" + R + ")"),
            CLASS: RegExp("^\\.(" + R + ")"),
            TAG: RegExp("^(" + R.replace("w", "w*") + ")"),
            ATTR: RegExp("^" + $),
            PSEUDO: RegExp("^" + I),
            CHILD: RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + P + "*(even|odd|(([+-]|)(\\d*)n|)" + P + "*(?:([+-]|)" + P + "*(\\d+)|))" + P + "*\\)|)", "i"),
            bool: RegExp("^(?:" + B + ")$", "i"),
            needsContext: RegExp("^" + P + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" + P + "*((?:-\\d)?\\d*)" + P + "*\\)|)(?=[^-]|$)", "i")
        }, K = /^[^{]+\{\s*\[native \w/, Z = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/, et = /^(?:input|select|textarea|button)$/i, tt = /^h\d$/i, nt = /'|\\/g, rt = RegExp("\\\\([\\da-f]{1,6}" + P + "?|(" + P + ")|.)", "ig"), it = function(e, t, n) {
            var r = "0x" + t - 65536;
            return r !== r || n ? t : 0 > r ? String.fromCharCode(r + 65536) : String.fromCharCode(55296 | r >> 10, 56320 | 1023 & r)
        };
        try {
            M.apply(H = O.call(w.childNodes), w.childNodes),
            H[w.childNodes.length].nodeType
        } catch (ot) {
            M = {
                apply: H.length ? function(e, t) {
                    _.apply(e, O.call(t))
                }
                : function(e, t) {
                    var n = e.length
                      , r = 0;
                    while (e[n++] = t[r++])
                        ;
                    e.length = n - 1
                }
            }
        }
        function at(e, t, n, i) {
            var o, a, s, l, u, c, d, m, y, x;
            if ((t ? t.ownerDocument || t : w) !== f && p(t),
            t = t || f,
            n = n || [],
            !e || "string" != typeof e)
                return n;
            if (1 !== (l = t.nodeType) && 9 !== l)
                return [];
            if (h && !i) {
                if (o = Z.exec(e))
                    if (s = o[1]) {
                        if (9 === l) {
                            if (a = t.getElementById(s),
                            !a || !a.parentNode)
                                return n;
                            if (a.id === s)
                                return n.push(a),
                                n
                        } else if (t.ownerDocument && (a = t.ownerDocument.getElementById(s)) && v(t, a) && a.id === s)
                            return n.push(a),
                            n
                    } else {
                        if (o[2])
                            return M.apply(n, t.getElementsByTagName(e)),
                            n;
                        if ((s = o[3]) && r.getElementsByClassName && t.getElementsByClassName)
                            return M.apply(n, t.getElementsByClassName(s)),
                            n
                    }
                if (r.qsa && (!g || !g.test(e))) {
                    if (m = d = b,
                    y = t,
                    x = 9 === l && e,
                    1 === l && "object" !== t.nodeName.toLowerCase()) {
                        c = mt(e),
                        (d = t.getAttribute("id")) ? m = d.replace(nt, "\\$&") : t.setAttribute("id", m),
                        m = "[id='" + m + "'] ",
                        u = c.length;
                        while (u--)
                            c[u] = m + yt(c[u]);
                        y = V.test(e) && t.parentNode || t,
                        x = c.join(",")
                    }
                    if (x)
                        try {
                            return M.apply(n, y.querySelectorAll(x)),
                            n
                        } catch (T) {} finally {
                            d || t.removeAttribute("id")
                        }
                }
            }
            return kt(e.replace(z, "$1"), t, n, i)
        }
        function st() {
            var e = [];
            function t(n, r) {
                return e.push(n += " ") > o.cacheLength && delete t[e.shift()],
                t[n] = r
            }
            return t
        }
        function lt(e) {
            return e[b] = !0,
            e
        }
        function ut(e) {
            var t = f.createElement("div");
            try {
                return !!e(t)
            } catch (n) {
                return !1
            } finally {
                t.parentNode && t.parentNode.removeChild(t),
                t = null
            }
        }
        function ct(e, t) {
            var n = e.split("|")
              , r = e.length;
            while (r--)
                o.attrHandle[n[r]] = t
        }
        function pt(e, t) {
            var n = t && e
              , r = n && 1 === e.nodeType && 1 === t.nodeType && (~t.sourceIndex || D) - (~e.sourceIndex || D);
            if (r)
                return r;
            if (n)
                while (n = n.nextSibling)
                    if (n === t)
                        return -1;
            return e ? 1 : -1
        }
        function ft(e) {
            return function(t) {
                var n = t.nodeName.toLowerCase();
                return "input" === n && t.type === e
            }
        }
        function dt(e) {
            return function(t) {
                var n = t.nodeName.toLowerCase();
                return ("input" === n || "button" === n) && t.type === e
            }
        }
        function ht(e) {
            return lt(function(t) {
                return t = +t,
                lt(function(n, r) {
                    var i, o = e([], n.length, t), a = o.length;
                    while (a--)
                        n[i = o[a]] && (n[i] = !(r[i] = n[i]))
                })
            })
        }
        s = at.isXML = function(e) {
            var t = e && (e.ownerDocument || e).documentElement;
            return t ? "HTML" !== t.nodeName : !1
        }
        ,
        r = at.support = {},
        p = at.setDocument = function(e) {
            var n = e ? e.ownerDocument || e : w
              , i = n.defaultView;
            return n !== f && 9 === n.nodeType && n.documentElement ? (f = n,
            d = n.documentElement,
            h = !s(n),
            i && i.attachEvent && i !== i.top && i.attachEvent("onbeforeunload", function() {
                p()
            }),
            r.attributes = ut(function(e) {
                return e.className = "i",
                !e.getAttribute("className")
            }),
            r.getElementsByTagName = ut(function(e) {
                return e.appendChild(n.createComment("")),
                !e.getElementsByTagName("*").length
            }),
            r.getElementsByClassName = ut(function(e) {
                return e.innerHTML = "<div class='a'></div><div class='a i'></div>",
                e.firstChild.className = "i",
                2 === e.getElementsByClassName("i").length
            }),
            r.getById = ut(function(e) {
                return d.appendChild(e).id = b,
                !n.getElementsByName || !n.getElementsByName(b).length
            }),
            r.getById ? (o.find.ID = function(e, t) {
                if (typeof t.getElementById !== j && h) {
                    var n = t.getElementById(e);
                    return n && n.parentNode ? [n] : []
                }
            }
            ,
            o.filter.ID = function(e) {
                var t = e.replace(rt, it);
                return function(e) {
                    return e.getAttribute("id") === t
                }
            }
            ) : (delete o.find.ID,
            o.filter.ID = function(e) {
                var t = e.replace(rt, it);
                return function(e) {
                    var n = typeof e.getAttributeNode !== j && e.getAttributeNode("id");
                    return n && n.value === t
                }
            }
            ),
            o.find.TAG = r.getElementsByTagName ? function(e, n) {
                return typeof n.getElementsByTagName !== j ? n.getElementsByTagName(e) : t
            }
            : function(e, t) {
                var n, r = [], i = 0, o = t.getElementsByTagName(e);
                if ("*" === e) {
                    while (n = o[i++])
                        1 === n.nodeType && r.push(n);
                    return r
                }
                return o
            }
            ,
            o.find.CLASS = r.getElementsByClassName && function(e, n) {
                return typeof n.getElementsByClassName !== j && h ? n.getElementsByClassName(e) : t
            }
            ,
            m = [],
            g = [],
            (r.qsa = K.test(n.querySelectorAll)) && (ut(function(e) {
                e.innerHTML = "<select><option selected=''></option></select>",
                e.querySelectorAll("[selected]").length || g.push("\\[" + P + "*(?:value|" + B + ")"),
                e.querySelectorAll(":checked").length || g.push(":checked")
            }),
            ut(function(e) {
                var t = n.createElement("input");
                t.setAttribute("type", "hidden"),
                e.appendChild(t).setAttribute("t", ""),
                e.querySelectorAll("[t^='']").length && g.push("[*^$]=" + P + "*(?:''|\"\")"),
                e.querySelectorAll(":enabled").length || g.push(":enabled", ":disabled"),
                e.querySelectorAll("*,:x"),
                g.push(",.*:")
            })),
            (r.matchesSelector = K.test(y = d.webkitMatchesSelector || d.mozMatchesSelector || d.oMatchesSelector || d.msMatchesSelector)) && ut(function(e) {
                r.disconnectedMatch = y.call(e, "div"),
                y.call(e, "[s!='']:x"),
                m.push("!=", I)
            }),
            g = g.length && RegExp(g.join("|")),
            m = m.length && RegExp(m.join("|")),
            v = K.test(d.contains) || d.compareDocumentPosition ? function(e, t) {
                var n = 9 === e.nodeType ? e.documentElement : e
                  , r = t && t.parentNode;
                return e === r || !(!r || 1 !== r.nodeType || !(n.contains ? n.contains(r) : e.compareDocumentPosition && 16 & e.compareDocumentPosition(r)))
            }
            : function(e, t) {
                if (t)
                    while (t = t.parentNode)
                        if (t === e)
                            return !0;
                return !1
            }
            ,
            A = d.compareDocumentPosition ? function(e, t) {
                if (e === t)
                    return S = !0,
                    0;
                var i = t.compareDocumentPosition && e.compareDocumentPosition && e.compareDocumentPosition(t);
                return i ? 1 & i || !r.sortDetached && t.compareDocumentPosition(e) === i ? e === n || v(w, e) ? -1 : t === n || v(w, t) ? 1 : c ? F.call(c, e) - F.call(c, t) : 0 : 4 & i ? -1 : 1 : e.compareDocumentPosition ? -1 : 1
            }
            : function(e, t) {
                var r, i = 0, o = e.parentNode, a = t.parentNode, s = [e], l = [t];
                if (e === t)
                    return S = !0,
                    0;
                if (!o || !a)
                    return e === n ? -1 : t === n ? 1 : o ? -1 : a ? 1 : c ? F.call(c, e) - F.call(c, t) : 0;
                if (o === a)
                    return pt(e, t);
                r = e;
                while (r = r.parentNode)
                    s.unshift(r);
                r = t;
                while (r = r.parentNode)
                    l.unshift(r);
                while (s[i] === l[i])
                    i++;
                return i ? pt(s[i], l[i]) : s[i] === w ? -1 : l[i] === w ? 1 : 0
            }
            ,
            n) : f
        }
        ,
        at.matches = function(e, t) {
            return at(e, null, null, t)
        }
        ,
        at.matchesSelector = function(e, t) {
            if ((e.ownerDocument || e) !== f && p(e),
            t = t.replace(Y, "='$1']"),
            !(!r.matchesSelector || !h || m && m.test(t) || g && g.test(t)))
                try {
                    var n = y.call(e, t);
                    if (n || r.disconnectedMatch || e.document && 11 !== e.document.nodeType)
                        return n
                } catch (i) {}
            return at(t, f, null, [e]).length > 0
        }
        ,
        at.contains = function(e, t) {
            return (e.ownerDocument || e) !== f && p(e),
            v(e, t)
        }
        ,
        at.attr = function(e, n) {
            (e.ownerDocument || e) !== f && p(e);
            var i = o.attrHandle[n.toLowerCase()]
              , a = i && L.call(o.attrHandle, n.toLowerCase()) ? i(e, n, !h) : t;
            return a === t ? r.attributes || !h ? e.getAttribute(n) : (a = e.getAttributeNode(n)) && a.specified ? a.value : null : a
        }
        ,
        at.error = function(e) {
            throw Error("Syntax error, unrecognized expression: " + e)
        }
        ,
        at.uniqueSort = function(e) {
            var t, n = [], i = 0, o = 0;
            if (S = !r.detectDuplicates,
            c = !r.sortStable && e.slice(0),
            e.sort(A),
            S) {
                while (t = e[o++])
                    t === e[o] && (i = n.push(o));
                while (i--)
                    e.splice(n[i], 1)
            }
            return e
        }
        ,
        a = at.getText = function(e) {
            var t, n = "", r = 0, i = e.nodeType;
            if (i) {
                if (1 === i || 9 === i || 11 === i) {
                    if ("string" == typeof e.textContent)
                        return e.textContent;
                    for (e = e.firstChild; e; e = e.nextSibling)
                        n += a(e)
                } else if (3 === i || 4 === i)
                    return e.nodeValue
            } else
                for (; t = e[r]; r++)
                    n += a(t);
            return n
        }
        ,
        o = at.selectors = {
            cacheLength: 50,
            createPseudo: lt,
            match: Q,
            attrHandle: {},
            find: {},
            relative: {
                ">": {
                    dir: "parentNode",
                    first: !0
                },
                " ": {
                    dir: "parentNode"
                },
                "+": {
                    dir: "previousSibling",
                    first: !0
                },
                "~": {
                    dir: "previousSibling"
                }
            },
            preFilter: {
                ATTR: function(e) {
                    return e[1] = e[1].replace(rt, it),
                    e[3] = (e[4] || e[5] || "").replace(rt, it),
                    "~=" === e[2] && (e[3] = " " + e[3] + " "),
                    e.slice(0, 4)
                },
                CHILD: function(e) {
                    return e[1] = e[1].toLowerCase(),
                    "nth" === e[1].slice(0, 3) ? (e[3] || at.error(e[0]),
                    e[4] = +(e[4] ? e[5] + (e[6] || 1) : 2 * ("even" === e[3] || "odd" === e[3])),
                    e[5] = +(e[7] + e[8] || "odd" === e[3])) : e[3] && at.error(e[0]),
                    e
                },
                PSEUDO: function(e) {
                    var n, r = !e[5] && e[2];
                    return Q.CHILD.test(e[0]) ? null : (e[3] && e[4] !== t ? e[2] = e[4] : r && J.test(r) && (n = mt(r, !0)) && (n = r.indexOf(")", r.length - n) - r.length) && (e[0] = e[0].slice(0, n),
                    e[2] = r.slice(0, n)),
                    e.slice(0, 3))
                }
            },
            filter: {
                TAG: function(e) {
                    var t = e.replace(rt, it).toLowerCase();
                    return "*" === e ? function() {
                        return !0
                    }
                    : function(e) {
                        return e.nodeName && e.nodeName.toLowerCase() === t
                    }
                },
                CLASS: function(e) {
                    var t = N[e + " "];
                    return t || (t = RegExp("(^|" + P + ")" + e + "(" + P + "|$)")) && N(e, function(e) {
                        return t.test("string" == typeof e.className && e.className || typeof e.getAttribute !== j && e.getAttribute("class") || "")
                    })
                },
                ATTR: function(e, t, n) {
                    return function(r) {
                        var i = at.attr(r, e);
                        return null == i ? "!=" === t : t ? (i += "",
                        "=" === t ? i === n : "!=" === t ? i !== n : "^=" === t ? n && 0 === i.indexOf(n) : "*=" === t ? n && i.indexOf(n) > -1 : "$=" === t ? n && i.slice(-n.length) === n : "~=" === t ? (" " + i + " ").indexOf(n) > -1 : "|=" === t ? i === n || i.slice(0, n.length + 1) === n + "-" : !1) : !0
                    }
                },
                CHILD: function(e, t, n, r, i) {
                    var o = "nth" !== e.slice(0, 3)
                      , a = "last" !== e.slice(-4)
                      , s = "of-type" === t;
                    return 1 === r && 0 === i ? function(e) {
                        return !!e.parentNode
                    }
                    : function(t, n, l) {
                        var u, c, p, f, d, h, g = o !== a ? "nextSibling" : "previousSibling", m = t.parentNode, y = s && t.nodeName.toLowerCase(), v = !l && !s;
                        if (m) {
                            if (o) {
                                while (g) {
                                    p = t;
                                    while (p = p[g])
                                        if (s ? p.nodeName.toLowerCase() === y : 1 === p.nodeType)
                                            return !1;
                                    h = g = "only" === e && !h && "nextSibling"
                                }
                                return !0
                            }
                            if (h = [a ? m.firstChild : m.lastChild],
                            a && v) {
                                c = m[b] || (m[b] = {}),
                                u = c[e] || [],
                                d = u[0] === T && u[1],
                                f = u[0] === T && u[2],
                                p = d && m.childNodes[d];
                                while (p = ++d && p && p[g] || (f = d = 0) || h.pop())
                                    if (1 === p.nodeType && ++f && p === t) {
                                        c[e] = [T, d, f];
                                        break
                                    }
                            } else if (v && (u = (t[b] || (t[b] = {}))[e]) && u[0] === T)
                                f = u[1];
                            else
                                while (p = ++d && p && p[g] || (f = d = 0) || h.pop())
                                    if ((s ? p.nodeName.toLowerCase() === y : 1 === p.nodeType) && ++f && (v && ((p[b] || (p[b] = {}))[e] = [T, f]),
                                    p === t))
                                        break;
                            return f -= i,
                            f === r || 0 === f % r && f / r >= 0
                        }
                    }
                },
                PSEUDO: function(e, t) {
                    var n, r = o.pseudos[e] || o.setFilters[e.toLowerCase()] || at.error("unsupported pseudo: " + e);
                    return r[b] ? r(t) : r.length > 1 ? (n = [e, e, "", t],
                    o.setFilters.hasOwnProperty(e.toLowerCase()) ? lt(function(e, n) {
                        var i, o = r(e, t), a = o.length;
                        while (a--)
                            i = F.call(e, o[a]),
                            e[i] = !(n[i] = o[a])
                    }) : function(e) {
                        return r(e, 0, n)
                    }
                    ) : r
                }
            },
            pseudos: {
                not: lt(function(e) {
                    var t = []
                      , n = []
                      , r = l(e.replace(z, "$1"));
                    return r[b] ? lt(function(e, t, n, i) {
                        var o, a = r(e, null, i, []), s = e.length;
                        while (s--)
                            (o = a[s]) && (e[s] = !(t[s] = o))
                    }) : function(e, i, o) {
                        return t[0] = e,
                        r(t, null, o, n),
                        !n.pop()
                    }
                }),
                has: lt(function(e) {
                    return function(t) {
                        return at(e, t).length > 0
                    }
                }),
                contains: lt(function(e) {
                    return function(t) {
                        return (t.textContent || t.innerText || a(t)).indexOf(e) > -1
                    }
                }),
                lang: lt(function(e) {
                    return G.test(e || "") || at.error("unsupported lang: " + e),
                    e = e.replace(rt, it).toLowerCase(),
                    function(t) {
                        var n;
                        do
                            if (n = h ? t.lang : t.getAttribute("xml:lang") || t.getAttribute("lang"))
                                return n = n.toLowerCase(),
                                n === e || 0 === n.indexOf(e + "-");
                        while ((t = t.parentNode) && 1 === t.nodeType);return !1
                    }
                }),
                target: function(t) {
                    var n = e.location && e.location.hash;
                    return n && n.slice(1) === t.id
                },
                root: function(e) {
                    return e === d
                },
                focus: function(e) {
                    return e === f.activeElement && (!f.hasFocus || f.hasFocus()) && !!(e.type || e.href || ~e.tabIndex)
                },
                enabled: function(e) {
                    return e.disabled === !1
                },
                disabled: function(e) {
                    return e.disabled === !0
                },
                checked: function(e) {
                    var t = e.nodeName.toLowerCase();
                    return "input" === t && !!e.checked || "option" === t && !!e.selected
                },
                selected: function(e) {
                    return e.parentNode && e.parentNode.selectedIndex,
                    e.selected === !0
                },
                empty: function(e) {
                    for (e = e.firstChild; e; e = e.nextSibling)
                        if (e.nodeName > "@" || 3 === e.nodeType || 4 === e.nodeType)
                            return !1;
                    return !0
                },
                parent: function(e) {
                    return !o.pseudos.empty(e)
                },
                header: function(e) {
                    return tt.test(e.nodeName)
                },
                input: function(e) {
                    return et.test(e.nodeName)
                },
                button: function(e) {
                    var t = e.nodeName.toLowerCase();
                    return "input" === t && "button" === e.type || "button" === t
                },
                text: function(e) {
                    var t;
                    return "input" === e.nodeName.toLowerCase() && "text" === e.type && (null == (t = e.getAttribute("type")) || t.toLowerCase() === e.type)
                },
                first: ht(function() {
                    return [0]
                }),
                last: ht(function(e, t) {
                    return [t - 1]
                }),
                eq: ht(function(e, t, n) {
                    return [0 > n ? n + t : n]
                }),
                even: ht(function(e, t) {
                    var n = 0;
                    for (; t > n; n += 2)
                        e.push(n);
                    return e
                }),
                odd: ht(function(e, t) {
                    var n = 1;
                    for (; t > n; n += 2)
                        e.push(n);
                    return e
                }),
                lt: ht(function(e, t, n) {
                    var r = 0 > n ? n + t : n;
                    for (; --r >= 0; )
                        e.push(r);
                    return e
                }),
                gt: ht(function(e, t, n) {
                    var r = 0 > n ? n + t : n;
                    for (; t > ++r; )
                        e.push(r);
                    return e
                })
            }
        },
        o.pseudos.nth = o.pseudos.eq;
        for (n in {
            radio: !0,
            checkbox: !0,
            file: !0,
            password: !0,
            image: !0
        })
            o.pseudos[n] = ft(n);
        for (n in {
            submit: !0,
            reset: !0
        })
            o.pseudos[n] = dt(n);
        function gt() {}
        gt.prototype = o.filters = o.pseudos,
        o.setFilters = new gt;
        function mt(e, t) {
            var n, r, i, a, s, l, u, c = k[e + " "];
            if (c)
                return t ? 0 : c.slice(0);
            s = e,
            l = [],
            u = o.preFilter;
            while (s) {
                (!n || (r = X.exec(s))) && (r && (s = s.slice(r[0].length) || s),
                l.push(i = [])),
                n = !1,
                (r = U.exec(s)) && (n = r.shift(),
                i.push({
                    value: n,
                    type: r[0].replace(z, " ")
                }),
                s = s.slice(n.length));
                for (a in o.filter)
                    !(r = Q[a].exec(s)) || u[a] && !(r = u[a](r)) || (n = r.shift(),
                    i.push({
                        value: n,
                        type: a,
                        matches: r
                    }),
                    s = s.slice(n.length));
                if (!n)
                    break
            }
            return t ? s.length : s ? at.error(e) : k(e, l).slice(0)
        }
        function yt(e) {
            var t = 0
              , n = e.length
              , r = "";
            for (; n > t; t++)
                r += e[t].value;
            return r
        }
        function vt(e, t, n) {
            var r = t.dir
              , o = n && "parentNode" === r
              , a = C++;
            return t.first ? function(t, n, i) {
                while (t = t[r])
                    if (1 === t.nodeType || o)
                        return e(t, n, i)
            }
            : function(t, n, s) {
                var l, u, c, p = T + " " + a;
                if (s) {
                    while (t = t[r])
                        if ((1 === t.nodeType || o) && e(t, n, s))
                            return !0
                } else
                    while (t = t[r])
                        if (1 === t.nodeType || o)
                            if (c = t[b] || (t[b] = {}),
                            (u = c[r]) && u[0] === p) {
                                if ((l = u[1]) === !0 || l === i)
                                    return l === !0
                            } else if (u = c[r] = [p],
                            u[1] = e(t, n, s) || i,
                            u[1] === !0)
                                return !0
            }
        }
        function bt(e) {
            return e.length > 1 ? function(t, n, r) {
                var i = e.length;
                while (i--)
                    if (!e[i](t, n, r))
                        return !1;
                return !0
            }
            : e[0]
        }
        function xt(e, t, n, r, i) {
            var o, a = [], s = 0, l = e.length, u = null != t;
            for (; l > s; s++)
                (o = e[s]) && (!n || n(o, r, i)) && (a.push(o),
                u && t.push(s));
            return a
        }
        function wt(e, t, n, r, i, o) {
            return r && !r[b] && (r = wt(r)),
            i && !i[b] && (i = wt(i, o)),
            lt(function(o, a, s, l) {
                var u, c, p, f = [], d = [], h = a.length, g = o || Nt(t || "*", s.nodeType ? [s] : s, []), m = !e || !o && t ? g : xt(g, f, e, s, l), y = n ? i || (o ? e : h || r) ? [] : a : m;
                if (n && n(m, y, s, l),
                r) {
                    u = xt(y, d),
                    r(u, [], s, l),
                    c = u.length;
                    while (c--)
                        (p = u[c]) && (y[d[c]] = !(m[d[c]] = p))
                }
                if (o) {
                    if (i || e) {
                        if (i) {
                            u = [],
                            c = y.length;
                            while (c--)
                                (p = y[c]) && u.push(m[c] = p);
                            i(null, y = [], u, l)
                        }
                        c = y.length;
                        while (c--)
                            (p = y[c]) && (u = i ? F.call(o, p) : f[c]) > -1 && (o[u] = !(a[u] = p))
                    }
                } else
                    y = xt(y === a ? y.splice(h, y.length) : y),
                    i ? i(null, a, y, l) : M.apply(a, y)
            })
        }
        function Tt(e) {
            var t, n, r, i = e.length, a = o.relative[e[0].type], s = a || o.relative[" "], l = a ? 1 : 0, c = vt(function(e) {
                return e === t
            }, s, !0), p = vt(function(e) {
                return F.call(t, e) > -1
            }, s, !0), f = [function(e, n, r) {
                return !a && (r || n !== u) || ((t = n).nodeType ? c(e, n, r) : p(e, n, r))
            }
            ];
            for (; i > l; l++)
                if (n = o.relative[e[l].type])
                    f = [vt(bt(f), n)];
                else {
                    if (n = o.filter[e[l].type].apply(null, e[l].matches),
                    n[b]) {
                        for (r = ++l; i > r; r++)
                            if (o.relative[e[r].type])
                                break;
                        return wt(l > 1 && bt(f), l > 1 && yt(e.slice(0, l - 1).concat({
                            value: " " === e[l - 2].type ? "*" : ""
                        })).replace(z, "$1"), n, r > l && Tt(e.slice(l, r)), i > r && Tt(e = e.slice(r)), i > r && yt(e))
                    }
                    f.push(n)
                }
            return bt(f)
        }
        function Ct(e, t) {
            var n = 0
              , r = t.length > 0
              , a = e.length > 0
              , s = function(s, l, c, p, d) {
                var h, g, m, y = [], v = 0, b = "0", x = s && [], w = null != d, C = u, N = s || a && o.find.TAG("*", d && l.parentNode || l), k = T += null == C ? 1 : Math.random() || .1;
                for (w && (u = l !== f && l,
                i = n); null != (h = N[b]); b++) {
                    if (a && h) {
                        g = 0;
                        while (m = e[g++])
                            if (m(h, l, c)) {
                                p.push(h);
                                break
                            }
                        w && (T = k,
                        i = ++n)
                    }
                    r && ((h = !m && h) && v--,
                    s && x.push(h))
                }
                if (v += b,
                r && b !== v) {
                    g = 0;
                    while (m = t[g++])
                        m(x, y, l, c);
                    if (s) {
                        if (v > 0)
                            while (b--)
                                x[b] || y[b] || (y[b] = q.call(p));
                        y = xt(y)
                    }
                    M.apply(p, y),
                    w && !s && y.length > 0 && v + t.length > 1 && at.uniqueSort(p)
                }
                return w && (T = k,
                u = C),
                x
            };
            return r ? lt(s) : s
        }
        l = at.compile = function(e, t) {
            var n, r = [], i = [], o = E[e + " "];
            if (!o) {
                t || (t = mt(e)),
                n = t.length;
                while (n--)
                    o = Tt(t[n]),
                    o[b] ? r.push(o) : i.push(o);
                o = E(e, Ct(i, r))
            }
            return o
        }
        ;
        function Nt(e, t, n) {
            var r = 0
              , i = t.length;
            for (; i > r; r++)
                at(e, t[r], n);
            return n
        }
        function kt(e, t, n, i) {
            var a, s, u, c, p, f = mt(e);
            if (!i && 1 === f.length) {
                if (s = f[0] = f[0].slice(0),
                s.length > 2 && "ID" === (u = s[0]).type && r.getById && 9 === t.nodeType && h && o.relative[s[1].type]) {
                    if (t = (o.find.ID(u.matches[0].replace(rt, it), t) || [])[0],
                    !t)
                        return n;
                    e = e.slice(s.shift().value.length)
                }
                a = Q.needsContext.test(e) ? 0 : s.length;
                while (a--) {
                    if (u = s[a],
                    o.relative[c = u.type])
                        break;
                    if ((p = o.find[c]) && (i = p(u.matches[0].replace(rt, it), V.test(s[0].type) && t.parentNode || t))) {
                        if (s.splice(a, 1),
                        e = i.length && yt(s),
                        !e)
                            return M.apply(n, i),
                            n;
                        break
                    }
                }
            }
            return l(e, f)(i, t, !h, n, V.test(e)),
            n
        }
        r.sortStable = b.split("").sort(A).join("") === b,
        r.detectDuplicates = S,
        p(),
        r.sortDetached = ut(function(e) {
            return 1 & e.compareDocumentPosition(f.createElement("div"))
        }),
        ut(function(e) {
            return e.innerHTML = "<a href='#'></a>",
            "#" === e.firstChild.getAttribute("href")
        }) || ct("type|href|height|width", function(e, n, r) {
            return r ? t : e.getAttribute(n, "type" === n.toLowerCase() ? 1 : 2)
        }),
        r.attributes && ut(function(e) {
            return e.innerHTML = "<input/>",
            e.firstChild.setAttribute("value", ""),
            "" === e.firstChild.getAttribute("value")
        }) || ct("value", function(e, n, r) {
            return r || "input" !== e.nodeName.toLowerCase() ? t : e.defaultValue
        }),
        ut(function(e) {
            return null == e.getAttribute("disabled")
        }) || ct(B, function(e, n, r) {
            var i;
            return r ? t : (i = e.getAttributeNode(n)) && i.specified ? i.value : e[n] === !0 ? n.toLowerCase() : null
        }),
        x.find = at,
        x.expr = at.selectors,
        x.expr[":"] = x.expr.pseudos,
        x.unique = at.uniqueSort,
        x.text = at.getText,
        x.isXMLDoc = at.isXML,
        x.contains = at.contains
    }(e);
    var O = {};
    function F(e) {
        var t = O[e] = {};
        return x.each(e.match(T) || [], function(e, n) {
            t[n] = !0
        }),
        t
    }
    x.Callbacks = function(e) {
        e = "string" == typeof e ? O[e] || F(e) : x.extend({}, e);
        var n, r, i, o, a, s, l = [], u = !e.once && [], c = function(t) {
            for (r = e.memory && t,
            i = !0,
            a = s || 0,
            s = 0,
            o = l.length,
            n = !0; l && o > a; a++)
                if (l[a].apply(t[0], t[1]) === !1 && e.stopOnFalse) {
                    r = !1;
                    break
                }
            n = !1,
            l && (u ? u.length && c(u.shift()) : r ? l = [] : p.disable())
        }, p = {
            add: function() {
                if (l) {
                    var t = l.length;
                    (function i(t) {
                        x.each(t, function(t, n) {
                            var r = x.type(n);
                            "function" === r ? e.unique && p.has(n) || l.push(n) : n && n.length && "string" !== r && i(n)
                        })
                    }
                    )(arguments),
                    n ? o = l.length : r && (s = t,
                    c(r))
                }
                return this
            },
            remove: function() {
                return l && x.each(arguments, function(e, t) {
                    var r;
                    while ((r = x.inArray(t, l, r)) > -1)
                        l.splice(r, 1),
                        n && (o >= r && o--,
                        a >= r && a--)
                }),
                this
            },
            has: function(e) {
                return e ? x.inArray(e, l) > -1 : !(!l || !l.length)
            },
            empty: function() {
                return l = [],
                o = 0,
                this
            },
            disable: function() {
                return l = u = r = t,
                this
            },
            disabled: function() {
                return !l
            },
            lock: function() {
                return u = t,
                r || p.disable(),
                this
            },
            locked: function() {
                return !u
            },
            fireWith: function(e, t) {
                return !l || i && !u || (t = t || [],
                t = [e, t.slice ? t.slice() : t],
                n ? u.push(t) : c(t)),
                this
            },
            fire: function() {
                return p.fireWith(this, arguments),
                this
            },
            fired: function() {
                return !!i
            }
        };
        return p
    }
    ,
    x.extend({
        Deferred: function(e) {
            var t = [["resolve", "done", x.Callbacks("once memory"), "resolved"], ["reject", "fail", x.Callbacks("once memory"), "rejected"], ["notify", "progress", x.Callbacks("memory")]]
              , n = "pending"
              , r = {
                state: function() {
                    return n
                },
                always: function() {
                    return i.done(arguments).fail(arguments),
                    this
                },
                then: function() {
                    var e = arguments;
                    return x.Deferred(function(n) {
                        x.each(t, function(t, o) {
                            var a = o[0]
                              , s = x.isFunction(e[t]) && e[t];
                            i[o[1]](function() {
                                var e = s && s.apply(this, arguments);
                                e && x.isFunction(e.promise) ? e.promise().done(n.resolve).fail(n.reject).progress(n.notify) : n[a + "With"](this === r ? n.promise() : this, s ? [e] : arguments)
                            })
                        }),
                        e = null
                    }).promise()
                },
                promise: function(e) {
                    return null != e ? x.extend(e, r) : r
                }
            }
              , i = {};
            return r.pipe = r.then,
            x.each(t, function(e, o) {
                var a = o[2]
                  , s = o[3];
                r[o[1]] = a.add,
                s && a.add(function() {
                    n = s
                }, t[1 ^ e][2].disable, t[2][2].lock),
                i[o[0]] = function() {
                    return i[o[0] + "With"](this === i ? r : this, arguments),
                    this
                }
                ,
                i[o[0] + "With"] = a.fireWith
            }),
            r.promise(i),
            e && e.call(i, i),
            i
        },
        when: function(e) {
            var t = 0, n = g.call(arguments), r = n.length, i = 1 !== r || e && x.isFunction(e.promise) ? r : 0, o = 1 === i ? e : x.Deferred(), a = function(e, t, n) {
                return function(r) {
                    t[e] = this,
                    n[e] = arguments.length > 1 ? g.call(arguments) : r,
                    n === s ? o.notifyWith(t, n) : --i || o.resolveWith(t, n)
                }
            }, s, l, u;
            if (r > 1)
                for (s = Array(r),
                l = Array(r),
                u = Array(r); r > t; t++)
                    n[t] && x.isFunction(n[t].promise) ? n[t].promise().done(a(t, u, n)).fail(o.reject).progress(a(t, l, s)) : --i;
            return i || o.resolveWith(u, n),
            o.promise()
        }
    }),
    x.support = function(t) {
        var n, r, o, s, l, u, c, p, f, d = a.createElement("div");
        if (d.setAttribute("className", "t"),
        d.innerHTML = "  <link/><table></table><a href='/a'>a</a><input type='checkbox'/>",
        n = d.getElementsByTagName("*") || [],
        r = d.getElementsByTagName("a")[0],
        !r || !r.style || !n.length)
            return t;
        s = a.createElement("select"),
        u = s.appendChild(a.createElement("option")),
        o = d.getElementsByTagName("input")[0],
        r.style.cssText = "top:1px;float:left;opacity:.5",
        t.getSetAttribute = "t" !== d.className,
        t.leadingWhitespace = 3 === d.firstChild.nodeType,
        t.tbody = !d.getElementsByTagName("tbody").length,
        t.htmlSerialize = !!d.getElementsByTagName("link").length,
        t.style = /top/.test(r.getAttribute("style")),
        t.hrefNormalized = "/a" === r.getAttribute("href"),
        t.opacity = /^0.5/.test(r.style.opacity),
        t.cssFloat = !!r.style.cssFloat,
        t.checkOn = !!o.value,
        t.optSelected = u.selected,
        t.enctype = !!a.createElement("form").enctype,
        t.html5Clone = "<:nav></:nav>" !== a.createElement("nav").cloneNode(!0).outerHTML,
        t.inlineBlockNeedsLayout = !1,
        t.shrinkWrapBlocks = !1,
        t.pixelPosition = !1,
        t.deleteExpando = !0,
        t.noCloneEvent = !0,
        t.reliableMarginRight = !0,
        t.boxSizingReliable = !0,
        o.checked = !0,
        t.noCloneChecked = o.cloneNode(!0).checked,
        s.disabled = !0,
        t.optDisabled = !u.disabled;
        try {
            delete d.test
        } catch (h) {
            t.deleteExpando = !1
        }
        o = a.createElement("input"),
        o.setAttribute("value", ""),
        t.input = "" === o.getAttribute("value"),
        o.value = "t",
        o.setAttribute("type", "radio"),
        t.radioValue = "t" === o.value,
        o.setAttribute("checked", "t"),
        o.setAttribute("name", "t"),
        l = a.createDocumentFragment(),
        l.appendChild(o),
        t.appendChecked = o.checked,
        t.checkClone = l.cloneNode(!0).cloneNode(!0).lastChild.checked,
        d.attachEvent && (d.attachEvent("onclick", function() {
            t.noCloneEvent = !1
        }),
        d.cloneNode(!0).click());
        for (f in {
            submit: !0,
            change: !0,
            focusin: !0
        })
            d.setAttribute(c = "on" + f, "t"),
            t[f + "Bubbles"] = c in e || d.attributes[c].expando === !1;
        d.style.backgroundClip = "content-box",
        d.cloneNode(!0).style.backgroundClip = "",
        t.clearCloneStyle = "content-box" === d.style.backgroundClip;
        for (f in x(t))
            break;
        return t.ownLast = "0" !== f,
        x(function() {
            var n, r, o, s = "padding:0;margin:0;border:0;display:block;box-sizing:content-box;-moz-box-sizing:content-box;-webkit-box-sizing:content-box;", l = a.getElementsByTagName("body")[0];
            l && (n = a.createElement("div"),
            n.style.cssText = "border:0;width:0;height:0;position:absolute;top:0;left:-9999px;margin-top:1px",
            l.appendChild(n).appendChild(d),
            d.innerHTML = "<table><tr><td></td><td>t</td></tr></table>",
            o = d.getElementsByTagName("td"),
            o[0].style.cssText = "padding:0;margin:0;border:0;display:none",
            p = 0 === o[0].offsetHeight,
            o[0].style.display = "",
            o[1].style.display = "none",
            t.reliableHiddenOffsets = p && 0 === o[0].offsetHeight,
            d.innerHTML = "",
            d.style.cssText = "box-sizing:border-box;-moz-box-sizing:border-box;-webkit-box-sizing:border-box;padding:1px;border:1px;display:block;width:4px;margin-top:1%;position:absolute;top:1%;",
            x.swap(l, null != l.style.zoom ? {
                zoom: 1
            } : {}, function() {
                t.boxSizing = 4 === d.offsetWidth
            }),
            e.getComputedStyle && (t.pixelPosition = "1%" !== (e.getComputedStyle(d, null) || {}).top,
            t.boxSizingReliable = "4px" === (e.getComputedStyle(d, null) || {
                width: "4px"
            }).width,
            r = d.appendChild(a.createElement("div")),
            r.style.cssText = d.style.cssText = s,
            r.style.marginRight = r.style.width = "0",
            d.style.width = "1px",
            t.reliableMarginRight = !parseFloat((e.getComputedStyle(r, null) || {}).marginRight)),
            typeof d.style.zoom !== i && (d.innerHTML = "",
            d.style.cssText = s + "width:1px;padding:1px;display:inline;zoom:1",
            t.inlineBlockNeedsLayout = 3 === d.offsetWidth,
            d.style.display = "block",
            d.innerHTML = "<div></div>",
            d.firstChild.style.width = "5px",
            t.shrinkWrapBlocks = 3 !== d.offsetWidth,
            t.inlineBlockNeedsLayout && (l.style.zoom = 1)),
            l.removeChild(n),
            n = d = o = r = null)
        }),
        n = s = l = u = r = o = null,
        t
    }({});
    var B = /(?:\{[\s\S]*\}|\[[\s\S]*\])$/
      , P = /([A-Z])/g;
    function R(e, n, r, i) {
        if (x.acceptData(e)) {
            var o, a, s = x.expando, l = e.nodeType, u = l ? x.cache : e, c = l ? e[s] : e[s] && s;
            if (c && u[c] && (i || u[c].data) || r !== t || "string" != typeof n)
                return c || (c = l ? e[s] = p.pop() || x.guid++ : s),
                u[c] || (u[c] = l ? {} : {
                    toJSON: x.noop
                }),
                ("object" == typeof n || "function" == typeof n) && (i ? u[c] = x.extend(u[c], n) : u[c].data = x.extend(u[c].data, n)),
                a = u[c],
                i || (a.data || (a.data = {}),
                a = a.data),
                r !== t && (a[x.camelCase(n)] = r),
                "string" == typeof n ? (o = a[n],
                null == o && (o = a[x.camelCase(n)])) : o = a,
                o
        }
    }
    function W(e, t, n) {
        if (x.acceptData(e)) {
            var r, i, o = e.nodeType, a = o ? x.cache : e, s = o ? e[x.expando] : x.expando;
            if (a[s]) {
                if (t && (r = n ? a[s] : a[s].data)) {
                    x.isArray(t) ? t = t.concat(x.map(t, x.camelCase)) : t in r ? t = [t] : (t = x.camelCase(t),
                    t = t in r ? [t] : t.split(" ")),
                    i = t.length;
                    while (i--)
                        delete r[t[i]];
                    if (n ? !I(r) : !x.isEmptyObject(r))
                        return
                }
                (n || (delete a[s].data,
                I(a[s]))) && (o ? x.cleanData([e], !0) : x.support.deleteExpando || a != a.window ? delete a[s] : a[s] = null)
            }
        }
    }
    x.extend({
        cache: {},
        noData: {
            applet: !0,
            embed: !0,
            object: "clsid:D27CDB6E-AE6D-11cf-96B8-444553540000"
        },
        hasData: function(e) {
            return e = e.nodeType ? x.cache[e[x.expando]] : e[x.expando],
            !!e && !I(e)
        },
        data: function(e, t, n) {
            return R(e, t, n)
        },
        removeData: function(e, t) {
            return W(e, t)
        },
        _data: function(e, t, n) {
            return R(e, t, n, !0)
        },
        _removeData: function(e, t) {
            return W(e, t, !0)
        },
        acceptData: function(e) {
            if (e.nodeType && 1 !== e.nodeType && 9 !== e.nodeType)
                return !1;
            var t = e.nodeName && x.noData[e.nodeName.toLowerCase()];
            return !t || t !== !0 && e.getAttribute("classid") === t
        }
    }),
    x.fn.extend({
        data: function(e, n) {
            var r, i, o = null, a = 0, s = this[0];
            if (e === t) {
                if (this.length && (o = x.data(s),
                1 === s.nodeType && !x._data(s, "parsedAttrs"))) {
                    for (r = s.attributes; r.length > a; a++)
                        i = r[a].name,
                        0 === i.indexOf("data-") && (i = x.camelCase(i.slice(5)),
                        $(s, i, o[i]));
                    x._data(s, "parsedAttrs", !0)
                }
                return o
            }
            return "object" == typeof e ? this.each(function() {
                x.data(this, e)
            }) : arguments.length > 1 ? this.each(function() {
                x.data(this, e, n)
            }) : s ? $(s, e, x.data(s, e)) : null
        },
        removeData: function(e) {
            return this.each(function() {
                x.removeData(this, e)
            })
        }
    });
    function $(e, n, r) {
        if (r === t && 1 === e.nodeType) {
            var i = "data-" + n.replace(P, "-$1").toLowerCase();
            if (r = e.getAttribute(i),
            "string" == typeof r) {
                try {
                    r = "true" === r ? !0 : "false" === r ? !1 : "null" === r ? null : +r + "" === r ? +r : B.test(r) ? x.parseJSON(r) : r
                } catch (o) {}
                x.data(e, n, r)
            } else
                r = t
        }
        return r
    }
    function I(e) {
        var t;
        for (t in e)
            if (("data" !== t || !x.isEmptyObject(e[t])) && "toJSON" !== t)
                return !1;
        return !0
    }
    x.extend({
        queue: function(e, n, r) {
            var i;
            return e ? (n = (n || "fx") + "queue",
            i = x._data(e, n),
            r && (!i || x.isArray(r) ? i = x._data(e, n, x.makeArray(r)) : i.push(r)),
            i || []) : t
        },
        dequeue: function(e, t) {
            t = t || "fx";
            var n = x.queue(e, t)
              , r = n.length
              , i = n.shift()
              , o = x._queueHooks(e, t)
              , a = function() {
                x.dequeue(e, t)
            };
            "inprogress" === i && (i = n.shift(),
            r--),
            i && ("fx" === t && n.unshift("inprogress"),
            delete o.stop,
            i.call(e, a, o)),
            !r && o && o.empty.fire()
        },
        _queueHooks: function(e, t) {
            var n = t + "queueHooks";
            return x._data(e, n) || x._data(e, n, {
                empty: x.Callbacks("once memory").add(function() {
                    x._removeData(e, t + "queue"),
                    x._removeData(e, n)
                })
            })
        }
    }),
    x.fn.extend({
        queue: function(e, n) {
            var r = 2;
            return "string" != typeof e && (n = e,
            e = "fx",
            r--),
            r > arguments.length ? x.queue(this[0], e) : n === t ? this : this.each(function() {
                var t = x.queue(this, e, n);
                x._queueHooks(this, e),
                "fx" === e && "inprogress" !== t[0] && x.dequeue(this, e)
            })
        },
        dequeue: function(e) {
            return this.each(function() {
                x.dequeue(this, e)
            })
        },
        delay: function(e, t) {
            return e = x.fx ? x.fx.speeds[e] || e : e,
            t = t || "fx",
            this.queue(t, function(t, n) {
                var r = setTimeout(t, e);
                n.stop = function() {
                    clearTimeout(r)
                }
            })
        },
        clearQueue: function(e) {
            return this.queue(e || "fx", [])
        },
        promise: function(e, n) {
            var r, i = 1, o = x.Deferred(), a = this, s = this.length, l = function() {
                --i || o.resolveWith(a, [a])
            };
            "string" != typeof e && (n = e,
            e = t),
            e = e || "fx";
            while (s--)
                r = x._data(a[s], e + "queueHooks"),
                r && r.empty && (i++,
                r.empty.add(l));
            return l(),
            o.promise(n)
        }
    });
    var z, X, U = /[\t\r\n\f]/g, V = /\r/g, Y = /^(?:input|select|textarea|button|object)$/i, J = /^(?:a|area)$/i, G = /^(?:checked|selected)$/i, Q = x.support.getSetAttribute, K = x.support.input;
    x.fn.extend({
        attr: function(e, t) {
            return x.access(this, x.attr, e, t, arguments.length > 1)
        },
        removeAttr: function(e) {
            return this.each(function() {
                x.removeAttr(this, e)
            })
        },
        prop: function(e, t) {
            return x.access(this, x.prop, e, t, arguments.length > 1)
        },
        removeProp: function(e) {
            return e = x.propFix[e] || e,
            this.each(function() {
                try {
                    this[e] = t,
                    delete this[e]
                } catch (n) {}
            })
        },
        addClass: function(e) {
            var t, n, r, i, o, a = 0, s = this.length, l = "string" == typeof e && e;
            if (x.isFunction(e))
                return this.each(function(t) {
                    x(this).addClass(e.call(this, t, this.className))
                });
            if (l)
                for (t = (e || "").match(T) || []; s > a; a++)
                    if (n = this[a],
                    r = 1 === n.nodeType && (n.className ? (" " + n.className + " ").replace(U, " ") : " ")) {
                        o = 0;
                        while (i = t[o++])
                            0 > r.indexOf(" " + i + " ") && (r += i + " ");
                        n.className = x.trim(r)
                    }
            return this
        },
        removeClass: function(e) {
            var t, n, r, i, o, a = 0, s = this.length, l = 0 === arguments.length || "string" == typeof e && e;
            if (x.isFunction(e))
                return this.each(function(t) {
                    x(this).removeClass(e.call(this, t, this.className))
                });
            if (l)
                for (t = (e || "").match(T) || []; s > a; a++)
                    if (n = this[a],
                    r = 1 === n.nodeType && (n.className ? (" " + n.className + " ").replace(U, " ") : "")) {
                        o = 0;
                        while (i = t[o++])
                            while (r.indexOf(" " + i + " ") >= 0)
                                r = r.replace(" " + i + " ", " ");
                        n.className = e ? x.trim(r) : ""
                    }
            return this
        },
        toggleClass: function(e, t) {
            var n = typeof e;
            return "boolean" == typeof t && "string" === n ? t ? this.addClass(e) : this.removeClass(e) : x.isFunction(e) ? this.each(function(n) {
                x(this).toggleClass(e.call(this, n, this.className, t), t)
            }) : this.each(function() {
                if ("string" === n) {
                    var t, r = 0, o = x(this), a = e.match(T) || [];
                    while (t = a[r++])
                        o.hasClass(t) ? o.removeClass(t) : o.addClass(t)
                } else
                    (n === i || "boolean" === n) && (this.className && x._data(this, "__className__", this.className),
                    this.className = this.className || e === !1 ? "" : x._data(this, "__className__") || "")
            })
        },
        hasClass: function(e) {
            var t = " " + e + " "
              , n = 0
              , r = this.length;
            for (; r > n; n++)
                if (1 === this[n].nodeType && (" " + this[n].className + " ").replace(U, " ").indexOf(t) >= 0)
                    return !0;
            return !1
        },
        val: function(e) {
            var n, r, i, o = this[0];
            {
                if (arguments.length)
                    return i = x.isFunction(e),
                    this.each(function(n) {
                        var o;
                        1 === this.nodeType && (o = i ? e.call(this, n, x(this).val()) : e,
                        null == o ? o = "" : "number" == typeof o ? o += "" : x.isArray(o) && (o = x.map(o, function(e) {
                            return null == e ? "" : e + ""
                        })),
                        r = x.valHooks[this.type] || x.valHooks[this.nodeName.toLowerCase()],
                        r && "set"in r && r.set(this, o, "value") !== t || (this.value = o))
                    });
                if (o)
                    return r = x.valHooks[o.type] || x.valHooks[o.nodeName.toLowerCase()],
                    r && "get"in r && (n = r.get(o, "value")) !== t ? n : (n = o.value,
                    "string" == typeof n ? n.replace(V, "") : null == n ? "" : n)
            }
        }
    }),
    x.extend({
        valHooks: {
            option: {
                get: function(e) {
                    var t = x.find.attr(e, "value");
                    return null != t ? t : e.text
                }
            },
            select: {
                get: function(e) {
                    var t, n, r = e.options, i = e.selectedIndex, o = "select-one" === e.type || 0 > i, a = o ? null : [], s = o ? i + 1 : r.length, l = 0 > i ? s : o ? i : 0;
                    for (; s > l; l++)
                        if (n = r[l],
                        !(!n.selected && l !== i || (x.support.optDisabled ? n.disabled : null !== n.getAttribute("disabled")) || n.parentNode.disabled && x.nodeName(n.parentNode, "optgroup"))) {
                            if (t = x(n).val(),
                            o)
                                return t;
                            a.push(t)
                        }
                    return a
                },
                set: function(e, t) {
                    var n, r, i = e.options, o = x.makeArray(t), a = i.length;
                    while (a--)
                        r = i[a],
                        (r.selected = x.inArray(x(r).val(), o) >= 0) && (n = !0);
                    return n || (e.selectedIndex = -1),
                    o
                }
            }
        },
        attr: function(e, n, r) {
            var o, a, s = e.nodeType;
            if (e && 3 !== s && 8 !== s && 2 !== s)
                return typeof e.getAttribute === i ? x.prop(e, n, r) : (1 === s && x.isXMLDoc(e) || (n = n.toLowerCase(),
                o = x.attrHooks[n] || (x.expr.match.bool.test(n) ? X : z)),
                r === t ? o && "get"in o && null !== (a = o.get(e, n)) ? a : (a = x.find.attr(e, n),
                null == a ? t : a) : null !== r ? o && "set"in o && (a = o.set(e, r, n)) !== t ? a : (e.setAttribute(n, r + ""),
                r) : (x.removeAttr(e, n),
                t))
        },
        removeAttr: function(e, t) {
            var n, r, i = 0, o = t && t.match(T);
            if (o && 1 === e.nodeType)
                while (n = o[i++])
                    r = x.propFix[n] || n,
                    x.expr.match.bool.test(n) ? K && Q || !G.test(n) ? e[r] = !1 : e[x.camelCase("default-" + n)] = e[r] = !1 : x.attr(e, n, ""),
                    e.removeAttribute(Q ? n : r)
        },
        attrHooks: {
            type: {
                set: function(e, t) {
                    if (!x.support.radioValue && "radio" === t && x.nodeName(e, "input")) {
                        var n = e.value;
                        return e.setAttribute("type", t),
                        n && (e.value = n),
                        t
                    }
                }
            }
        },
        propFix: {
            "for": "htmlFor",
            "class": "className"
        },
        prop: function(e, n, r) {
            var i, o, a, s = e.nodeType;
            if (e && 3 !== s && 8 !== s && 2 !== s)
                return a = 1 !== s || !x.isXMLDoc(e),
                a && (n = x.propFix[n] || n,
                o = x.propHooks[n]),
                r !== t ? o && "set"in o && (i = o.set(e, r, n)) !== t ? i : e[n] = r : o && "get"in o && null !== (i = o.get(e, n)) ? i : e[n]
        },
        propHooks: {
            tabIndex: {
                get: function(e) {
                    var t = x.find.attr(e, "tabindex");
                    return t ? parseInt(t, 10) : Y.test(e.nodeName) || J.test(e.nodeName) && e.href ? 0 : -1
                }
            }
        }
    }),
    X = {
        set: function(e, t, n) {
            return t === !1 ? x.removeAttr(e, n) : K && Q || !G.test(n) ? e.setAttribute(!Q && x.propFix[n] || n, n) : e[x.camelCase("default-" + n)] = e[n] = !0,
            n
        }
    },
    x.each(x.expr.match.bool.source.match(/\w+/g), function(e, n) {
        var r = x.expr.attrHandle[n] || x.find.attr;
        x.expr.attrHandle[n] = K && Q || !G.test(n) ? function(e, n, i) {
            var o = x.expr.attrHandle[n]
              , a = i ? t : (x.expr.attrHandle[n] = t) != r(e, n, i) ? n.toLowerCase() : null;
            return x.expr.attrHandle[n] = o,
            a
        }
        : function(e, n, r) {
            return r ? t : e[x.camelCase("default-" + n)] ? n.toLowerCase() : null
        }
    }),
    K && Q || (x.attrHooks.value = {
        set: function(e, n, r) {
            return x.nodeName(e, "input") ? (e.defaultValue = n,
            t) : z && z.set(e, n, r)
        }
    }),
    Q || (z = {
        set: function(e, n, r) {
            var i = e.getAttributeNode(r);
            return i || e.setAttributeNode(i = e.ownerDocument.createAttribute(r)),
            i.value = n += "",
            "value" === r || n === e.getAttribute(r) ? n : t
        }
    },
    x.expr.attrHandle.id = x.expr.attrHandle.name = x.expr.attrHandle.coords = function(e, n, r) {
        var i;
        return r ? t : (i = e.getAttributeNode(n)) && "" !== i.value ? i.value : null
    }
    ,
    x.valHooks.button = {
        get: function(e, n) {
            var r = e.getAttributeNode(n);
            return r && r.specified ? r.value : t
        },
        set: z.set
    },
    x.attrHooks.contenteditable = {
        set: function(e, t, n) {
            z.set(e, "" === t ? !1 : t, n)
        }
    },
    x.each(["width", "height"], function(e, n) {
        x.attrHooks[n] = {
            set: function(e, r) {
                return "" === r ? (e.setAttribute(n, "auto"),
                r) : t
            }
        }
    })),
    x.support.hrefNormalized || x.each(["href", "src"], function(e, t) {
        x.propHooks[t] = {
            get: function(e) {
                return e.getAttribute(t, 4)
            }
        }
    }),
    x.support.style || (x.attrHooks.style = {
        get: function(e) {
            return e.style.cssText || t
        },
        set: function(e, t) {
            return e.style.cssText = t + ""
        }
    }),
    x.support.optSelected || (x.propHooks.selected = {
        get: function(e) {
            var t = e.parentNode;
            return t && (t.selectedIndex,
            t.parentNode && t.parentNode.selectedIndex),
            null
        }
    }),
    x.each(["tabIndex", "readOnly", "maxLength", "cellSpacing", "cellPadding", "rowSpan", "colSpan", "useMap", "frameBorder", "contentEditable"], function() {
        x.propFix[this.toLowerCase()] = this
    }),
    x.support.enctype || (x.propFix.enctype = "encoding"),
    x.each(["radio", "checkbox"], function() {
        x.valHooks[this] = {
            set: function(e, n) {
                return x.isArray(n) ? e.checked = x.inArray(x(e).val(), n) >= 0 : t
            }
        },
        x.support.checkOn || (x.valHooks[this].get = function(e) {
            return null === e.getAttribute("value") ? "on" : e.value
        }
        )
    });
    var Z = /^(?:input|select|textarea)$/i
      , et = /^key/
      , tt = /^(?:mouse|contextmenu)|click/
      , nt = /^(?:focusinfocus|focusoutblur)$/
      , rt = /^([^.]*)(?:\.(.+)|)$/;
    function it() {
        return !0
    }
    function ot() {
        return !1
    }
    function at() {
        try {
            return a.activeElement
        } catch (e) {}
    }
    x.event = {
        global: {},
        add: function(e, n, r, o, a) {
            var s, l, u, c, p, f, d, h, g, m, y, v = x._data(e);
            if (v) {
                r.handler && (c = r,
                r = c.handler,
                a = c.selector),
                r.guid || (r.guid = x.guid++),
                (l = v.events) || (l = v.events = {}),
                (f = v.handle) || (f = v.handle = function(e) {
                    return typeof x === i || e && x.event.triggered === e.type ? t : x.event.dispatch.apply(f.elem, arguments)
                }
                ,
                f.elem = e),
                n = (n || "").match(T) || [""],
                u = n.length;
                while (u--)
                    s = rt.exec(n[u]) || [],
                    g = y = s[1],
                    m = (s[2] || "").split(".").sort(),
                    g && (p = x.event.special[g] || {},
                    g = (a ? p.delegateType : p.bindType) || g,
                    p = x.event.special[g] || {},
                    d = x.extend({
                        type: g,
                        origType: y,
                        data: o,
                        handler: r,
                        guid: r.guid,
                        selector: a,
                        needsContext: a && x.expr.match.needsContext.test(a),
                        namespace: m.join(".")
                    }, c),
                    (h = l[g]) || (h = l[g] = [],
                    h.delegateCount = 0,
                    p.setup && p.setup.call(e, o, m, f) !== !1 || (e.addEventListener ? e.addEventListener(g, f, !1) : e.attachEvent && e.attachEvent("on" + g, f))),
                    p.add && (p.add.call(e, d),
                    d.handler.guid || (d.handler.guid = r.guid)),
                    a ? h.splice(h.delegateCount++, 0, d) : h.push(d),
                    x.event.global[g] = !0);
                e = null
            }
        },
        remove: function(e, t, n, r, i) {
            var o, a, s, l, u, c, p, f, d, h, g, m = x.hasData(e) && x._data(e);
            if (m && (c = m.events)) {
                t = (t || "").match(T) || [""],
                u = t.length;
                while (u--)
                    if (s = rt.exec(t[u]) || [],
                    d = g = s[1],
                    h = (s[2] || "").split(".").sort(),
                    d) {
                        p = x.event.special[d] || {},
                        d = (r ? p.delegateType : p.bindType) || d,
                        f = c[d] || [],
                        s = s[2] && RegExp("(^|\\.)" + h.join("\\.(?:.*\\.|)") + "(\\.|$)"),
                        l = o = f.length;
                        while (o--)
                            a = f[o],
                            !i && g !== a.origType || n && n.guid !== a.guid || s && !s.test(a.namespace) || r && r !== a.selector && ("**" !== r || !a.selector) || (f.splice(o, 1),
                            a.selector && f.delegateCount--,
                            p.remove && p.remove.call(e, a));
                        l && !f.length && (p.teardown && p.teardown.call(e, h, m.handle) !== !1 || x.removeEvent(e, d, m.handle),
                        delete c[d])
                    } else
                        for (d in c)
                            x.event.remove(e, d + t[u], n, r, !0);
                x.isEmptyObject(c) && (delete m.handle,
                x._removeData(e, "events"))
            }
        },
        trigger: function(n, r, i, o) {
            var s, l, u, c, p, f, d, h = [i || a], g = v.call(n, "type") ? n.type : n, m = v.call(n, "namespace") ? n.namespace.split(".") : [];
            if (u = f = i = i || a,
            3 !== i.nodeType && 8 !== i.nodeType && !nt.test(g + x.event.triggered) && (g.indexOf(".") >= 0 && (m = g.split("."),
            g = m.shift(),
            m.sort()),
            l = 0 > g.indexOf(":") && "on" + g,
            n = n[x.expando] ? n : new x.Event(g,"object" == typeof n && n),
            n.isTrigger = o ? 2 : 3,
            n.namespace = m.join("."),
            n.namespace_re = n.namespace ? RegExp("(^|\\.)" + m.join("\\.(?:.*\\.|)") + "(\\.|$)") : null,
            n.result = t,
            n.target || (n.target = i),
            r = null == r ? [n] : x.makeArray(r, [n]),
            p = x.event.special[g] || {},
            o || !p.trigger || p.trigger.apply(i, r) !== !1)) {
                if (!o && !p.noBubble && !x.isWindow(i)) {
                    for (c = p.delegateType || g,
                    nt.test(c + g) || (u = u.parentNode); u; u = u.parentNode)
                        h.push(u),
                        f = u;
                    f === (i.ownerDocument || a) && h.push(f.defaultView || f.parentWindow || e)
                }
                d = 0;
                while ((u = h[d++]) && !n.isPropagationStopped())
                    n.type = d > 1 ? c : p.bindType || g,
                    s = (x._data(u, "events") || {})[n.type] && x._data(u, "handle"),
                    s && s.apply(u, r),
                    s = l && u[l],
                    s && x.acceptData(u) && s.apply && s.apply(u, r) === !1 && n.preventDefault();
                if (n.type = g,
                !o && !n.isDefaultPrevented() && (!p._default || p._default.apply(h.pop(), r) === !1) && x.acceptData(i) && l && i[g] && !x.isWindow(i)) {
                    f = i[l],
                    f && (i[l] = null),
                    x.event.triggered = g;
                    try {
                        i[g]()
                    } catch (y) {}
                    x.event.triggered = t,
                    f && (i[l] = f)
                }
                return n.result
            }
        },
        dispatch: function(e) {
            e = x.event.fix(e);
            var n, r, i, o, a, s = [], l = g.call(arguments), u = (x._data(this, "events") || {})[e.type] || [], c = x.event.special[e.type] || {};
            if (l[0] = e,
            e.delegateTarget = this,
            !c.preDispatch || c.preDispatch.call(this, e) !== !1) {
                s = x.event.handlers.call(this, e, u),
                n = 0;
                while ((o = s[n++]) && !e.isPropagationStopped()) {
                    e.currentTarget = o.elem,
                    a = 0;
                    while ((i = o.handlers[a++]) && !e.isImmediatePropagationStopped())
                        (!e.namespace_re || e.namespace_re.test(i.namespace)) && (e.handleObj = i,
                        e.data = i.data,
                        r = ((x.event.special[i.origType] || {}).handle || i.handler).apply(o.elem, l),
                        r !== t && (e.result = r) === !1 && (e.preventDefault(),
                        e.stopPropagation()))
                }
                return c.postDispatch && c.postDispatch.call(this, e),
                e.result
            }
        },
        handlers: function(e, n) {
            var r, i, o, a, s = [], l = n.delegateCount, u = e.target;
            if (l && u.nodeType && (!e.button || "click" !== e.type))
                for (; u != this; u = u.parentNode || this)
                    if (1 === u.nodeType && (u.disabled !== !0 || "click" !== e.type)) {
                        for (o = [],
                        a = 0; l > a; a++)
                            i = n[a],
                            r = i.selector + " ",
                            o[r] === t && (o[r] = i.needsContext ? x(r, this).index(u) >= 0 : x.find(r, this, null, [u]).length),
                            o[r] && o.push(i);
                        o.length && s.push({
                            elem: u,
                            handlers: o
                        })
                    }
            return n.length > l && s.push({
                elem: this,
                handlers: n.slice(l)
            }),
            s
        },
        fix: function(e) {
            if (e[x.expando])
                return e;
            var t, n, r, i = e.type, o = e, s = this.fixHooks[i];
            s || (this.fixHooks[i] = s = tt.test(i) ? this.mouseHooks : et.test(i) ? this.keyHooks : {}),
            r = s.props ? this.props.concat(s.props) : this.props,
            e = new x.Event(o),
            t = r.length;
            while (t--)
                n = r[t],
                e[n] = o[n];
            return e.target || (e.target = o.srcElement || a),
            3 === e.target.nodeType && (e.target = e.target.parentNode),
            e.metaKey = !!e.metaKey,
            s.filter ? s.filter(e, o) : e
        },
        props: "altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which".split(" "),
        fixHooks: {},
        keyHooks: {
            props: "char charCode key keyCode".split(" "),
            filter: function(e, t) {
                return null == e.which && (e.which = null != t.charCode ? t.charCode : t.keyCode),
                e
            }
        },
        mouseHooks: {
            props: "button buttons clientX clientY fromElement offsetX offsetY pageX pageY screenX screenY toElement".split(" "),
            filter: function(e, n) {
                var r, i, o, s = n.button, l = n.fromElement;
                return null == e.pageX && null != n.clientX && (i = e.target.ownerDocument || a,
                o = i.documentElement,
                r = i.body,
                e.pageX = n.clientX + (o && o.scrollLeft || r && r.scrollLeft || 0) - (o && o.clientLeft || r && r.clientLeft || 0),
                e.pageY = n.clientY + (o && o.scrollTop || r && r.scrollTop || 0) - (o && o.clientTop || r && r.clientTop || 0)),
                !e.relatedTarget && l && (e.relatedTarget = l === e.target ? n.toElement : l),
                e.which || s === t || (e.which = 1 & s ? 1 : 2 & s ? 3 : 4 & s ? 2 : 0),
                e
            }
        },
        special: {
            load: {
                noBubble: !0
            },
            focus: {
                trigger: function() {
                    if (this !== at() && this.focus)
                        try {
                            return this.focus(),
                            !1
                        } catch (e) {}
                },
                delegateType: "focusin"
            },
            blur: {
                trigger: function() {
                    return this === at() && this.blur ? (this.blur(),
                    !1) : t
                },
                delegateType: "focusout"
            },
            click: {
                trigger: function() {
                    return x.nodeName(this, "input") && "checkbox" === this.type && this.click ? (this.click(),
                    !1) : t
                },
                _default: function(e) {
                    return x.nodeName(e.target, "a")
                }
            },
            beforeunload: {
                postDispatch: function(e) {
                    e.result !== t && (e.originalEvent.returnValue = e.result)
                }
            }
        },
        simulate: function(e, t, n, r) {
            var i = x.extend(new x.Event, n, {
                type: e,
                isSimulated: !0,
                originalEvent: {}
            });
            r ? x.event.trigger(i, null, t) : x.event.dispatch.call(t, i),
            i.isDefaultPrevented() && n.preventDefault()
        }
    },
    x.removeEvent = a.removeEventListener ? function(e, t, n) {
        e.removeEventListener && e.removeEventListener(t, n, !1)
    }
    : function(e, t, n) {
        var r = "on" + t;
        e.detachEvent && (typeof e[r] === i && (e[r] = null),
        e.detachEvent(r, n))
    }
    ,
    x.Event = function(e, n) {
        return this instanceof x.Event ? (e && e.type ? (this.originalEvent = e,
        this.type = e.type,
        this.isDefaultPrevented = e.defaultPrevented || e.returnValue === !1 || e.getPreventDefault && e.getPreventDefault() ? it : ot) : this.type = e,
        n && x.extend(this, n),
        this.timeStamp = e && e.timeStamp || x.now(),
        this[x.expando] = !0,
        t) : new x.Event(e,n)
    }
    ,
    x.Event.prototype = {
        isDefaultPrevented: ot,
        isPropagationStopped: ot,
        isImmediatePropagationStopped: ot,
        preventDefault: function() {
            var e = this.originalEvent;
            this.isDefaultPrevented = it,
            e && (e.preventDefault ? e.preventDefault() : e.returnValue = !1)
        },
        stopPropagation: function() {
            var e = this.originalEvent;
            this.isPropagationStopped = it,
            e && (e.stopPropagation && e.stopPropagation(),
            e.cancelBubble = !0)
        },
        stopImmediatePropagation: function() {
            this.isImmediatePropagationStopped = it,
            this.stopPropagation()
        }
    },
    x.each({
        mouseenter: "mouseover",
        mouseleave: "mouseout"
    }, function(e, t) {
        x.event.special[e] = {
            delegateType: t,
            bindType: t,
            handle: function(e) {
                var n, r = this, i = e.relatedTarget, o = e.handleObj;
                return (!i || i !== r && !x.contains(r, i)) && (e.type = o.origType,
                n = o.handler.apply(this, arguments),
                e.type = t),
                n
            }
        }
    }),
    x.support.submitBubbles || (x.event.special.submit = {
        setup: function() {
            return x.nodeName(this, "form") ? !1 : (x.event.add(this, "click._submit keypress._submit", function(e) {
                var n = e.target
                  , r = x.nodeName(n, "input") || x.nodeName(n, "button") ? n.form : t;
                r && !x._data(r, "submitBubbles") && (x.event.add(r, "submit._submit", function(e) {
                    e._submit_bubble = !0
                }),
                x._data(r, "submitBubbles", !0))
            }),
            t)
        },
        postDispatch: function(e) {
            e._submit_bubble && (delete e._submit_bubble,
            this.parentNode && !e.isTrigger && x.event.simulate("submit", this.parentNode, e, !0))
        },
        teardown: function() {
            return x.nodeName(this, "form") ? !1 : (x.event.remove(this, "._submit"),
            t)
        }
    }),
    x.support.changeBubbles || (x.event.special.change = {
        setup: function() {
            return Z.test(this.nodeName) ? (("checkbox" === this.type || "radio" === this.type) && (x.event.add(this, "propertychange._change", function(e) {
                "checked" === e.originalEvent.propertyName && (this._just_changed = !0)
            }),
            x.event.add(this, "click._change", function(e) {
                this._just_changed && !e.isTrigger && (this._just_changed = !1),
                x.event.simulate("change", this, e, !0)
            })),
            !1) : (x.event.add(this, "beforeactivate._change", function(e) {
                var t = e.target;
                Z.test(t.nodeName) && !x._data(t, "changeBubbles") && (x.event.add(t, "change._change", function(e) {
                    !this.parentNode || e.isSimulated || e.isTrigger || x.event.simulate("change", this.parentNode, e, !0)
                }),
                x._data(t, "changeBubbles", !0))
            }),
            t)
        },
        handle: function(e) {
            var n = e.target;
            return this !== n || e.isSimulated || e.isTrigger || "radio" !== n.type && "checkbox" !== n.type ? e.handleObj.handler.apply(this, arguments) : t
        },
        teardown: function() {
            return x.event.remove(this, "._change"),
            !Z.test(this.nodeName)
        }
    }),
    x.support.focusinBubbles || x.each({
        focus: "focusin",
        blur: "focusout"
    }, function(e, t) {
        var n = 0
          , r = function(e) {
            x.event.simulate(t, e.target, x.event.fix(e), !0)
        };
        x.event.special[t] = {
            setup: function() {
                0 === n++ && a.addEventListener(e, r, !0)
            },
            teardown: function() {
                0 === --n && a.removeEventListener(e, r, !0)
            }
        }
    }),
    x.fn.extend({
        on: function(e, n, r, i, o) {
            var a, s;
            if ("object" == typeof e) {
                "string" != typeof n && (r = r || n,
                n = t);
                for (a in e)
                    this.on(a, n, r, e[a], o);
                return this
            }
            if (null == r && null == i ? (i = n,
            r = n = t) : null == i && ("string" == typeof n ? (i = r,
            r = t) : (i = r,
            r = n,
            n = t)),
            i === !1)
                i = ot;
            else if (!i)
                return this;
            return 1 === o && (s = i,
            i = function(e) {
                return x().off(e),
                s.apply(this, arguments)
            }
            ,
            i.guid = s.guid || (s.guid = x.guid++)),
            this.each(function() {
                x.event.add(this, e, i, r, n)
            })
        },
        one: function(e, t, n, r) {
            return this.on(e, t, n, r, 1)
        },
        off: function(e, n, r) {
            var i, o;
            if (e && e.preventDefault && e.handleObj)
                return i = e.handleObj,
                x(e.delegateTarget).off(i.namespace ? i.origType + "." + i.namespace : i.origType, i.selector, i.handler),
                this;
            if ("object" == typeof e) {
                for (o in e)
                    this.off(o, n, e[o]);
                return this
            }
            return (n === !1 || "function" == typeof n) && (r = n,
            n = t),
            r === !1 && (r = ot),
            this.each(function() {
                x.event.remove(this, e, r, n)
            })
        },
        trigger: function(e, t) {
            return this.each(function() {
                x.event.trigger(e, t, this)
            })
        },
        triggerHandler: function(e, n) {
            var r = this[0];
            return r ? x.event.trigger(e, n, r, !0) : t
        }
    });
    var st = /^.[^:#\[\.,]*$/
      , lt = /^(?:parents|prev(?:Until|All))/
      , ut = x.expr.match.needsContext
      , ct = {
        children: !0,
        contents: !0,
        next: !0,
        prev: !0
    };
    x.fn.extend({
        find: function(e) {
            var t, n = [], r = this, i = r.length;
            if ("string" != typeof e)
                return this.pushStack(x(e).filter(function() {
                    for (t = 0; i > t; t++)
                        if (x.contains(r[t], this))
                            return !0
                }));
            for (t = 0; i > t; t++)
                x.find(e, r[t], n);
            return n = this.pushStack(i > 1 ? x.unique(n) : n),
            n.selector = this.selector ? this.selector + " " + e : e,
            n
        },
        has: function(e) {
            var t, n = x(e, this), r = n.length;
            return this.filter(function() {
                for (t = 0; r > t; t++)
                    if (x.contains(this, n[t]))
                        return !0
            })
        },
        not: function(e) {
            return this.pushStack(ft(this, e || [], !0))
        },
        filter: function(e) {
            return this.pushStack(ft(this, e || [], !1))
        },
        is: function(e) {
            return !!ft(this, "string" == typeof e && ut.test(e) ? x(e) : e || [], !1).length
        },
        closest: function(e, t) {
            var n, r = 0, i = this.length, o = [], a = ut.test(e) || "string" != typeof e ? x(e, t || this.context) : 0;
            for (; i > r; r++)
                for (n = this[r]; n && n !== t; n = n.parentNode)
                    if (11 > n.nodeType && (a ? a.index(n) > -1 : 1 === n.nodeType && x.find.matchesSelector(n, e))) {
                        n = o.push(n);
                        break
                    }
            return this.pushStack(o.length > 1 ? x.unique(o) : o)
        },
        index: function(e) {
            return e ? "string" == typeof e ? x.inArray(this[0], x(e)) : x.inArray(e.jquery ? e[0] : e, this) : this[0] && this[0].parentNode ? this.first().prevAll().length : -1
        },
        add: function(e, t) {
            var n = "string" == typeof e ? x(e, t) : x.makeArray(e && e.nodeType ? [e] : e)
              , r = x.merge(this.get(), n);
            return this.pushStack(x.unique(r))
        },
        addBack: function(e) {
            return this.add(null == e ? this.prevObject : this.prevObject.filter(e))
        }
    });
    function pt(e, t) {
        do
            e = e[t];
        while (e && 1 !== e.nodeType);return e
    }
    x.each({
        parent: function(e) {
            var t = e.parentNode;
            return t && 11 !== t.nodeType ? t : null
        },
        parents: function(e) {
            return x.dir(e, "parentNode")
        },
        parentsUntil: function(e, t, n) {
            return x.dir(e, "parentNode", n)
        },
        next: function(e) {
            return pt(e, "nextSibling")
        },
        prev: function(e) {
            return pt(e, "previousSibling")
        },
        nextAll: function(e) {
            return x.dir(e, "nextSibling")
        },
        prevAll: function(e) {
            return x.dir(e, "previousSibling")
        },
        nextUntil: function(e, t, n) {
            return x.dir(e, "nextSibling", n)
        },
        prevUntil: function(e, t, n) {
            return x.dir(e, "previousSibling", n)
        },
        siblings: function(e) {
            return x.sibling((e.parentNode || {}).firstChild, e)
        },
        children: function(e) {
            return x.sibling(e.firstChild)
        },
        contents: function(e) {
            return x.nodeName(e, "iframe") ? e.contentDocument || e.contentWindow.document : x.merge([], e.childNodes)
        }
    }, function(e, t) {
        x.fn[e] = function(n, r) {
            var i = x.map(this, t, n);
            return "Until" !== e.slice(-5) && (r = n),
            r && "string" == typeof r && (i = x.filter(r, i)),
            this.length > 1 && (ct[e] || (i = x.unique(i)),
            lt.test(e) && (i = i.reverse())),
            this.pushStack(i)
        }
    }),
    x.extend({
        filter: function(e, t, n) {
            var r = t[0];
            return n && (e = ":not(" + e + ")"),
            1 === t.length && 1 === r.nodeType ? x.find.matchesSelector(r, e) ? [r] : [] : x.find.matches(e, x.grep(t, function(e) {
                return 1 === e.nodeType
            }))
        },
        dir: function(e, n, r) {
            var i = []
              , o = e[n];
            while (o && 9 !== o.nodeType && (r === t || 1 !== o.nodeType || !x(o).is(r)))
                1 === o.nodeType && i.push(o),
                o = o[n];
            return i
        },
        sibling: function(e, t) {
            var n = [];
            for (; e; e = e.nextSibling)
                1 === e.nodeType && e !== t && n.push(e);
            return n
        }
    });
    function ft(e, t, n) {
        if (x.isFunction(t))
            return x.grep(e, function(e, r) {
                return !!t.call(e, r, e) !== n
            });
        if (t.nodeType)
            return x.grep(e, function(e) {
                return e === t !== n
            });
        if ("string" == typeof t) {
            if (st.test(t))
                return x.filter(t, e, n);
            t = x.filter(t, e)
        }
        return x.grep(e, function(e) {
            return x.inArray(e, t) >= 0 !== n
        })
    }
    function dt(e) {
        var t = ht.split("|")
          , n = e.createDocumentFragment();
        if (n.createElement)
            while (t.length)
                n.createElement(t.pop());
        return n
    }
    var ht = "abbr|article|aside|audio|bdi|canvas|data|datalist|details|figcaption|figure|footer|header|hgroup|mark|meter|nav|output|progress|section|summary|time|video"
      , gt = / jQuery\d+="(?:null|\d+)"/g
      , mt = RegExp("<(?:" + ht + ")[\\s/>]", "i")
      , yt = /^\s+/
      , vt = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/gi
      , bt = /<([\w:]+)/
      , xt = /<tbody/i
      , wt = /<|&#?\w+;/
      , Tt = /<(?:script|style|link)/i
      , Ct = /^(?:checkbox|radio)$/i
      , Nt = /checked\s*(?:[^=]|=\s*.checked.)/i
      , kt = /^$|\/(?:java|ecma)script/i
      , Et = /^true\/(.*)/
      , St = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g
      , At = {
        option: [1, "<select multiple='multiple'>", "</select>"],
        legend: [1, "<fieldset>", "</fieldset>"],
        area: [1, "<map>", "</map>"],
        param: [1, "<object>", "</object>"],
        thead: [1, "<table>", "</table>"],
        tr: [2, "<table><tbody>", "</tbody></table>"],
        col: [2, "<table><tbody></tbody><colgroup>", "</colgroup></table>"],
        td: [3, "<table><tbody><tr>", "</tr></tbody></table>"],
        _default: x.support.htmlSerialize ? [0, "", ""] : [1, "X<div>", "</div>"]
    }
      , jt = dt(a)
      , Dt = jt.appendChild(a.createElement("div"));
    At.optgroup = At.option,
    At.tbody = At.tfoot = At.colgroup = At.caption = At.thead,
    At.th = At.td,
    x.fn.extend({
        text: function(e) {
            return x.access(this, function(e) {
                return e === t ? x.text(this) : this.empty().append((this[0] && this[0].ownerDocument || a).createTextNode(e))
            }, null, e, arguments.length)
        },
        append: function() {
            return this.domManip(arguments, function(e) {
                if (1 === this.nodeType || 11 === this.nodeType || 9 === this.nodeType) {
                    var t = Lt(this, e);
                    t.appendChild(e)
                }
            })
        },
        prepend: function() {
            return this.domManip(arguments, function(e) {
                if (1 === this.nodeType || 11 === this.nodeType || 9 === this.nodeType) {
                    var t = Lt(this, e);
                    t.insertBefore(e, t.firstChild)
                }
            })
        },
        before: function() {
            return this.domManip(arguments, function(e) {
                this.parentNode && this.parentNode.insertBefore(e, this)
            })
        },
        after: function() {
            return this.domManip(arguments, function(e) {
                this.parentNode && this.parentNode.insertBefore(e, this.nextSibling)
            })
        },
        remove: function(e, t) {
            var n, r = e ? x.filter(e, this) : this, i = 0;
            for (; null != (n = r[i]); i++)
                t || 1 !== n.nodeType || x.cleanData(Ft(n)),
                n.parentNode && (t && x.contains(n.ownerDocument, n) && _t(Ft(n, "script")),
                n.parentNode.removeChild(n));
            return this
        },
        empty: function() {
            var e, t = 0;
            for (; null != (e = this[t]); t++) {
                1 === e.nodeType && x.cleanData(Ft(e, !1));
                while (e.firstChild)
                    e.removeChild(e.firstChild);
                e.options && x.nodeName(e, "select") && (e.options.length = 0)
            }
            return this
        },
        clone: function(e, t) {
            return e = null == e ? !1 : e,
            t = null == t ? e : t,
            this.map(function() {
                return x.clone(this, e, t)
            })
        },
        html: function(e) {
            return x.access(this, function(e) {
                var n = this[0] || {}
                  , r = 0
                  , i = this.length;
                if (e === t)
                    return 1 === n.nodeType ? n.innerHTML.replace(gt, "") : t;
                if (!("string" != typeof e || Tt.test(e) || !x.support.htmlSerialize && mt.test(e) || !x.support.leadingWhitespace && yt.test(e) || At[(bt.exec(e) || ["", ""])[1].toLowerCase()])) {
                    e = e.replace(vt, "<$1></$2>");
                    try {
                        for (; i > r; r++)
                            n = this[r] || {},
                            1 === n.nodeType && (x.cleanData(Ft(n, !1)),
                            n.innerHTML = e);
                        n = 0
                    } catch (o) {}
                }
                n && this.empty().append(e)
            }, null, e, arguments.length)
        },
        replaceWith: function() {
            var e = x.map(this, function(e) {
                return [e.nextSibling, e.parentNode]
            })
              , t = 0;
            return this.domManip(arguments, function(n) {
                var r = e[t++]
                  , i = e[t++];
                i && (r && r.parentNode !== i && (r = this.nextSibling),
                x(this).remove(),
                i.insertBefore(n, r))
            }, !0),
            t ? this : this.remove()
        },
        detach: function(e) {
            return this.remove(e, !0)
        },
        domManip: function(e, t, n) {
            e = d.apply([], e);
            var r, i, o, a, s, l, u = 0, c = this.length, p = this, f = c - 1, h = e[0], g = x.isFunction(h);
            if (g || !(1 >= c || "string" != typeof h || x.support.checkClone) && Nt.test(h))
                return this.each(function(r) {
                    var i = p.eq(r);
                    g && (e[0] = h.call(this, r, i.html())),
                    i.domManip(e, t, n)
                });
            if (c && (l = x.buildFragment(e, this[0].ownerDocument, !1, !n && this),
            r = l.firstChild,
            1 === l.childNodes.length && (l = r),
            r)) {
                for (a = x.map(Ft(l, "script"), Ht),
                o = a.length; c > u; u++)
                    i = l,
                    u !== f && (i = x.clone(i, !0, !0),
                    o && x.merge(a, Ft(i, "script"))),
                    t.call(this[u], i, u);
                if (o)
                    for (s = a[a.length - 1].ownerDocument,
                    x.map(a, qt),
                    u = 0; o > u; u++)
                        i = a[u],
                        kt.test(i.type || "") && !x._data(i, "globalEval") && x.contains(s, i) && (i.src ? x._evalUrl(i.src) : x.globalEval((i.text || i.textContent || i.innerHTML || "").replace(St, "")));
                l = r = null
            }
            return this
        }
    });
    function Lt(e, t) {
        return x.nodeName(e, "table") && x.nodeName(1 === t.nodeType ? t : t.firstChild, "tr") ? e.getElementsByTagName("tbody")[0] || e.appendChild(e.ownerDocument.createElement("tbody")) : e
    }
    function Ht(e) {
        return e.type = (null !== x.find.attr(e, "type")) + "/" + e.type,
        e
    }
    function qt(e) {
        var t = Et.exec(e.type);
        return t ? e.type = t[1] : e.removeAttribute("type"),
        e
    }
    function _t(e, t) {
        var n, r = 0;
        for (; null != (n = e[r]); r++)
            x._data(n, "globalEval", !t || x._data(t[r], "globalEval"))
    }
    function Mt(e, t) {
        if (1 === t.nodeType && x.hasData(e)) {
            var n, r, i, o = x._data(e), a = x._data(t, o), s = o.events;
            if (s) {
                delete a.handle,
                a.events = {};
                for (n in s)
                    for (r = 0,
                    i = s[n].length; i > r; r++)
                        x.event.add(t, n, s[n][r])
            }
            a.data && (a.data = x.extend({}, a.data))
        }
    }
    function Ot(e, t) {
        var n, r, i;
        if (1 === t.nodeType) {
            if (n = t.nodeName.toLowerCase(),
            !x.support.noCloneEvent && t[x.expando]) {
                i = x._data(t);
                for (r in i.events)
                    x.removeEvent(t, r, i.handle);
                t.removeAttribute(x.expando)
            }
            "script" === n && t.text !== e.text ? (Ht(t).text = e.text,
            qt(t)) : "object" === n ? (t.parentNode && (t.outerHTML = e.outerHTML),
            x.support.html5Clone && e.innerHTML && !x.trim(t.innerHTML) && (t.innerHTML = e.innerHTML)) : "input" === n && Ct.test(e.type) ? (t.defaultChecked = t.checked = e.checked,
            t.value !== e.value && (t.value = e.value)) : "option" === n ? t.defaultSelected = t.selected = e.defaultSelected : ("input" === n || "textarea" === n) && (t.defaultValue = e.defaultValue)
        }
    }
    x.each({
        appendTo: "append",
        prependTo: "prepend",
        insertBefore: "before",
        insertAfter: "after",
        replaceAll: "replaceWith"
    }, function(e, t) {
        x.fn[e] = function(e) {
            var n, r = 0, i = [], o = x(e), a = o.length - 1;
            for (; a >= r; r++)
                n = r === a ? this : this.clone(!0),
                x(o[r])[t](n),
                h.apply(i, n.get());
            return this.pushStack(i)
        }
    });
    function Ft(e, n) {
        var r, o, a = 0, s = typeof e.getElementsByTagName !== i ? e.getElementsByTagName(n || "*") : typeof e.querySelectorAll !== i ? e.querySelectorAll(n || "*") : t;
        if (!s)
            for (s = [],
            r = e.childNodes || e; null != (o = r[a]); a++)
                !n || x.nodeName(o, n) ? s.push(o) : x.merge(s, Ft(o, n));
        return n === t || n && x.nodeName(e, n) ? x.merge([e], s) : s
    }
    function Bt(e) {
        Ct.test(e.type) && (e.defaultChecked = e.checked)
    }
    x.extend({
        clone: function(e, t, n) {
            var r, i, o, a, s, l = x.contains(e.ownerDocument, e);
            if (x.support.html5Clone || x.isXMLDoc(e) || !mt.test("<" + e.nodeName + ">") ? o = e.cloneNode(!0) : (Dt.innerHTML = e.outerHTML,
            Dt.removeChild(o = Dt.firstChild)),
            !(x.support.noCloneEvent && x.support.noCloneChecked || 1 !== e.nodeType && 11 !== e.nodeType || x.isXMLDoc(e)))
                for (r = Ft(o),
                s = Ft(e),
                a = 0; null != (i = s[a]); ++a)
                    r[a] && Ot(i, r[a]);
            if (t)
                if (n)
                    for (s = s || Ft(e),
                    r = r || Ft(o),
                    a = 0; null != (i = s[a]); a++)
                        Mt(i, r[a]);
                else
                    Mt(e, o);
            return r = Ft(o, "script"),
            r.length > 0 && _t(r, !l && Ft(e, "script")),
            r = s = i = null,
            o
        },
        buildFragment: function(e, t, n, r) {
            var i, o, a, s, l, u, c, p = e.length, f = dt(t), d = [], h = 0;
            for (; p > h; h++)
                if (o = e[h],
                o || 0 === o)
                    if ("object" === x.type(o))
                        x.merge(d, o.nodeType ? [o] : o);
                    else if (wt.test(o)) {
                        s = s || f.appendChild(t.createElement("div")),
                        l = (bt.exec(o) || ["", ""])[1].toLowerCase(),
                        c = At[l] || At._default,
                        s.innerHTML = c[1] + o.replace(vt, "<$1></$2>") + c[2],
                        i = c[0];
                        while (i--)
                            s = s.lastChild;
                        if (!x.support.leadingWhitespace && yt.test(o) && d.push(t.createTextNode(yt.exec(o)[0])),
                        !x.support.tbody) {
                            o = "table" !== l || xt.test(o) ? "<table>" !== c[1] || xt.test(o) ? 0 : s : s.firstChild,
                            i = o && o.childNodes.length;
                            while (i--)
                                x.nodeName(u = o.childNodes[i], "tbody") && !u.childNodes.length && o.removeChild(u)
                        }
                        x.merge(d, s.childNodes),
                        s.textContent = "";
                        while (s.firstChild)
                            s.removeChild(s.firstChild);
                        s = f.lastChild
                    } else
                        d.push(t.createTextNode(o));
            s && f.removeChild(s),
            x.support.appendChecked || x.grep(Ft(d, "input"), Bt),
            h = 0;
            while (o = d[h++])
                if ((!r || -1 === x.inArray(o, r)) && (a = x.contains(o.ownerDocument, o),
                s = Ft(f.appendChild(o), "script"),
                a && _t(s),
                n)) {
                    i = 0;
                    while (o = s[i++])
                        kt.test(o.type || "") && n.push(o)
                }
            return s = null,
            f
        },
        cleanData: function(e, t) {
            var n, r, o, a, s = 0, l = x.expando, u = x.cache, c = x.support.deleteExpando, f = x.event.special;
            for (; null != (n = e[s]); s++)
                if ((t || x.acceptData(n)) && (o = n[l],
                a = o && u[o])) {
                    if (a.events)
                        for (r in a.events)
                            f[r] ? x.event.remove(n, r) : x.removeEvent(n, r, a.handle);
                    u[o] && (delete u[o],
                    c ? delete n[l] : typeof n.removeAttribute !== i ? n.removeAttribute(l) : n[l] = null,
                    p.push(o))
                }
        },
        _evalUrl: function(e) {
            return x.ajax({
                url: e,
                type: "GET",
                dataType: "script",
                async: !1,
                global: !1,
                "throws": !0
            })
        }
    }),
    x.fn.extend({
        wrapAll: function(e) {
            if (x.isFunction(e))
                return this.each(function(t) {
                    x(this).wrapAll(e.call(this, t))
                });
            if (this[0]) {
                var t = x(e, this[0].ownerDocument).eq(0).clone(!0);
                this[0].parentNode && t.insertBefore(this[0]),
                t.map(function() {
                    var e = this;
                    while (e.firstChild && 1 === e.firstChild.nodeType)
                        e = e.firstChild;
                    return e
                }).append(this)
            }
            return this
        },
        wrapInner: function(e) {
            return x.isFunction(e) ? this.each(function(t) {
                x(this).wrapInner(e.call(this, t))
            }) : this.each(function() {
                var t = x(this)
                  , n = t.contents();
                n.length ? n.wrapAll(e) : t.append(e)
            })
        },
        wrap: function(e) {
            var t = x.isFunction(e);
            return this.each(function(n) {
                x(this).wrapAll(t ? e.call(this, n) : e)
            })
        },
        unwrap: function() {
            return this.parent().each(function() {
                x.nodeName(this, "body") || x(this).replaceWith(this.childNodes)
            }).end()
        }
    });
    var Pt, Rt, Wt, $t = /alpha\([^)]*\)/i, It = /opacity\s*=\s*([^)]*)/, zt = /^(top|right|bottom|left)$/, Xt = /^(none|table(?!-c[ea]).+)/, Ut = /^margin/, Vt = RegExp("^(" + w + ")(.*)$", "i"), Yt = RegExp("^(" + w + ")(?!px)[a-z%]+$", "i"), Jt = RegExp("^([+-])=(" + w + ")", "i"), Gt = {
        BODY: "block"
    }, Qt = {
        position: "absolute",
        visibility: "hidden",
        display: "block"
    }, Kt = {
        letterSpacing: 0,
        fontWeight: 400
    }, Zt = ["Top", "Right", "Bottom", "Left"], en = ["Webkit", "O", "Moz", "ms"];
    function tn(e, t) {
        if (t in e)
            return t;
        var n = t.charAt(0).toUpperCase() + t.slice(1)
          , r = t
          , i = en.length;
        while (i--)
            if (t = en[i] + n,
            t in e)
                return t;
        return r
    }
    function nn(e, t) {
        return e = t || e,
        "none" === x.css(e, "display") || !x.contains(e.ownerDocument, e)
    }
    function rn(e, t) {
        var n, r, i, o = [], a = 0, s = e.length;
        for (; s > a; a++)
            r = e[a],
            r.style && (o[a] = x._data(r, "olddisplay"),
            n = r.style.display,
            t ? (o[a] || "none" !== n || (r.style.display = ""),
            "" === r.style.display && nn(r) && (o[a] = x._data(r, "olddisplay", ln(r.nodeName)))) : o[a] || (i = nn(r),
            (n && "none" !== n || !i) && x._data(r, "olddisplay", i ? n : x.css(r, "display"))));
        for (a = 0; s > a; a++)
            r = e[a],
            r.style && (t && "none" !== r.style.display && "" !== r.style.display || (r.style.display = t ? o[a] || "" : "none"));
        return e
    }
    x.fn.extend({
        css: function(e, n) {
            return x.access(this, function(e, n, r) {
                var i, o, a = {}, s = 0;
                if (x.isArray(n)) {
                    for (o = Rt(e),
                    i = n.length; i > s; s++)
                        a[n[s]] = x.css(e, n[s], !1, o);
                    return a
                }
                return r !== t ? x.style(e, n, r) : x.css(e, n)
            }, e, n, arguments.length > 1)
        },
        show: function() {
            return rn(this, !0)
        },
        hide: function() {
            return rn(this)
        },
        toggle: function(e) {
            return "boolean" == typeof e ? e ? this.show() : this.hide() : this.each(function() {
                nn(this) ? x(this).show() : x(this).hide()
            })
        }
    }),
    x.extend({
        cssHooks: {
            opacity: {
                get: function(e, t) {
                    if (t) {
                        var n = Wt(e, "opacity");
                        return "" === n ? "1" : n
                    }
                }
            }
        },
        cssNumber: {
            columnCount: !0,
            fillOpacity: !0,
            fontWeight: !0,
            lineHeight: !0,
            opacity: !0,
            order: !0,
            orphans: !0,
            widows: !0,
            zIndex: !0,
            zoom: !0
        },
        cssProps: {
            "float": x.support.cssFloat ? "cssFloat" : "styleFloat"
        },
        style: function(e, n, r, i) {
            if (e && 3 !== e.nodeType && 8 !== e.nodeType && e.style) {
                var o, a, s, l = x.camelCase(n), u = e.style;
                if (n = x.cssProps[l] || (x.cssProps[l] = tn(u, l)),
                s = x.cssHooks[n] || x.cssHooks[l],
                r === t)
                    return s && "get"in s && (o = s.get(e, !1, i)) !== t ? o : u[n];
                if (a = typeof r,
                "string" === a && (o = Jt.exec(r)) && (r = (o[1] + 1) * o[2] + parseFloat(x.css(e, n)),
                a = "number"),
                !(null == r || "number" === a && isNaN(r) || ("number" !== a || x.cssNumber[l] || (r += "px"),
                x.support.clearCloneStyle || "" !== r || 0 !== n.indexOf("background") || (u[n] = "inherit"),
                s && "set"in s && (r = s.set(e, r, i)) === t)))
                    try {
                        u[n] = r
                    } catch (c) {}
            }
        },
        css: function(e, n, r, i) {
            var o, a, s, l = x.camelCase(n);
            return n = x.cssProps[l] || (x.cssProps[l] = tn(e.style, l)),
            s = x.cssHooks[n] || x.cssHooks[l],
            s && "get"in s && (a = s.get(e, !0, r)),
            a === t && (a = Wt(e, n, i)),
            "normal" === a && n in Kt && (a = Kt[n]),
            "" === r || r ? (o = parseFloat(a),
            r === !0 || x.isNumeric(o) ? o || 0 : a) : a
        }
    }),
    e.getComputedStyle ? (Rt = function(t) {
        return e.getComputedStyle(t, null)
    }
    ,
    Wt = function(e, n, r) {
        var i, o, a, s = r || Rt(e), l = s ? s.getPropertyValue(n) || s[n] : t, u = e.style;
        return s && ("" !== l || x.contains(e.ownerDocument, e) || (l = x.style(e, n)),
        Yt.test(l) && Ut.test(n) && (i = u.width,
        o = u.minWidth,
        a = u.maxWidth,
        u.minWidth = u.maxWidth = u.width = l,
        l = s.width,
        u.width = i,
        u.minWidth = o,
        u.maxWidth = a)),
        l
    }
    ) : a.documentElement.currentStyle && (Rt = function(e) {
        return e.currentStyle
    }
    ,
    Wt = function(e, n, r) {
        var i, o, a, s = r || Rt(e), l = s ? s[n] : t, u = e.style;
        return null == l && u && u[n] && (l = u[n]),
        Yt.test(l) && !zt.test(n) && (i = u.left,
        o = e.runtimeStyle,
        a = o && o.left,
        a && (o.left = e.currentStyle.left),
        u.left = "fontSize" === n ? "1em" : l,
        l = u.pixelLeft + "px",
        u.left = i,
        a && (o.left = a)),
        "" === l ? "auto" : l
    }
    );
    function on(e, t, n) {
        var r = Vt.exec(t);
        return r ? Math.max(0, r[1] - (n || 0)) + (r[2] || "px") : t
    }
    function an(e, t, n, r, i) {
        var o = n === (r ? "border" : "content") ? 4 : "width" === t ? 1 : 0
          , a = 0;
        for (; 4 > o; o += 2)
            "margin" === n && (a += x.css(e, n + Zt[o], !0, i)),
            r ? ("content" === n && (a -= x.css(e, "padding" + Zt[o], !0, i)),
            "margin" !== n && (a -= x.css(e, "border" + Zt[o] + "Width", !0, i))) : (a += x.css(e, "padding" + Zt[o], !0, i),
            "padding" !== n && (a += x.css(e, "border" + Zt[o] + "Width", !0, i)));
        return a
    }
    function sn(e, t, n) {
        var r = !0
          , i = "width" === t ? e.offsetWidth : e.offsetHeight
          , o = Rt(e)
          , a = x.support.boxSizing && "border-box" === x.css(e, "boxSizing", !1, o);
        if (0 >= i || null == i) {
            if (i = Wt(e, t, o),
            (0 > i || null == i) && (i = e.style[t]),
            Yt.test(i))
                return i;
            r = a && (x.support.boxSizingReliable || i === e.style[t]),
            i = parseFloat(i) || 0
        }
        return i + an(e, t, n || (a ? "border" : "content"), r, o) + "px"
    }
    function ln(e) {
        var t = a
          , n = Gt[e];
        return n || (n = un(e, t),
        "none" !== n && n || (Pt = (Pt || x("<iframe frameborder='0' width='0' height='0'/>").css("cssText", "display:block !important")).appendTo(t.documentElement),
        t = (Pt[0].contentWindow || Pt[0].contentDocument).document,
        t.write("<!doctype html><html><body>"),
        t.close(),
        n = un(e, t),
        Pt.detach()),
        Gt[e] = n),
        n
    }
    function un(e, t) {
        var n = x(t.createElement(e)).appendTo(t.body)
          , r = x.css(n[0], "display");
        return n.remove(),
        r
    }
    x.each(["height", "width"], function(e, n) {
        x.cssHooks[n] = {
            get: function(e, r, i) {
                return r ? 0 === e.offsetWidth && Xt.test(x.css(e, "display")) ? x.swap(e, Qt, function() {
                    return sn(e, n, i)
                }) : sn(e, n, i) : t
            },
            set: function(e, t, r) {
                var i = r && Rt(e);
                return on(e, t, r ? an(e, n, r, x.support.boxSizing && "border-box" === x.css(e, "boxSizing", !1, i), i) : 0)
            }
        }
    }),
    x.support.opacity || (x.cssHooks.opacity = {
        get: function(e, t) {
            return It.test((t && e.currentStyle ? e.currentStyle.filter : e.style.filter) || "") ? .01 * parseFloat(RegExp.$1) + "" : t ? "1" : ""
        },
        set: function(e, t) {
            var n = e.style
              , r = e.currentStyle
              , i = x.isNumeric(t) ? "alpha(opacity=" + 100 * t + ")" : ""
              , o = r && r.filter || n.filter || "";
            n.zoom = 1,
            (t >= 1 || "" === t) && "" === x.trim(o.replace($t, "")) && n.removeAttribute && (n.removeAttribute("filter"),
            "" === t || r && !r.filter) || (n.filter = $t.test(o) ? o.replace($t, i) : o + " " + i)
        }
    }),
    x(function() {
        x.support.reliableMarginRight || (x.cssHooks.marginRight = {
            get: function(e, n) {
                return n ? x.swap(e, {
                    display: "inline-block"
                }, Wt, [e, "marginRight"]) : t
            }
        }),
        !x.support.pixelPosition && x.fn.position && x.each(["top", "left"], function(e, n) {
            x.cssHooks[n] = {
                get: function(e, r) {
                    return r ? (r = Wt(e, n),
                    Yt.test(r) ? x(e).position()[n] + "px" : r) : t
                }
            }
        })
    }),
    x.expr && x.expr.filters && (x.expr.filters.hidden = function(e) {
        return 0 >= e.offsetWidth && 0 >= e.offsetHeight || !x.support.reliableHiddenOffsets && "none" === (e.style && e.style.display || x.css(e, "display"))
    }
    ,
    x.expr.filters.visible = function(e) {
        return !x.expr.filters.hidden(e)
    }
    ),
    x.each({
        margin: "",
        padding: "",
        border: "Width"
    }, function(e, t) {
        x.cssHooks[e + t] = {
            expand: function(n) {
                var r = 0
                  , i = {}
                  , o = "string" == typeof n ? n.split(" ") : [n];
                for (; 4 > r; r++)
                    i[e + Zt[r] + t] = o[r] || o[r - 2] || o[0];
                return i
            }
        },
        Ut.test(e) || (x.cssHooks[e + t].set = on)
    });
    var cn = /%20/g
      , pn = /\[\]$/
      , fn = /\r?\n/g
      , dn = /^(?:submit|button|image|reset|file)$/i
      , hn = /^(?:input|select|textarea|keygen)/i;
    x.fn.extend({
        serialize: function() {
            return x.param(this.serializeArray())
        },
        serializeArray: function() {
            return this.map(function() {
                var e = x.prop(this, "elements");
                return e ? x.makeArray(e) : this
            }).filter(function() {
                var e = this.type;
                return this.name && !x(this).is(":disabled") && hn.test(this.nodeName) && !dn.test(e) && (this.checked || !Ct.test(e))
            }).map(function(e, t) {
                var n = x(this).val();
                return null == n ? null : x.isArray(n) ? x.map(n, function(e) {
                    return {
                        name: t.name,
                        value: e.replace(fn, "\r\n")
                    }
                }) : {
                    name: t.name,
                    value: n.replace(fn, "\r\n")
                }
            }).get()
        }
    }),
    x.param = function(e, n) {
        var r, i = [], o = function(e, t) {
            t = x.isFunction(t) ? t() : null == t ? "" : t,
            i[i.length] = encodeURIComponent(e) + "=" + encodeURIComponent(t)
        };
        if (n === t && (n = x.ajaxSettings && x.ajaxSettings.traditional),
        x.isArray(e) || e.jquery && !x.isPlainObject(e))
            x.each(e, function() {
                o(this.name, this.value)
            });
        else
            for (r in e)
                gn(r, e[r], n, o);
        return i.join("&").replace(cn, "+")
    }
    ;
    function gn(e, t, n, r) {
        var i;
        if (x.isArray(t))
            x.each(t, function(t, i) {
                n || pn.test(e) ? r(e, i) : gn(e + "[" + ("object" == typeof i ? t : "") + "]", i, n, r)
            });
        else if (n || "object" !== x.type(t))
            r(e, t);
        else
            for (i in t)
                gn(e + "[" + i + "]", t[i], n, r)
    }
    x.each("blur focus focusin focusout load resize scroll unload click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup error contextmenu".split(" "), function(e, t) {
        x.fn[t] = function(e, n) {
            return arguments.length > 0 ? this.on(t, null, e, n) : this.trigger(t)
        }
    }),
    x.fn.extend({
        hover: function(e, t) {
            return this.mouseenter(e).mouseleave(t || e)
        },
        bind: function(e, t, n) {
            return this.on(e, null, t, n)
        },
        unbind: function(e, t) {
            return this.off(e, null, t)
        },
        delegate: function(e, t, n, r) {
            return this.on(t, e, n, r)
        },
        undelegate: function(e, t, n) {
            return 1 === arguments.length ? this.off(e, "**") : this.off(t, e || "**", n)
        }
    });
    var mn, yn, vn = x.now(), bn = /\?/, xn = /#.*$/, wn = /([?&])_=[^&]*/, Tn = /^(.*?):[ \t]*([^\r\n]*)\r?$/gm, Cn = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/, Nn = /^(?:GET|HEAD)$/, kn = /^\/\//, En = /^([\w.+-]+:)(?:\/\/([^\/?#:]*)(?::(\d+)|)|)/, Sn = x.fn.load, An = {}, jn = {}, Dn = "*/".concat("*");
    try {
        yn = o.href
    } catch (Ln) {
        yn = a.createElement("a"),
        yn.href = "",
        yn = yn.href
    }
    mn = En.exec(yn.toLowerCase()) || [];
    function Hn(e) {
        return function(t, n) {
            "string" != typeof t && (n = t,
            t = "*");
            var r, i = 0, o = t.toLowerCase().match(T) || [];
            if (x.isFunction(n))
                while (r = o[i++])
                    "+" === r[0] ? (r = r.slice(1) || "*",
                    (e[r] = e[r] || []).unshift(n)) : (e[r] = e[r] || []).push(n)
        }
    }
    function qn(e, n, r, i) {
        var o = {}
          , a = e === jn;
        function s(l) {
            var u;
            return o[l] = !0,
            x.each(e[l] || [], function(e, l) {
                var c = l(n, r, i);
                return "string" != typeof c || a || o[c] ? a ? !(u = c) : t : (n.dataTypes.unshift(c),
                s(c),
                !1)
            }),
            u
        }
        return s(n.dataTypes[0]) || !o["*"] && s("*")
    }
    function _n(e, n) {
        var r, i, o = x.ajaxSettings.flatOptions || {};
        for (i in n)
            n[i] !== t && ((o[i] ? e : r || (r = {}))[i] = n[i]);
        return r && x.extend(!0, e, r),
        e
    }
    x.fn.load = function(e, n, r) {
        if ("string" != typeof e && Sn)
            return Sn.apply(this, arguments);
        var i, o, a, s = this, l = e.indexOf(" ");
        return l >= 0 && (i = e.slice(l, e.length),
        e = e.slice(0, l)),
        x.isFunction(n) ? (r = n,
        n = t) : n && "object" == typeof n && (a = "POST"),
        s.length > 0 && x.ajax({
            url: e,
            type: a,
            dataType: "html",
            data: n
        }).done(function(e) {
            o = arguments,
            s.html(i ? x("<div>").append(x.parseHTML(e)).find(i) : e)
        }).complete(r && function(e, t) {
            s.each(r, o || [e.responseText, t, e])
        }
        ),
        this
    }
    ,
    x.each(["ajaxStart", "ajaxStop", "ajaxComplete", "ajaxError", "ajaxSuccess", "ajaxSend"], function(e, t) {
        x.fn[t] = function(e) {
            return this.on(t, e)
        }
    }),
    x.extend({
        active: 0,
        lastModified: {},
        etag: {},
        ajaxSettings: {
            url: yn,
            type: "GET",
            isLocal: Cn.test(mn[1]),
            global: !0,
            processData: !0,
            async: !0,
            contentType: "application/x-www-form-urlencoded; charset=UTF-8",
            accepts: {
                "*": Dn,
                text: "text/plain",
                html: "text/html",
                xml: "application/xml, text/xml",
                json: "application/json, text/javascript"
            },
            contents: {
                xml: /xml/,
                html: /html/,
                json: /json/
            },
            responseFields: {
                xml: "responseXML",
                text: "responseText",
                json: "responseJSON"
            },
            converters: {
                "* text": String,
                "text html": !0,
                "text json": x.parseJSON,
                "text xml": x.parseXML
            },
            flatOptions: {
                url: !0,
                context: !0
            }
        },
        ajaxSetup: function(e, t) {
            return t ? _n(_n(e, x.ajaxSettings), t) : _n(x.ajaxSettings, e)
        },
        ajaxPrefilter: Hn(An),
        ajaxTransport: Hn(jn),
        ajax: function(e, n) {
            "object" == typeof e && (n = e,
            e = t),
            n = n || {};
            var r, i, o, a, s, l, u, c, p = x.ajaxSetup({}, n), f = p.context || p, d = p.context && (f.nodeType || f.jquery) ? x(f) : x.event, h = x.Deferred(), g = x.Callbacks("once memory"), m = p.statusCode || {}, y = {}, v = {}, b = 0, w = "canceled", C = {
                readyState: 0,
                getResponseHeader: function(e) {
                    var t;
                    if (2 === b) {
                        if (!c) {
                            c = {};
                            while (t = Tn.exec(a))
                                c[t[1].toLowerCase()] = t[2]
                        }
                        t = c[e.toLowerCase()]
                    }
                    return null == t ? null : t
                },
                getAllResponseHeaders: function() {
                    return 2 === b ? a : null
                },
                setRequestHeader: function(e, t) {
                    var n = e.toLowerCase();
                    return b || (e = v[n] = v[n] || e,
                    y[e] = t),
                    this
                },
                overrideMimeType: function(e) {
                    return b || (p.mimeType = e),
                    this
                },
                statusCode: function(e) {
                    var t;
                    if (e)
                        if (2 > b)
                            for (t in e)
                                m[t] = [m[t], e[t]];
                        else
                            C.always(e[C.status]);
                    return this
                },
                abort: function(e) {
                    var t = e || w;
                    return u && u.abort(t),
                    k(0, t),
                    this
                }
            };
            if (h.promise(C).complete = g.add,
            C.success = C.done,
            C.error = C.fail,
            p.url = ((e || p.url || yn) + "").replace(xn, "").replace(kn, mn[1] + "//"),
            p.type = n.method || n.type || p.method || p.type,
            p.dataTypes = x.trim(p.dataType || "*").toLowerCase().match(T) || [""],
            null == p.crossDomain && (r = En.exec(p.url.toLowerCase()),
            p.crossDomain = !(!r || r[1] === mn[1] && r[2] === mn[2] && (r[3] || ("http:" === r[1] ? "80" : "443")) === (mn[3] || ("http:" === mn[1] ? "80" : "443")))),
            p.data && p.processData && "string" != typeof p.data && (p.data = x.param(p.data, p.traditional)),
            qn(An, p, n, C),
            2 === b)
                return C;
            l = p.global,
            l && 0 === x.active++ && x.event.trigger("ajaxStart"),
            p.type = p.type.toUpperCase(),
            p.hasContent = !Nn.test(p.type),
            o = p.url,
            p.hasContent || (p.data && (o = p.url += (bn.test(o) ? "&" : "?") + p.data,
            delete p.data),
            p.cache === !1 && (p.url = wn.test(o) ? o.replace(wn, "$1_=" + vn++) : o + (bn.test(o) ? "&" : "?") + "_=" + vn++)),
            p.ifModified && (x.lastModified[o] && C.setRequestHeader("If-Modified-Since", x.lastModified[o]),
            x.etag[o] && C.setRequestHeader("If-None-Match", x.etag[o])),
            (p.data && p.hasContent && p.contentType !== !1 || n.contentType) && C.setRequestHeader("Content-Type", p.contentType),
            C.setRequestHeader("Accept", p.dataTypes[0] && p.accepts[p.dataTypes[0]] ? p.accepts[p.dataTypes[0]] + ("*" !== p.dataTypes[0] ? ", " + Dn + "; q=0.01" : "") : p.accepts["*"]);
            for (i in p.headers)
                C.setRequestHeader(i, p.headers[i]);
            if (p.beforeSend && (p.beforeSend.call(f, C, p) === !1 || 2 === b))
                return C.abort();
            w = "abort";
            for (i in {
                success: 1,
                error: 1,
                complete: 1
            })
                C[i](p[i]);
            if (u = qn(jn, p, n, C)) {
                C.readyState = 1,
                l && d.trigger("ajaxSend", [C, p]),
                p.async && p.timeout > 0 && (s = setTimeout(function() {
                    C.abort("timeout")
                }, p.timeout));
                try {
                    b = 1,
                    u.send(y, k)
                } catch (N) {
                    if (!(2 > b))
                        throw N;
                    k(-1, N)
                }
            } else
                k(-1, "No Transport");
            function k(e, n, r, i) {
                var c, y, v, w, T, N = n;
                2 !== b && (b = 2,
                s && clearTimeout(s),
                u = t,
                a = i || "",
                C.readyState = e > 0 ? 4 : 0,
                c = e >= 200 && 300 > e || 304 === e,
                r && (w = Mn(p, C, r)),
                w = On(p, w, C, c),
                c ? (p.ifModified && (T = C.getResponseHeader("Last-Modified"),
                T && (x.lastModified[o] = T),
                T = C.getResponseHeader("etag"),
                T && (x.etag[o] = T)),
                204 === e || "HEAD" === p.type ? N = "nocontent" : 304 === e ? N = "notmodified" : (N = w.state,
                y = w.data,
                v = w.error,
                c = !v)) : (v = N,
                (e || !N) && (N = "error",
                0 > e && (e = 0))),
                C.status = e,
                C.statusText = (n || N) + "",
                c ? h.resolveWith(f, [y, N, C]) : h.rejectWith(f, [C, N, v]),
                C.statusCode(m),
                m = t,
                l && d.trigger(c ? "ajaxSuccess" : "ajaxError", [C, p, c ? y : v]),
                g.fireWith(f, [C, N]),
                l && (d.trigger("ajaxComplete", [C, p]),
                --x.active || x.event.trigger("ajaxStop")))
            }
            return C
        },
        getJSON: function(e, t, n) {
            return x.get(e, t, n, "json")
        },
        getScript: function(e, n) {
            return x.get(e, t, n, "script")
        }
    }),
    x.each(["get", "post"], function(e, n) {
        x[n] = function(e, r, i, o) {
            return x.isFunction(r) && (o = o || i,
            i = r,
            r = t),
            x.ajax({
                url: e,
                type: n,
                dataType: o,
                data: r,
                success: i
            })
        }
    });
    function Mn(e, n, r) {
        var i, o, a, s, l = e.contents, u = e.dataTypes;
        while ("*" === u[0])
            u.shift(),
            o === t && (o = e.mimeType || n.getResponseHeader("Content-Type"));
        if (o)
            for (s in l)
                if (l[s] && l[s].test(o)) {
                    u.unshift(s);
                    break
                }
        if (u[0]in r)
            a = u[0];
        else {
            for (s in r) {
                if (!u[0] || e.converters[s + " " + u[0]]) {
                    a = s;
                    break
                }
                i || (i = s)
            }
            a = a || i
        }
        return a ? (a !== u[0] && u.unshift(a),
        r[a]) : t
    }
    function On(e, t, n, r) {
        var i, o, a, s, l, u = {}, c = e.dataTypes.slice();
        if (c[1])
            for (a in e.converters)
                u[a.toLowerCase()] = e.converters[a];
        o = c.shift();
        while (o)
            if (e.responseFields[o] && (n[e.responseFields[o]] = t),
            !l && r && e.dataFilter && (t = e.dataFilter(t, e.dataType)),
            l = o,
            o = c.shift())
                if ("*" === o)
                    o = l;
                else if ("*" !== l && l !== o) {
                    if (a = u[l + " " + o] || u["* " + o],
                    !a)
                        for (i in u)
                            if (s = i.split(" "),
                            s[1] === o && (a = u[l + " " + s[0]] || u["* " + s[0]])) {
                                a === !0 ? a = u[i] : u[i] !== !0 && (o = s[0],
                                c.unshift(s[1]));
                                break
                            }
                    if (a !== !0)
                        if (a && e["throws"])
                            t = a(t);
                        else
                            try {
                                t = a(t)
                            } catch (p) {
                                return {
                                    state: "parsererror",
                                    error: a ? p : "No conversion from " + l + " to " + o
                                }
                            }
                }
        return {
            state: "success",
            data: t
        }
    }
    x.ajaxSetup({
        accepts: {
            script: "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"
        },
        contents: {
            script: /(?:java|ecma)script/
        },
        converters: {
            "text script": function(e) {
                return x.globalEval(e),
                e
            }
        }
    }),
    x.ajaxPrefilter("script", function(e) {
        e.cache === t && (e.cache = !1),
        e.crossDomain && (e.type = "GET",
        e.global = !1)
    }),
    x.ajaxTransport("script", function(e) {
        if (e.crossDomain) {
            var n, r = a.head || x("head")[0] || a.documentElement;
            return {
                send: function(t, i) {
                    n = a.createElement("script"),
                    n.async = !0,
                    e.scriptCharset && (n.charset = e.scriptCharset),
                    n.src = e.url,
                    n.onload = n.onreadystatechange = function(e, t) {
                        (t || !n.readyState || /loaded|complete/.test(n.readyState)) && (n.onload = n.onreadystatechange = null,
                        n.parentNode && n.parentNode.removeChild(n),
                        n = null,
                        t || i(200, "success"))
                    }
                    ,
                    r.insertBefore(n, r.firstChild)
                },
                abort: function() {
                    n && n.onload(t, !0)
                }
            }
        }
    });
    var Fn = []
      , Bn = /(=)\?(?=&|$)|\?\?/;
    x.ajaxSetup({
        jsonp: "callback",
        jsonpCallback: function() {
            var e = Fn.pop() || x.expando + "_" + vn++;
            return this[e] = !0,
            e
        }
    }),
    x.ajaxPrefilter("json jsonp", function(n, r, i) {
        var o, a, s, l = n.jsonp !== !1 && (Bn.test(n.url) ? "url" : "string" == typeof n.data && !(n.contentType || "").indexOf("application/x-www-form-urlencoded") && Bn.test(n.data) && "data");
        return l || "jsonp" === n.dataTypes[0] ? (o = n.jsonpCallback = x.isFunction(n.jsonpCallback) ? n.jsonpCallback() : n.jsonpCallback,
        l ? n[l] = n[l].replace(Bn, "$1" + o) : n.jsonp !== !1 && (n.url += (bn.test(n.url) ? "&" : "?") + n.jsonp + "=" + o),
        n.converters["script json"] = function() {
            return s || x.error(o + " was not called"),
            s[0]
        }
        ,
        n.dataTypes[0] = "json",
        a = e[o],
        e[o] = function() {
            s = arguments
        }
        ,
        i.always(function() {
            e[o] = a,
            n[o] && (n.jsonpCallback = r.jsonpCallback,
            Fn.push(o)),
            s && x.isFunction(a) && a(s[0]),
            s = a = t
        }),
        "script") : t
    });
    var Pn, Rn, Wn = 0, $n = e.ActiveXObject && function() {
        var e;
        for (e in Pn)
            Pn[e](t, !0)
    }
    ;
    function In() {
        try {
            return new e.XMLHttpRequest
        } catch (t) {}
    }
    function zn() {
        try {
            return new e.ActiveXObject("Microsoft.XMLHTTP")
        } catch (t) {}
    }
    x.ajaxSettings.xhr = e.ActiveXObject ? function() {
        return !this.isLocal && In() || zn()
    }
    : In,
    Rn = x.ajaxSettings.xhr(),
    x.support.cors = !!Rn && "withCredentials"in Rn,
    Rn = x.support.ajax = !!Rn,
    Rn && x.ajaxTransport(function(n) {
        if (!n.crossDomain || x.support.cors) {
            var r;
            return {
                send: function(i, o) {
                    var a, s, l = n.xhr();
                    if (n.username ? l.open(n.type, n.url, n.async, n.username, n.password) : l.open(n.type, n.url, n.async),
                    n.xhrFields)
                        for (s in n.xhrFields)
                            l[s] = n.xhrFields[s];
                    n.mimeType && l.overrideMimeType && l.overrideMimeType(n.mimeType),
                    n.crossDomain || i["X-Requested-With"] || (i["X-Requested-With"] = "XMLHttpRequest");
                    try {
                        for (s in i)
                            l.setRequestHeader(s, i[s])
                    } catch (u) {}
                    l.send(n.hasContent && n.data || null),
                    r = function(e, i) {
                        var s, u, c, p;
                        try {
                            if (r && (i || 4 === l.readyState))
                                if (r = t,
                                a && (l.onreadystatechange = x.noop,
                                $n && delete Pn[a]),
                                i)
                                    4 !== l.readyState && l.abort();
                                else {
                                    p = {},
                                    s = l.status,
                                    u = l.getAllResponseHeaders(),
                                    "string" == typeof l.responseText && (p.text = l.responseText);
                                    try {
                                        c = l.statusText
                                    } catch (f) {
                                        c = ""
                                    }
                                    s || !n.isLocal || n.crossDomain ? 1223 === s && (s = 204) : s = p.text ? 200 : 404
                                }
                        } catch (d) {
                            i || o(-1, d)
                        }
                        p && o(s, c, p, u)
                    }
                    ,
                    n.async ? 4 === l.readyState ? setTimeout(r) : (a = ++Wn,
                    $n && (Pn || (Pn = {},
                    x(e).unload($n)),
                    Pn[a] = r),
                    l.onreadystatechange = r) : r()
                },
                abort: function() {
                    r && r(t, !0)
                }
            }
        }
    });
    var Xn, Un, Vn = /^(?:toggle|show|hide)$/, Yn = RegExp("^(?:([+-])=|)(" + w + ")([a-z%]*)$", "i"), Jn = /queueHooks$/, Gn = [nr], Qn = {
        "*": [function(e, t) {
            var n = this.createTween(e, t)
              , r = n.cur()
              , i = Yn.exec(t)
              , o = i && i[3] || (x.cssNumber[e] ? "" : "px")
              , a = (x.cssNumber[e] || "px" !== o && +r) && Yn.exec(x.css(n.elem, e))
              , s = 1
              , l = 20;
            if (a && a[3] !== o) {
                o = o || a[3],
                i = i || [],
                a = +r || 1;
                do
                    s = s || ".5",
                    a /= s,
                    x.style(n.elem, e, a + o);
                while (s !== (s = n.cur() / r) && 1 !== s && --l)
            }
            return i && (a = n.start = +a || +r || 0,
            n.unit = o,
            n.end = i[1] ? a + (i[1] + 1) * i[2] : +i[2]),
            n
        }
        ]
    };
    function Kn() {
        return setTimeout(function() {
            Xn = t
        }),
        Xn = x.now()
    }
    function Zn(e, t, n) {
        var r, i = (Qn[t] || []).concat(Qn["*"]), o = 0, a = i.length;
        for (; a > o; o++)
            if (r = i[o].call(n, t, e))
                return r
    }
    function er(e, t, n) {
        var r, i, o = 0, a = Gn.length, s = x.Deferred().always(function() {
            delete l.elem
        }), l = function() {
            if (i)
                return !1;
            var t = Xn || Kn()
              , n = Math.max(0, u.startTime + u.duration - t)
              , r = n / u.duration || 0
              , o = 1 - r
              , a = 0
              , l = u.tweens.length;
            for (; l > a; a++)
                u.tweens[a].run(o);
            return s.notifyWith(e, [u, o, n]),
            1 > o && l ? n : (s.resolveWith(e, [u]),
            !1)
        }, u = s.promise({
            elem: e,
            props: x.extend({}, t),
            opts: x.extend(!0, {
                specialEasing: {}
            }, n),
            originalProperties: t,
            originalOptions: n,
            startTime: Xn || Kn(),
            duration: n.duration,
            tweens: [],
            createTween: function(t, n) {
                var r = x.Tween(e, u.opts, t, n, u.opts.specialEasing[t] || u.opts.easing);
                return u.tweens.push(r),
                r
            },
            stop: function(t) {
                var n = 0
                  , r = t ? u.tweens.length : 0;
                if (i)
                    return this;
                for (i = !0; r > n; n++)
                    u.tweens[n].run(1);
                return t ? s.resolveWith(e, [u, t]) : s.rejectWith(e, [u, t]),
                this
            }
        }), c = u.props;
        for (tr(c, u.opts.specialEasing); a > o; o++)
            if (r = Gn[o].call(u, e, c, u.opts))
                return r;
        return x.map(c, Zn, u),
        x.isFunction(u.opts.start) && u.opts.start.call(e, u),
        x.fx.timer(x.extend(l, {
            elem: e,
            anim: u,
            queue: u.opts.queue
        })),
        u.progress(u.opts.progress).done(u.opts.done, u.opts.complete).fail(u.opts.fail).always(u.opts.always)
    }
    function tr(e, t) {
        var n, r, i, o, a;
        for (n in e)
            if (r = x.camelCase(n),
            i = t[r],
            o = e[n],
            x.isArray(o) && (i = o[1],
            o = e[n] = o[0]),
            n !== r && (e[r] = o,
            delete e[n]),
            a = x.cssHooks[r],
            a && "expand"in a) {
                o = a.expand(o),
                delete e[r];
                for (n in o)
                    n in e || (e[n] = o[n],
                    t[n] = i)
            } else
                t[r] = i
    }
    x.Animation = x.extend(er, {
        tweener: function(e, t) {
            x.isFunction(e) ? (t = e,
            e = ["*"]) : e = e.split(" ");
            var n, r = 0, i = e.length;
            for (; i > r; r++)
                n = e[r],
                Qn[n] = Qn[n] || [],
                Qn[n].unshift(t)
        },
        prefilter: function(e, t) {
            t ? Gn.unshift(e) : Gn.push(e)
        }
    });
    function nr(e, t, n) {
        var r, i, o, a, s, l, u = this, c = {}, p = e.style, f = e.nodeType && nn(e), d = x._data(e, "fxshow");
        n.queue || (s = x._queueHooks(e, "fx"),
        null == s.unqueued && (s.unqueued = 0,
        l = s.empty.fire,
        s.empty.fire = function() {
            s.unqueued || l()
        }
        ),
        s.unqueued++,
        u.always(function() {
            u.always(function() {
                s.unqueued--,
                x.queue(e, "fx").length || s.empty.fire()
            })
        })),
        1 === e.nodeType && ("height"in t || "width"in t) && (n.overflow = [p.overflow, p.overflowX, p.overflowY],
        "inline" === x.css(e, "display") && "none" === x.css(e, "float") && (x.support.inlineBlockNeedsLayout && "inline" !== ln(e.nodeName) ? p.zoom = 1 : p.display = "inline-block")),
        n.overflow && (p.overflow = "hidden",
        x.support.shrinkWrapBlocks || u.always(function() {
            p.overflow = n.overflow[0],
            p.overflowX = n.overflow[1],
            p.overflowY = n.overflow[2]
        }));
        for (r in t)
            if (i = t[r],
            Vn.exec(i)) {
                if (delete t[r],
                o = o || "toggle" === i,
                i === (f ? "hide" : "show"))
                    continue;
                c[r] = d && d[r] || x.style(e, r)
            }
        if (!x.isEmptyObject(c)) {
            d ? "hidden"in d && (f = d.hidden) : d = x._data(e, "fxshow", {}),
            o && (d.hidden = !f),
            f ? x(e).show() : u.done(function() {
                x(e).hide()
            }),
            u.done(function() {
                var t;
                x._removeData(e, "fxshow");
                for (t in c)
                    x.style(e, t, c[t])
            });
            for (r in c)
                a = Zn(f ? d[r] : 0, r, u),
                r in d || (d[r] = a.start,
                f && (a.end = a.start,
                a.start = "width" === r || "height" === r ? 1 : 0))
        }
    }
    function rr(e, t, n, r, i) {
        return new rr.prototype.init(e,t,n,r,i)
    }
    x.Tween = rr,
    rr.prototype = {
        constructor: rr,
        init: function(e, t, n, r, i, o) {
            this.elem = e,
            this.prop = n,
            this.easing = i || "swing",
            this.options = t,
            this.start = this.now = this.cur(),
            this.end = r,
            this.unit = o || (x.cssNumber[n] ? "" : "px")
        },
        cur: function() {
            var e = rr.propHooks[this.prop];
            return e && e.get ? e.get(this) : rr.propHooks._default.get(this)
        },
        run: function(e) {
            var t, n = rr.propHooks[this.prop];
            return this.pos = t = this.options.duration ? x.easing[this.easing](e, this.options.duration * e, 0, 1, this.options.duration) : e,
            this.now = (this.end - this.start) * t + this.start,
            this.options.step && this.options.step.call(this.elem, this.now, this),
            n && n.set ? n.set(this) : rr.propHooks._default.set(this),
            this
        }
    },
    rr.prototype.init.prototype = rr.prototype,
    rr.propHooks = {
        _default: {
            get: function(e) {
                var t;
                return null == e.elem[e.prop] || e.elem.style && null != e.elem.style[e.prop] ? (t = x.css(e.elem, e.prop, ""),
                t && "auto" !== t ? t : 0) : e.elem[e.prop]
            },
            set: function(e) {
                x.fx.step[e.prop] ? x.fx.step[e.prop](e) : e.elem.style && (null != e.elem.style[x.cssProps[e.prop]] || x.cssHooks[e.prop]) ? x.style(e.elem, e.prop, e.now + e.unit) : e.elem[e.prop] = e.now
            }
        }
    },
    rr.propHooks.scrollTop = rr.propHooks.scrollLeft = {
        set: function(e) {
            e.elem.nodeType && e.elem.parentNode && (e.elem[e.prop] = e.now)
        }
    },
    x.each(["toggle", "show", "hide"], function(e, t) {
        var n = x.fn[t];
        x.fn[t] = function(e, r, i) {
            return null == e || "boolean" == typeof e ? n.apply(this, arguments) : this.animate(ir(t, !0), e, r, i)
        }
    }),
    x.fn.extend({
        fadeTo: function(e, t, n, r) {
            return this.filter(nn).css("opacity", 0).show().end().animate({
                opacity: t
            }, e, n, r)
        },
        animate: function(e, t, n, r) {
            var i = x.isEmptyObject(e)
              , o = x.speed(t, n, r)
              , a = function() {
                var t = er(this, x.extend({}, e), o);
                (i || x._data(this, "finish")) && t.stop(!0)
            };
            return a.finish = a,
            i || o.queue === !1 ? this.each(a) : this.queue(o.queue, a)
        },
        stop: function(e, n, r) {
            var i = function(e) {
                var t = e.stop;
                delete e.stop,
                t(r)
            };
            return "string" != typeof e && (r = n,
            n = e,
            e = t),
            n && e !== !1 && this.queue(e || "fx", []),
            this.each(function() {
                var t = !0
                  , n = null != e && e + "queueHooks"
                  , o = x.timers
                  , a = x._data(this);
                if (n)
                    a[n] && a[n].stop && i(a[n]);
                else
                    for (n in a)
                        a[n] && a[n].stop && Jn.test(n) && i(a[n]);
                for (n = o.length; n--; )
                    o[n].elem !== this || null != e && o[n].queue !== e || (o[n].anim.stop(r),
                    t = !1,
                    o.splice(n, 1));
                (t || !r) && x.dequeue(this, e)
            })
        },
        finish: function(e) {
            return e !== !1 && (e = e || "fx"),
            this.each(function() {
                var t, n = x._data(this), r = n[e + "queue"], i = n[e + "queueHooks"], o = x.timers, a = r ? r.length : 0;
                for (n.finish = !0,
                x.queue(this, e, []),
                i && i.stop && i.stop.call(this, !0),
                t = o.length; t--; )
                    o[t].elem === this && o[t].queue === e && (o[t].anim.stop(!0),
                    o.splice(t, 1));
                for (t = 0; a > t; t++)
                    r[t] && r[t].finish && r[t].finish.call(this);
                delete n.finish
            })
        }
    });
    function ir(e, t) {
        var n, r = {
            height: e
        }, i = 0;
        for (t = t ? 1 : 0; 4 > i; i += 2 - t)
            n = Zt[i],
            r["margin" + n] = r["padding" + n] = e;
        return t && (r.opacity = r.width = e),
        r
    }
    x.each({
        slideDown: ir("show"),
        slideUp: ir("hide"),
        slideToggle: ir("toggle"),
        fadeIn: {
            opacity: "show"
        },
        fadeOut: {
            opacity: "hide"
        },
        fadeToggle: {
            opacity: "toggle"
        }
    }, function(e, t) {
        x.fn[e] = function(e, n, r) {
            return this.animate(t, e, n, r)
        }
    }),
    x.speed = function(e, t, n) {
        var r = e && "object" == typeof e ? x.extend({}, e) : {
            complete: n || !n && t || x.isFunction(e) && e,
            duration: e,
            easing: n && t || t && !x.isFunction(t) && t
        };
        return r.duration = x.fx.off ? 0 : "number" == typeof r.duration ? r.duration : r.duration in x.fx.speeds ? x.fx.speeds[r.duration] : x.fx.speeds._default,
        (null == r.queue || r.queue === !0) && (r.queue = "fx"),
        r.old = r.complete,
        r.complete = function() {
            x.isFunction(r.old) && r.old.call(this),
            r.queue && x.dequeue(this, r.queue)
        }
        ,
        r
    }
    ,
    x.easing = {
        linear: function(e) {
            return e
        },
        swing: function(e) {
            return .5 - Math.cos(e * Math.PI) / 2
        }
    },
    x.timers = [],
    x.fx = rr.prototype.init,
    x.fx.tick = function() {
        var e, n = x.timers, r = 0;
        for (Xn = x.now(); n.length > r; r++)
            e = n[r],
            e() || n[r] !== e || n.splice(r--, 1);
        n.length || x.fx.stop(),
        Xn = t
    }
    ,
    x.fx.timer = function(e) {
        e() && x.timers.push(e) && x.fx.start()
    }
    ,
    x.fx.interval = 13,
    x.fx.start = function() {
        Un || (Un = setInterval(x.fx.tick, x.fx.interval))
    }
    ,
    x.fx.stop = function() {
        clearInterval(Un),
        Un = null
    }
    ,
    x.fx.speeds = {
        slow: 600,
        fast: 200,
        _default: 400
    },
    x.fx.step = {},
    x.expr && x.expr.filters && (x.expr.filters.animated = function(e) {
        return x.grep(x.timers, function(t) {
            return e === t.elem
        }).length
    }
    ),
    x.fn.offset = function(e) {
        if (arguments.length)
            return e === t ? this : this.each(function(t) {
                x.offset.setOffset(this, e, t)
            });
        var n, r, o = {
            top: 0,
            left: 0
        }, a = this[0], s = a && a.ownerDocument;
        if (s)
            return n = s.documentElement,
            x.contains(n, a) ? (typeof a.getBoundingClientRect !== i && (o = a.getBoundingClientRect()),
            r = or(s),
            {
                top: o.top + (r.pageYOffset || n.scrollTop) - (n.clientTop || 0),
                left: o.left + (r.pageXOffset || n.scrollLeft) - (n.clientLeft || 0)
            }) : o
    }
    ,
    x.offset = {
        setOffset: function(e, t, n) {
            var r = x.css(e, "position");
            "static" === r && (e.style.position = "relative");
            var i = x(e), o = i.offset(), a = x.css(e, "top"), s = x.css(e, "left"), l = ("absolute" === r || "fixed" === r) && x.inArray("auto", [a, s]) > -1, u = {}, c = {}, p, f;
            l ? (c = i.position(),
            p = c.top,
            f = c.left) : (p = parseFloat(a) || 0,
            f = parseFloat(s) || 0),
            x.isFunction(t) && (t = t.call(e, n, o)),
            null != t.top && (u.top = t.top - o.top + p),
            null != t.left && (u.left = t.left - o.left + f),
            "using"in t ? t.using.call(e, u) : i.css(u)
        }
    },
    x.fn.extend({
        position: function() {
            if (this[0]) {
                var e, t, n = {
                    top: 0,
                    left: 0
                }, r = this[0];
                return "fixed" === x.css(r, "position") ? t = r.getBoundingClientRect() : (e = this.offsetParent(),
                t = this.offset(),
                x.nodeName(e[0], "html") || (n = e.offset()),
                n.top += x.css(e[0], "borderTopWidth", !0),
                n.left += x.css(e[0], "borderLeftWidth", !0)),
                {
                    top: t.top - n.top - x.css(r, "marginTop", !0),
                    left: t.left - n.left - x.css(r, "marginLeft", !0)
                }
            }
        },
        offsetParent: function() {
            return this.map(function() {
                var e = this.offsetParent || s;
                while (e && !x.nodeName(e, "html") && "static" === x.css(e, "position"))
                    e = e.offsetParent;
                return e || s
            })
        }
    }),
    x.each({
        scrollLeft: "pageXOffset",
        scrollTop: "pageYOffset"
    }, function(e, n) {
        var r = /Y/.test(n);
        x.fn[e] = function(i) {
            return x.access(this, function(e, i, o) {
                var a = or(e);
                return o === t ? a ? n in a ? a[n] : a.document.documentElement[i] : e[i] : (a ? a.scrollTo(r ? x(a).scrollLeft() : o, r ? o : x(a).scrollTop()) : e[i] = o,
                t)
            }, e, i, arguments.length, null)
        }
    });
    function or(e) {
        return x.isWindow(e) ? e : 9 === e.nodeType ? e.defaultView || e.parentWindow : !1
    }
    x.each({
        Height: "height",
        Width: "width"
    }, function(e, n) {
        x.each({
            padding: "inner" + e,
            content: n,
            "": "outer" + e
        }, function(r, i) {
            x.fn[i] = function(i, o) {
                var a = arguments.length && (r || "boolean" != typeof i)
                  , s = r || (i === !0 || o === !0 ? "margin" : "border");
                return x.access(this, function(n, r, i) {
                    var o;
                    return x.isWindow(n) ? n.document.documentElement["client" + e] : 9 === n.nodeType ? (o = n.documentElement,
                    Math.max(n.body["scroll" + e], o["scroll" + e], n.body["offset" + e], o["offset" + e], o["client" + e])) : i === t ? x.css(n, r, s) : x.style(n, r, i, s)
                }, n, a ? i : t, a, null)
            }
        })
    }),
    x.fn.size = function() {
        return this.length
    }
    ,
    x.fn.andSelf = x.fn.addBack,
    "object" == typeof module && module && "object" == typeof module.exports ? module.exports = x : (e.jQuery = e.$ = x,
    "function" == typeof define && define.amd && define("jquery", [], function() {
        return x
    }))
}
)(window);

//     Underscore.js 1.5.2
//     http://underscorejs.org
//     (c) 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
//     Underscore may be freely distributed under the MIT license.
(function() {
    var n = this
      , t = n._
      , r = {}
      , e = Array.prototype
      , u = Object.prototype
      , i = Function.prototype
      , a = e.push
      , o = e.slice
      , c = e.concat
      , l = u.toString
      , f = u.hasOwnProperty
      , s = e.forEach
      , p = e.map
      , h = e.reduce
      , v = e.reduceRight
      , g = e.filter
      , d = e.every
      , m = e.some
      , y = e.indexOf
      , b = e.lastIndexOf
      , x = Array.isArray
      , w = Object.keys
      , _ = i.bind
      , j = function(n) {
        return n instanceof j ? n : this instanceof j ? (this._wrapped = n,
        void 0) : new j(n)
    };
    "undefined" != typeof exports ? ("undefined" != typeof module && module.exports && (exports = module.exports = j),
    exports._ = j) : n._ = j,
    j.VERSION = "1.5.2";
    var A = j.each = j.forEach = function(n, t, e) {
        if (null != n)
            if (s && n.forEach === s)
                n.forEach(t, e);
            else if (n.length === +n.length) {
                for (var u = 0, i = n.length; i > u; u++)
                    if (t.call(e, n[u], u, n) === r)
                        return
            } else
                for (var a = j.keys(n), u = 0, i = a.length; i > u; u++)
                    if (t.call(e, n[a[u]], a[u], n) === r)
                        return
    }
    ;
    j.map = j.collect = function(n, t, r) {
        var e = [];
        return null == n ? e : p && n.map === p ? n.map(t, r) : (A(n, function(n, u, i) {
            e.push(t.call(r, n, u, i))
        }),
        e)
    }
    ;
    var E = "Reduce of empty array with no initial value";
    j.reduce = j.foldl = j.inject = function(n, t, r, e) {
        var u = arguments.length > 2;
        if (null == n && (n = []),
        h && n.reduce === h)
            return e && (t = j.bind(t, e)),
            u ? n.reduce(t, r) : n.reduce(t);
        if (A(n, function(n, i, a) {
            u ? r = t.call(e, r, n, i, a) : (r = n,
            u = !0)
        }),
        !u)
            throw new TypeError(E);
        return r
    }
    ,
    j.reduceRight = j.foldr = function(n, t, r, e) {
        var u = arguments.length > 2;
        if (null == n && (n = []),
        v && n.reduceRight === v)
            return e && (t = j.bind(t, e)),
            u ? n.reduceRight(t, r) : n.reduceRight(t);
        var i = n.length;
        if (i !== +i) {
            var a = j.keys(n);
            i = a.length
        }
        if (A(n, function(o, c, l) {
            c = a ? a[--i] : --i,
            u ? r = t.call(e, r, n[c], c, l) : (r = n[c],
            u = !0)
        }),
        !u)
            throw new TypeError(E);
        return r
    }
    ,
    j.find = j.detect = function(n, t, r) {
        var e;
        return O(n, function(n, u, i) {
            return t.call(r, n, u, i) ? (e = n,
            !0) : void 0
        }),
        e
    }
    ,
    j.filter = j.select = function(n, t, r) {
        var e = [];
        return null == n ? e : g && n.filter === g ? n.filter(t, r) : (A(n, function(n, u, i) {
            t.call(r, n, u, i) && e.push(n)
        }),
        e)
    }
    ,
    j.reject = function(n, t, r) {
        return j.filter(n, function(n, e, u) {
            return !t.call(r, n, e, u)
        }, r)
    }
    ,
    j.every = j.all = function(n, t, e) {
        t || (t = j.identity);
        var u = !0;
        return null == n ? u : d && n.every === d ? n.every(t, e) : (A(n, function(n, i, a) {
            return (u = u && t.call(e, n, i, a)) ? void 0 : r
        }),
        !!u)
    }
    ;
    var O = j.some = j.any = function(n, t, e) {
        t || (t = j.identity);
        var u = !1;
        return null == n ? u : m && n.some === m ? n.some(t, e) : (A(n, function(n, i, a) {
            return u || (u = t.call(e, n, i, a)) ? r : void 0
        }),
        !!u)
    }
    ;
    j.contains = j.include = function(n, t) {
        return null == n ? !1 : y && n.indexOf === y ? n.indexOf(t) != -1 : O(n, function(n) {
            return n === t
        })
    }
    ,
    j.invoke = function(n, t) {
        var r = o.call(arguments, 2)
          , e = j.isFunction(t);
        return j.map(n, function(n) {
            return (e ? t : n[t]).apply(n, r)
        })
    }
    ,
    j.pluck = function(n, t) {
        return j.map(n, function(n) {
            return n[t]
        })
    }
    ,
    j.where = function(n, t, r) {
        return j.isEmpty(t) ? r ? void 0 : [] : j[r ? "find" : "filter"](n, function(n) {
            for (var r in t)
                if (t[r] !== n[r])
                    return !1;
            return !0
        })
    }
    ,
    j.findWhere = function(n, t) {
        return j.where(n, t, !0)
    }
    ,
    j.max = function(n, t, r) {
        if (!t && j.isArray(n) && n[0] === +n[0] && n.length < 65535)
            return Math.max.apply(Math, n);
        if (!t && j.isEmpty(n))
            return -1 / 0;
        var e = {
            computed: -1 / 0,
            value: -1 / 0
        };
        return A(n, function(n, u, i) {
            var a = t ? t.call(r, n, u, i) : n;
            a > e.computed && (e = {
                value: n,
                computed: a
            })
        }),
        e.value
    }
    ,
    j.min = function(n, t, r) {
        if (!t && j.isArray(n) && n[0] === +n[0] && n.length < 65535)
            return Math.min.apply(Math, n);
        if (!t && j.isEmpty(n))
            return 1 / 0;
        var e = {
            computed: 1 / 0,
            value: 1 / 0
        };
        return A(n, function(n, u, i) {
            var a = t ? t.call(r, n, u, i) : n;
            a < e.computed && (e = {
                value: n,
                computed: a
            })
        }),
        e.value
    }
    ,
    j.shuffle = function(n) {
        var t, r = 0, e = [];
        return A(n, function(n) {
            t = j.random(r++),
            e[r - 1] = e[t],
            e[t] = n
        }),
        e
    }
    ,
    j.sample = function(n, t, r) {
        return arguments.length < 2 || r ? n[j.random(n.length - 1)] : j.shuffle(n).slice(0, Math.max(0, t))
    }
    ;
    var k = function(n) {
        return j.isFunction(n) ? n : function(t) {
            return t[n]
        }
    };
    j.sortBy = function(n, t, r) {
        var e = k(t);
        return j.pluck(j.map(n, function(n, t, u) {
            return {
                value: n,
                index: t,
                criteria: e.call(r, n, t, u)
            }
        }).sort(function(n, t) {
            var r = n.criteria
              , e = t.criteria;
            if (r !== e) {
                if (r > e || r === void 0)
                    return 1;
                if (e > r || e === void 0)
                    return -1
            }
            return n.index - t.index
        }), "value")
    }
    ;
    var F = function(n) {
        return function(t, r, e) {
            var u = {}
              , i = null == r ? j.identity : k(r);
            return A(t, function(r, a) {
                var o = i.call(e, r, a, t);
                n(u, o, r)
            }),
            u
        }
    };
    j.groupBy = F(function(n, t, r) {
        (j.has(n, t) ? n[t] : n[t] = []).push(r)
    }),
    j.indexBy = F(function(n, t, r) {
        n[t] = r
    }),
    j.countBy = F(function(n, t) {
        j.has(n, t) ? n[t]++ : n[t] = 1
    }),
    j.sortedIndex = function(n, t, r, e) {
        r = null == r ? j.identity : k(r);
        for (var u = r.call(e, t), i = 0, a = n.length; a > i; ) {
            var o = i + a >>> 1;
            r.call(e, n[o]) < u ? i = o + 1 : a = o
        }
        return i
    }
    ,
    j.toArray = function(n) {
        return n ? j.isArray(n) ? o.call(n) : n.length === +n.length ? j.map(n, j.identity) : j.values(n) : []
    }
    ,
    j.size = function(n) {
        return null == n ? 0 : n.length === +n.length ? n.length : j.keys(n).length
    }
    ,
    j.first = j.head = j.take = function(n, t, r) {
        return null == n ? void 0 : null == t || r ? n[0] : o.call(n, 0, t)
    }
    ,
    j.initial = function(n, t, r) {
        return o.call(n, 0, n.length - (null == t || r ? 1 : t))
    }
    ,
    j.last = function(n, t, r) {
        return null == n ? void 0 : null == t || r ? n[n.length - 1] : o.call(n, Math.max(n.length - t, 0))
    }
    ,
    j.rest = j.tail = j.drop = function(n, t, r) {
        return o.call(n, null == t || r ? 1 : t)
    }
    ,
    j.compact = function(n) {
        return j.filter(n, j.identity)
    }
    ;
    var M = function(n, t, r) {
        return t && j.every(n, j.isArray) ? c.apply(r, n) : (A(n, function(n) {
            j.isArray(n) || j.isArguments(n) ? t ? a.apply(r, n) : M(n, t, r) : r.push(n)
        }),
        r)
    };
    j.flatten = function(n, t) {
        return M(n, t, [])
    }
    ,
    j.without = function(n) {
        return j.difference(n, o.call(arguments, 1))
    }
    ,
    j.uniq = j.unique = function(n, t, r, e) {
        j.isFunction(t) && (e = r,
        r = t,
        t = !1);
        var u = r ? j.map(n, r, e) : n
          , i = []
          , a = [];
        return A(u, function(r, e) {
            (t ? e && a[a.length - 1] === r : j.contains(a, r)) || (a.push(r),
            i.push(n[e]))
        }),
        i
    }
    ,
    j.union = function() {
        return j.uniq(j.flatten(arguments, !0))
    }
    ,
    j.intersection = function(n) {
        var t = o.call(arguments, 1);
        return j.filter(j.uniq(n), function(n) {
            return j.every(t, function(t) {
                return j.indexOf(t, n) >= 0
            })
        })
    }
    ,
    j.difference = function(n) {
        var t = c.apply(e, o.call(arguments, 1));
        return j.filter(n, function(n) {
            return !j.contains(t, n)
        })
    }
    ,
    j.zip = function() {
        for (var n = j.max(j.pluck(arguments, "length").concat(0)), t = new Array(n), r = 0; n > r; r++)
            t[r] = j.pluck(arguments, "" + r);
        return t
    }
    ,
    j.object = function(n, t) {
        if (null == n)
            return {};
        for (var r = {}, e = 0, u = n.length; u > e; e++)
            t ? r[n[e]] = t[e] : r[n[e][0]] = n[e][1];
        return r
    }
    ,
    j.indexOf = function(n, t, r) {
        if (null == n)
            return -1;
        var e = 0
          , u = n.length;
        if (r) {
            if ("number" != typeof r)
                return e = j.sortedIndex(n, t),
                n[e] === t ? e : -1;
            e = 0 > r ? Math.max(0, u + r) : r
        }
        if (y && n.indexOf === y)
            return n.indexOf(t, r);
        for (; u > e; e++)
            if (n[e] === t)
                return e;
        return -1
    }
    ,
    j.lastIndexOf = function(n, t, r) {
        if (null == n)
            return -1;
        var e = null != r;
        if (b && n.lastIndexOf === b)
            return e ? n.lastIndexOf(t, r) : n.lastIndexOf(t);
        for (var u = e ? r : n.length; u--; )
            if (n[u] === t)
                return u;
        return -1
    }
    ,
    j.range = function(n, t, r) {
        arguments.length <= 1 && (t = n || 0,
        n = 0),
        r = arguments[2] || 1;
        for (var e = Math.max(Math.ceil((t - n) / r), 0), u = 0, i = new Array(e); e > u; )
            i[u++] = n,
            n += r;
        return i
    }
    ;
    var R = function() {};
    j.bind = function(n, t) {
        var r, e;
        if (_ && n.bind === _)
            return _.apply(n, o.call(arguments, 1));
        if (!j.isFunction(n))
            throw new TypeError;
        return r = o.call(arguments, 2),
        e = function() {
            if (!(this instanceof e))
                return n.apply(t, r.concat(o.call(arguments)));
            R.prototype = n.prototype;
            var u = new R;
            R.prototype = null;
            var i = n.apply(u, r.concat(o.call(arguments)));
            return Object(i) === i ? i : u
        }
    }
    ,
    j.partial = function(n) {
        var t = o.call(arguments, 1);
        return function() {
            return n.apply(this, t.concat(o.call(arguments)))
        }
    }
    ,
    j.bindAll = function(n) {
        var t = o.call(arguments, 1);
        if (0 === t.length)
            throw new Error("bindAll must be passed function names");
        return A(t, function(t) {
            n[t] = j.bind(n[t], n)
        }),
        n
    }
    ,
    j.memoize = function(n, t) {
        var r = {};
        return t || (t = j.identity),
        function() {
            var e = t.apply(this, arguments);
            return j.has(r, e) ? r[e] : r[e] = n.apply(this, arguments)
        }
    }
    ,
    j.delay = function(n, t) {
        var r = o.call(arguments, 2);
        return setTimeout(function() {
            return n.apply(null, r)
        }, t)
    }
    ,
    j.defer = function(n) {
        return j.delay.apply(j, [n, 1].concat(o.call(arguments, 1)))
    }
    ,
    j.throttle = function(n, t, r) {
        var e, u, i, a = null, o = 0;
        r || (r = {});
        var c = function() {
            o = r.leading === !1 ? 0 : new Date,
            a = null,
            i = n.apply(e, u)
        };
        return function() {
            var l = new Date;
            o || r.leading !== !1 || (o = l);
            var f = t - (l - o);
            return e = this,
            u = arguments,
            0 >= f ? (clearTimeout(a),
            a = null,
            o = l,
            i = n.apply(e, u)) : a || r.trailing === !1 || (a = setTimeout(c, f)),
            i
        }
    }
    ,
    j.debounce = function(n, t, r) {
        var e, u, i, a, o;
        return function() {
            i = this,
            u = arguments,
            a = new Date;
            var c = function() {
                var l = new Date - a;
                t > l ? e = setTimeout(c, t - l) : (e = null,
                r || (o = n.apply(i, u)))
            }
              , l = r && !e;
            return e || (e = setTimeout(c, t)),
            l && (o = n.apply(i, u)),
            o
        }
    }
    ,
    j.once = function(n) {
        var t, r = !1;
        return function() {
            return r ? t : (r = !0,
            t = n.apply(this, arguments),
            n = null,
            t)
        }
    }
    ,
    j.wrap = function(n, t) {
        return function() {
            var r = [n];
            return a.apply(r, arguments),
            t.apply(this, r)
        }
    }
    ,
    j.compose = function() {
        var n = arguments;
        return function() {
            for (var t = arguments, r = n.length - 1; r >= 0; r--)
                t = [n[r].apply(this, t)];
            return t[0]
        }
    }
    ,
    j.after = function(n, t) {
        return function() {
            return --n < 1 ? t.apply(this, arguments) : void 0
        }
    }
    ,
    j.keys = w || function(n) {
        if (n !== Object(n))
            throw new TypeError("Invalid object");
        var t = [];
        for (var r in n)
            j.has(n, r) && t.push(r);
        return t
    }
    ,
    j.values = function(n) {
        for (var t = j.keys(n), r = t.length, e = new Array(r), u = 0; r > u; u++)
            e[u] = n[t[u]];
        return e
    }
    ,
    j.pairs = function(n) {
        for (var t = j.keys(n), r = t.length, e = new Array(r), u = 0; r > u; u++)
            e[u] = [t[u], n[t[u]]];
        return e
    }
    ,
    j.invert = function(n) {
        for (var t = {}, r = j.keys(n), e = 0, u = r.length; u > e; e++)
            t[n[r[e]]] = r[e];
        return t
    }
    ,
    j.functions = j.methods = function(n) {
        var t = [];
        for (var r in n)
            j.isFunction(n[r]) && t.push(r);
        return t.sort()
    }
    ,
    j.extend = function(n) {
        return A(o.call(arguments, 1), function(t) {
            if (t)
                for (var r in t)
                    n[r] = t[r]
        }),
        n
    }
    ,
    j.pick = function(n) {
        var t = {}
          , r = c.apply(e, o.call(arguments, 1));
        return A(r, function(r) {
            r in n && (t[r] = n[r])
        }),
        t
    }
    ,
    j.omit = function(n) {
        var t = {}
          , r = c.apply(e, o.call(arguments, 1));
        for (var u in n)
            j.contains(r, u) || (t[u] = n[u]);
        return t
    }
    ,
    j.defaults = function(n) {
        return A(o.call(arguments, 1), function(t) {
            if (t)
                for (var r in t)
                    n[r] === void 0 && (n[r] = t[r])
        }),
        n
    }
    ,
    j.clone = function(n) {
        return j.isObject(n) ? j.isArray(n) ? n.slice() : j.extend({}, n) : n
    }
    ,
    j.tap = function(n, t) {
        return t(n),
        n
    }
    ;
    var S = function(n, t, r, e) {
        if (n === t)
            return 0 !== n || 1 / n == 1 / t;
        if (null == n || null == t)
            return n === t;
        n instanceof j && (n = n._wrapped),
        t instanceof j && (t = t._wrapped);
        var u = l.call(n);
        if (u != l.call(t))
            return !1;
        switch (u) {
        case "[object String]":
            return n == String(t);
        case "[object Number]":
            return n != +n ? t != +t : 0 == n ? 1 / n == 1 / t : n == +t;
        case "[object Date]":
        case "[object Boolean]":
            return +n == +t;
        case "[object RegExp]":
            return n.source == t.source && n.global == t.global && n.multiline == t.multiline && n.ignoreCase == t.ignoreCase
        }
        if ("object" != typeof n || "object" != typeof t)
            return !1;
        for (var i = r.length; i--; )
            if (r[i] == n)
                return e[i] == t;
        var a = n.constructor
          , o = t.constructor;
        if (a !== o && !(j.isFunction(a) && a instanceof a && j.isFunction(o) && o instanceof o))
            return !1;
        r.push(n),
        e.push(t);
        var c = 0
          , f = !0;
        if ("[object Array]" == u) {
            if (c = n.length,
            f = c == t.length)
                for (; c-- && (f = S(n[c], t[c], r, e)); )
                    ;
        } else {
            for (var s in n)
                if (j.has(n, s) && (c++,
                !(f = j.has(t, s) && S(n[s], t[s], r, e))))
                    break;
            if (f) {
                for (s in t)
                    if (j.has(t, s) && !c--)
                        break;
                f = !c
            }
        }
        return r.pop(),
        e.pop(),
        f
    };
    j.isEqual = function(n, t) {
        return S(n, t, [], [])
    }
    ,
    j.isEmpty = function(n) {
        if (null == n)
            return !0;
        if (j.isArray(n) || j.isString(n))
            return 0 === n.length;
        for (var t in n)
            if (j.has(n, t))
                return !1;
        return !0
    }
    ,
    j.isElement = function(n) {
        return !(!n || 1 !== n.nodeType)
    }
    ,
    j.isArray = x || function(n) {
        return "[object Array]" == l.call(n)
    }
    ,
    j.isObject = function(n) {
        return n === Object(n)
    }
    ,
    A(["Arguments", "Function", "String", "Number", "Date", "RegExp"], function(n) {
        j["is" + n] = function(t) {
            return l.call(t) == "[object " + n + "]"
        }
    }),
    j.isArguments(arguments) || (j.isArguments = function(n) {
        return !(!n || !j.has(n, "callee"))
    }
    ),
    "function" != typeof /./ && (j.isFunction = function(n) {
        return "function" == typeof n
    }
    ),
    j.isFinite = function(n) {
        return isFinite(n) && !isNaN(parseFloat(n))
    }
    ,
    j.isNaN = function(n) {
        return j.isNumber(n) && n != +n
    }
    ,
    j.isBoolean = function(n) {
        return n === !0 || n === !1 || "[object Boolean]" == l.call(n)
    }
    ,
    j.isNull = function(n) {
        return null === n
    }
    ,
    j.isUndefined = function(n) {
        return n === void 0
    }
    ,
    j.has = function(n, t) {
        return f.call(n, t)
    }
    ,
    j.noConflict = function() {
        return n._ = t,
        this
    }
    ,
    j.identity = function(n) {
        return n
    }
    ,
    j.times = function(n, t, r) {
        for (var e = Array(Math.max(0, n)), u = 0; n > u; u++)
            e[u] = t.call(r, u);
        return e
    }
    ,
    j.random = function(n, t) {
        return null == t && (t = n,
        n = 0),
        n + Math.floor(Math.random() * (t - n + 1))
    }
    ;
    var I = {
        escape: {
            "&": "&amp;",
            "<": "&lt;",
            ">": "&gt;",
            '"': "&quot;",
            "'": "&#x27;"
        }
    };
    I.unescape = j.invert(I.escape);
    var T = {
        escape: new RegExp("[" + j.keys(I.escape).join("") + "]","g"),
        unescape: new RegExp("(" + j.keys(I.unescape).join("|") + ")","g")
    };
    j.each(["escape", "unescape"], function(n) {
        j[n] = function(t) {
            return null == t ? "" : ("" + t).replace(T[n], function(t) {
                return I[n][t]
            })
        }
    }),
    j.result = function(n, t) {
        if (null == n)
            return void 0;
        var r = n[t];
        return j.isFunction(r) ? r.call(n) : r
    }
    ,
    j.mixin = function(n) {
        A(j.functions(n), function(t) {
            var r = j[t] = n[t];
            j.prototype[t] = function() {
                var n = [this._wrapped];
                return a.apply(n, arguments),
                z.call(this, r.apply(j, n))
            }
        })
    }
    ;
    var N = 0;
    j.uniqueId = function(n) {
        var t = ++N + "";
        return n ? n + t : t
    }
    ,
    j.templateSettings = {
        evaluate: /<%([\s\S]+?)%>/g,
        interpolate: /<%=([\s\S]+?)%>/g,
        escape: /<%-([\s\S]+?)%>/g
    };
    var q = /(.)^/
      , B = {
        "'": "'",
        "\\": "\\",
        "\r": "r",
        "\n": "n",
        "	": "t",
        "\u2028": "u2028",
        "\u2029": "u2029"
    }
      , D = /\\|'|\r|\n|\t|\u2028|\u2029/g;
    j.template = function(n, t, r) {
        var e;
        r = j.defaults({}, r, j.templateSettings);
        var u = new RegExp([(r.escape || q).source, (r.interpolate || q).source, (r.evaluate || q).source].join("|") + "|$","g")
          , i = 0
          , a = "__p+='";
        n.replace(u, function(t, r, e, u, o) {
            return a += n.slice(i, o).replace(D, function(n) {
                return "\\" + B[n]
            }),
            r && (a += "'+\n((__t=(" + r + "))==null?'':_.escape(__t))+\n'"),
            e && (a += "'+\n((__t=(" + e + "))==null?'':__t)+\n'"),
            u && (a += "';\n" + u + "\n__p+='"),
            i = o + t.length,
            t
        }),
        a += "';\n",
        r.variable || (a = "with(obj||{}){\n" + a + "}\n"),
        a = "var __t,__p='',__j=Array.prototype.join," + "print=function(){__p+=__j.call(arguments,'');};\n" + a + "return __p;\n";
        try {
            e = new Function(r.variable || "obj","_",a)
        } catch (o) {
            throw o.source = a,
            o
        }
        if (t)
            return e(t, j);
        var c = function(n) {
            return e.call(this, n, j)
        };
        return c.source = "function(" + (r.variable || "obj") + "){\n" + a + "}",
        c
    }
    ,
    j.chain = function(n) {
        return j(n).chain()
    }
    ;
    var z = function(n) {
        return this._chain ? j(n).chain() : n
    };
    j.mixin(j),
    A(["pop", "push", "reverse", "shift", "sort", "splice", "unshift"], function(n) {
        var t = e[n];
        j.prototype[n] = function() {
            var r = this._wrapped;
            return t.apply(r, arguments),
            "shift" != n && "splice" != n || 0 !== r.length || delete r[0],
            z.call(this, r)
        }
    }),
    A(["concat", "join", "slice"], function(n) {
        var t = e[n];
        j.prototype[n] = function() {
            return z.call(this, t.apply(this._wrapped, arguments))
        }
    }),
    j.extend(j.prototype, {
        chain: function() {
            return this._chain = !0,
            this
        },
        value: function() {
            return this._wrapped
        }
    })
}
).call(this);
//# sourceMappingURL=underscore-min.map
!function() {
    var d3 = {
        version: "3.4.6"
    };
    if (!Date.now)
        Date.now = function() {
            return +new Date();
        }
        ;
    var d3_arraySlice = [].slice
      , d3_array = function(list) {
        return d3_arraySlice.call(list);
    };
    var d3_document = document
      , d3_documentElement = d3_document.documentElement
      , d3_window = window;
    try {
        d3_array(d3_documentElement.childNodes)[0].nodeType;
    } catch (e) {
        d3_array = function(list) {
            var i = list.length
              , array = new Array(i);
            while (i--)
                array[i] = list[i];
            return array;
        }
        ;
    }
    try {
        d3_document.createElement("div").style.setProperty("opacity", 0, "");
    } catch (error) {
        var d3_element_prototype = d3_window.Element.prototype
          , d3_element_setAttribute = d3_element_prototype.setAttribute
          , d3_element_setAttributeNS = d3_element_prototype.setAttributeNS
          , d3_style_prototype = d3_window.CSSStyleDeclaration.prototype
          , d3_style_setProperty = d3_style_prototype.setProperty;
        d3_element_prototype.setAttribute = function(name, value) {
            d3_element_setAttribute.call(this, name, value + "");
        }
        ;
        d3_element_prototype.setAttributeNS = function(space, local, value) {
            d3_element_setAttributeNS.call(this, space, local, value + "");
        }
        ;
        d3_style_prototype.setProperty = function(name, value, priority) {
            d3_style_setProperty.call(this, name, value + "", priority);
        }
        ;
    }
    d3.ascending = d3_ascending;
    function d3_ascending(a, b) {
        return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
    }
    d3.descending = function(a, b) {
        return b < a ? -1 : b > a ? 1 : b >= a ? 0 : NaN;
    }
    ;
    d3.min = function(array, f) {
        var i = -1, n = array.length, a, b;
        if (arguments.length === 1) {
            while (++i < n && !((a = array[i]) != null && a <= a))
                a = undefined;
            while (++i < n)
                if ((b = array[i]) != null && a > b)
                    a = b;
        } else {
            while (++i < n && !((a = f.call(array, array[i], i)) != null && a <= a))
                a = undefined;
            while (++i < n)
                if ((b = f.call(array, array[i], i)) != null && a > b)
                    a = b;
        }
        return a;
    }
    ;
    d3.max = function(array, f) {
        var i = -1, n = array.length, a, b;
        if (arguments.length === 1) {
            while (++i < n && !((a = array[i]) != null && a <= a))
                a = undefined;
            while (++i < n)
                if ((b = array[i]) != null && b > a)
                    a = b;
        } else {
            while (++i < n && !((a = f.call(array, array[i], i)) != null && a <= a))
                a = undefined;
            while (++i < n)
                if ((b = f.call(array, array[i], i)) != null && b > a)
                    a = b;
        }
        return a;
    }
    ;
    d3.extent = function(array, f) {
        var i = -1, n = array.length, a, b, c;
        if (arguments.length === 1) {
            while (++i < n && !((a = c = array[i]) != null && a <= a))
                a = c = undefined;
            while (++i < n)
                if ((b = array[i]) != null) {
                    if (a > b)
                        a = b;
                    if (c < b)
                        c = b;
                }
        } else {
            while (++i < n && !((a = c = f.call(array, array[i], i)) != null && a <= a))
                a = undefined;
            while (++i < n)
                if ((b = f.call(array, array[i], i)) != null) {
                    if (a > b)
                        a = b;
                    if (c < b)
                        c = b;
                }
        }
        return [a, c];
    }
    ;
    d3.sum = function(array, f) {
        var s = 0, n = array.length, a, i = -1;
        if (arguments.length === 1) {
            while (++i < n)
                if (!isNaN(a = +array[i]))
                    s += a;
        } else {
            while (++i < n)
                if (!isNaN(a = +f.call(array, array[i], i)))
                    s += a;
        }
        return s;
    }
    ;
    function d3_number(x) {
        return x != null && !isNaN(x);
    }
    d3.mean = function(array, f) {
        var s = 0, n = array.length, a, i = -1, j = n;
        if (arguments.length === 1) {
            while (++i < n)
                if (d3_number(a = array[i]))
                    s += a;
                else
                    --j;
        } else {
            while (++i < n)
                if (d3_number(a = f.call(array, array[i], i)))
                    s += a;
                else
                    --j;
        }
        return j ? s / j : undefined;
    }
    ;
    d3.quantile = function(values, p) {
        var H = (values.length - 1) * p + 1
          , h = Math.floor(H)
          , v = +values[h - 1]
          , e = H - h;
        return e ? v + e * (values[h] - v) : v;
    }
    ;
    d3.median = function(array, f) {
        if (arguments.length > 1)
            array = array.map(f);
        array = array.filter(d3_number);
        return array.length ? d3.quantile(array.sort(d3_ascending), .5) : undefined;
    }
    ;
    function d3_bisector(compare) {
        return {
            left: function(a, x, lo, hi) {
                if (arguments.length < 3)
                    lo = 0;
                if (arguments.length < 4)
                    hi = a.length;
                while (lo < hi) {
                    var mid = lo + hi >>> 1;
                    if (compare(a[mid], x) < 0)
                        lo = mid + 1;
                    else
                        hi = mid;
                }
                return lo;
            },
            right: function(a, x, lo, hi) {
                if (arguments.length < 3)
                    lo = 0;
                if (arguments.length < 4)
                    hi = a.length;
                while (lo < hi) {
                    var mid = lo + hi >>> 1;
                    if (compare(a[mid], x) > 0)
                        hi = mid;
                    else
                        lo = mid + 1;
                }
                return lo;
            }
        };
    }
    var d3_bisect = d3_bisector(d3_ascending);
    d3.bisectLeft = d3_bisect.left;
    d3.bisect = d3.bisectRight = d3_bisect.right;
    d3.bisector = function(f) {
        return d3_bisector(f.length === 1 ? function(d, x) {
            return d3_ascending(f(d), x);
        }
        : f);
    }
    ;
    d3.shuffle = function(array) {
        var m = array.length, t, i;
        while (m) {
            i = Math.random() * m-- | 0;
            t = array[m],
            array[m] = array[i],
            array[i] = t;
        }
        return array;
    }
    ;
    d3.permute = function(array, indexes) {
        var i = indexes.length
          , permutes = new Array(i);
        while (i--)
            permutes[i] = array[indexes[i]];
        return permutes;
    }
    ;
    d3.pairs = function(array) {
        var i = 0, n = array.length - 1, p0, p1 = array[0], pairs = new Array(n < 0 ? 0 : n);
        while (i < n)
            pairs[i] = [p0 = p1, p1 = array[++i]];
        return pairs;
    }
    ;
    d3.zip = function() {
        if (!(n = arguments.length))
            return [];
        for (var i = -1, m = d3.min(arguments, d3_zipLength), zips = new Array(m); ++i < m; ) {
            for (var j = -1, n, zip = zips[i] = new Array(n); ++j < n; ) {
                zip[j] = arguments[j][i];
            }
        }
        return zips;
    }
    ;
    function d3_zipLength(d) {
        return d.length;
    }
    d3.transpose = function(matrix) {
        return d3.zip.apply(d3, matrix);
    }
    ;
    d3.keys = function(map) {
        var keys = [];
        for (var key in map)
            keys.push(key);
        return keys;
    }
    ;
    d3.values = function(map) {
        var values = [];
        for (var key in map)
            values.push(map[key]);
        return values;
    }
    ;
    d3.entries = function(map) {
        var entries = [];
        for (var key in map)
            entries.push({
                key: key,
                value: map[key]
            });
        return entries;
    }
    ;
    d3.merge = function(arrays) {
        var n = arrays.length, m, i = -1, j = 0, merged, array;
        while (++i < n)
            j += arrays[i].length;
        merged = new Array(j);
        while (--n >= 0) {
            array = arrays[n];
            m = array.length;
            while (--m >= 0) {
                merged[--j] = array[m];
            }
        }
        return merged;
    }
    ;
    var abs = Math.abs;
    d3.range = function(start, stop, step) {
        if (arguments.length < 3) {
            step = 1;
            if (arguments.length < 2) {
                stop = start;
                start = 0;
            }
        }
        if ((stop - start) / step === Infinity)
            throw new Error("infinite range");
        var range = [], k = d3_range_integerScale(abs(step)), i = -1, j;
        start *= k,
        stop *= k,
        step *= k;
        if (step < 0)
            while ((j = start + step * ++i) > stop)
                range.push(j / k);
        else
            while ((j = start + step * ++i) < stop)
                range.push(j / k);
        return range;
    }
    ;
    function d3_range_integerScale(x) {
        var k = 1;
        while (x * k % 1)
            k *= 10;
        return k;
    }
    function d3_class(ctor, properties) {
        try {
            for (var key in properties) {
                Object.defineProperty(ctor.prototype, key, {
                    value: properties[key],
                    enumerable: false
                });
            }
        } catch (e) {
            ctor.prototype = properties;
        }
    }
    d3.map = function(object) {
        var map = new d3_Map();
        if (object instanceof d3_Map)
            object.forEach(function(key, value) {
                map.set(key, value);
            });
        else
            for (var key in object)
                map.set(key, object[key]);
        return map;
    }
    ;
    function d3_Map() {}
    d3_class(d3_Map, {
        has: d3_map_has,
        get: function(key) {
            return this[d3_map_prefix + key];
        },
        set: function(key, value) {
            return this[d3_map_prefix + key] = value;
        },
        remove: d3_map_remove,
        keys: d3_map_keys,
        values: function() {
            var values = [];
            this.forEach(function(key, value) {
                values.push(value);
            });
            return values;
        },
        entries: function() {
            var entries = [];
            this.forEach(function(key, value) {
                entries.push({
                    key: key,
                    value: value
                });
            });
            return entries;
        },
        size: d3_map_size,
        empty: d3_map_empty,
        forEach: function(f) {
            for (var key in this)
                if (key.charCodeAt(0) === d3_map_prefixCode)
                    f.call(this, key.substring(1), this[key]);
        }
    });
    var d3_map_prefix = "\x00"
      , d3_map_prefixCode = d3_map_prefix.charCodeAt(0);
    function d3_map_has(key) {
        return d3_map_prefix + key in this;
    }
    function d3_map_remove(key) {
        key = d3_map_prefix + key;
        return key in this && delete this[key];
    }
    function d3_map_keys() {
        var keys = [];
        this.forEach(function(key) {
            keys.push(key);
        });
        return keys;
    }
    function d3_map_size() {
        var size = 0;
        for (var key in this)
            if (key.charCodeAt(0) === d3_map_prefixCode)
                ++size;
        return size;
    }
    function d3_map_empty() {
        for (var key in this)
            if (key.charCodeAt(0) === d3_map_prefixCode)
                return false;
        return true;
    }
    d3.nest = function() {
        var nest = {}, keys = [], sortKeys = [], sortValues, rollup;
        function map(mapType, array, depth) {
            if (depth >= keys.length)
                return rollup ? rollup.call(nest, array) : sortValues ? array.sort(sortValues) : array;
            var i = -1, n = array.length, key = keys[depth++], keyValue, object, setter, valuesByKey = new d3_Map(), values;
            while (++i < n) {
                if (values = valuesByKey.get(keyValue = key(object = array[i]))) {
                    values.push(object);
                } else {
                    valuesByKey.set(keyValue, [object]);
                }
            }
            if (mapType) {
                object = mapType();
                setter = function(keyValue, values) {
                    object.set(keyValue, map(mapType, values, depth));
                }
                ;
            } else {
                object = {};
                setter = function(keyValue, values) {
                    object[keyValue] = map(mapType, values, depth);
                }
                ;
            }
            valuesByKey.forEach(setter);
            return object;
        }
        function entries(map, depth) {
            if (depth >= keys.length)
                return map;
            var array = []
              , sortKey = sortKeys[depth++];
            map.forEach(function(key, keyMap) {
                array.push({
                    key: key,
                    values: entries(keyMap, depth)
                });
            });
            return sortKey ? array.sort(function(a, b) {
                return sortKey(a.key, b.key);
            }) : array;
        }
        nest.map = function(array, mapType) {
            return map(mapType, array, 0);
        }
        ;
        nest.entries = function(array) {
            return entries(map(d3.map, array, 0), 0);
        }
        ;
        nest.key = function(d) {
            keys.push(d);
            return nest;
        }
        ;
        nest.sortKeys = function(order) {
            sortKeys[keys.length - 1] = order;
            return nest;
        }
        ;
        nest.sortValues = function(order) {
            sortValues = order;
            return nest;
        }
        ;
        nest.rollup = function(f) {
            rollup = f;
            return nest;
        }
        ;
        return nest;
    }
    ;
    d3.set = function(array) {
        var set = new d3_Set();
        if (array)
            for (var i = 0, n = array.length; i < n; ++i)
                set.add(array[i]);
        return set;
    }
    ;
    function d3_Set() {}
    d3_class(d3_Set, {
        has: d3_map_has,
        add: function(value) {
            this[d3_map_prefix + value] = true;
            return value;
        },
        remove: function(value) {
            value = d3_map_prefix + value;
            return value in this && delete this[value];
        },
        values: d3_map_keys,
        size: d3_map_size,
        empty: d3_map_empty,
        forEach: function(f) {
            for (var value in this)
                if (value.charCodeAt(0) === d3_map_prefixCode)
                    f.call(this, value.substring(1));
        }
    });
    d3.behavior = {};
    d3.rebind = function(target, source) {
        var i = 1, n = arguments.length, method;
        while (++i < n)
            target[method = arguments[i]] = d3_rebind(target, source, source[method]);
        return target;
    }
    ;
    function d3_rebind(target, source, method) {
        return function() {
            var value = method.apply(source, arguments);
            return value === source ? target : value;
        }
        ;
    }
    function d3_vendorSymbol(object, name) {
        if (name in object)
            return name;
        name = name.charAt(0).toUpperCase() + name.substring(1);
        for (var i = 0, n = d3_vendorPrefixes.length; i < n; ++i) {
            var prefixName = d3_vendorPrefixes[i] + name;
            if (prefixName in object)
                return prefixName;
        }
    }
    var d3_vendorPrefixes = ["webkit", "ms", "moz", "Moz", "o", "O"];
    function d3_noop() {}
    d3.dispatch = function() {
        var dispatch = new d3_dispatch()
          , i = -1
          , n = arguments.length;
        while (++i < n)
            dispatch[arguments[i]] = d3_dispatch_event(dispatch);
        return dispatch;
    }
    ;
    function d3_dispatch() {}
    d3_dispatch.prototype.on = function(type, listener) {
        var i = type.indexOf(".")
          , name = "";
        if (i >= 0) {
            name = type.substring(i + 1);
            type = type.substring(0, i);
        }
        if (type)
            return arguments.length < 2 ? this[type].on(name) : this[type].on(name, listener);
        if (arguments.length === 2) {
            if (listener == null)
                for (type in this) {
                    if (this.hasOwnProperty(type))
                        this[type].on(name, null);
                }
            return this;
        }
    }
    ;
    function d3_dispatch_event(dispatch) {
        var listeners = []
          , listenerByName = new d3_Map();
        function event() {
            var z = listeners, i = -1, n = z.length, l;
            while (++i < n)
                if (l = z[i].on)
                    l.apply(this, arguments);
            return dispatch;
        }
        event.on = function(name, listener) {
            var l = listenerByName.get(name), i;
            if (arguments.length < 2)
                return l && l.on;
            if (l) {
                l.on = null;
                listeners = listeners.slice(0, i = listeners.indexOf(l)).concat(listeners.slice(i + 1));
                listenerByName.remove(name);
            }
            if (listener)
                listeners.push(listenerByName.set(name, {
                    on: listener
                }));
            return dispatch;
        }
        ;
        return event;
    }
    d3.event = null;
    function d3_eventPreventDefault() {
        d3.event.preventDefault();
    }
    function d3_eventSource() {
        var e = d3.event, s;
        while (s = e.sourceEvent)
            e = s;
        return e;
    }
    function d3_eventDispatch(target) {
        var dispatch = new d3_dispatch()
          , i = 0
          , n = arguments.length;
        while (++i < n)
            dispatch[arguments[i]] = d3_dispatch_event(dispatch);
        dispatch.of = function(thiz, argumentz) {
            return function(e1) {
                try {
                    var e0 = e1.sourceEvent = d3.event;
                    e1.target = target;
                    d3.event = e1;
                    dispatch[e1.type].apply(thiz, argumentz);
                } finally {
                    d3.event = e0;
                }
            }
            ;
        }
        ;
        return dispatch;
    }
    d3.requote = function(s) {
        return s.replace(d3_requote_re, "\\$&");
    }
    ;
    var d3_requote_re = /[\\\^\$\*\+\?\|\[\]\(\)\.\{\}]/g;
    var d3_subclass = {}.__proto__ ? function(object, prototype) {
        object.__proto__ = prototype;
    }
    : function(object, prototype) {
        for (var property in prototype)
            object[property] = prototype[property];
    }
    ;
    function d3_selection(groups) {
        d3_subclass(groups, d3_selectionPrototype);
        return groups;
    }
    var d3_select = function(s, n) {
        return n.querySelector(s);
    }
      , d3_selectAll = function(s, n) {
        return n.querySelectorAll(s);
    }
      , d3_selectMatcher = d3_documentElement[d3_vendorSymbol(d3_documentElement, "matchesSelector")]
      , d3_selectMatches = function(n, s) {
        return d3_selectMatcher.call(n, s);
    };
    if (typeof Sizzle === "function") {
        d3_select = function(s, n) {
            return Sizzle(s, n)[0] || null;
        }
        ;
        d3_selectAll = Sizzle;
        d3_selectMatches = Sizzle.matchesSelector;
    }
    d3.selection = function() {
        return d3_selectionRoot;
    }
    ;
    var d3_selectionPrototype = d3.selection.prototype = [];
    d3_selectionPrototype.select = function(selector) {
        var subgroups = [], subgroup, subnode, group, node;
        selector = d3_selection_selector(selector);
        for (var j = -1, m = this.length; ++j < m; ) {
            subgroups.push(subgroup = []);
            subgroup.parentNode = (group = this[j]).parentNode;
            for (var i = -1, n = group.length; ++i < n; ) {
                if (node = group[i]) {
                    subgroup.push(subnode = selector.call(node, node.__data__, i, j));
                    if (subnode && "__data__"in node)
                        subnode.__data__ = node.__data__;
                } else {
                    subgroup.push(null);
                }
            }
        }
        return d3_selection(subgroups);
    }
    ;
    function d3_selection_selector(selector) {
        return typeof selector === "function" ? selector : function() {
            return d3_select(selector, this);
        }
        ;
    }
    d3_selectionPrototype.selectAll = function(selector) {
        var subgroups = [], subgroup, node;
        selector = d3_selection_selectorAll(selector);
        for (var j = -1, m = this.length; ++j < m; ) {
            for (var group = this[j], i = -1, n = group.length; ++i < n; ) {
                if (node = group[i]) {
                    subgroups.push(subgroup = d3_array(selector.call(node, node.__data__, i, j)));
                    subgroup.parentNode = node;
                }
            }
        }
        return d3_selection(subgroups);
    }
    ;
    function d3_selection_selectorAll(selector) {
        return typeof selector === "function" ? selector : function() {
            return d3_selectAll(selector, this);
        }
        ;
    }
    var d3_nsPrefix = {
        svg: "http://www.w3.org/2000/svg",
        xhtml: "http://www.w3.org/1999/xhtml",
        xlink: "http://www.w3.org/1999/xlink",
        xml: "http://www.w3.org/XML/1998/namespace",
        xmlns: "http://www.w3.org/2000/xmlns/"
    };
    d3.ns = {
        prefix: d3_nsPrefix,
        qualify: function(name) {
            var i = name.indexOf(":")
              , prefix = name;
            if (i >= 0) {
                prefix = name.substring(0, i);
                name = name.substring(i + 1);
            }
            return d3_nsPrefix.hasOwnProperty(prefix) ? {
                space: d3_nsPrefix[prefix],
                local: name
            } : name;
        }
    };
    d3_selectionPrototype.attr = function(name, value) {
        if (arguments.length < 2) {
            if (typeof name === "string") {
                var node = this.node();
                name = d3.ns.qualify(name);
                return name.local ? node.getAttributeNS(name.space, name.local) : node.getAttribute(name);
            }
            for (value in name)
                this.each(d3_selection_attr(value, name[value]));
            return this;
        }
        return this.each(d3_selection_attr(name, value));
    }
    ;
    function d3_selection_attr(name, value) {
        name = d3.ns.qualify(name);
        function attrNull() {
            this.removeAttribute(name);
        }
        function attrNullNS() {
            this.removeAttributeNS(name.space, name.local);
        }
        function attrConstant() {
            this.setAttribute(name, value);
        }
        function attrConstantNS() {
            this.setAttributeNS(name.space, name.local, value);
        }
        function attrFunction() {
            var x = value.apply(this, arguments);
            if (x == null)
                this.removeAttribute(name);
            else
                this.setAttribute(name, x);
        }
        function attrFunctionNS() {
            var x = value.apply(this, arguments);
            if (x == null)
                this.removeAttributeNS(name.space, name.local);
            else
                this.setAttributeNS(name.space, name.local, x);
        }
        return value == null ? name.local ? attrNullNS : attrNull : typeof value === "function" ? name.local ? attrFunctionNS : attrFunction : name.local ? attrConstantNS : attrConstant;
    }
    function d3_collapse(s) {
        return s.trim().replace(/\s+/g, " ");
    }
    d3_selectionPrototype.classed = function(name, value) {
        if (arguments.length < 2) {
            if (typeof name === "string") {
                var node = this.node()
                  , n = (name = d3_selection_classes(name)).length
                  , i = -1;
                if (value = node.classList) {
                    while (++i < n)
                        if (!value.contains(name[i]))
                            return false;
                } else {
                    value = node.getAttribute("class");
                    while (++i < n)
                        if (!d3_selection_classedRe(name[i]).test(value))
                            return false;
                }
                return true;
            }
            for (value in name)
                this.each(d3_selection_classed(value, name[value]));
            return this;
        }
        return this.each(d3_selection_classed(name, value));
    }
    ;
    function d3_selection_classedRe(name) {
        return new RegExp("(?:^|\\s+)" + d3.requote(name) + "(?:\\s+|$)","g");
    }
    function d3_selection_classes(name) {
        return name.trim().split(/^|\s+/);
    }
    function d3_selection_classed(name, value) {
        name = d3_selection_classes(name).map(d3_selection_classedName);
        var n = name.length;
        function classedConstant() {
            var i = -1;
            while (++i < n)
                name[i](this, value);
        }
        function classedFunction() {
            var i = -1
              , x = value.apply(this, arguments);
            while (++i < n)
                name[i](this, x);
        }
        return typeof value === "function" ? classedFunction : classedConstant;
    }
    function d3_selection_classedName(name) {
        var re = d3_selection_classedRe(name);
        return function(node, value) {
            if (c = node.classList)
                return value ? c.add(name) : c.remove(name);
            var c = node.getAttribute("class") || "";
            if (value) {
                re.lastIndex = 0;
                if (!re.test(c))
                    node.setAttribute("class", d3_collapse(c + " " + name));
            } else {
                node.setAttribute("class", d3_collapse(c.replace(re, " ")));
            }
        }
        ;
    }
    d3_selectionPrototype.style = function(name, value, priority) {
        var n = arguments.length;
        if (n < 3) {
            if (typeof name !== "string") {
                if (n < 2)
                    value = "";
                for (priority in name)
                    this.each(d3_selection_style(priority, name[priority], value));
                return this;
            }
            if (n < 2)
                return d3_window.getComputedStyle(this.node(), null).getPropertyValue(name);
            priority = "";
        }
        return this.each(d3_selection_style(name, value, priority));
    }
    ;
    function d3_selection_style(name, value, priority) {
        function styleNull() {
            this.style.removeProperty(name);
        }
        function styleConstant() {
            this.style.setProperty(name, value, priority);
        }
        function styleFunction() {
            var x = value.apply(this, arguments);
            if (x == null)
                this.style.removeProperty(name);
            else
                this.style.setProperty(name, x, priority);
        }
        return value == null ? styleNull : typeof value === "function" ? styleFunction : styleConstant;
    }
    d3_selectionPrototype.property = function(name, value) {
        if (arguments.length < 2) {
            if (typeof name === "string")
                return this.node()[name];
            for (value in name)
                this.each(d3_selection_property(value, name[value]));
            return this;
        }
        return this.each(d3_selection_property(name, value));
    }
    ;
    function d3_selection_property(name, value) {
        function propertyNull() {
            delete this[name];
        }
        function propertyConstant() {
            this[name] = value;
        }
        function propertyFunction() {
            var x = value.apply(this, arguments);
            if (x == null)
                delete this[name];
            else
                this[name] = x;
        }
        return value == null ? propertyNull : typeof value === "function" ? propertyFunction : propertyConstant;
    }
    d3_selectionPrototype.text = function(value) {
        return arguments.length ? this.each(typeof value === "function" ? function() {
            var v = value.apply(this, arguments);
            this.textContent = v == null ? "" : v;
        }
        : value == null ? function() {
            this.textContent = "";
        }
        : function() {
            this.textContent = value;
        }
        ) : this.node().textContent;
    }
    ;
    d3_selectionPrototype.html = function(value) {
        return arguments.length ? this.each(typeof value === "function" ? function() {
            var v = value.apply(this, arguments);
            this.innerHTML = v == null ? "" : v;
        }
        : value == null ? function() {
            this.innerHTML = "";
        }
        : function() {
            this.innerHTML = value;
        }
        ) : this.node().innerHTML;
    }
    ;
    d3_selectionPrototype.append = function(name) {
        name = d3_selection_creator(name);
        return this.select(function() {
            return this.appendChild(name.apply(this, arguments));
        });
    }
    ;
    function d3_selection_creator(name) {
        return typeof name === "function" ? name : (name = d3.ns.qualify(name)).local ? function() {
            return this.ownerDocument.createElementNS(name.space, name.local);
        }
        : function() {
            return this.ownerDocument.createElementNS(this.namespaceURI, name);
        }
        ;
    }
    d3_selectionPrototype.insert = function(name, before) {
        name = d3_selection_creator(name);
        before = d3_selection_selector(before);
        return this.select(function() {
            return this.insertBefore(name.apply(this, arguments), before.apply(this, arguments) || null);
        });
    }
    ;
    d3_selectionPrototype.remove = function() {
        return this.each(function() {
            var parent = this.parentNode;
            if (parent)
                parent.removeChild(this);
        });
    }
    ;
    d3_selectionPrototype.data = function(value, key) {
        var i = -1, n = this.length, group, node;
        if (!arguments.length) {
            value = new Array(n = (group = this[0]).length);
            while (++i < n) {
                if (node = group[i]) {
                    value[i] = node.__data__;
                }
            }
            return value;
        }
        function bind(group, groupData) {
            var i, n = group.length, m = groupData.length, n0 = Math.min(n, m), updateNodes = new Array(m), enterNodes = new Array(m), exitNodes = new Array(n), node, nodeData;
            if (key) {
                var nodeByKeyValue = new d3_Map(), dataByKeyValue = new d3_Map(), keyValues = [], keyValue;
                for (i = -1; ++i < n; ) {
                    keyValue = key.call(node = group[i], node.__data__, i);
                    if (nodeByKeyValue.has(keyValue)) {
                        exitNodes[i] = node;
                    } else {
                        nodeByKeyValue.set(keyValue, node);
                    }
                    keyValues.push(keyValue);
                }
                for (i = -1; ++i < m; ) {
                    keyValue = key.call(groupData, nodeData = groupData[i], i);
                    if (node = nodeByKeyValue.get(keyValue)) {
                        updateNodes[i] = node;
                        node.__data__ = nodeData;
                    } else if (!dataByKeyValue.has(keyValue)) {
                        enterNodes[i] = d3_selection_dataNode(nodeData);
                    }
                    dataByKeyValue.set(keyValue, nodeData);
                    nodeByKeyValue.remove(keyValue);
                }
                for (i = -1; ++i < n; ) {
                    if (nodeByKeyValue.has(keyValues[i])) {
                        exitNodes[i] = group[i];
                    }
                }
            } else {
                for (i = -1; ++i < n0; ) {
                    node = group[i];
                    nodeData = groupData[i];
                    if (node) {
                        node.__data__ = nodeData;
                        updateNodes[i] = node;
                    } else {
                        enterNodes[i] = d3_selection_dataNode(nodeData);
                    }
                }
                for (; i < m; ++i) {
                    enterNodes[i] = d3_selection_dataNode(groupData[i]);
                }
                for (; i < n; ++i) {
                    exitNodes[i] = group[i];
                }
            }
            enterNodes.update = updateNodes;
            enterNodes.parentNode = updateNodes.parentNode = exitNodes.parentNode = group.parentNode;
            enter.push(enterNodes);
            update.push(updateNodes);
            exit.push(exitNodes);
        }
        var enter = d3_selection_enter([])
          , update = d3_selection([])
          , exit = d3_selection([]);
        if (typeof value === "function") {
            while (++i < n) {
                bind(group = this[i], value.call(group, group.parentNode.__data__, i));
            }
        } else {
            while (++i < n) {
                bind(group = this[i], value);
            }
        }
        update.enter = function() {
            return enter;
        }
        ;
        update.exit = function() {
            return exit;
        }
        ;
        return update;
    }
    ;
    function d3_selection_dataNode(data) {
        return {
            __data__: data
        };
    }
    d3_selectionPrototype.datum = function(value) {
        return arguments.length ? this.property("__data__", value) : this.property("__data__");
    }
    ;
    d3_selectionPrototype.filter = function(filter) {
        var subgroups = [], subgroup, group, node;
        if (typeof filter !== "function")
            filter = d3_selection_filter(filter);
        for (var j = 0, m = this.length; j < m; j++) {
            subgroups.push(subgroup = []);
            subgroup.parentNode = (group = this[j]).parentNode;
            for (var i = 0, n = group.length; i < n; i++) {
                if ((node = group[i]) && filter.call(node, node.__data__, i, j)) {
                    subgroup.push(node);
                }
            }
        }
        return d3_selection(subgroups);
    }
    ;
    function d3_selection_filter(selector) {
        return function() {
            return d3_selectMatches(this, selector);
        }
        ;
    }
    d3_selectionPrototype.order = function() {
        for (var j = -1, m = this.length; ++j < m; ) {
            for (var group = this[j], i = group.length - 1, next = group[i], node; --i >= 0; ) {
                if (node = group[i]) {
                    if (next && next !== node.nextSibling)
                        next.parentNode.insertBefore(node, next);
                    next = node;
                }
            }
        }
        return this;
    }
    ;
    d3_selectionPrototype.sort = function(comparator) {
        comparator = d3_selection_sortComparator.apply(this, arguments);
        for (var j = -1, m = this.length; ++j < m; )
            this[j].sort(comparator);
        return this.order();
    }
    ;
    function d3_selection_sortComparator(comparator) {
        if (!arguments.length)
            comparator = d3_ascending;
        return function(a, b) {
            return a && b ? comparator(a.__data__, b.__data__) : !a - !b;
        }
        ;
    }
    d3_selectionPrototype.each = function(callback) {
        return d3_selection_each(this, function(node, i, j) {
            callback.call(node, node.__data__, i, j);
        });
    }
    ;
    function d3_selection_each(groups, callback) {
        for (var j = 0, m = groups.length; j < m; j++) {
            for (var group = groups[j], i = 0, n = group.length, node; i < n; i++) {
                if (node = group[i])
                    callback(node, i, j);
            }
        }
        return groups;
    }
    d3_selectionPrototype.call = function(callback) {
        var args = d3_array(arguments);
        callback.apply(args[0] = this, args);
        return this;
    }
    ;
    d3_selectionPrototype.empty = function() {
        return !this.node();
    }
    ;
    d3_selectionPrototype.node = function() {
        for (var j = 0, m = this.length; j < m; j++) {
            for (var group = this[j], i = 0, n = group.length; i < n; i++) {
                var node = group[i];
                if (node)
                    return node;
            }
        }
        return null;
    }
    ;
    d3_selectionPrototype.size = function() {
        var n = 0;
        this.each(function() {
            ++n;
        });
        return n;
    }
    ;
    function d3_selection_enter(selection) {
        d3_subclass(selection, d3_selection_enterPrototype);
        return selection;
    }
    var d3_selection_enterPrototype = [];
    d3.selection.enter = d3_selection_enter;
    d3.selection.enter.prototype = d3_selection_enterPrototype;
    d3_selection_enterPrototype.append = d3_selectionPrototype.append;
    d3_selection_enterPrototype.empty = d3_selectionPrototype.empty;
    d3_selection_enterPrototype.node = d3_selectionPrototype.node;
    d3_selection_enterPrototype.call = d3_selectionPrototype.call;
    d3_selection_enterPrototype.size = d3_selectionPrototype.size;
    d3_selection_enterPrototype.select = function(selector) {
        var subgroups = [], subgroup, subnode, upgroup, group, node;
        for (var j = -1, m = this.length; ++j < m; ) {
            upgroup = (group = this[j]).update;
            subgroups.push(subgroup = []);
            subgroup.parentNode = group.parentNode;
            for (var i = -1, n = group.length; ++i < n; ) {
                if (node = group[i]) {
                    subgroup.push(upgroup[i] = subnode = selector.call(group.parentNode, node.__data__, i, j));
                    subnode.__data__ = node.__data__;
                } else {
                    subgroup.push(null);
                }
            }
        }
        return d3_selection(subgroups);
    }
    ;
    d3_selection_enterPrototype.insert = function(name, before) {
        if (arguments.length < 2)
            before = d3_selection_enterInsertBefore(this);
        return d3_selectionPrototype.insert.call(this, name, before);
    }
    ;
    function d3_selection_enterInsertBefore(enter) {
        var i0, j0;
        return function(d, i, j) {
            var group = enter[j].update, n = group.length, node;
            if (j != j0)
                j0 = j,
                i0 = 0;
            if (i >= i0)
                i0 = i + 1;
            while (!(node = group[i0]) && ++i0 < n)
                ;
            return node;
        }
        ;
    }
    d3_selectionPrototype.transition = function() {
        var id = d3_transitionInheritId || ++d3_transitionId, subgroups = [], subgroup, node, transition = d3_transitionInherit || {
            time: Date.now(),
            ease: d3_ease_cubicInOut,
            delay: 0,
            duration: 250
        };
        for (var j = -1, m = this.length; ++j < m; ) {
            subgroups.push(subgroup = []);
            for (var group = this[j], i = -1, n = group.length; ++i < n; ) {
                if (node = group[i])
                    d3_transitionNode(node, i, id, transition);
                subgroup.push(node);
            }
        }
        return d3_transition(subgroups, id);
    }
    ;
    d3_selectionPrototype.interrupt = function() {
        return this.each(d3_selection_interrupt);
    }
    ;
    function d3_selection_interrupt() {
        var lock = this.__transition__;
        if (lock)
            ++lock.active;
    }
    d3.select = function(node) {
        var group = [typeof node === "string" ? d3_select(node, d3_document) : node];
        group.parentNode = d3_documentElement;
        return d3_selection([group]);
    }
    ;
    d3.selectAll = function(nodes) {
        var group = d3_array(typeof nodes === "string" ? d3_selectAll(nodes, d3_document) : nodes);
        group.parentNode = d3_documentElement;
        return d3_selection([group]);
    }
    ;
    var d3_selectionRoot = d3.select(d3_documentElement);
    d3_selectionPrototype.on = function(type, listener, capture) {
        var n = arguments.length;
        if (n < 3) {
            if (typeof type !== "string") {
                if (n < 2)
                    listener = false;
                for (capture in type)
                    this.each(d3_selection_on(capture, type[capture], listener));
                return this;
            }
            if (n < 2)
                return (n = this.node()["__on" + type]) && n._;
            capture = false;
        }
        return this.each(d3_selection_on(type, listener, capture));
    }
    ;
    function d3_selection_on(type, listener, capture) {
        var name = "__on" + type
          , i = type.indexOf(".")
          , wrap = d3_selection_onListener;
        if (i > 0)
            type = type.substring(0, i);
        var filter = d3_selection_onFilters.get(type);
        if (filter)
            type = filter,
            wrap = d3_selection_onFilter;
        function onRemove() {
            var l = this[name];
            if (l) {
                this.removeEventListener(type, l, l.$);
                delete this[name];
            }
        }
        function onAdd() {
            var l = wrap(listener, d3_array(arguments));
            onRemove.call(this);
            this.addEventListener(type, this[name] = l, l.$ = capture);
            l._ = listener;
        }
        function removeAll() {
            var re = new RegExp("^__on([^.]+)" + d3.requote(type) + "$"), match;
            for (var name in this) {
                if (match = name.match(re)) {
                    var l = this[name];
                    this.removeEventListener(match[1], l, l.$);
                    delete this[name];
                }
            }
        }
        return i ? listener ? onAdd : onRemove : listener ? d3_noop : removeAll;
    }
    var d3_selection_onFilters = d3.map({
        mouseenter: "mouseover",
        mouseleave: "mouseout"
    });
    d3_selection_onFilters.forEach(function(k) {
        if ("on" + k in d3_document)
            d3_selection_onFilters.remove(k);
    });
    function d3_selection_onListener(listener, argumentz) {
        return function(e) {
            var o = d3.event;
            d3.event = e;
            argumentz[0] = this.__data__;
            try {
                listener.apply(this, argumentz);
            } finally {
                d3.event = o;
            }
        }
        ;
    }
    function d3_selection_onFilter(listener, argumentz) {
        var l = d3_selection_onListener(listener, argumentz);
        return function(e) {
            var target = this
              , related = e.relatedTarget;
            if (!related || related !== target && !(related.compareDocumentPosition(target) & 8)) {
                l.call(target, e);
            }
        }
        ;
    }
    var d3_event_dragSelect = "onselectstart"in d3_document ? null : d3_vendorSymbol(d3_documentElement.style, "userSelect")
      , d3_event_dragId = 0;
    function d3_event_dragSuppress() {
        var name = ".dragsuppress-" + (++d3_event_dragId)
          , click = "click" + name
          , w = d3.select(d3_window).on("touchmove" + name, d3_eventPreventDefault).on("dragstart" + name, d3_eventPreventDefault).on("selectstart" + name, d3_eventPreventDefault);
        if (d3_event_dragSelect) {
            var style = d3_documentElement.style
              , select = style[d3_event_dragSelect];
            style[d3_event_dragSelect] = "none";
        }
        return function(suppressClick) {
            w.on(name, null);
            if (d3_event_dragSelect)
                style[d3_event_dragSelect] = select;
            if (suppressClick) {
                function off() {
                    w.on(click, null);
                }
                w.on(click, function() {
                    d3_eventPreventDefault();
                    off();
                }, true);
                setTimeout(off, 0);
            }
        }
        ;
    }
    d3.mouse = function(container) {
        return d3_mousePoint(container, d3_eventSource());
    }
    ;
    function d3_mousePoint(container, e) {
        if (e.changedTouches)
            e = e.changedTouches[0];
        var svg = container.ownerSVGElement || container;
        if (svg.createSVGPoint) {
            var point = svg.createSVGPoint();
            point.x = e.clientX,
            point.y = e.clientY;
            point = point.matrixTransform(container.getScreenCTM().inverse());
            return [point.x, point.y];
        }
        var rect = container.getBoundingClientRect();
        return [e.clientX - rect.left - container.clientLeft, e.clientY - rect.top - container.clientTop];
    }
    d3.touches = function(container, touches) {
        if (arguments.length < 2)
            touches = d3_eventSource().touches;
        return touches ? d3_array(touches).map(function(touch) {
            var point = d3_mousePoint(container, touch);
            point.identifier = touch.identifier;
            return point;
        }) : [];
    }
    ;
    d3.behavior.drag = function() {
        var event = d3_eventDispatch(drag, "drag", "dragstart", "dragend")
          , origin = null
          , mousedown = dragstart(d3_noop, d3.mouse, d3_behavior_dragMouseSubject, "mousemove", "mouseup")
          , touchstart = dragstart(d3_behavior_dragTouchId, d3.touch, d3_behavior_dragTouchSubject, "touchmove", "touchend");
        function drag() {
            this.on("mousedown.drag", mousedown).on("touchstart.drag", touchstart);
        }
        function dragstart(id, position, subject, move, end) {
            return function() {
                var that = this, target = d3.event.target, parent = that.parentNode, dispatch = event.of(that, arguments), dragged = 0, dragId = id(), dragName = ".drag" + (dragId == null ? "" : "-" + dragId), dragOffset, dragSubject = d3.select(subject()).on(move + dragName, moved).on(end + dragName, ended), dragRestore = d3_event_dragSuppress(), position0 = position(parent, dragId);
                if (origin) {
                    dragOffset = origin.apply(that, arguments);
                    dragOffset = [dragOffset.x - position0[0], dragOffset.y - position0[1]];
                } else {
                    dragOffset = [0, 0];
                }
                dispatch({
                    type: "dragstart"
                });
                function moved() {
                    var position1 = position(parent, dragId), dx, dy;
                    if (!position1)
                        return;
                    dx = position1[0] - position0[0];
                    dy = position1[1] - position0[1];
                    dragged |= dx | dy;
                    position0 = position1;
                    dispatch({
                        type: "drag",
                        x: position1[0] + dragOffset[0],
                        y: position1[1] + dragOffset[1],
                        dx: dx,
                        dy: dy
                    });
                }
                function ended() {
                    if (!position(parent, dragId))
                        return;
                    dragSubject.on(move + dragName, null).on(end + dragName, null);
                    dragRestore(dragged && d3.event.target === target);
                    dispatch({
                        type: "dragend"
                    });
                }
            }
            ;
        }
        drag.origin = function(x) {
            if (!arguments.length)
                return origin;
            origin = x;
            return drag;
        }
        ;
        return d3.rebind(drag, event, "on");
    }
    ;
    function d3_behavior_dragTouchId() {
        return d3.event.changedTouches[0].identifier;
    }
    function d3_behavior_dragTouchSubject() {
        return d3.event.target;
    }
    function d3_behavior_dragMouseSubject() {
        return d3_window;
    }
    var π = Math.PI
      , τ = 2 * π
      , halfπ = π / 2
      , ε = 1e-6
      , ε2 = ε * ε
      , d3_radians = π / 180
      , d3_degrees = 180 / π;
    function d3_sgn(x) {
        return x > 0 ? 1 : x < 0 ? -1 : 0;
    }
    function d3_cross2d(a, b, c) {
        return (b[0] - a[0]) * (c[1] - a[1]) - (b[1] - a[1]) * (c[0] - a[0]);
    }
    function d3_acos(x) {
        return x > 1 ? 0 : x < -1 ? π : Math.acos(x);
    }
    function d3_asin(x) {
        return x > 1 ? halfπ : x < -1 ? -halfπ : Math.asin(x);
    }
    function d3_sinh(x) {
        return ((x = Math.exp(x)) - 1 / x) / 2;
    }
    function d3_cosh(x) {
        return ((x = Math.exp(x)) + 1 / x) / 2;
    }
    function d3_tanh(x) {
        return ((x = Math.exp(2 * x)) - 1) / (x + 1);
    }
    function d3_haversin(x) {
        return (x = Math.sin(x / 2)) * x;
    }
    var ρ = Math.SQRT2
      , ρ2 = 2
      , ρ4 = 4;
    d3.interpolateZoom = function(p0, p1) {
        var ux0 = p0[0]
          , uy0 = p0[1]
          , w0 = p0[2]
          , ux1 = p1[0]
          , uy1 = p1[1]
          , w1 = p1[2];
        var dx = ux1 - ux0
          , dy = uy1 - uy0
          , d2 = dx * dx + dy * dy
          , d1 = Math.sqrt(d2)
          , b0 = (w1 * w1 - w0 * w0 + ρ4 * d2) / (2 * w0 * ρ2 * d1)
          , b1 = (w1 * w1 - w0 * w0 - ρ4 * d2) / (2 * w1 * ρ2 * d1)
          , r0 = Math.log(Math.sqrt(b0 * b0 + 1) - b0)
          , r1 = Math.log(Math.sqrt(b1 * b1 + 1) - b1)
          , dr = r1 - r0
          , S = (dr || Math.log(w1 / w0)) / ρ;
        function interpolate(t) {
            var s = t * S;
            if (dr) {
                var coshr0 = d3_cosh(r0)
                  , u = w0 / (ρ2 * d1) * (coshr0 * d3_tanh(ρ * s + r0) - d3_sinh(r0));
                return [ux0 + u * dx, uy0 + u * dy, w0 * coshr0 / d3_cosh(ρ * s + r0)];
            }
            return [ux0 + t * dx, uy0 + t * dy, w0 * Math.exp(ρ * s)];
        }
        interpolate.duration = S * 1e3;
        return interpolate;
    }
    ;
    d3.behavior.zoom = function() {
        var view = {
            x: 0,
            y: 0,
            k: 1
        }, translate0, center, size = [960, 500], scaleExtent = d3_behavior_zoomInfinity, mousedown = "mousedown.zoom", mousemove = "mousemove.zoom", mouseup = "mouseup.zoom", mousewheelTimer, touchstart = "touchstart.zoom", touchtime, event = d3_eventDispatch(zoom, "zoomstart", "zoom", "zoomend"), x0, x1, y0, y1;
        function zoom(g) {
            g.on(mousedown, mousedowned).on(d3_behavior_zoomWheel + ".zoom", mousewheeled).on(mousemove, mousewheelreset).on("dblclick.zoom", dblclicked).on(touchstart, touchstarted);
        }
        zoom.event = function(g) {
            g.each(function() {
                var dispatch = event.of(this, arguments)
                  , view1 = view;
                if (d3_transitionInheritId) {
                    d3.select(this).transition().each("start.zoom", function() {
                        view = this.__chart__ || {
                            x: 0,
                            y: 0,
                            k: 1
                        };
                        zoomstarted(dispatch);
                    }).tween("zoom:zoom", function() {
                        var dx = size[0]
                          , dy = size[1]
                          , cx = dx / 2
                          , cy = dy / 2
                          , i = d3.interpolateZoom([(cx - view.x) / view.k, (cy - view.y) / view.k, dx / view.k], [(cx - view1.x) / view1.k, (cy - view1.y) / view1.k, dx / view1.k]);
                        return function(t) {
                            var l = i(t)
                              , k = dx / l[2];
                            this.__chart__ = view = {
                                x: cx - l[0] * k,
                                y: cy - l[1] * k,
                                k: k
                            };
                            zoomed(dispatch);
                        }
                        ;
                    }).each("end.zoom", function() {
                        zoomended(dispatch);
                    });
                } else {
                    this.__chart__ = view;
                    zoomstarted(dispatch);
                    zoomed(dispatch);
                    zoomended(dispatch);
                }
            });
        }
        ;
        zoom.translate = function(_) {
            if (!arguments.length)
                return [view.x, view.y];
            view = {
                x: +_[0],
                y: +_[1],
                k: view.k
            };
            rescale();
            return zoom;
        }
        ;
        zoom.scale = function(_) {
            if (!arguments.length)
                return view.k;
            view = {
                x: view.x,
                y: view.y,
                k: +_
            };
            rescale();
            return zoom;
        }
        ;
        zoom.scaleExtent = function(_) {
            if (!arguments.length)
                return scaleExtent;
            scaleExtent = _ == null ? d3_behavior_zoomInfinity : [+_[0], +_[1]];
            return zoom;
        }
        ;
        zoom.center = function(_) {
            if (!arguments.length)
                return center;
            center = _ && [+_[0], +_[1]];
            return zoom;
        }
        ;
        zoom.size = function(_) {
            if (!arguments.length)
                return size;
            size = _ && [+_[0], +_[1]];
            return zoom;
        }
        ;
        zoom.x = function(z) {
            if (!arguments.length)
                return x1;
            x1 = z;
            x0 = z.copy();
            view = {
                x: 0,
                y: 0,
                k: 1
            };
            return zoom;
        }
        ;
        zoom.y = function(z) {
            if (!arguments.length)
                return y1;
            y1 = z;
            y0 = z.copy();
            view = {
                x: 0,
                y: 0,
                k: 1
            };
            return zoom;
        }
        ;
        function location(p) {
            return [(p[0] - view.x) / view.k, (p[1] - view.y) / view.k];
        }
        function point(l) {
            return [l[0] * view.k + view.x, l[1] * view.k + view.y];
        }
        function scaleTo(s) {
            view.k = Math.max(scaleExtent[0], Math.min(scaleExtent[1], s));
        }
        function translateTo(p, l) {
            l = point(l);
            view.x += p[0] - l[0];
            view.y += p[1] - l[1];
        }
        function rescale() {
            if (x1)
                x1.domain(x0.range().map(function(x) {
                    return (x - view.x) / view.k;
                }).map(x0.invert));
            if (y1)
                y1.domain(y0.range().map(function(y) {
                    return (y - view.y) / view.k;
                }).map(y0.invert));
        }
        function zoomstarted(dispatch) {
            dispatch({
                type: "zoomstart"
            });
        }
        function zoomed(dispatch) {
            rescale();
            dispatch({
                type: "zoom",
                scale: view.k,
                translate: [view.x, view.y]
            });
        }
        function zoomended(dispatch) {
            dispatch({
                type: "zoomend"
            });
        }
        function mousedowned() {
            var that = this
              , target = d3.event.target
              , dispatch = event.of(that, arguments)
              , dragged = 0
              , subject = d3.select(d3_window).on(mousemove, moved).on(mouseup, ended)
              , location0 = location(d3.mouse(that))
              , dragRestore = d3_event_dragSuppress();
            d3_selection_interrupt.call(that);
            zoomstarted(dispatch);
            function moved() {
                dragged = 1;
                translateTo(d3.mouse(that), location0);
                zoomed(dispatch);
            }
            function ended() {
                subject.on(mousemove, d3_window === that ? mousewheelreset : null).on(mouseup, null);
                dragRestore(dragged && d3.event.target === target);
                zoomended(dispatch);
            }
        }
        function touchstarted() {
            var that = this, dispatch = event.of(that, arguments), locations0 = {}, distance0 = 0, scale0, zoomName = ".zoom-" + d3.event.changedTouches[0].identifier, touchmove = "touchmove" + zoomName, touchend = "touchend" + zoomName, target = d3.select(d3.event.target).on(touchmove, moved).on(touchend, ended), subject = d3.select(that).on(mousedown, null).on(touchstart, started), dragRestore = d3_event_dragSuppress();
            d3_selection_interrupt.call(that);
            started();
            zoomstarted(dispatch);
            function relocate() {
                var touches = d3.touches(that);
                scale0 = view.k;
                touches.forEach(function(t) {
                    if (t.identifier in locations0)
                        locations0[t.identifier] = location(t);
                });
                return touches;
            }
            function started() {
                var changed = d3.event.changedTouches;
                for (var i = 0, n = changed.length; i < n; ++i) {
                    locations0[changed[i].identifier] = null;
                }
                var touches = relocate()
                  , now = Date.now();
                if (touches.length === 1) {
                    if (now - touchtime < 500) {
                        var p = touches[0]
                          , l = locations0[p.identifier];
                        scaleTo(view.k * 2);
                        translateTo(p, l);
                        d3_eventPreventDefault();
                        zoomed(dispatch);
                    }
                    touchtime = now;
                } else if (touches.length > 1) {
                    var p = touches[0]
                      , q = touches[1]
                      , dx = p[0] - q[0]
                      , dy = p[1] - q[1];
                    distance0 = dx * dx + dy * dy;
                }
            }
            function moved() {
                var touches = d3.touches(that), p0, l0, p1, l1;
                for (var i = 0, n = touches.length; i < n; ++i,
                l1 = null) {
                    p1 = touches[i];
                    if (l1 = locations0[p1.identifier]) {
                        if (l0)
                            break;
                        p0 = p1,
                        l0 = l1;
                    }
                }
                if (l1) {
                    var distance1 = (distance1 = p1[0] - p0[0]) * distance1 + (distance1 = p1[1] - p0[1]) * distance1
                      , scale1 = distance0 && Math.sqrt(distance1 / distance0);
                    p0 = [(p0[0] + p1[0]) / 2, (p0[1] + p1[1]) / 2];
                    l0 = [(l0[0] + l1[0]) / 2, (l0[1] + l1[1]) / 2];
                    scaleTo(scale1 * scale0);
                }
                touchtime = null;
                translateTo(p0, l0);
                zoomed(dispatch);
            }
            function ended() {
                if (d3.event.touches.length) {
                    var changed = d3.event.changedTouches;
                    for (var i = 0, n = changed.length; i < n; ++i) {
                        delete locations0[changed[i].identifier];
                    }
                    for (var identifier in locations0) {
                        return void relocate();
                    }
                }
                target.on(zoomName, null);
                subject.on(mousedown, mousedowned).on(touchstart, touchstarted);
                dragRestore();
                zoomended(dispatch);
            }
        }
        function mousewheeled() {
            var dispatch = event.of(this, arguments);
            if (mousewheelTimer)
                clearTimeout(mousewheelTimer);
            else
                d3_selection_interrupt.call(this),
                zoomstarted(dispatch);
            mousewheelTimer = setTimeout(function() {
                mousewheelTimer = null;
                zoomended(dispatch);
            }, 50);
            d3_eventPreventDefault();
            var point = center || d3.mouse(this);
            if (!translate0)
                translate0 = location(point);
            scaleTo(Math.pow(2, d3_behavior_zoomDelta() * .002) * view.k);
            translateTo(point, translate0);
            zoomed(dispatch);
        }
        function mousewheelreset() {
            translate0 = null;
        }
        function dblclicked() {
            var dispatch = event.of(this, arguments)
              , p = d3.mouse(this)
              , l = location(p)
              , k = Math.log(view.k) / Math.LN2;
            zoomstarted(dispatch);
            scaleTo(Math.pow(2, d3.event.shiftKey ? Math.ceil(k) - 1 : Math.floor(k) + 1));
            translateTo(p, l);
            zoomed(dispatch);
            zoomended(dispatch);
        }
        return d3.rebind(zoom, event, "on");
    }
    ;
    var d3_behavior_zoomInfinity = [0, Infinity];
    var d3_behavior_zoomDelta, d3_behavior_zoomWheel = "onwheel"in d3_document ? (d3_behavior_zoomDelta = function() {
        return -d3.event.deltaY * (d3.event.deltaMode ? 120 : 1);
    }
    ,
    "wheel") : "onmousewheel"in d3_document ? (d3_behavior_zoomDelta = function() {
        return d3.event.wheelDelta;
    }
    ,
    "mousewheel") : (d3_behavior_zoomDelta = function() {
        return -d3.event.detail;
    }
    ,
    "MozMousePixelScroll");
    function d3_Color() {}
    d3_Color.prototype.toString = function() {
        return this.rgb() + "";
    }
    ;
    d3.hsl = function(h, s, l) {
        return arguments.length === 1 ? h instanceof d3_Hsl ? d3_hsl(h.h, h.s, h.l) : d3_rgb_parse("" + h, d3_rgb_hsl, d3_hsl) : d3_hsl(+h, +s, +l);
    }
    ;
    function d3_hsl(h, s, l) {
        return new d3_Hsl(h,s,l);
    }
    function d3_Hsl(h, s, l) {
        this.h = h;
        this.s = s;
        this.l = l;
    }
    var d3_hslPrototype = d3_Hsl.prototype = new d3_Color();
    d3_hslPrototype.brighter = function(k) {
        k = Math.pow(.7, arguments.length ? k : 1);
        return d3_hsl(this.h, this.s, this.l / k);
    }
    ;
    d3_hslPrototype.darker = function(k) {
        k = Math.pow(.7, arguments.length ? k : 1);
        return d3_hsl(this.h, this.s, k * this.l);
    }
    ;
    d3_hslPrototype.rgb = function() {
        return d3_hsl_rgb(this.h, this.s, this.l);
    }
    ;
    function d3_hsl_rgb(h, s, l) {
        var m1, m2;
        h = isNaN(h) ? 0 : (h %= 360) < 0 ? h + 360 : h;
        s = isNaN(s) ? 0 : s < 0 ? 0 : s > 1 ? 1 : s;
        l = l < 0 ? 0 : l > 1 ? 1 : l;
        m2 = l <= .5 ? l * (1 + s) : l + s - l * s;
        m1 = 2 * l - m2;
        function v(h) {
            if (h > 360)
                h -= 360;
            else if (h < 0)
                h += 360;
            if (h < 60)
                return m1 + (m2 - m1) * h / 60;
            if (h < 180)
                return m2;
            if (h < 240)
                return m1 + (m2 - m1) * (240 - h) / 60;
            return m1;
        }
        function vv(h) {
            return Math.round(v(h) * 255);
        }
        return d3_rgb(vv(h + 120), vv(h), vv(h - 120));
    }
    d3.hcl = function(h, c, l) {
        return arguments.length === 1 ? h instanceof d3_Hcl ? d3_hcl(h.h, h.c, h.l) : h instanceof d3_Lab ? d3_lab_hcl(h.l, h.a, h.b) : d3_lab_hcl((h = d3_rgb_lab((h = d3.rgb(h)).r, h.g, h.b)).l, h.a, h.b) : d3_hcl(+h, +c, +l);
    }
    ;
    function d3_hcl(h, c, l) {
        return new d3_Hcl(h,c,l);
    }
    function d3_Hcl(h, c, l) {
        this.h = h;
        this.c = c;
        this.l = l;
    }
    var d3_hclPrototype = d3_Hcl.prototype = new d3_Color();
    d3_hclPrototype.brighter = function(k) {
        return d3_hcl(this.h, this.c, Math.min(100, this.l + d3_lab_K * (arguments.length ? k : 1)));
    }
    ;
    d3_hclPrototype.darker = function(k) {
        return d3_hcl(this.h, this.c, Math.max(0, this.l - d3_lab_K * (arguments.length ? k : 1)));
    }
    ;
    d3_hclPrototype.rgb = function() {
        return d3_hcl_lab(this.h, this.c, this.l).rgb();
    }
    ;
    function d3_hcl_lab(h, c, l) {
        if (isNaN(h))
            h = 0;
        if (isNaN(c))
            c = 0;
        return d3_lab(l, Math.cos(h *= d3_radians) * c, Math.sin(h) * c);
    }
    d3.lab = function(l, a, b) {
        return arguments.length === 1 ? l instanceof d3_Lab ? d3_lab(l.l, l.a, l.b) : l instanceof d3_Hcl ? d3_hcl_lab(l.l, l.c, l.h) : d3_rgb_lab((l = d3.rgb(l)).r, l.g, l.b) : d3_lab(+l, +a, +b);
    }
    ;
    function d3_lab(l, a, b) {
        return new d3_Lab(l,a,b);
    }
    function d3_Lab(l, a, b) {
        this.l = l;
        this.a = a;
        this.b = b;
    }
    var d3_lab_K = 18;
    var d3_lab_X = .95047
      , d3_lab_Y = 1
      , d3_lab_Z = 1.08883;
    var d3_labPrototype = d3_Lab.prototype = new d3_Color();
    d3_labPrototype.brighter = function(k) {
        return d3_lab(Math.min(100, this.l + d3_lab_K * (arguments.length ? k : 1)), this.a, this.b);
    }
    ;
    d3_labPrototype.darker = function(k) {
        return d3_lab(Math.max(0, this.l - d3_lab_K * (arguments.length ? k : 1)), this.a, this.b);
    }
    ;
    d3_labPrototype.rgb = function() {
        return d3_lab_rgb(this.l, this.a, this.b);
    }
    ;
    function d3_lab_rgb(l, a, b) {
        var y = (l + 16) / 116
          , x = y + a / 500
          , z = y - b / 200;
        x = d3_lab_xyz(x) * d3_lab_X;
        y = d3_lab_xyz(y) * d3_lab_Y;
        z = d3_lab_xyz(z) * d3_lab_Z;
        return d3_rgb(d3_xyz_rgb(3.2404542 * x - 1.5371385 * y - .4985314 * z), d3_xyz_rgb(-.969266 * x + 1.8760108 * y + .041556 * z), d3_xyz_rgb(.0556434 * x - .2040259 * y + 1.0572252 * z));
    }
    function d3_lab_hcl(l, a, b) {
        return l > 0 ? d3_hcl(Math.atan2(b, a) * d3_degrees, Math.sqrt(a * a + b * b), l) : d3_hcl(NaN, NaN, l);
    }
    function d3_lab_xyz(x) {
        return x > .206893034 ? x * x * x : (x - 4 / 29) / 7.787037;
    }
    function d3_xyz_lab(x) {
        return x > .008856 ? Math.pow(x, 1 / 3) : 7.787037 * x + 4 / 29;
    }
    function d3_xyz_rgb(r) {
        return Math.round(255 * (r <= .00304 ? 12.92 * r : 1.055 * Math.pow(r, 1 / 2.4) - .055));
    }
    d3.rgb = function(r, g, b) {
        return arguments.length === 1 ? r instanceof d3_Rgb ? d3_rgb(r.r, r.g, r.b) : d3_rgb_parse("" + r, d3_rgb, d3_hsl_rgb) : d3_rgb(~~r, ~~g, ~~b);
    }
    ;
    function d3_rgbNumber(value) {
        return d3_rgb(value >> 16, value >> 8 & 255, value & 255);
    }
    function d3_rgbString(value) {
        return d3_rgbNumber(value) + "";
    }
    function d3_rgb(r, g, b) {
        return new d3_Rgb(r,g,b);
    }
    function d3_Rgb(r, g, b) {
        this.r = r;
        this.g = g;
        this.b = b;
    }
    var d3_rgbPrototype = d3_Rgb.prototype = new d3_Color();
    d3_rgbPrototype.brighter = function(k) {
        k = Math.pow(.7, arguments.length ? k : 1);
        var r = this.r
          , g = this.g
          , b = this.b
          , i = 30;
        if (!r && !g && !b)
            return d3_rgb(i, i, i);
        if (r && r < i)
            r = i;
        if (g && g < i)
            g = i;
        if (b && b < i)
            b = i;
        return d3_rgb(Math.min(255, ~~(r / k)), Math.min(255, ~~(g / k)), Math.min(255, ~~(b / k)));
    }
    ;
    d3_rgbPrototype.darker = function(k) {
        k = Math.pow(.7, arguments.length ? k : 1);
        return d3_rgb(~~(k * this.r), ~~(k * this.g), ~~(k * this.b));
    }
    ;
    d3_rgbPrototype.hsl = function() {
        return d3_rgb_hsl(this.r, this.g, this.b);
    }
    ;
    d3_rgbPrototype.toString = function() {
        return "#" + d3_rgb_hex(this.r) + d3_rgb_hex(this.g) + d3_rgb_hex(this.b);
    }
    ;
    function d3_rgb_hex(v) {
        return v < 16 ? "0" + Math.max(0, v).toString(16) : Math.min(255, v).toString(16);
    }
    function d3_rgb_parse(format, rgb, hsl) {
        var r = 0, g = 0, b = 0, m1, m2, color;
        m1 = /([a-z]+)\((.*)\)/i.exec(format);
        if (m1) {
            m2 = m1[2].split(",");
            switch (m1[1]) {
            case "hsl":
                {
                    return hsl(parseFloat(m2[0]), parseFloat(m2[1]) / 100, parseFloat(m2[2]) / 100);
                }

            case "rgb":
                {
                    return rgb(d3_rgb_parseNumber(m2[0]), d3_rgb_parseNumber(m2[1]), d3_rgb_parseNumber(m2[2]));
                }
            }
        }
        if (color = d3_rgb_names.get(format))
            return rgb(color.r, color.g, color.b);
        if (format != null && format.charAt(0) === "#" && !isNaN(color = parseInt(format.substring(1), 16))) {
            if (format.length === 4) {
                r = (color & 3840) >> 4;
                r = r >> 4 | r;
                g = color & 240;
                g = g >> 4 | g;
                b = color & 15;
                b = b << 4 | b;
            } else if (format.length === 7) {
                r = (color & 16711680) >> 16;
                g = (color & 65280) >> 8;
                b = color & 255;
            }
        }
        return rgb(r, g, b);
    }
    function d3_rgb_hsl(r, g, b) {
        var min = Math.min(r /= 255, g /= 255, b /= 255), max = Math.max(r, g, b), d = max - min, h, s, l = (max + min) / 2;
        if (d) {
            s = l < .5 ? d / (max + min) : d / (2 - max - min);
            if (r == max)
                h = (g - b) / d + (g < b ? 6 : 0);
            else if (g == max)
                h = (b - r) / d + 2;
            else
                h = (r - g) / d + 4;
            h *= 60;
        } else {
            h = NaN;
            s = l > 0 && l < 1 ? 0 : h;
        }
        return d3_hsl(h, s, l);
    }
    function d3_rgb_lab(r, g, b) {
        r = d3_rgb_xyz(r);
        g = d3_rgb_xyz(g);
        b = d3_rgb_xyz(b);
        var x = d3_xyz_lab((.4124564 * r + .3575761 * g + .1804375 * b) / d3_lab_X)
          , y = d3_xyz_lab((.2126729 * r + .7151522 * g + .072175 * b) / d3_lab_Y)
          , z = d3_xyz_lab((.0193339 * r + .119192 * g + .9503041 * b) / d3_lab_Z);
        return d3_lab(116 * y - 16, 500 * (x - y), 200 * (y - z));
    }
    function d3_rgb_xyz(r) {
        return (r /= 255) <= .04045 ? r / 12.92 : Math.pow((r + .055) / 1.055, 2.4);
    }
    function d3_rgb_parseNumber(c) {
        var f = parseFloat(c);
        return c.charAt(c.length - 1) === "%" ? Math.round(f * 2.55) : f;
    }
    var d3_rgb_names = d3.map({
        aliceblue: 15792383,
        antiquewhite: 16444375,
        aqua: 65535,
        aquamarine: 8388564,
        azure: 15794175,
        beige: 16119260,
        bisque: 16770244,
        black: 0,
        blanchedalmond: 16772045,
        blue: 255,
        blueviolet: 9055202,
        brown: 10824234,
        burlywood: 14596231,
        cadetblue: 6266528,
        chartreuse: 8388352,
        chocolate: 13789470,
        coral: 16744272,
        cornflowerblue: 6591981,
        cornsilk: 16775388,
        crimson: 14423100,
        cyan: 65535,
        darkblue: 139,
        darkcyan: 35723,
        darkgoldenrod: 12092939,
        darkgray: 11119017,
        darkgreen: 25600,
        darkgrey: 11119017,
        darkkhaki: 12433259,
        darkmagenta: 9109643,
        darkolivegreen: 5597999,
        darkorange: 16747520,
        darkorchid: 10040012,
        darkred: 9109504,
        darksalmon: 15308410,
        darkseagreen: 9419919,
        darkslateblue: 4734347,
        darkslategray: 3100495,
        darkslategrey: 3100495,
        darkturquoise: 52945,
        darkviolet: 9699539,
        deeppink: 16716947,
        deepskyblue: 49151,
        dimgray: 6908265,
        dimgrey: 6908265,
        dodgerblue: 2003199,
        firebrick: 11674146,
        floralwhite: 16775920,
        forestgreen: 2263842,
        fuchsia: 16711935,
        gainsboro: 14474460,
        ghostwhite: 16316671,
        gold: 16766720,
        goldenrod: 14329120,
        gray: 8421504,
        green: 32768,
        greenyellow: 11403055,
        grey: 8421504,
        honeydew: 15794160,
        hotpink: 16738740,
        indianred: 13458524,
        indigo: 4915330,
        ivory: 16777200,
        khaki: 15787660,
        lavender: 15132410,
        lavenderblush: 16773365,
        lawngreen: 8190976,
        lemonchiffon: 16775885,
        lightblue: 11393254,
        lightcoral: 15761536,
        lightcyan: 14745599,
        lightgoldenrodyellow: 16448210,
        lightgray: 13882323,
        lightgreen: 9498256,
        lightgrey: 13882323,
        lightpink: 16758465,
        lightsalmon: 16752762,
        lightseagreen: 2142890,
        lightskyblue: 8900346,
        lightslategray: 7833753,
        lightslategrey: 7833753,
        lightsteelblue: 11584734,
        lightyellow: 16777184,
        lime: 65280,
        limegreen: 3329330,
        linen: 16445670,
        magenta: 16711935,
        maroon: 8388608,
        mediumaquamarine: 6737322,
        mediumblue: 205,
        mediumorchid: 12211667,
        mediumpurple: 9662683,
        mediumseagreen: 3978097,
        mediumslateblue: 8087790,
        mediumspringgreen: 64154,
        mediumturquoise: 4772300,
        mediumvioletred: 13047173,
        midnightblue: 1644912,
        mintcream: 16121850,
        mistyrose: 16770273,
        moccasin: 16770229,
        navajowhite: 16768685,
        navy: 128,
        oldlace: 16643558,
        olive: 8421376,
        olivedrab: 7048739,
        orange: 16753920,
        orangered: 16729344,
        orchid: 14315734,
        palegoldenrod: 15657130,
        palegreen: 10025880,
        paleturquoise: 11529966,
        palevioletred: 14381203,
        papayawhip: 16773077,
        peachpuff: 16767673,
        peru: 13468991,
        pink: 16761035,
        plum: 14524637,
        powderblue: 11591910,
        purple: 8388736,
        red: 16711680,
        rosybrown: 12357519,
        royalblue: 4286945,
        saddlebrown: 9127187,
        salmon: 16416882,
        sandybrown: 16032864,
        seagreen: 3050327,
        seashell: 16774638,
        sienna: 10506797,
        silver: 12632256,
        skyblue: 8900331,
        slateblue: 6970061,
        slategray: 7372944,
        slategrey: 7372944,
        snow: 16775930,
        springgreen: 65407,
        steelblue: 4620980,
        tan: 13808780,
        teal: 32896,
        thistle: 14204888,
        tomato: 16737095,
        turquoise: 4251856,
        violet: 15631086,
        wheat: 16113331,
        white: 16777215,
        whitesmoke: 16119285,
        yellow: 16776960,
        yellowgreen: 10145074
    });
    d3_rgb_names.forEach(function(key, value) {
        d3_rgb_names.set(key, d3_rgbNumber(value));
    });
    function d3_functor(v) {
        return typeof v === "function" ? v : function() {
            return v;
        }
        ;
    }
    d3.functor = d3_functor;
    function d3_identity(d) {
        return d;
    }
    d3.xhr = d3_xhrType(d3_identity);
    function d3_xhrType(response) {
        return function(url, mimeType, callback) {
            if (arguments.length === 2 && typeof mimeType === "function")
                callback = mimeType,
                mimeType = null;
            return d3_xhr(url, mimeType, response, callback);
        }
        ;
    }
    function d3_xhr(url, mimeType, response, callback) {
        var xhr = {}
          , dispatch = d3.dispatch("beforesend", "progress", "load", "error")
          , headers = {}
          , request = new XMLHttpRequest()
          , responseType = null;
        if (d3_window.XDomainRequest && !("withCredentials"in request) && /^(http(s)?:)?\/\//.test(url))
            request = new XDomainRequest();
        "onload"in request ? request.onload = request.onerror = respond : request.onreadystatechange = function() {
            request.readyState > 3 && respond();
        }
        ;
        function respond() {
            var status = request.status, result;
            if (!status && request.responseText || status >= 200 && status < 300 || status === 304) {
                try {
                    result = response.call(xhr, request);
                } catch (e) {
                    dispatch.error.call(xhr, e);
                    return;
                }
                dispatch.load.call(xhr, result);
            } else {
                dispatch.error.call(xhr, request);
            }
        }
        request.onprogress = function(event) {
            var o = d3.event;
            d3.event = event;
            try {
                dispatch.progress.call(xhr, request);
            } finally {
                d3.event = o;
            }
        }
        ;
        xhr.header = function(name, value) {
            name = (name + "").toLowerCase();
            if (arguments.length < 2)
                return headers[name];
            if (value == null)
                delete headers[name];
            else
                headers[name] = value + "";
            return xhr;
        }
        ;
        xhr.mimeType = function(value) {
            if (!arguments.length)
                return mimeType;
            mimeType = value == null ? null : value + "";
            return xhr;
        }
        ;
        xhr.responseType = function(value) {
            if (!arguments.length)
                return responseType;
            responseType = value;
            return xhr;
        }
        ;
        xhr.response = function(value) {
            response = value;
            return xhr;
        }
        ;
        ["get", "post"].forEach(function(method) {
            xhr[method] = function() {
                return xhr.send.apply(xhr, [method].concat(d3_array(arguments)));
            }
            ;
        });
        xhr.send = function(method, data, callback) {
            if (arguments.length === 2 && typeof data === "function")
                callback = data,
                data = null;
            request.open(method, url, true);
            if (mimeType != null && !("accept"in headers))
                headers["accept"] = mimeType + ",*/*";
            if (request.setRequestHeader)
                for (var name in headers)
                    request.setRequestHeader(name, headers[name]);
            if (mimeType != null && request.overrideMimeType)
                request.overrideMimeType(mimeType);
            if (responseType != null)
                request.responseType = responseType;
            if (callback != null)
                xhr.on("error", callback).on("load", function(request) {
                    callback(null, request);
                });
            dispatch.beforesend.call(xhr, request);
            request.send(data == null ? null : data);
            return xhr;
        }
        ;
        xhr.abort = function() {
            request.abort();
            return xhr;
        }
        ;
        d3.rebind(xhr, dispatch, "on");
        return callback == null ? xhr : xhr.get(d3_xhr_fixCallback(callback));
    }
    function d3_xhr_fixCallback(callback) {
        return callback.length === 1 ? function(error, request) {
            callback(error == null ? request : null);
        }
        : callback;
    }
    d3.dsv = function(delimiter, mimeType) {
        var reFormat = new RegExp('["' + delimiter + "\n]")
          , delimiterCode = delimiter.charCodeAt(0);
        function dsv(url, row, callback) {
            if (arguments.length < 3)
                callback = row,
                row = null;
            var xhr = d3_xhr(url, mimeType, row == null ? response : typedResponse(row), callback);
            xhr.row = function(_) {
                return arguments.length ? xhr.response((row = _) == null ? response : typedResponse(_)) : row;
            }
            ;
            return xhr;
        }
        function response(request) {
            return dsv.parse(request.responseText);
        }
        function typedResponse(f) {
            return function(request) {
                return dsv.parse(request.responseText, f);
            }
            ;
        }
        dsv.parse = function(text, f) {
            var o;
            return dsv.parseRows(text, function(row, i) {
                if (o)
                    return o(row, i - 1);
                var a = new Function("d","return {" + row.map(function(name, i) {
                    return JSON.stringify(name) + ": d[" + i + "]";
                }).join(",") + "}");
                o = f ? function(row, i) {
                    return f(a(row), i);
                }
                : a;
            });
        }
        ;
        dsv.parseRows = function(text, f) {
            var EOL = {}, EOF = {}, rows = [], N = text.length, I = 0, n = 0, t, eol;
            function token() {
                if (I >= N)
                    return EOF;
                if (eol)
                    return eol = false,
                    EOL;
                var j = I;
                if (text.charCodeAt(j) === 34) {
                    var i = j;
                    while (i++ < N) {
                        if (text.charCodeAt(i) === 34) {
                            if (text.charCodeAt(i + 1) !== 34)
                                break;
                            ++i;
                        }
                    }
                    I = i + 2;
                    var c = text.charCodeAt(i + 1);
                    if (c === 13) {
                        eol = true;
                        if (text.charCodeAt(i + 2) === 10)
                            ++I;
                    } else if (c === 10) {
                        eol = true;
                    }
                    return text.substring(j + 1, i).replace(/""/g, '"');
                }
                while (I < N) {
                    var c = text.charCodeAt(I++)
                      , k = 1;
                    if (c === 10)
                        eol = true;
                    else if (c === 13) {
                        eol = true;
                        if (text.charCodeAt(I) === 10)
                            ++I,
                            ++k;
                    } else if (c !== delimiterCode)
                        continue;
                    return text.substring(j, I - k);
                }
                return text.substring(j);
            }
            while ((t = token()) !== EOF) {
                var a = [];
                while (t !== EOL && t !== EOF) {
                    a.push(t);
                    t = token();
                }
                if (f && !(a = f(a, n++)))
                    continue;
                rows.push(a);
            }
            return rows;
        }
        ;
        dsv.format = function(rows) {
            if (Array.isArray(rows[0]))
                return dsv.formatRows(rows);
            var fieldSet = new d3_Set()
              , fields = [];
            rows.forEach(function(row) {
                for (var field in row) {
                    if (!fieldSet.has(field)) {
                        fields.push(fieldSet.add(field));
                    }
                }
            });
            return [fields.map(formatValue).join(delimiter)].concat(rows.map(function(row) {
                return fields.map(function(field) {
                    return formatValue(row[field]);
                }).join(delimiter);
            })).join("\n");
        }
        ;
        dsv.formatRows = function(rows) {
            return rows.map(formatRow).join("\n");
        }
        ;
        function formatRow(row) {
            return row.map(formatValue).join(delimiter);
        }
        function formatValue(text) {
            return reFormat.test(text) ? '"' + text.replace(/\"/g, '""') + '"' : text;
        }
        return dsv;
    }
    ;
    d3.csv = d3.dsv(",", "text/csv");
    d3.tsv = d3.dsv("	", "text/tab-separated-values");
    d3.touch = function(container, touches, identifier) {
        if (arguments.length < 3)
            identifier = touches,
            touches = d3_eventSource().changedTouches;
        if (touches)
            for (var i = 0, n = touches.length, touch; i < n; ++i) {
                if ((touch = touches[i]).identifier === identifier) {
                    return d3_mousePoint(container, touch);
                }
            }
    }
    ;
    var d3_timer_queueHead, d3_timer_queueTail, d3_timer_interval, d3_timer_timeout, d3_timer_active, d3_timer_frame = d3_window[d3_vendorSymbol(d3_window, "requestAnimationFrame")] || function(callback) {
        setTimeout(callback, 17);
    }
    ;
    d3.timer = function(callback, delay, then) {
        var n = arguments.length;
        if (n < 2)
            delay = 0;
        if (n < 3)
            then = Date.now();
        var time = then + delay
          , timer = {
            c: callback,
            t: time,
            f: false,
            n: null
        };
        if (d3_timer_queueTail)
            d3_timer_queueTail.n = timer;
        else
            d3_timer_queueHead = timer;
        d3_timer_queueTail = timer;
        if (!d3_timer_interval) {
            d3_timer_timeout = clearTimeout(d3_timer_timeout);
            d3_timer_interval = 1;
            d3_timer_frame(d3_timer_step);
        }
    }
    ;
    function d3_timer_step() {
        var now = d3_timer_mark()
          , delay = d3_timer_sweep() - now;
        if (delay > 24) {
            if (isFinite(delay)) {
                clearTimeout(d3_timer_timeout);
                d3_timer_timeout = setTimeout(d3_timer_step, delay);
            }
            d3_timer_interval = 0;
        } else {
            d3_timer_interval = 1;
            d3_timer_frame(d3_timer_step);
        }
    }
    d3.timer.flush = function() {
        d3_timer_mark();
        d3_timer_sweep();
    }
    ;
    function d3_timer_mark() {
        var now = Date.now();
        d3_timer_active = d3_timer_queueHead;
        while (d3_timer_active) {
            if (now >= d3_timer_active.t)
                d3_timer_active.f = d3_timer_active.c(now - d3_timer_active.t);
            d3_timer_active = d3_timer_active.n;
        }
        return now;
    }
    function d3_timer_sweep() {
        var t0, t1 = d3_timer_queueHead, time = Infinity;
        while (t1) {
            if (t1.f) {
                t1 = t0 ? t0.n = t1.n : d3_timer_queueHead = t1.n;
            } else {
                if (t1.t < time)
                    time = t1.t;
                t1 = (t0 = t1).n;
            }
        }
        d3_timer_queueTail = t0;
        return time;
    }
    function d3_format_precision(x, p) {
        return p - (x ? Math.ceil(Math.log(x) / Math.LN10) : 1);
    }
    d3.round = function(x, n) {
        return n ? Math.round(x * (n = Math.pow(10, n))) / n : Math.round(x);
    }
    ;
    var d3_formatPrefixes = ["y", "z", "a", "f", "p", "n", "µ", "m", "", "k", "M", "G", "T", "P", "E", "Z", "Y"].map(d3_formatPrefix);
    d3.formatPrefix = function(value, precision) {
        var i = 0;
        if (value) {
            if (value < 0)
                value *= -1;
            if (precision)
                value = d3.round(value, d3_format_precision(value, precision));
            i = 1 + Math.floor(1e-12 + Math.log(value) / Math.LN10);
            i = Math.max(-24, Math.min(24, Math.floor((i - 1) / 3) * 3));
        }
        return d3_formatPrefixes[8 + i / 3];
    }
    ;
    function d3_formatPrefix(d, i) {
        var k = Math.pow(10, abs(8 - i) * 3);
        return {
            scale: i > 8 ? function(d) {
                return d / k;
            }
            : function(d) {
                return d * k;
            }
            ,
            symbol: d
        };
    }
    function d3_locale_numberFormat(locale) {
        var locale_decimal = locale.decimal
          , locale_thousands = locale.thousands
          , locale_grouping = locale.grouping
          , locale_currency = locale.currency
          , formatGroup = locale_grouping ? function(value) {
            var i = value.length
              , t = []
              , j = 0
              , g = locale_grouping[0];
            while (i > 0 && g > 0) {
                t.push(value.substring(i -= g, i + g));
                g = locale_grouping[j = (j + 1) % locale_grouping.length];
            }
            return t.reverse().join(locale_thousands);
        }
        : d3_identity;
        return function(specifier) {
            var match = d3_format_re.exec(specifier)
              , fill = match[1] || " "
              , align = match[2] || ">"
              , sign = match[3] || ""
              , symbol = match[4] || ""
              , zfill = match[5]
              , width = +match[6]
              , comma = match[7]
              , precision = match[8]
              , type = match[9]
              , scale = 1
              , prefix = ""
              , suffix = ""
              , integer = false;
            if (precision)
                precision = +precision.substring(1);
            if (zfill || fill === "0" && align === "=") {
                zfill = fill = "0";
                align = "=";
                if (comma)
                    width -= Math.floor((width - 1) / 4);
            }
            switch (type) {
            case "n":
                comma = true;
                type = "g";
                break;

            case "%":
                scale = 100;
                suffix = "%";
                type = "f";
                break;

            case "p":
                scale = 100;
                suffix = "%";
                type = "r";
                break;

            case "b":
            case "o":
            case "x":
            case "X":
                if (symbol === "#")
                    prefix = "0" + type.toLowerCase();

            case "c":
            case "d":
                integer = true;
                precision = 0;
                break;

            case "s":
                scale = -1;
                type = "r";
                break;
            }
            if (symbol === "$")
                prefix = locale_currency[0],
                suffix = locale_currency[1];
            if (type == "r" && !precision)
                type = "g";
            if (precision != null) {
                if (type == "g")
                    precision = Math.max(1, Math.min(21, precision));
                else if (type == "e" || type == "f")
                    precision = Math.max(0, Math.min(20, precision));
            }
            type = d3_format_types.get(type) || d3_format_typeDefault;
            var zcomma = zfill && comma;
            return function(value) {
                var fullSuffix = suffix;
                if (integer && value % 1)
                    return "";
                var negative = value < 0 || value === 0 && 1 / value < 0 ? (value = -value,
                "-") : sign;
                if (scale < 0) {
                    var unit = d3.formatPrefix(value, precision);
                    value = unit.scale(value);
                    fullSuffix = unit.symbol + suffix;
                } else {
                    value *= scale;
                }
                value = type(value, precision);
                var i = value.lastIndexOf(".")
                  , before = i < 0 ? value : value.substring(0, i)
                  , after = i < 0 ? "" : locale_decimal + value.substring(i + 1);
                if (!zfill && comma)
                    before = formatGroup(before);
                var length = prefix.length + before.length + after.length + (zcomma ? 0 : negative.length)
                  , padding = length < width ? new Array(length = width - length + 1).join(fill) : "";
                if (zcomma)
                    before = formatGroup(padding + before);
                negative += prefix;
                value = before + after;
                return (align === "<" ? negative + value + padding : align === ">" ? padding + negative + value : align === "^" ? padding.substring(0, length >>= 1) + negative + value + padding.substring(length) : negative + (zcomma ? value : padding + value)) + fullSuffix;
            }
            ;
        }
        ;
    }
    var d3_format_re = /(?:([^{])?([<>=^]))?([+\- ])?([$#])?(0)?(\d+)?(,)?(\.-?\d+)?([a-z%])?/i;
    var d3_format_types = d3.map({
        b: function(x) {
            return x.toString(2);
        },
        c: function(x) {
            return String.fromCharCode(x);
        },
        o: function(x) {
            return x.toString(8);
        },
        x: function(x) {
            return x.toString(16);
        },
        X: function(x) {
            return x.toString(16).toUpperCase();
        },
        g: function(x, p) {
            return x.toPrecision(p);
        },
        e: function(x, p) {
            return x.toExponential(p);
        },
        f: function(x, p) {
            return x.toFixed(p);
        },
        r: function(x, p) {
            return (x = d3.round(x, d3_format_precision(x, p))).toFixed(Math.max(0, Math.min(20, d3_format_precision(x * (1 + 1e-15), p))));
        }
    });
    function d3_format_typeDefault(x) {
        return x + "";
    }
    var d3_time = d3.time = {}
      , d3_date = Date;
    function d3_date_utc() {
        this._ = new Date(arguments.length > 1 ? Date.UTC.apply(this, arguments) : arguments[0]);
    }
    d3_date_utc.prototype = {
        getDate: function() {
            return this._.getUTCDate();
        },
        getDay: function() {
            return this._.getUTCDay();
        },
        getFullYear: function() {
            return this._.getUTCFullYear();
        },
        getHours: function() {
            return this._.getUTCHours();
        },
        getMilliseconds: function() {
            return this._.getUTCMilliseconds();
        },
        getMinutes: function() {
            return this._.getUTCMinutes();
        },
        getMonth: function() {
            return this._.getUTCMonth();
        },
        getSeconds: function() {
            return this._.getUTCSeconds();
        },
        getTime: function() {
            return this._.getTime();
        },
        getTimezoneOffset: function() {
            return 0;
        },
        valueOf: function() {
            return this._.valueOf();
        },
        setDate: function() {
            d3_time_prototype.setUTCDate.apply(this._, arguments);
        },
        setDay: function() {
            d3_time_prototype.setUTCDay.apply(this._, arguments);
        },
        setFullYear: function() {
            d3_time_prototype.setUTCFullYear.apply(this._, arguments);
        },
        setHours: function() {
            d3_time_prototype.setUTCHours.apply(this._, arguments);
        },
        setMilliseconds: function() {
            d3_time_prototype.setUTCMilliseconds.apply(this._, arguments);
        },
        setMinutes: function() {
            d3_time_prototype.setUTCMinutes.apply(this._, arguments);
        },
        setMonth: function() {
            d3_time_prototype.setUTCMonth.apply(this._, arguments);
        },
        setSeconds: function() {
            d3_time_prototype.setUTCSeconds.apply(this._, arguments);
        },
        setTime: function() {
            d3_time_prototype.setTime.apply(this._, arguments);
        }
    };
    var d3_time_prototype = Date.prototype;
    function d3_time_interval(local, step, number) {
        function round(date) {
            var d0 = local(date)
              , d1 = offset(d0, 1);
            return date - d0 < d1 - date ? d0 : d1;
        }
        function ceil(date) {
            step(date = local(new d3_date(date - 1)), 1);
            return date;
        }
        function offset(date, k) {
            step(date = new d3_date(+date), k);
            return date;
        }
        function range(t0, t1, dt) {
            var time = ceil(t0)
              , times = [];
            if (dt > 1) {
                while (time < t1) {
                    if (!(number(time) % dt))
                        times.push(new Date(+time));
                    step(time, 1);
                }
            } else {
                while (time < t1)
                    times.push(new Date(+time)),
                    step(time, 1);
            }
            return times;
        }
        function range_utc(t0, t1, dt) {
            try {
                d3_date = d3_date_utc;
                var utc = new d3_date_utc();
                utc._ = t0;
                return range(utc, t1, dt);
            } finally {
                d3_date = Date;
            }
        }
        local.floor = local;
        local.round = round;
        local.ceil = ceil;
        local.offset = offset;
        local.range = range;
        var utc = local.utc = d3_time_interval_utc(local);
        utc.floor = utc;
        utc.round = d3_time_interval_utc(round);
        utc.ceil = d3_time_interval_utc(ceil);
        utc.offset = d3_time_interval_utc(offset);
        utc.range = range_utc;
        return local;
    }
    function d3_time_interval_utc(method) {
        return function(date, k) {
            try {
                d3_date = d3_date_utc;
                var utc = new d3_date_utc();
                utc._ = date;
                return method(utc, k)._;
            } finally {
                d3_date = Date;
            }
        }
        ;
    }
    d3_time.year = d3_time_interval(function(date) {
        date = d3_time.day(date);
        date.setMonth(0, 1);
        return date;
    }, function(date, offset) {
        date.setFullYear(date.getFullYear() + offset);
    }, function(date) {
        return date.getFullYear();
    });
    d3_time.years = d3_time.year.range;
    d3_time.years.utc = d3_time.year.utc.range;
    d3_time.day = d3_time_interval(function(date) {
        var day = new d3_date(2e3,0);
        day.setFullYear(date.getFullYear(), date.getMonth(), date.getDate());
        return day;
    }, function(date, offset) {
        date.setDate(date.getDate() + offset);
    }, function(date) {
        return date.getDate() - 1;
    });
    d3_time.days = d3_time.day.range;
    d3_time.days.utc = d3_time.day.utc.range;
    d3_time.dayOfYear = function(date) {
        var year = d3_time.year(date);
        return Math.floor((date - year - (date.getTimezoneOffset() - year.getTimezoneOffset()) * 6e4) / 864e5);
    }
    ;
    ["sunday", "monday", "tuesday", "wednesday", "thursday", "friday", "saturday"].forEach(function(day, i) {
        i = 7 - i;
        var interval = d3_time[day] = d3_time_interval(function(date) {
            (date = d3_time.day(date)).setDate(date.getDate() - (date.getDay() + i) % 7);
            return date;
        }, function(date, offset) {
            date.setDate(date.getDate() + Math.floor(offset) * 7);
        }, function(date) {
            var day = d3_time.year(date).getDay();
            return Math.floor((d3_time.dayOfYear(date) + (day + i) % 7) / 7) - (day !== i);
        });
        d3_time[day + "s"] = interval.range;
        d3_time[day + "s"].utc = interval.utc.range;
        d3_time[day + "OfYear"] = function(date) {
            var day = d3_time.year(date).getDay();
            return Math.floor((d3_time.dayOfYear(date) + (day + i) % 7) / 7);
        }
        ;
    });
    d3_time.week = d3_time.sunday;
    d3_time.weeks = d3_time.sunday.range;
    d3_time.weeks.utc = d3_time.sunday.utc.range;
    d3_time.weekOfYear = d3_time.sundayOfYear;
    function d3_locale_timeFormat(locale) {
        var locale_dateTime = locale.dateTime
          , locale_date = locale.date
          , locale_time = locale.time
          , locale_periods = locale.periods
          , locale_days = locale.days
          , locale_shortDays = locale.shortDays
          , locale_months = locale.months
          , locale_shortMonths = locale.shortMonths;
        function d3_time_format(template) {
            var n = template.length;
            function format(date) {
                var string = [], i = -1, j = 0, c, p, f;
                while (++i < n) {
                    if (template.charCodeAt(i) === 37) {
                        string.push(template.substring(j, i));
                        if ((p = d3_time_formatPads[c = template.charAt(++i)]) != null)
                            c = template.charAt(++i);
                        if (f = d3_time_formats[c])
                            c = f(date, p == null ? c === "e" ? " " : "0" : p);
                        string.push(c);
                        j = i + 1;
                    }
                }
                string.push(template.substring(j, i));
                return string.join("");
            }
            format.parse = function(string) {
                var d = {
                    y: 1900,
                    m: 0,
                    d: 1,
                    H: 0,
                    M: 0,
                    S: 0,
                    L: 0,
                    Z: null
                }
                  , i = d3_time_parse(d, template, string, 0);
                if (i != string.length)
                    return null;
                if ("p"in d)
                    d.H = d.H % 12 + d.p * 12;
                var localZ = d.Z != null && d3_date !== d3_date_utc
                  , date = new (localZ ? d3_date_utc : d3_date)();
                if ("j"in d)
                    date.setFullYear(d.y, 0, d.j);
                else if ("w"in d && ("W"in d || "U"in d)) {
                    date.setFullYear(d.y, 0, 1);
                    date.setFullYear(d.y, 0, "W"in d ? (d.w + 6) % 7 + d.W * 7 - (date.getDay() + 5) % 7 : d.w + d.U * 7 - (date.getDay() + 6) % 7);
                } else
                    date.setFullYear(d.y, d.m, d.d);
                date.setHours(d.H + Math.floor(d.Z / 100), d.M + d.Z % 100, d.S, d.L);
                return localZ ? date._ : date;
            }
            ;
            format.toString = function() {
                return template;
            }
            ;
            return format;
        }
        function d3_time_parse(date, template, string, j) {
            var c, p, t, i = 0, n = template.length, m = string.length;
            while (i < n) {
                if (j >= m)
                    return -1;
                c = template.charCodeAt(i++);
                if (c === 37) {
                    t = template.charAt(i++);
                    p = d3_time_parsers[t in d3_time_formatPads ? template.charAt(i++) : t];
                    if (!p || (j = p(date, string, j)) < 0)
                        return -1;
                } else if (c != string.charCodeAt(j++)) {
                    return -1;
                }
            }
            return j;
        }
        d3_time_format.utc = function(template) {
            var local = d3_time_format(template);
            function format(date) {
                try {
                    d3_date = d3_date_utc;
                    var utc = new d3_date();
                    utc._ = date;
                    return local(utc);
                } finally {
                    d3_date = Date;
                }
            }
            format.parse = function(string) {
                try {
                    d3_date = d3_date_utc;
                    var date = local.parse(string);
                    return date && date._;
                } finally {
                    d3_date = Date;
                }
            }
            ;
            format.toString = local.toString;
            return format;
        }
        ;
        d3_time_format.multi = d3_time_format.utc.multi = d3_time_formatMulti;
        var d3_time_periodLookup = d3.map()
          , d3_time_dayRe = d3_time_formatRe(locale_days)
          , d3_time_dayLookup = d3_time_formatLookup(locale_days)
          , d3_time_dayAbbrevRe = d3_time_formatRe(locale_shortDays)
          , d3_time_dayAbbrevLookup = d3_time_formatLookup(locale_shortDays)
          , d3_time_monthRe = d3_time_formatRe(locale_months)
          , d3_time_monthLookup = d3_time_formatLookup(locale_months)
          , d3_time_monthAbbrevRe = d3_time_formatRe(locale_shortMonths)
          , d3_time_monthAbbrevLookup = d3_time_formatLookup(locale_shortMonths);
        locale_periods.forEach(function(p, i) {
            d3_time_periodLookup.set(p.toLowerCase(), i);
        });
        var d3_time_formats = {
            a: function(d) {
                return locale_shortDays[d.getDay()];
            },
            A: function(d) {
                return locale_days[d.getDay()];
            },
            b: function(d) {
                return locale_shortMonths[d.getMonth()];
            },
            B: function(d) {
                return locale_months[d.getMonth()];
            },
            c: d3_time_format(locale_dateTime),
            d: function(d, p) {
                return d3_time_formatPad(d.getDate(), p, 2);
            },
            e: function(d, p) {
                return d3_time_formatPad(d.getDate(), p, 2);
            },
            H: function(d, p) {
                return d3_time_formatPad(d.getHours(), p, 2);
            },
            I: function(d, p) {
                return d3_time_formatPad(d.getHours() % 12 || 12, p, 2);
            },
            j: function(d, p) {
                return d3_time_formatPad(1 + d3_time.dayOfYear(d), p, 3);
            },
            L: function(d, p) {
                return d3_time_formatPad(d.getMilliseconds(), p, 3);
            },
            m: function(d, p) {
                return d3_time_formatPad(d.getMonth() + 1, p, 2);
            },
            M: function(d, p) {
                return d3_time_formatPad(d.getMinutes(), p, 2);
            },
            p: function(d) {
                return locale_periods[+(d.getHours() >= 12)];
            },
            S: function(d, p) {
                return d3_time_formatPad(d.getSeconds(), p, 2);
            },
            U: function(d, p) {
                return d3_time_formatPad(d3_time.sundayOfYear(d), p, 2);
            },
            w: function(d) {
                return d.getDay();
            },
            W: function(d, p) {
                return d3_time_formatPad(d3_time.mondayOfYear(d), p, 2);
            },
            x: d3_time_format(locale_date),
            X: d3_time_format(locale_time),
            y: function(d, p) {
                return d3_time_formatPad(d.getFullYear() % 100, p, 2);
            },
            Y: function(d, p) {
                return d3_time_formatPad(d.getFullYear() % 1e4, p, 4);
            },
            Z: d3_time_zone,
            "%": function() {
                return "%";
            }
        };
        var d3_time_parsers = {
            a: d3_time_parseWeekdayAbbrev,
            A: d3_time_parseWeekday,
            b: d3_time_parseMonthAbbrev,
            B: d3_time_parseMonth,
            c: d3_time_parseLocaleFull,
            d: d3_time_parseDay,
            e: d3_time_parseDay,
            H: d3_time_parseHour24,
            I: d3_time_parseHour24,
            j: d3_time_parseDayOfYear,
            L: d3_time_parseMilliseconds,
            m: d3_time_parseMonthNumber,
            M: d3_time_parseMinutes,
            p: d3_time_parseAmPm,
            S: d3_time_parseSeconds,
            U: d3_time_parseWeekNumberSunday,
            w: d3_time_parseWeekdayNumber,
            W: d3_time_parseWeekNumberMonday,
            x: d3_time_parseLocaleDate,
            X: d3_time_parseLocaleTime,
            y: d3_time_parseYear,
            Y: d3_time_parseFullYear,
            Z: d3_time_parseZone,
            "%": d3_time_parseLiteralPercent
        };
        function d3_time_parseWeekdayAbbrev(date, string, i) {
            d3_time_dayAbbrevRe.lastIndex = 0;
            var n = d3_time_dayAbbrevRe.exec(string.substring(i));
            return n ? (date.w = d3_time_dayAbbrevLookup.get(n[0].toLowerCase()),
            i + n[0].length) : -1;
        }
        function d3_time_parseWeekday(date, string, i) {
            d3_time_dayRe.lastIndex = 0;
            var n = d3_time_dayRe.exec(string.substring(i));
            return n ? (date.w = d3_time_dayLookup.get(n[0].toLowerCase()),
            i + n[0].length) : -1;
        }
        function d3_time_parseMonthAbbrev(date, string, i) {
            d3_time_monthAbbrevRe.lastIndex = 0;
            var n = d3_time_monthAbbrevRe.exec(string.substring(i));
            return n ? (date.m = d3_time_monthAbbrevLookup.get(n[0].toLowerCase()),
            i + n[0].length) : -1;
        }
        function d3_time_parseMonth(date, string, i) {
            d3_time_monthRe.lastIndex = 0;
            var n = d3_time_monthRe.exec(string.substring(i));
            return n ? (date.m = d3_time_monthLookup.get(n[0].toLowerCase()),
            i + n[0].length) : -1;
        }
        function d3_time_parseLocaleFull(date, string, i) {
            return d3_time_parse(date, d3_time_formats.c.toString(), string, i);
        }
        function d3_time_parseLocaleDate(date, string, i) {
            return d3_time_parse(date, d3_time_formats.x.toString(), string, i);
        }
        function d3_time_parseLocaleTime(date, string, i) {
            return d3_time_parse(date, d3_time_formats.X.toString(), string, i);
        }
        function d3_time_parseAmPm(date, string, i) {
            var n = d3_time_periodLookup.get(string.substring(i, i += 2).toLowerCase());
            return n == null ? -1 : (date.p = n,
            i);
        }
        return d3_time_format;
    }
    var d3_time_formatPads = {
        "-": "",
        _: " ",
        "0": "0"
    }
      , d3_time_numberRe = /^\s*\d+/
      , d3_time_percentRe = /^%/;
    function d3_time_formatPad(value, fill, width) {
        var sign = value < 0 ? "-" : ""
          , string = (sign ? -value : value) + ""
          , length = string.length;
        return sign + (length < width ? new Array(width - length + 1).join(fill) + string : string);
    }
    function d3_time_formatRe(names) {
        return new RegExp("^(?:" + names.map(d3.requote).join("|") + ")","i");
    }
    function d3_time_formatLookup(names) {
        var map = new d3_Map()
          , i = -1
          , n = names.length;
        while (++i < n)
            map.set(names[i].toLowerCase(), i);
        return map;
    }
    function d3_time_parseWeekdayNumber(date, string, i) {
        d3_time_numberRe.lastIndex = 0;
        var n = d3_time_numberRe.exec(string.substring(i, i + 1));
        return n ? (date.w = +n[0],
        i + n[0].length) : -1;
    }
    function d3_time_parseWeekNumberSunday(date, string, i) {
        d3_time_numberRe.lastIndex = 0;
        var n = d3_time_numberRe.exec(string.substring(i));
        return n ? (date.U = +n[0],
        i + n[0].length) : -1;
    }
    function d3_time_parseWeekNumberMonday(date, string, i) {
        d3_time_numberRe.lastIndex = 0;
        var n = d3_time_numberRe.exec(string.substring(i));
        return n ? (date.W = +n[0],
        i + n[0].length) : -1;
    }
    function d3_time_parseFullYear(date, string, i) {
        d3_time_numberRe.lastIndex = 0;
        var n = d3_time_numberRe.exec(string.substring(i, i + 4));
        return n ? (date.y = +n[0],
        i + n[0].length) : -1;
    }
    function d3_time_parseYear(date, string, i) {
        d3_time_numberRe.lastIndex = 0;
        var n = d3_time_numberRe.exec(string.substring(i, i + 2));
        return n ? (date.y = d3_time_expandYear(+n[0]),
        i + n[0].length) : -1;
    }
    function d3_time_parseZone(date, string, i) {
        return /^[+-]\d{4}$/.test(string = string.substring(i, i + 5)) ? (date.Z = -string,
        i + 5) : -1;
    }
    function d3_time_expandYear(d) {
        return d + (d > 68 ? 1900 : 2e3);
    }
    function d3_time_parseMonthNumber(date, string, i) {
        d3_time_numberRe.lastIndex = 0;
        var n = d3_time_numberRe.exec(string.substring(i, i + 2));
        return n ? (date.m = n[0] - 1,
        i + n[0].length) : -1;
    }
    function d3_time_parseDay(date, string, i) {
        d3_time_numberRe.lastIndex = 0;
        var n = d3_time_numberRe.exec(string.substring(i, i + 2));
        return n ? (date.d = +n[0],
        i + n[0].length) : -1;
    }
    function d3_time_parseDayOfYear(date, string, i) {
        d3_time_numberRe.lastIndex = 0;
        var n = d3_time_numberRe.exec(string.substring(i, i + 3));
        return n ? (date.j = +n[0],
        i + n[0].length) : -1;
    }
    function d3_time_parseHour24(date, string, i) {
        d3_time_numberRe.lastIndex = 0;
        var n = d3_time_numberRe.exec(string.substring(i, i + 2));
        return n ? (date.H = +n[0],
        i + n[0].length) : -1;
    }
    function d3_time_parseMinutes(date, string, i) {
        d3_time_numberRe.lastIndex = 0;
        var n = d3_time_numberRe.exec(string.substring(i, i + 2));
        return n ? (date.M = +n[0],
        i + n[0].length) : -1;
    }
    function d3_time_parseSeconds(date, string, i) {
        d3_time_numberRe.lastIndex = 0;
        var n = d3_time_numberRe.exec(string.substring(i, i + 2));
        return n ? (date.S = +n[0],
        i + n[0].length) : -1;
    }
    function d3_time_parseMilliseconds(date, string, i) {
        d3_time_numberRe.lastIndex = 0;
        var n = d3_time_numberRe.exec(string.substring(i, i + 3));
        return n ? (date.L = +n[0],
        i + n[0].length) : -1;
    }
    function d3_time_zone(d) {
        var z = d.getTimezoneOffset()
          , zs = z > 0 ? "-" : "+"
          , zh = ~~(abs(z) / 60)
          , zm = abs(z) % 60;
        return zs + d3_time_formatPad(zh, "0", 2) + d3_time_formatPad(zm, "0", 2);
    }
    function d3_time_parseLiteralPercent(date, string, i) {
        d3_time_percentRe.lastIndex = 0;
        var n = d3_time_percentRe.exec(string.substring(i, i + 1));
        return n ? i + n[0].length : -1;
    }
    function d3_time_formatMulti(formats) {
        var n = formats.length
          , i = -1;
        while (++i < n)
            formats[i][0] = this(formats[i][0]);
        return function(date) {
            var i = 0
              , f = formats[i];
            while (!f[1](date))
                f = formats[++i];
            return f[0](date);
        }
        ;
    }
    d3.locale = function(locale) {
        return {
            numberFormat: d3_locale_numberFormat(locale),
            timeFormat: d3_locale_timeFormat(locale)
        };
    }
    ;
    var d3_locale_enUS = d3.locale({
        decimal: ".",
        thousands: ",",
        grouping: [3],
        currency: ["$", ""],
        dateTime: "%a %b %e %X %Y",
        date: "%m/%d/%Y",
        time: "%H:%M:%S",
        periods: ["AM", "PM"],
        days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
        shortDays: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
        months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
        shortMonths: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]
    });
    d3.format = d3_locale_enUS.numberFormat;
    d3.geo = {};
    function d3_adder() {}
    d3_adder.prototype = {
        s: 0,
        t: 0,
        add: function(y) {
            d3_adderSum(y, this.t, d3_adderTemp);
            d3_adderSum(d3_adderTemp.s, this.s, this);
            if (this.s)
                this.t += d3_adderTemp.t;
            else
                this.s = d3_adderTemp.t;
        },
        reset: function() {
            this.s = this.t = 0;
        },
        valueOf: function() {
            return this.s;
        }
    };
    var d3_adderTemp = new d3_adder();
    function d3_adderSum(a, b, o) {
        var x = o.s = a + b
          , bv = x - a
          , av = x - bv;
        o.t = a - av + (b - bv);
    }
    d3.geo.stream = function(object, listener) {
        if (object && d3_geo_streamObjectType.hasOwnProperty(object.type)) {
            d3_geo_streamObjectType[object.type](object, listener);
        } else {
            d3_geo_streamGeometry(object, listener);
        }
    }
    ;
    function d3_geo_streamGeometry(geometry, listener) {
        if (geometry && d3_geo_streamGeometryType.hasOwnProperty(geometry.type)) {
            d3_geo_streamGeometryType[geometry.type](geometry, listener);
        }
    }
    var d3_geo_streamObjectType = {
        Feature: function(feature, listener) {
            d3_geo_streamGeometry(feature.geometry, listener);
        },
        FeatureCollection: function(object, listener) {
            var features = object.features
              , i = -1
              , n = features.length;
            while (++i < n)
                d3_geo_streamGeometry(features[i].geometry, listener);
        }
    };
    var d3_geo_streamGeometryType = {
        Sphere: function(object, listener) {
            listener.sphere();
        },
        Point: function(object, listener) {
            object = object.coordinates;
            listener.point(object[0], object[1], object[2]);
        },
        MultiPoint: function(object, listener) {
            var coordinates = object.coordinates
              , i = -1
              , n = coordinates.length;
            while (++i < n)
                object = coordinates[i],
                listener.point(object[0], object[1], object[2]);
        },
        LineString: function(object, listener) {
            d3_geo_streamLine(object.coordinates, listener, 0);
        },
        MultiLineString: function(object, listener) {
            var coordinates = object.coordinates
              , i = -1
              , n = coordinates.length;
            while (++i < n)
                d3_geo_streamLine(coordinates[i], listener, 0);
        },
        Polygon: function(object, listener) {
            d3_geo_streamPolygon(object.coordinates, listener);
        },
        MultiPolygon: function(object, listener) {
            var coordinates = object.coordinates
              , i = -1
              , n = coordinates.length;
            while (++i < n)
                d3_geo_streamPolygon(coordinates[i], listener);
        },
        GeometryCollection: function(object, listener) {
            var geometries = object.geometries
              , i = -1
              , n = geometries.length;
            while (++i < n)
                d3_geo_streamGeometry(geometries[i], listener);
        }
    };
    function d3_geo_streamLine(coordinates, listener, closed) {
        var i = -1, n = coordinates.length - closed, coordinate;
        listener.lineStart();
        while (++i < n)
            coordinate = coordinates[i],
            listener.point(coordinate[0], coordinate[1], coordinate[2]);
        listener.lineEnd();
    }
    function d3_geo_streamPolygon(coordinates, listener) {
        var i = -1
          , n = coordinates.length;
        listener.polygonStart();
        while (++i < n)
            d3_geo_streamLine(coordinates[i], listener, 1);
        listener.polygonEnd();
    }
    d3.geo.area = function(object) {
        d3_geo_areaSum = 0;
        d3.geo.stream(object, d3_geo_area);
        return d3_geo_areaSum;
    }
    ;
    var d3_geo_areaSum, d3_geo_areaRingSum = new d3_adder();
    var d3_geo_area = {
        sphere: function() {
            d3_geo_areaSum += 4 * π;
        },
        point: d3_noop,
        lineStart: d3_noop,
        lineEnd: d3_noop,
        polygonStart: function() {
            d3_geo_areaRingSum.reset();
            d3_geo_area.lineStart = d3_geo_areaRingStart;
        },
        polygonEnd: function() {
            var area = 2 * d3_geo_areaRingSum;
            d3_geo_areaSum += area < 0 ? 4 * π + area : area;
            d3_geo_area.lineStart = d3_geo_area.lineEnd = d3_geo_area.point = d3_noop;
        }
    };
    function d3_geo_areaRingStart() {
        var λ00, φ00, λ0, cosφ0, sinφ0;
        d3_geo_area.point = function(λ, φ) {
            d3_geo_area.point = nextPoint;
            λ0 = (λ00 = λ) * d3_radians,
            cosφ0 = Math.cos(φ = (φ00 = φ) * d3_radians / 2 + π / 4),
            sinφ0 = Math.sin(φ);
        }
        ;
        function nextPoint(λ, φ) {
            λ *= d3_radians;
            φ = φ * d3_radians / 2 + π / 4;
            var dλ = λ - λ0
              , sdλ = dλ >= 0 ? 1 : -1
              , adλ = sdλ * dλ
              , cosφ = Math.cos(φ)
              , sinφ = Math.sin(φ)
              , k = sinφ0 * sinφ
              , u = cosφ0 * cosφ + k * Math.cos(adλ)
              , v = k * sdλ * Math.sin(adλ);
            d3_geo_areaRingSum.add(Math.atan2(v, u));
            λ0 = λ,
            cosφ0 = cosφ,
            sinφ0 = sinφ;
        }
        d3_geo_area.lineEnd = function() {
            nextPoint(λ00, φ00);
        }
        ;
    }
    function d3_geo_cartesian(spherical) {
        var λ = spherical[0]
          , φ = spherical[1]
          , cosφ = Math.cos(φ);
        return [cosφ * Math.cos(λ), cosφ * Math.sin(λ), Math.sin(φ)];
    }
    function d3_geo_cartesianDot(a, b) {
        return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
    }
    function d3_geo_cartesianCross(a, b) {
        return [a[1] * b[2] - a[2] * b[1], a[2] * b[0] - a[0] * b[2], a[0] * b[1] - a[1] * b[0]];
    }
    function d3_geo_cartesianAdd(a, b) {
        a[0] += b[0];
        a[1] += b[1];
        a[2] += b[2];
    }
    function d3_geo_cartesianScale(vector, k) {
        return [vector[0] * k, vector[1] * k, vector[2] * k];
    }
    function d3_geo_cartesianNormalize(d) {
        var l = Math.sqrt(d[0] * d[0] + d[1] * d[1] + d[2] * d[2]);
        d[0] /= l;
        d[1] /= l;
        d[2] /= l;
    }
    function d3_geo_spherical(cartesian) {
        return [Math.atan2(cartesian[1], cartesian[0]), d3_asin(cartesian[2])];
    }
    function d3_geo_sphericalEqual(a, b) {
        return abs(a[0] - b[0]) < ε && abs(a[1] - b[1]) < ε;
    }
    d3.geo.bounds = function() {
        var λ0, φ0, λ1, φ1, λ_, λ__, φ__, p0, dλSum, ranges, range;
        var bound = {
            point: point,
            lineStart: lineStart,
            lineEnd: lineEnd,
            polygonStart: function() {
                bound.point = ringPoint;
                bound.lineStart = ringStart;
                bound.lineEnd = ringEnd;
                dλSum = 0;
                d3_geo_area.polygonStart();
            },
            polygonEnd: function() {
                d3_geo_area.polygonEnd();
                bound.point = point;
                bound.lineStart = lineStart;
                bound.lineEnd = lineEnd;
                if (d3_geo_areaRingSum < 0)
                    λ0 = -(λ1 = 180),
                    φ0 = -(φ1 = 90);
                else if (dλSum > ε)
                    φ1 = 90;
                else if (dλSum < -ε)
                    φ0 = -90;
                range[0] = λ0,
                range[1] = λ1;
            }
        };
        function point(λ, φ) {
            ranges.push(range = [λ0 = λ, λ1 = λ]);
            if (φ < φ0)
                φ0 = φ;
            if (φ > φ1)
                φ1 = φ;
        }
        function linePoint(λ, φ) {
            var p = d3_geo_cartesian([λ * d3_radians, φ * d3_radians]);
            if (p0) {
                var normal = d3_geo_cartesianCross(p0, p)
                  , equatorial = [normal[1], -normal[0], 0]
                  , inflection = d3_geo_cartesianCross(equatorial, normal);
                d3_geo_cartesianNormalize(inflection);
                inflection = d3_geo_spherical(inflection);
                var dλ = λ - λ_
                  , s = dλ > 0 ? 1 : -1
                  , λi = inflection[0] * d3_degrees * s
                  , antimeridian = abs(dλ) > 180;
                if (antimeridian ^ (s * λ_ < λi && λi < s * λ)) {
                    var φi = inflection[1] * d3_degrees;
                    if (φi > φ1)
                        φ1 = φi;
                } else if (λi = (λi + 360) % 360 - 180,
                antimeridian ^ (s * λ_ < λi && λi < s * λ)) {
                    var φi = -inflection[1] * d3_degrees;
                    if (φi < φ0)
                        φ0 = φi;
                } else {
                    if (φ < φ0)
                        φ0 = φ;
                    if (φ > φ1)
                        φ1 = φ;
                }
                if (antimeridian) {
                    if (λ < λ_) {
                        if (angle(λ0, λ) > angle(λ0, λ1))
                            λ1 = λ;
                    } else {
                        if (angle(λ, λ1) > angle(λ0, λ1))
                            λ0 = λ;
                    }
                } else {
                    if (λ1 >= λ0) {
                        if (λ < λ0)
                            λ0 = λ;
                        if (λ > λ1)
                            λ1 = λ;
                    } else {
                        if (λ > λ_) {
                            if (angle(λ0, λ) > angle(λ0, λ1))
                                λ1 = λ;
                        } else {
                            if (angle(λ, λ1) > angle(λ0, λ1))
                                λ0 = λ;
                        }
                    }
                }
            } else {
                point(λ, φ);
            }
            p0 = p,
            λ_ = λ;
        }
        function lineStart() {
            bound.point = linePoint;
        }
        function lineEnd() {
            range[0] = λ0,
            range[1] = λ1;
            bound.point = point;
            p0 = null;
        }
        function ringPoint(λ, φ) {
            if (p0) {
                var dλ = λ - λ_;
                dλSum += abs(dλ) > 180 ? dλ + (dλ > 0 ? 360 : -360) : dλ;
            } else
                λ__ = λ,
                φ__ = φ;
            d3_geo_area.point(λ, φ);
            linePoint(λ, φ);
        }
        function ringStart() {
            d3_geo_area.lineStart();
        }
        function ringEnd() {
            ringPoint(λ__, φ__);
            d3_geo_area.lineEnd();
            if (abs(dλSum) > ε)
                λ0 = -(λ1 = 180);
            range[0] = λ0,
            range[1] = λ1;
            p0 = null;
        }
        function angle(λ0, λ1) {
            return (λ1 -= λ0) < 0 ? λ1 + 360 : λ1;
        }
        function compareRanges(a, b) {
            return a[0] - b[0];
        }
        function withinRange(x, range) {
            return range[0] <= range[1] ? range[0] <= x && x <= range[1] : x < range[0] || range[1] < x;
        }
        return function(feature) {
            φ1 = λ1 = -(λ0 = φ0 = Infinity);
            ranges = [];
            d3.geo.stream(feature, bound);
            var n = ranges.length;
            if (n) {
                ranges.sort(compareRanges);
                for (var i = 1, a = ranges[0], b, merged = [a]; i < n; ++i) {
                    b = ranges[i];
                    if (withinRange(b[0], a) || withinRange(b[1], a)) {
                        if (angle(a[0], b[1]) > angle(a[0], a[1]))
                            a[1] = b[1];
                        if (angle(b[0], a[1]) > angle(a[0], a[1]))
                            a[0] = b[0];
                    } else {
                        merged.push(a = b);
                    }
                }
                var best = -Infinity, dλ;
                for (var n = merged.length - 1, i = 0, a = merged[n], b; i <= n; a = b,
                ++i) {
                    b = merged[i];
                    if ((dλ = angle(a[1], b[0])) > best)
                        best = dλ,
                        λ0 = b[0],
                        λ1 = a[1];
                }
            }
            ranges = range = null;
            return λ0 === Infinity || φ0 === Infinity ? [[NaN, NaN], [NaN, NaN]] : [[λ0, φ0], [λ1, φ1]];
        }
        ;
    }();
    d3.geo.centroid = function(object) {
        d3_geo_centroidW0 = d3_geo_centroidW1 = d3_geo_centroidX0 = d3_geo_centroidY0 = d3_geo_centroidZ0 = d3_geo_centroidX1 = d3_geo_centroidY1 = d3_geo_centroidZ1 = d3_geo_centroidX2 = d3_geo_centroidY2 = d3_geo_centroidZ2 = 0;
        d3.geo.stream(object, d3_geo_centroid);
        var x = d3_geo_centroidX2
          , y = d3_geo_centroidY2
          , z = d3_geo_centroidZ2
          , m = x * x + y * y + z * z;
        if (m < ε2) {
            x = d3_geo_centroidX1,
            y = d3_geo_centroidY1,
            z = d3_geo_centroidZ1;
            if (d3_geo_centroidW1 < ε)
                x = d3_geo_centroidX0,
                y = d3_geo_centroidY0,
                z = d3_geo_centroidZ0;
            m = x * x + y * y + z * z;
            if (m < ε2)
                return [NaN, NaN];
        }
        return [Math.atan2(y, x) * d3_degrees, d3_asin(z / Math.sqrt(m)) * d3_degrees];
    }
    ;
    var d3_geo_centroidW0, d3_geo_centroidW1, d3_geo_centroidX0, d3_geo_centroidY0, d3_geo_centroidZ0, d3_geo_centroidX1, d3_geo_centroidY1, d3_geo_centroidZ1, d3_geo_centroidX2, d3_geo_centroidY2, d3_geo_centroidZ2;
    var d3_geo_centroid = {
        sphere: d3_noop,
        point: d3_geo_centroidPoint,
        lineStart: d3_geo_centroidLineStart,
        lineEnd: d3_geo_centroidLineEnd,
        polygonStart: function() {
            d3_geo_centroid.lineStart = d3_geo_centroidRingStart;
        },
        polygonEnd: function() {
            d3_geo_centroid.lineStart = d3_geo_centroidLineStart;
        }
    };
    function d3_geo_centroidPoint(λ, φ) {
        λ *= d3_radians;
        var cosφ = Math.cos(φ *= d3_radians);
        d3_geo_centroidPointXYZ(cosφ * Math.cos(λ), cosφ * Math.sin(λ), Math.sin(φ));
    }
    function d3_geo_centroidPointXYZ(x, y, z) {
        ++d3_geo_centroidW0;
        d3_geo_centroidX0 += (x - d3_geo_centroidX0) / d3_geo_centroidW0;
        d3_geo_centroidY0 += (y - d3_geo_centroidY0) / d3_geo_centroidW0;
        d3_geo_centroidZ0 += (z - d3_geo_centroidZ0) / d3_geo_centroidW0;
    }
    function d3_geo_centroidLineStart() {
        var x0, y0, z0;
        d3_geo_centroid.point = function(λ, φ) {
            λ *= d3_radians;
            var cosφ = Math.cos(φ *= d3_radians);
            x0 = cosφ * Math.cos(λ);
            y0 = cosφ * Math.sin(λ);
            z0 = Math.sin(φ);
            d3_geo_centroid.point = nextPoint;
            d3_geo_centroidPointXYZ(x0, y0, z0);
        }
        ;
        function nextPoint(λ, φ) {
            λ *= d3_radians;
            var cosφ = Math.cos(φ *= d3_radians)
              , x = cosφ * Math.cos(λ)
              , y = cosφ * Math.sin(λ)
              , z = Math.sin(φ)
              , w = Math.atan2(Math.sqrt((w = y0 * z - z0 * y) * w + (w = z0 * x - x0 * z) * w + (w = x0 * y - y0 * x) * w), x0 * x + y0 * y + z0 * z);
            d3_geo_centroidW1 += w;
            d3_geo_centroidX1 += w * (x0 + (x0 = x));
            d3_geo_centroidY1 += w * (y0 + (y0 = y));
            d3_geo_centroidZ1 += w * (z0 + (z0 = z));
            d3_geo_centroidPointXYZ(x0, y0, z0);
        }
    }
    function d3_geo_centroidLineEnd() {
        d3_geo_centroid.point = d3_geo_centroidPoint;
    }
    function d3_geo_centroidRingStart() {
        var λ00, φ00, x0, y0, z0;
        d3_geo_centroid.point = function(λ, φ) {
            λ00 = λ,
            φ00 = φ;
            d3_geo_centroid.point = nextPoint;
            λ *= d3_radians;
            var cosφ = Math.cos(φ *= d3_radians);
            x0 = cosφ * Math.cos(λ);
            y0 = cosφ * Math.sin(λ);
            z0 = Math.sin(φ);
            d3_geo_centroidPointXYZ(x0, y0, z0);
        }
        ;
        d3_geo_centroid.lineEnd = function() {
            nextPoint(λ00, φ00);
            d3_geo_centroid.lineEnd = d3_geo_centroidLineEnd;
            d3_geo_centroid.point = d3_geo_centroidPoint;
        }
        ;
        function nextPoint(λ, φ) {
            λ *= d3_radians;
            var cosφ = Math.cos(φ *= d3_radians)
              , x = cosφ * Math.cos(λ)
              , y = cosφ * Math.sin(λ)
              , z = Math.sin(φ)
              , cx = y0 * z - z0 * y
              , cy = z0 * x - x0 * z
              , cz = x0 * y - y0 * x
              , m = Math.sqrt(cx * cx + cy * cy + cz * cz)
              , u = x0 * x + y0 * y + z0 * z
              , v = m && -d3_acos(u) / m
              , w = Math.atan2(m, u);
            d3_geo_centroidX2 += v * cx;
            d3_geo_centroidY2 += v * cy;
            d3_geo_centroidZ2 += v * cz;
            d3_geo_centroidW1 += w;
            d3_geo_centroidX1 += w * (x0 + (x0 = x));
            d3_geo_centroidY1 += w * (y0 + (y0 = y));
            d3_geo_centroidZ1 += w * (z0 + (z0 = z));
            d3_geo_centroidPointXYZ(x0, y0, z0);
        }
    }
    function d3_true() {
        return true;
    }
    function d3_geo_clipPolygon(segments, compare, clipStartInside, interpolate, listener) {
        var subject = []
          , clip = [];
        segments.forEach(function(segment) {
            if ((n = segment.length - 1) <= 0)
                return;
            var n, p0 = segment[0], p1 = segment[n];
            if (d3_geo_sphericalEqual(p0, p1)) {
                listener.lineStart();
                for (var i = 0; i < n; ++i)
                    listener.point((p0 = segment[i])[0], p0[1]);
                listener.lineEnd();
                return;
            }
            var a = new d3_geo_clipPolygonIntersection(p0,segment,null,true)
              , b = new d3_geo_clipPolygonIntersection(p0,null,a,false);
            a.o = b;
            subject.push(a);
            clip.push(b);
            a = new d3_geo_clipPolygonIntersection(p1,segment,null,false);
            b = new d3_geo_clipPolygonIntersection(p1,null,a,true);
            a.o = b;
            subject.push(a);
            clip.push(b);
        });
        clip.sort(compare);
        d3_geo_clipPolygonLinkCircular(subject);
        d3_geo_clipPolygonLinkCircular(clip);
        if (!subject.length)
            return;
        for (var i = 0, entry = clipStartInside, n = clip.length; i < n; ++i) {
            clip[i].e = entry = !entry;
        }
        var start = subject[0], points, point;
        while (1) {
            var current = start
              , isSubject = true;
            while (current.v)
                if ((current = current.n) === start)
                    return;
            points = current.z;
            listener.lineStart();
            do {
                current.v = current.o.v = true;
                if (current.e) {
                    if (isSubject) {
                        for (var i = 0, n = points.length; i < n; ++i)
                            listener.point((point = points[i])[0], point[1]);
                    } else {
                        interpolate(current.x, current.n.x, 1, listener);
                    }
                    current = current.n;
                } else {
                    if (isSubject) {
                        points = current.p.z;
                        for (var i = points.length - 1; i >= 0; --i)
                            listener.point((point = points[i])[0], point[1]);
                    } else {
                        interpolate(current.x, current.p.x, -1, listener);
                    }
                    current = current.p;
                }
                current = current.o;
                points = current.z;
                isSubject = !isSubject;
            } while (!current.v);listener.lineEnd();
        }
    }
    function d3_geo_clipPolygonLinkCircular(array) {
        if (!(n = array.length))
            return;
        var n, i = 0, a = array[0], b;
        while (++i < n) {
            a.n = b = array[i];
            b.p = a;
            a = b;
        }
        a.n = b = array[0];
        b.p = a;
    }
    function d3_geo_clipPolygonIntersection(point, points, other, entry) {
        this.x = point;
        this.z = points;
        this.o = other;
        this.e = entry;
        this.v = false;
        this.n = this.p = null;
    }
    function d3_geo_clip(pointVisible, clipLine, interpolate, clipStart) {
        return function(rotate, listener) {
            var line = clipLine(listener)
              , rotatedClipStart = rotate.invert(clipStart[0], clipStart[1]);
            var clip = {
                point: point,
                lineStart: lineStart,
                lineEnd: lineEnd,
                polygonStart: function() {
                    clip.point = pointRing;
                    clip.lineStart = ringStart;
                    clip.lineEnd = ringEnd;
                    segments = [];
                    polygon = [];
                },
                polygonEnd: function() {
                    clip.point = point;
                    clip.lineStart = lineStart;
                    clip.lineEnd = lineEnd;
                    segments = d3.merge(segments);
                    var clipStartInside = d3_geo_pointInPolygon(rotatedClipStart, polygon);
                    if (segments.length) {
                        if (!polygonStarted)
                            listener.polygonStart(),
                            polygonStarted = true;
                        d3_geo_clipPolygon(segments, d3_geo_clipSort, clipStartInside, interpolate, listener);
                    } else if (clipStartInside) {
                        if (!polygonStarted)
                            listener.polygonStart(),
                            polygonStarted = true;
                        listener.lineStart();
                        interpolate(null, null, 1, listener);
                        listener.lineEnd();
                    }
                    if (polygonStarted)
                        listener.polygonEnd(),
                        polygonStarted = false;
                    segments = polygon = null;
                },
                sphere: function() {
                    listener.polygonStart();
                    listener.lineStart();
                    interpolate(null, null, 1, listener);
                    listener.lineEnd();
                    listener.polygonEnd();
                }
            };
            function point(λ, φ) {
                var point = rotate(λ, φ);
                if (pointVisible(λ = point[0], φ = point[1]))
                    listener.point(λ, φ);
            }
            function pointLine(λ, φ) {
                var point = rotate(λ, φ);
                line.point(point[0], point[1]);
            }
            function lineStart() {
                clip.point = pointLine;
                line.lineStart();
            }
            function lineEnd() {
                clip.point = point;
                line.lineEnd();
            }
            var segments;
            var buffer = d3_geo_clipBufferListener(), ringListener = clipLine(buffer), polygonStarted = false, polygon, ring;
            function pointRing(λ, φ) {
                ring.push([λ, φ]);
                var point = rotate(λ, φ);
                ringListener.point(point[0], point[1]);
            }
            function ringStart() {
                ringListener.lineStart();
                ring = [];
            }
            function ringEnd() {
                pointRing(ring[0][0], ring[0][1]);
                ringListener.lineEnd();
                var clean = ringListener.clean(), ringSegments = buffer.buffer(), segment, n = ringSegments.length;
                ring.pop();
                polygon.push(ring);
                ring = null;
                if (!n)
                    return;
                if (clean & 1) {
                    segment = ringSegments[0];
                    var n = segment.length - 1, i = -1, point;
                    if (n > 0) {
                        if (!polygonStarted)
                            listener.polygonStart(),
                            polygonStarted = true;
                        listener.lineStart();
                        while (++i < n)
                            listener.point((point = segment[i])[0], point[1]);
                        listener.lineEnd();
                    }
                    return;
                }
                if (n > 1 && clean & 2)
                    ringSegments.push(ringSegments.pop().concat(ringSegments.shift()));
                segments.push(ringSegments.filter(d3_geo_clipSegmentLength1));
            }
            return clip;
        }
        ;
    }
    function d3_geo_clipSegmentLength1(segment) {
        return segment.length > 1;
    }
    function d3_geo_clipBufferListener() {
        var lines = [], line;
        return {
            lineStart: function() {
                lines.push(line = []);
            },
            point: function(λ, φ) {
                line.push([λ, φ]);
            },
            lineEnd: d3_noop,
            buffer: function() {
                var buffer = lines;
                lines = [];
                line = null;
                return buffer;
            },
            rejoin: function() {
                if (lines.length > 1)
                    lines.push(lines.pop().concat(lines.shift()));
            }
        };
    }
    function d3_geo_clipSort(a, b) {
        return ((a = a.x)[0] < 0 ? a[1] - halfπ - ε : halfπ - a[1]) - ((b = b.x)[0] < 0 ? b[1] - halfπ - ε : halfπ - b[1]);
    }
    function d3_geo_pointInPolygon(point, polygon) {
        var meridian = point[0]
          , parallel = point[1]
          , meridianNormal = [Math.sin(meridian), -Math.cos(meridian), 0]
          , polarAngle = 0
          , winding = 0;
        d3_geo_areaRingSum.reset();
        for (var i = 0, n = polygon.length; i < n; ++i) {
            var ring = polygon[i]
              , m = ring.length;
            if (!m)
                continue;
            var point0 = ring[0]
              , λ0 = point0[0]
              , φ0 = point0[1] / 2 + π / 4
              , sinφ0 = Math.sin(φ0)
              , cosφ0 = Math.cos(φ0)
              , j = 1;
            while (true) {
                if (j === m)
                    j = 0;
                point = ring[j];
                var λ = point[0]
                  , φ = point[1] / 2 + π / 4
                  , sinφ = Math.sin(φ)
                  , cosφ = Math.cos(φ)
                  , dλ = λ - λ0
                  , sdλ = dλ >= 0 ? 1 : -1
                  , adλ = sdλ * dλ
                  , antimeridian = adλ > π
                  , k = sinφ0 * sinφ;
                d3_geo_areaRingSum.add(Math.atan2(k * sdλ * Math.sin(adλ), cosφ0 * cosφ + k * Math.cos(adλ)));
                polarAngle += antimeridian ? dλ + sdλ * τ : dλ;
                if (antimeridian ^ λ0 >= meridian ^ λ >= meridian) {
                    var arc = d3_geo_cartesianCross(d3_geo_cartesian(point0), d3_geo_cartesian(point));
                    d3_geo_cartesianNormalize(arc);
                    var intersection = d3_geo_cartesianCross(meridianNormal, arc);
                    d3_geo_cartesianNormalize(intersection);
                    var φarc = (antimeridian ^ dλ >= 0 ? -1 : 1) * d3_asin(intersection[2]);
                    if (parallel > φarc || parallel === φarc && (arc[0] || arc[1])) {
                        winding += antimeridian ^ dλ >= 0 ? 1 : -1;
                    }
                }
                if (!j++)
                    break;
                λ0 = λ,
                sinφ0 = sinφ,
                cosφ0 = cosφ,
                point0 = point;
            }
        }
        return (polarAngle < -ε || polarAngle < ε && d3_geo_areaRingSum < 0) ^ winding & 1;
    }
    var d3_geo_clipAntimeridian = d3_geo_clip(d3_true, d3_geo_clipAntimeridianLine, d3_geo_clipAntimeridianInterpolate, [-π, -π / 2]);
    function d3_geo_clipAntimeridianLine(listener) {
        var λ0 = NaN, φ0 = NaN, sλ0 = NaN, clean;
        return {
            lineStart: function() {
                listener.lineStart();
                clean = 1;
            },
            point: function(λ1, φ1) {
                var sλ1 = λ1 > 0 ? π : -π
                  , dλ = abs(λ1 - λ0);
                if (abs(dλ - π) < ε) {
                    listener.point(λ0, φ0 = (φ0 + φ1) / 2 > 0 ? halfπ : -halfπ);
                    listener.point(sλ0, φ0);
                    listener.lineEnd();
                    listener.lineStart();
                    listener.point(sλ1, φ0);
                    listener.point(λ1, φ0);
                    clean = 0;
                } else if (sλ0 !== sλ1 && dλ >= π) {
                    if (abs(λ0 - sλ0) < ε)
                        λ0 -= sλ0 * ε;
                    if (abs(λ1 - sλ1) < ε)
                        λ1 -= sλ1 * ε;
                    φ0 = d3_geo_clipAntimeridianIntersect(λ0, φ0, λ1, φ1);
                    listener.point(sλ0, φ0);
                    listener.lineEnd();
                    listener.lineStart();
                    listener.point(sλ1, φ0);
                    clean = 0;
                }
                listener.point(λ0 = λ1, φ0 = φ1);
                sλ0 = sλ1;
            },
            lineEnd: function() {
                listener.lineEnd();
                λ0 = φ0 = NaN;
            },
            clean: function() {
                return 2 - clean;
            }
        };
    }
    function d3_geo_clipAntimeridianIntersect(λ0, φ0, λ1, φ1) {
        var cosφ0, cosφ1, sinλ0_λ1 = Math.sin(λ0 - λ1);
        return abs(sinλ0_λ1) > ε ? Math.atan((Math.sin(φ0) * (cosφ1 = Math.cos(φ1)) * Math.sin(λ1) - Math.sin(φ1) * (cosφ0 = Math.cos(φ0)) * Math.sin(λ0)) / (cosφ0 * cosφ1 * sinλ0_λ1)) : (φ0 + φ1) / 2;
    }
    function d3_geo_clipAntimeridianInterpolate(from, to, direction, listener) {
        var φ;
        if (from == null) {
            φ = direction * halfπ;
            listener.point(-π, φ);
            listener.point(0, φ);
            listener.point(π, φ);
            listener.point(π, 0);
            listener.point(π, -φ);
            listener.point(0, -φ);
            listener.point(-π, -φ);
            listener.point(-π, 0);
            listener.point(-π, φ);
        } else if (abs(from[0] - to[0]) > ε) {
            var s = from[0] < to[0] ? π : -π;
            φ = direction * s / 2;
            listener.point(-s, φ);
            listener.point(0, φ);
            listener.point(s, φ);
        } else {
            listener.point(to[0], to[1]);
        }
    }
    function d3_geo_clipCircle(radius) {
        var cr = Math.cos(radius)
          , smallRadius = cr > 0
          , notHemisphere = abs(cr) > ε
          , interpolate = d3_geo_circleInterpolate(radius, 6 * d3_radians);
        return d3_geo_clip(visible, clipLine, interpolate, smallRadius ? [0, -radius] : [-π, radius - π]);
        function visible(λ, φ) {
            return Math.cos(λ) * Math.cos(φ) > cr;
        }
        function clipLine(listener) {
            var point0, c0, v0, v00, clean;
            return {
                lineStart: function() {
                    v00 = v0 = false;
                    clean = 1;
                },
                point: function(λ, φ) {
                    var point1 = [λ, φ], point2, v = visible(λ, φ), c = smallRadius ? v ? 0 : code(λ, φ) : v ? code(λ + (λ < 0 ? π : -π), φ) : 0;
                    if (!point0 && (v00 = v0 = v))
                        listener.lineStart();
                    if (v !== v0) {
                        point2 = intersect(point0, point1);
                        if (d3_geo_sphericalEqual(point0, point2) || d3_geo_sphericalEqual(point1, point2)) {
                            point1[0] += ε;
                            point1[1] += ε;
                            v = visible(point1[0], point1[1]);
                        }
                    }
                    if (v !== v0) {
                        clean = 0;
                        if (v) {
                            listener.lineStart();
                            point2 = intersect(point1, point0);
                            listener.point(point2[0], point2[1]);
                        } else {
                            point2 = intersect(point0, point1);
                            listener.point(point2[0], point2[1]);
                            listener.lineEnd();
                        }
                        point0 = point2;
                    } else if (notHemisphere && point0 && smallRadius ^ v) {
                        var t;
                        if (!(c & c0) && (t = intersect(point1, point0, true))) {
                            clean = 0;
                            if (smallRadius) {
                                listener.lineStart();
                                listener.point(t[0][0], t[0][1]);
                                listener.point(t[1][0], t[1][1]);
                                listener.lineEnd();
                            } else {
                                listener.point(t[1][0], t[1][1]);
                                listener.lineEnd();
                                listener.lineStart();
                                listener.point(t[0][0], t[0][1]);
                            }
                        }
                    }
                    if (v && (!point0 || !d3_geo_sphericalEqual(point0, point1))) {
                        listener.point(point1[0], point1[1]);
                    }
                    point0 = point1,
                    v0 = v,
                    c0 = c;
                },
                lineEnd: function() {
                    if (v0)
                        listener.lineEnd();
                    point0 = null;
                },
                clean: function() {
                    return clean | (v00 && v0) << 1;
                }
            };
        }
        function intersect(a, b, two) {
            var pa = d3_geo_cartesian(a)
              , pb = d3_geo_cartesian(b);
            var n1 = [1, 0, 0]
              , n2 = d3_geo_cartesianCross(pa, pb)
              , n2n2 = d3_geo_cartesianDot(n2, n2)
              , n1n2 = n2[0]
              , determinant = n2n2 - n1n2 * n1n2;
            if (!determinant)
                return !two && a;
            var c1 = cr * n2n2 / determinant
              , c2 = -cr * n1n2 / determinant
              , n1xn2 = d3_geo_cartesianCross(n1, n2)
              , A = d3_geo_cartesianScale(n1, c1)
              , B = d3_geo_cartesianScale(n2, c2);
            d3_geo_cartesianAdd(A, B);
            var u = n1xn2
              , w = d3_geo_cartesianDot(A, u)
              , uu = d3_geo_cartesianDot(u, u)
              , t2 = w * w - uu * (d3_geo_cartesianDot(A, A) - 1);
            if (t2 < 0)
                return;
            var t = Math.sqrt(t2)
              , q = d3_geo_cartesianScale(u, (-w - t) / uu);
            d3_geo_cartesianAdd(q, A);
            q = d3_geo_spherical(q);
            if (!two)
                return q;
            var λ0 = a[0], λ1 = b[0], φ0 = a[1], φ1 = b[1], z;
            if (λ1 < λ0)
                z = λ0,
                λ0 = λ1,
                λ1 = z;
            var δλ = λ1 - λ0
              , polar = abs(δλ - π) < ε
              , meridian = polar || δλ < ε;
            if (!polar && φ1 < φ0)
                z = φ0,
                φ0 = φ1,
                φ1 = z;
            if (meridian ? polar ? φ0 + φ1 > 0 ^ q[1] < (abs(q[0] - λ0) < ε ? φ0 : φ1) : φ0 <= q[1] && q[1] <= φ1 : δλ > π ^ (λ0 <= q[0] && q[0] <= λ1)) {
                var q1 = d3_geo_cartesianScale(u, (-w + t) / uu);
                d3_geo_cartesianAdd(q1, A);
                return [q, d3_geo_spherical(q1)];
            }
        }
        function code(λ, φ) {
            var r = smallRadius ? radius : π - radius
              , code = 0;
            if (λ < -r)
                code |= 1;
            else if (λ > r)
                code |= 2;
            if (φ < -r)
                code |= 4;
            else if (φ > r)
                code |= 8;
            return code;
        }
    }
    function d3_geom_clipLine(x0, y0, x1, y1) {
        return function(line) {
            var a = line.a, b = line.b, ax = a.x, ay = a.y, bx = b.x, by = b.y, t0 = 0, t1 = 1, dx = bx - ax, dy = by - ay, r;
            r = x0 - ax;
            if (!dx && r > 0)
                return;
            r /= dx;
            if (dx < 0) {
                if (r < t0)
                    return;
                if (r < t1)
                    t1 = r;
            } else if (dx > 0) {
                if (r > t1)
                    return;
                if (r > t0)
                    t0 = r;
            }
            r = x1 - ax;
            if (!dx && r < 0)
                return;
            r /= dx;
            if (dx < 0) {
                if (r > t1)
                    return;
                if (r > t0)
                    t0 = r;
            } else if (dx > 0) {
                if (r < t0)
                    return;
                if (r < t1)
                    t1 = r;
            }
            r = y0 - ay;
            if (!dy && r > 0)
                return;
            r /= dy;
            if (dy < 0) {
                if (r < t0)
                    return;
                if (r < t1)
                    t1 = r;
            } else if (dy > 0) {
                if (r > t1)
                    return;
                if (r > t0)
                    t0 = r;
            }
            r = y1 - ay;
            if (!dy && r < 0)
                return;
            r /= dy;
            if (dy < 0) {
                if (r > t1)
                    return;
                if (r > t0)
                    t0 = r;
            } else if (dy > 0) {
                if (r < t0)
                    return;
                if (r < t1)
                    t1 = r;
            }
            if (t0 > 0)
                line.a = {
                    x: ax + t0 * dx,
                    y: ay + t0 * dy
                };
            if (t1 < 1)
                line.b = {
                    x: ax + t1 * dx,
                    y: ay + t1 * dy
                };
            return line;
        }
        ;
    }
    var d3_geo_clipExtentMAX = 1e9;
    d3.geo.clipExtent = function() {
        var x0, y0, x1, y1, stream, clip, clipExtent = {
            stream: function(output) {
                if (stream)
                    stream.valid = false;
                stream = clip(output);
                stream.valid = true;
                return stream;
            },
            extent: function(_) {
                if (!arguments.length)
                    return [[x0, y0], [x1, y1]];
                clip = d3_geo_clipExtent(x0 = +_[0][0], y0 = +_[0][1], x1 = +_[1][0], y1 = +_[1][1]);
                if (stream)
                    stream.valid = false,
                    stream = null;
                return clipExtent;
            }
        };
        return clipExtent.extent([[0, 0], [960, 500]]);
    }
    ;
    function d3_geo_clipExtent(x0, y0, x1, y1) {
        return function(listener) {
            var listener_ = listener, bufferListener = d3_geo_clipBufferListener(), clipLine = d3_geom_clipLine(x0, y0, x1, y1), segments, polygon, ring;
            var clip = {
                point: point,
                lineStart: lineStart,
                lineEnd: lineEnd,
                polygonStart: function() {
                    listener = bufferListener;
                    segments = [];
                    polygon = [];
                    clean = true;
                },
                polygonEnd: function() {
                    listener = listener_;
                    segments = d3.merge(segments);
                    var clipStartInside = insidePolygon([x0, y1])
                      , inside = clean && clipStartInside
                      , visible = segments.length;
                    if (inside || visible) {
                        listener.polygonStart();
                        if (inside) {
                            listener.lineStart();
                            interpolate(null, null, 1, listener);
                            listener.lineEnd();
                        }
                        if (visible) {
                            d3_geo_clipPolygon(segments, compare, clipStartInside, interpolate, listener);
                        }
                        listener.polygonEnd();
                    }
                    segments = polygon = ring = null;
                }
            };
            function insidePolygon(p) {
                var wn = 0
                  , n = polygon.length
                  , y = p[1];
                for (var i = 0; i < n; ++i) {
                    for (var j = 1, v = polygon[i], m = v.length, a = v[0], b; j < m; ++j) {
                        b = v[j];
                        if (a[1] <= y) {
                            if (b[1] > y && d3_cross2d(a, b, p) > 0)
                                ++wn;
                        } else {
                            if (b[1] <= y && d3_cross2d(a, b, p) < 0)
                                --wn;
                        }
                        a = b;
                    }
                }
                return wn !== 0;
            }
            function interpolate(from, to, direction, listener) {
                var a = 0
                  , a1 = 0;
                if (from == null || (a = corner(from, direction)) !== (a1 = corner(to, direction)) || comparePoints(from, to) < 0 ^ direction > 0) {
                    do {
                        listener.point(a === 0 || a === 3 ? x0 : x1, a > 1 ? y1 : y0);
                    } while ((a = (a + direction + 4) % 4) !== a1);
                } else {
                    listener.point(to[0], to[1]);
                }
            }
            function pointVisible(x, y) {
                return x0 <= x && x <= x1 && y0 <= y && y <= y1;
            }
            function point(x, y) {
                if (pointVisible(x, y))
                    listener.point(x, y);
            }
            var x__, y__, v__, x_, y_, v_, first, clean;
            function lineStart() {
                clip.point = linePoint;
                if (polygon)
                    polygon.push(ring = []);
                first = true;
                v_ = false;
                x_ = y_ = NaN;
            }
            function lineEnd() {
                if (segments) {
                    linePoint(x__, y__);
                    if (v__ && v_)
                        bufferListener.rejoin();
                    segments.push(bufferListener.buffer());
                }
                clip.point = point;
                if (v_)
                    listener.lineEnd();
            }
            function linePoint(x, y) {
                x = Math.max(-d3_geo_clipExtentMAX, Math.min(d3_geo_clipExtentMAX, x));
                y = Math.max(-d3_geo_clipExtentMAX, Math.min(d3_geo_clipExtentMAX, y));
                var v = pointVisible(x, y);
                if (polygon)
                    ring.push([x, y]);
                if (first) {
                    x__ = x,
                    y__ = y,
                    v__ = v;
                    first = false;
                    if (v) {
                        listener.lineStart();
                        listener.point(x, y);
                    }
                } else {
                    if (v && v_)
                        listener.point(x, y);
                    else {
                        var l = {
                            a: {
                                x: x_,
                                y: y_
                            },
                            b: {
                                x: x,
                                y: y
                            }
                        };
                        if (clipLine(l)) {
                            if (!v_) {
                                listener.lineStart();
                                listener.point(l.a.x, l.a.y);
                            }
                            listener.point(l.b.x, l.b.y);
                            if (!v)
                                listener.lineEnd();
                            clean = false;
                        } else if (v) {
                            listener.lineStart();
                            listener.point(x, y);
                            clean = false;
                        }
                    }
                }
                x_ = x,
                y_ = y,
                v_ = v;
            }
            return clip;
        }
        ;
        function corner(p, direction) {
            return abs(p[0] - x0) < ε ? direction > 0 ? 0 : 3 : abs(p[0] - x1) < ε ? direction > 0 ? 2 : 1 : abs(p[1] - y0) < ε ? direction > 0 ? 1 : 0 : direction > 0 ? 3 : 2;
        }
        function compare(a, b) {
            return comparePoints(a.x, b.x);
        }
        function comparePoints(a, b) {
            var ca = corner(a, 1)
              , cb = corner(b, 1);
            return ca !== cb ? ca - cb : ca === 0 ? b[1] - a[1] : ca === 1 ? a[0] - b[0] : ca === 2 ? a[1] - b[1] : b[0] - a[0];
        }
    }
    function d3_geo_compose(a, b) {
        function compose(x, y) {
            return x = a(x, y),
            b(x[0], x[1]);
        }
        if (a.invert && b.invert)
            compose.invert = function(x, y) {
                return x = b.invert(x, y),
                x && a.invert(x[0], x[1]);
            }
            ;
        return compose;
    }
    function d3_geo_conic(projectAt) {
        var φ0 = 0
          , φ1 = π / 3
          , m = d3_geo_projectionMutator(projectAt)
          , p = m(φ0, φ1);
        p.parallels = function(_) {
            if (!arguments.length)
                return [φ0 / π * 180, φ1 / π * 180];
            return m(φ0 = _[0] * π / 180, φ1 = _[1] * π / 180);
        }
        ;
        return p;
    }
    function d3_geo_conicEqualArea(φ0, φ1) {
        var sinφ0 = Math.sin(φ0)
          , n = (sinφ0 + Math.sin(φ1)) / 2
          , C = 1 + sinφ0 * (2 * n - sinφ0)
          , ρ0 = Math.sqrt(C) / n;
        function forward(λ, φ) {
            var ρ = Math.sqrt(C - 2 * n * Math.sin(φ)) / n;
            return [ρ * Math.sin(λ *= n), ρ0 - ρ * Math.cos(λ)];
        }
        forward.invert = function(x, y) {
            var ρ0_y = ρ0 - y;
            return [Math.atan2(x, ρ0_y) / n, d3_asin((C - (x * x + ρ0_y * ρ0_y) * n * n) / (2 * n))];
        }
        ;
        return forward;
    }
    (d3.geo.conicEqualArea = function() {
        return d3_geo_conic(d3_geo_conicEqualArea);
    }
    ).raw = d3_geo_conicEqualArea;
    d3.geo.albers = function() {
        return d3.geo.conicEqualArea().rotate([96, 0]).center([-.6, 38.7]).parallels([29.5, 45.5]).scale(1070);
    }
    ;
    d3.geo.albersUsa = function() {
        var lower48 = d3.geo.albers();
        var alaska = d3.geo.conicEqualArea().rotate([154, 0]).center([-2, 58.5]).parallels([55, 65]);
        var hawaii = d3.geo.conicEqualArea().rotate([157, 0]).center([-3, 19.9]).parallels([8, 18]);
        var point, pointStream = {
            point: function(x, y) {
                point = [x, y];
            }
        }, lower48Point, alaskaPoint, hawaiiPoint;
        function albersUsa(coordinates) {
            var x = coordinates[0]
              , y = coordinates[1];
            point = null;
            (lower48Point(x, y),
            point) || (alaskaPoint(x, y),
            point) || hawaiiPoint(x, y);
            return point;
        }
        albersUsa.invert = function(coordinates) {
            var k = lower48.scale()
              , t = lower48.translate()
              , x = (coordinates[0] - t[0]) / k
              , y = (coordinates[1] - t[1]) / k;
            return (y >= .12 && y < .234 && x >= -.425 && x < -.214 ? alaska : y >= .166 && y < .234 && x >= -.214 && x < -.115 ? hawaii : lower48).invert(coordinates);
        }
        ;
        albersUsa.stream = function(stream) {
            var lower48Stream = lower48.stream(stream)
              , alaskaStream = alaska.stream(stream)
              , hawaiiStream = hawaii.stream(stream);
            return {
                point: function(x, y) {
                    lower48Stream.point(x, y);
                    alaskaStream.point(x, y);
                    hawaiiStream.point(x, y);
                },
                sphere: function() {
                    lower48Stream.sphere();
                    alaskaStream.sphere();
                    hawaiiStream.sphere();
                },
                lineStart: function() {
                    lower48Stream.lineStart();
                    alaskaStream.lineStart();
                    hawaiiStream.lineStart();
                },
                lineEnd: function() {
                    lower48Stream.lineEnd();
                    alaskaStream.lineEnd();
                    hawaiiStream.lineEnd();
                },
                polygonStart: function() {
                    lower48Stream.polygonStart();
                    alaskaStream.polygonStart();
                    hawaiiStream.polygonStart();
                },
                polygonEnd: function() {
                    lower48Stream.polygonEnd();
                    alaskaStream.polygonEnd();
                    hawaiiStream.polygonEnd();
                }
            };
        }
        ;
        albersUsa.precision = function(_) {
            if (!arguments.length)
                return lower48.precision();
            lower48.precision(_);
            alaska.precision(_);
            hawaii.precision(_);
            return albersUsa;
        }
        ;
        albersUsa.scale = function(_) {
            if (!arguments.length)
                return lower48.scale();
            lower48.scale(_);
            alaska.scale(_ * .35);
            hawaii.scale(_);
            return albersUsa.translate(lower48.translate());
        }
        ;
        albersUsa.translate = function(_) {
            if (!arguments.length)
                return lower48.translate();
            var k = lower48.scale()
              , x = +_[0]
              , y = +_[1];
            lower48Point = lower48.translate(_).clipExtent([[x - .455 * k, y - .238 * k], [x + .455 * k, y + .238 * k]]).stream(pointStream).point;
            alaskaPoint = alaska.translate([x - .307 * k, y + .201 * k]).clipExtent([[x - .425 * k + ε, y + .12 * k + ε], [x - .214 * k - ε, y + .234 * k - ε]]).stream(pointStream).point;
            hawaiiPoint = hawaii.translate([x - .205 * k, y + .212 * k]).clipExtent([[x - .214 * k + ε, y + .166 * k + ε], [x - .115 * k - ε, y + .234 * k - ε]]).stream(pointStream).point;
            return albersUsa;
        }
        ;
        return albersUsa.scale(1070);
    }
    ;
    var d3_geo_pathAreaSum, d3_geo_pathAreaPolygon, d3_geo_pathArea = {
        point: d3_noop,
        lineStart: d3_noop,
        lineEnd: d3_noop,
        polygonStart: function() {
            d3_geo_pathAreaPolygon = 0;
            d3_geo_pathArea.lineStart = d3_geo_pathAreaRingStart;
        },
        polygonEnd: function() {
            d3_geo_pathArea.lineStart = d3_geo_pathArea.lineEnd = d3_geo_pathArea.point = d3_noop;
            d3_geo_pathAreaSum += abs(d3_geo_pathAreaPolygon / 2);
        }
    };
    function d3_geo_pathAreaRingStart() {
        var x00, y00, x0, y0;
        d3_geo_pathArea.point = function(x, y) {
            d3_geo_pathArea.point = nextPoint;
            x00 = x0 = x,
            y00 = y0 = y;
        }
        ;
        function nextPoint(x, y) {
            d3_geo_pathAreaPolygon += y0 * x - x0 * y;
            x0 = x,
            y0 = y;
        }
        d3_geo_pathArea.lineEnd = function() {
            nextPoint(x00, y00);
        }
        ;
    }
    var d3_geo_pathBoundsX0, d3_geo_pathBoundsY0, d3_geo_pathBoundsX1, d3_geo_pathBoundsY1;
    var d3_geo_pathBounds = {
        point: d3_geo_pathBoundsPoint,
        lineStart: d3_noop,
        lineEnd: d3_noop,
        polygonStart: d3_noop,
        polygonEnd: d3_noop
    };
    function d3_geo_pathBoundsPoint(x, y) {
        if (x < d3_geo_pathBoundsX0)
            d3_geo_pathBoundsX0 = x;
        if (x > d3_geo_pathBoundsX1)
            d3_geo_pathBoundsX1 = x;
        if (y < d3_geo_pathBoundsY0)
            d3_geo_pathBoundsY0 = y;
        if (y > d3_geo_pathBoundsY1)
            d3_geo_pathBoundsY1 = y;
    }
    function d3_geo_pathBuffer() {
        var pointCircle = d3_geo_pathBufferCircle(4.5)
          , buffer = [];
        var stream = {
            point: point,
            lineStart: function() {
                stream.point = pointLineStart;
            },
            lineEnd: lineEnd,
            polygonStart: function() {
                stream.lineEnd = lineEndPolygon;
            },
            polygonEnd: function() {
                stream.lineEnd = lineEnd;
                stream.point = point;
            },
            pointRadius: function(_) {
                pointCircle = d3_geo_pathBufferCircle(_);
                return stream;
            },
            result: function() {
                if (buffer.length) {
                    var result = buffer.join("");
                    buffer = [];
                    return result;
                }
            }
        };
        function point(x, y) {
            buffer.push("M", x, ",", y, pointCircle);
        }
        function pointLineStart(x, y) {
            buffer.push("M", x, ",", y);
            stream.point = pointLine;
        }
        function pointLine(x, y) {
            buffer.push("L", x, ",", y);
        }
        function lineEnd() {
            stream.point = point;
        }
        function lineEndPolygon() {
            buffer.push("Z");
        }
        return stream;
    }
    function d3_geo_pathBufferCircle(radius) {
        return "m0," + radius + "a" + radius + "," + radius + " 0 1,1 0," + -2 * radius + "a" + radius + "," + radius + " 0 1,1 0," + 2 * radius + "z";
    }
    var d3_geo_pathCentroid = {
        point: d3_geo_pathCentroidPoint,
        lineStart: d3_geo_pathCentroidLineStart,
        lineEnd: d3_geo_pathCentroidLineEnd,
        polygonStart: function() {
            d3_geo_pathCentroid.lineStart = d3_geo_pathCentroidRingStart;
        },
        polygonEnd: function() {
            d3_geo_pathCentroid.point = d3_geo_pathCentroidPoint;
            d3_geo_pathCentroid.lineStart = d3_geo_pathCentroidLineStart;
            d3_geo_pathCentroid.lineEnd = d3_geo_pathCentroidLineEnd;
        }
    };
    function d3_geo_pathCentroidPoint(x, y) {
        d3_geo_centroidX0 += x;
        d3_geo_centroidY0 += y;
        ++d3_geo_centroidZ0;
    }
    function d3_geo_pathCentroidLineStart() {
        var x0, y0;
        d3_geo_pathCentroid.point = function(x, y) {
            d3_geo_pathCentroid.point = nextPoint;
            d3_geo_pathCentroidPoint(x0 = x, y0 = y);
        }
        ;
        function nextPoint(x, y) {
            var dx = x - x0
              , dy = y - y0
              , z = Math.sqrt(dx * dx + dy * dy);
            d3_geo_centroidX1 += z * (x0 + x) / 2;
            d3_geo_centroidY1 += z * (y0 + y) / 2;
            d3_geo_centroidZ1 += z;
            d3_geo_pathCentroidPoint(x0 = x, y0 = y);
        }
    }
    function d3_geo_pathCentroidLineEnd() {
        d3_geo_pathCentroid.point = d3_geo_pathCentroidPoint;
    }
    function d3_geo_pathCentroidRingStart() {
        var x00, y00, x0, y0;
        d3_geo_pathCentroid.point = function(x, y) {
            d3_geo_pathCentroid.point = nextPoint;
            d3_geo_pathCentroidPoint(x00 = x0 = x, y00 = y0 = y);
        }
        ;
        function nextPoint(x, y) {
            var dx = x - x0
              , dy = y - y0
              , z = Math.sqrt(dx * dx + dy * dy);
            d3_geo_centroidX1 += z * (x0 + x) / 2;
            d3_geo_centroidY1 += z * (y0 + y) / 2;
            d3_geo_centroidZ1 += z;
            z = y0 * x - x0 * y;
            d3_geo_centroidX2 += z * (x0 + x);
            d3_geo_centroidY2 += z * (y0 + y);
            d3_geo_centroidZ2 += z * 3;
            d3_geo_pathCentroidPoint(x0 = x, y0 = y);
        }
        d3_geo_pathCentroid.lineEnd = function() {
            nextPoint(x00, y00);
        }
        ;
    }
    function d3_geo_pathContext(context) {
        var pointRadius = 4.5;
        var stream = {
            point: point,
            lineStart: function() {
                stream.point = pointLineStart;
            },
            lineEnd: lineEnd,
            polygonStart: function() {
                stream.lineEnd = lineEndPolygon;
            },
            polygonEnd: function() {
                stream.lineEnd = lineEnd;
                stream.point = point;
            },
            pointRadius: function(_) {
                pointRadius = _;
                return stream;
            },
            result: d3_noop
        };
        function point(x, y) {
            context.moveTo(x, y);
            context.arc(x, y, pointRadius, 0, τ);
        }
        function pointLineStart(x, y) {
            context.moveTo(x, y);
            stream.point = pointLine;
        }
        function pointLine(x, y) {
            context.lineTo(x, y);
        }
        function lineEnd() {
            stream.point = point;
        }
        function lineEndPolygon() {
            context.closePath();
        }
        return stream;
    }
    function d3_geo_resample(project) {
        var δ2 = .5
          , cosMinDistance = Math.cos(30 * d3_radians)
          , maxDepth = 16;
        function resample(stream) {
            return (maxDepth ? resampleRecursive : resampleNone)(stream);
        }
        function resampleNone(stream) {
            return d3_geo_transformPoint(stream, function(x, y) {
                x = project(x, y);
                stream.point(x[0], x[1]);
            });
        }
        function resampleRecursive(stream) {
            var λ00, φ00, x00, y00, a00, b00, c00, λ0, x0, y0, a0, b0, c0;
            var resample = {
                point: point,
                lineStart: lineStart,
                lineEnd: lineEnd,
                polygonStart: function() {
                    stream.polygonStart();
                    resample.lineStart = ringStart;
                },
                polygonEnd: function() {
                    stream.polygonEnd();
                    resample.lineStart = lineStart;
                }
            };
            function point(x, y) {
                x = project(x, y);
                stream.point(x[0], x[1]);
            }
            function lineStart() {
                x0 = NaN;
                resample.point = linePoint;
                stream.lineStart();
            }
            function linePoint(λ, φ) {
                var c = d3_geo_cartesian([λ, φ])
                  , p = project(λ, φ);
                resampleLineTo(x0, y0, λ0, a0, b0, c0, x0 = p[0], y0 = p[1], λ0 = λ, a0 = c[0], b0 = c[1], c0 = c[2], maxDepth, stream);
                stream.point(x0, y0);
            }
            function lineEnd() {
                resample.point = point;
                stream.lineEnd();
            }
            function ringStart() {
                lineStart();
                resample.point = ringPoint;
                resample.lineEnd = ringEnd;
            }
            function ringPoint(λ, φ) {
                linePoint(λ00 = λ, φ00 = φ),
                x00 = x0,
                y00 = y0,
                a00 = a0,
                b00 = b0,
                c00 = c0;
                resample.point = linePoint;
            }
            function ringEnd() {
                resampleLineTo(x0, y0, λ0, a0, b0, c0, x00, y00, λ00, a00, b00, c00, maxDepth, stream);
                resample.lineEnd = lineEnd;
                lineEnd();
            }
            return resample;
        }
        function resampleLineTo(x0, y0, λ0, a0, b0, c0, x1, y1, λ1, a1, b1, c1, depth, stream) {
            var dx = x1 - x0
              , dy = y1 - y0
              , d2 = dx * dx + dy * dy;
            if (d2 > 4 * δ2 && depth--) {
                var a = a0 + a1
                  , b = b0 + b1
                  , c = c0 + c1
                  , m = Math.sqrt(a * a + b * b + c * c)
                  , φ2 = Math.asin(c /= m)
                  , λ2 = abs(abs(c) - 1) < ε || abs(λ0 - λ1) < ε ? (λ0 + λ1) / 2 : Math.atan2(b, a)
                  , p = project(λ2, φ2)
                  , x2 = p[0]
                  , y2 = p[1]
                  , dx2 = x2 - x0
                  , dy2 = y2 - y0
                  , dz = dy * dx2 - dx * dy2;
                if (dz * dz / d2 > δ2 || abs((dx * dx2 + dy * dy2) / d2 - .5) > .3 || a0 * a1 + b0 * b1 + c0 * c1 < cosMinDistance) {
                    resampleLineTo(x0, y0, λ0, a0, b0, c0, x2, y2, λ2, a /= m, b /= m, c, depth, stream);
                    stream.point(x2, y2);
                    resampleLineTo(x2, y2, λ2, a, b, c, x1, y1, λ1, a1, b1, c1, depth, stream);
                }
            }
        }
        resample.precision = function(_) {
            if (!arguments.length)
                return Math.sqrt(δ2);
            maxDepth = (δ2 = _ * _) > 0 && 16;
            return resample;
        }
        ;
        return resample;
    }
    d3.geo.path = function() {
        var pointRadius = 4.5, projection, context, projectStream, contextStream, cacheStream;
        function path(object) {
            if (object) {
                if (typeof pointRadius === "function")
                    contextStream.pointRadius(+pointRadius.apply(this, arguments));
                if (!cacheStream || !cacheStream.valid)
                    cacheStream = projectStream(contextStream);
                d3.geo.stream(object, cacheStream);
            }
            return contextStream.result();
        }
        path.area = function(object) {
            d3_geo_pathAreaSum = 0;
            d3.geo.stream(object, projectStream(d3_geo_pathArea));
            return d3_geo_pathAreaSum;
        }
        ;
        path.centroid = function(object) {
            d3_geo_centroidX0 = d3_geo_centroidY0 = d3_geo_centroidZ0 = d3_geo_centroidX1 = d3_geo_centroidY1 = d3_geo_centroidZ1 = d3_geo_centroidX2 = d3_geo_centroidY2 = d3_geo_centroidZ2 = 0;
            d3.geo.stream(object, projectStream(d3_geo_pathCentroid));
            return d3_geo_centroidZ2 ? [d3_geo_centroidX2 / d3_geo_centroidZ2, d3_geo_centroidY2 / d3_geo_centroidZ2] : d3_geo_centroidZ1 ? [d3_geo_centroidX1 / d3_geo_centroidZ1, d3_geo_centroidY1 / d3_geo_centroidZ1] : d3_geo_centroidZ0 ? [d3_geo_centroidX0 / d3_geo_centroidZ0, d3_geo_centroidY0 / d3_geo_centroidZ0] : [NaN, NaN];
        }
        ;
        path.bounds = function(object) {
            d3_geo_pathBoundsX1 = d3_geo_pathBoundsY1 = -(d3_geo_pathBoundsX0 = d3_geo_pathBoundsY0 = Infinity);
            d3.geo.stream(object, projectStream(d3_geo_pathBounds));
            return [[d3_geo_pathBoundsX0, d3_geo_pathBoundsY0], [d3_geo_pathBoundsX1, d3_geo_pathBoundsY1]];
        }
        ;
        path.projection = function(_) {
            if (!arguments.length)
                return projection;
            projectStream = (projection = _) ? _.stream || d3_geo_pathProjectStream(_) : d3_identity;
            return reset();
        }
        ;
        path.context = function(_) {
            if (!arguments.length)
                return context;
            contextStream = (context = _) == null ? new d3_geo_pathBuffer() : new d3_geo_pathContext(_);
            if (typeof pointRadius !== "function")
                contextStream.pointRadius(pointRadius);
            return reset();
        }
        ;
        path.pointRadius = function(_) {
            if (!arguments.length)
                return pointRadius;
            pointRadius = typeof _ === "function" ? _ : (contextStream.pointRadius(+_),
            +_);
            return path;
        }
        ;
        function reset() {
            cacheStream = null;
            return path;
        }
        return path.projection(d3.geo.albersUsa()).context(null);
    }
    ;
    function d3_geo_pathProjectStream(project) {
        var resample = d3_geo_resample(function(x, y) {
            return project([x * d3_degrees, y * d3_degrees]);
        });
        return function(stream) {
            return d3_geo_projectionRadians(resample(stream));
        }
        ;
    }
    d3.geo.transform = function(methods) {
        return {
            stream: function(stream) {
                var transform = new d3_geo_transform(stream);
                for (var k in methods)
                    transform[k] = methods[k];
                return transform;
            }
        };
    }
    ;
    function d3_geo_transform(stream) {
        this.stream = stream;
    }
    d3_geo_transform.prototype = {
        point: function(x, y) {
            this.stream.point(x, y);
        },
        sphere: function() {
            this.stream.sphere();
        },
        lineStart: function() {
            this.stream.lineStart();
        },
        lineEnd: function() {
            this.stream.lineEnd();
        },
        polygonStart: function() {
            this.stream.polygonStart();
        },
        polygonEnd: function() {
            this.stream.polygonEnd();
        }
    };
    function d3_geo_transformPoint(stream, point) {
        return {
            point: point,
            sphere: function() {
                stream.sphere();
            },
            lineStart: function() {
                stream.lineStart();
            },
            lineEnd: function() {
                stream.lineEnd();
            },
            polygonStart: function() {
                stream.polygonStart();
            },
            polygonEnd: function() {
                stream.polygonEnd();
            }
        };
    }
    d3.geo.projection = d3_geo_projection;
    d3.geo.projectionMutator = d3_geo_projectionMutator;
    function d3_geo_projection(project) {
        return d3_geo_projectionMutator(function() {
            return project;
        })();
    }
    function d3_geo_projectionMutator(projectAt) {
        var project, rotate, projectRotate, projectResample = d3_geo_resample(function(x, y) {
            x = project(x, y);
            return [x[0] * k + δx, δy - x[1] * k];
        }), k = 150, x = 480, y = 250, λ = 0, φ = 0, δλ = 0, δφ = 0, δγ = 0, δx, δy, preclip = d3_geo_clipAntimeridian, postclip = d3_identity, clipAngle = null, clipExtent = null, stream;
        function projection(point) {
            point = projectRotate(point[0] * d3_radians, point[1] * d3_radians);
            return [point[0] * k + δx, δy - point[1] * k];
        }
        function invert(point) {
            point = projectRotate.invert((point[0] - δx) / k, (δy - point[1]) / k);
            return point && [point[0] * d3_degrees, point[1] * d3_degrees];
        }
        projection.stream = function(output) {
            if (stream)
                stream.valid = false;
            stream = d3_geo_projectionRadians(preclip(rotate, projectResample(postclip(output))));
            stream.valid = true;
            return stream;
        }
        ;
        projection.clipAngle = function(_) {
            if (!arguments.length)
                return clipAngle;
            preclip = _ == null ? (clipAngle = _,
            d3_geo_clipAntimeridian) : d3_geo_clipCircle((clipAngle = +_) * d3_radians);
            return invalidate();
        }
        ;
        projection.clipExtent = function(_) {
            if (!arguments.length)
                return clipExtent;
            clipExtent = _;
            postclip = _ ? d3_geo_clipExtent(_[0][0], _[0][1], _[1][0], _[1][1]) : d3_identity;
            return invalidate();
        }
        ;
        projection.scale = function(_) {
            if (!arguments.length)
                return k;
            k = +_;
            return reset();
        }
        ;
        projection.translate = function(_) {
            if (!arguments.length)
                return [x, y];
            x = +_[0];
            y = +_[1];
            return reset();
        }
        ;
        projection.center = function(_) {
            if (!arguments.length)
                return [λ * d3_degrees, φ * d3_degrees];
            λ = _[0] % 360 * d3_radians;
            φ = _[1] % 360 * d3_radians;
            return reset();
        }
        ;
        projection.rotate = function(_) {
            if (!arguments.length)
                return [δλ * d3_degrees, δφ * d3_degrees, δγ * d3_degrees];
            δλ = _[0] % 360 * d3_radians;
            δφ = _[1] % 360 * d3_radians;
            δγ = _.length > 2 ? _[2] % 360 * d3_radians : 0;
            return reset();
        }
        ;
        d3.rebind(projection, projectResample, "precision");
        function reset() {
            projectRotate = d3_geo_compose(rotate = d3_geo_rotation(δλ, δφ, δγ), project);
            var center = project(λ, φ);
            δx = x - center[0] * k;
            δy = y + center[1] * k;
            return invalidate();
        }
        function invalidate() {
            if (stream)
                stream.valid = false,
                stream = null;
            return projection;
        }
        return function() {
            project = projectAt.apply(this, arguments);
            projection.invert = project.invert && invert;
            return reset();
        }
        ;
    }
    function d3_geo_projectionRadians(stream) {
        return d3_geo_transformPoint(stream, function(x, y) {
            stream.point(x * d3_radians, y * d3_radians);
        });
    }
    function d3_geo_equirectangular(λ, φ) {
        return [λ, φ];
    }
    (d3.geo.equirectangular = function() {
        return d3_geo_projection(d3_geo_equirectangular);
    }
    ).raw = d3_geo_equirectangular.invert = d3_geo_equirectangular;
    d3.geo.rotation = function(rotate) {
        rotate = d3_geo_rotation(rotate[0] % 360 * d3_radians, rotate[1] * d3_radians, rotate.length > 2 ? rotate[2] * d3_radians : 0);
        function forward(coordinates) {
            coordinates = rotate(coordinates[0] * d3_radians, coordinates[1] * d3_radians);
            return coordinates[0] *= d3_degrees,
            coordinates[1] *= d3_degrees,
            coordinates;
        }
        forward.invert = function(coordinates) {
            coordinates = rotate.invert(coordinates[0] * d3_radians, coordinates[1] * d3_radians);
            return coordinates[0] *= d3_degrees,
            coordinates[1] *= d3_degrees,
            coordinates;
        }
        ;
        return forward;
    }
    ;
    function d3_geo_identityRotation(λ, φ) {
        return [λ > π ? λ - τ : λ < -π ? λ + τ : λ, φ];
    }
    d3_geo_identityRotation.invert = d3_geo_equirectangular;
    function d3_geo_rotation(δλ, δφ, δγ) {
        return δλ ? δφ || δγ ? d3_geo_compose(d3_geo_rotationλ(δλ), d3_geo_rotationφγ(δφ, δγ)) : d3_geo_rotationλ(δλ) : δφ || δγ ? d3_geo_rotationφγ(δφ, δγ) : d3_geo_identityRotation;
    }
    function d3_geo_forwardRotationλ(δλ) {
        return function(λ, φ) {
            return λ += δλ,
            [λ > π ? λ - τ : λ < -π ? λ + τ : λ, φ];
        }
        ;
    }
    function d3_geo_rotationλ(δλ) {
        var rotation = d3_geo_forwardRotationλ(δλ);
        rotation.invert = d3_geo_forwardRotationλ(-δλ);
        return rotation;
    }
    function d3_geo_rotationφγ(δφ, δγ) {
        var cosδφ = Math.cos(δφ)
          , sinδφ = Math.sin(δφ)
          , cosδγ = Math.cos(δγ)
          , sinδγ = Math.sin(δγ);
        function rotation(λ, φ) {
            var cosφ = Math.cos(φ)
              , x = Math.cos(λ) * cosφ
              , y = Math.sin(λ) * cosφ
              , z = Math.sin(φ)
              , k = z * cosδφ + x * sinδφ;
            return [Math.atan2(y * cosδγ - k * sinδγ, x * cosδφ - z * sinδφ), d3_asin(k * cosδγ + y * sinδγ)];
        }
        rotation.invert = function(λ, φ) {
            var cosφ = Math.cos(φ)
              , x = Math.cos(λ) * cosφ
              , y = Math.sin(λ) * cosφ
              , z = Math.sin(φ)
              , k = z * cosδγ - y * sinδγ;
            return [Math.atan2(y * cosδγ + z * sinδγ, x * cosδφ + k * sinδφ), d3_asin(k * cosδφ - x * sinδφ)];
        }
        ;
        return rotation;
    }
    d3.geo.circle = function() {
        var origin = [0, 0], angle, precision = 6, interpolate;
        function circle() {
            var center = typeof origin === "function" ? origin.apply(this, arguments) : origin
              , rotate = d3_geo_rotation(-center[0] * d3_radians, -center[1] * d3_radians, 0).invert
              , ring = [];
            interpolate(null, null, 1, {
                point: function(x, y) {
                    ring.push(x = rotate(x, y));
                    x[0] *= d3_degrees,
                    x[1] *= d3_degrees;
                }
            });
            return {
                type: "Polygon",
                coordinates: [ring]
            };
        }
        circle.origin = function(x) {
            if (!arguments.length)
                return origin;
            origin = x;
            return circle;
        }
        ;
        circle.angle = function(x) {
            if (!arguments.length)
                return angle;
            interpolate = d3_geo_circleInterpolate((angle = +x) * d3_radians, precision * d3_radians);
            return circle;
        }
        ;
        circle.precision = function(_) {
            if (!arguments.length)
                return precision;
            interpolate = d3_geo_circleInterpolate(angle * d3_radians, (precision = +_) * d3_radians);
            return circle;
        }
        ;
        return circle.angle(90);
    }
    ;
    function d3_geo_circleInterpolate(radius, precision) {
        var cr = Math.cos(radius)
          , sr = Math.sin(radius);
        return function(from, to, direction, listener) {
            var step = direction * precision;
            if (from != null) {
                from = d3_geo_circleAngle(cr, from);
                to = d3_geo_circleAngle(cr, to);
                if (direction > 0 ? from < to : from > to)
                    from += direction * τ;
            } else {
                from = radius + direction * τ;
                to = radius - .5 * step;
            }
            for (var point, t = from; direction > 0 ? t > to : t < to; t -= step) {
                listener.point((point = d3_geo_spherical([cr, -sr * Math.cos(t), -sr * Math.sin(t)]))[0], point[1]);
            }
        }
        ;
    }
    function d3_geo_circleAngle(cr, point) {
        var a = d3_geo_cartesian(point);
        a[0] -= cr;
        d3_geo_cartesianNormalize(a);
        var angle = d3_acos(-a[1]);
        return ((-a[2] < 0 ? -angle : angle) + 2 * Math.PI - ε) % (2 * Math.PI);
    }
    d3.geo.distance = function(a, b) {
        var Δλ = (b[0] - a[0]) * d3_radians, φ0 = a[1] * d3_radians, φ1 = b[1] * d3_radians, sinΔλ = Math.sin(Δλ), cosΔλ = Math.cos(Δλ), sinφ0 = Math.sin(φ0), cosφ0 = Math.cos(φ0), sinφ1 = Math.sin(φ1), cosφ1 = Math.cos(φ1), t;
        return Math.atan2(Math.sqrt((t = cosφ1 * sinΔλ) * t + (t = cosφ0 * sinφ1 - sinφ0 * cosφ1 * cosΔλ) * t), sinφ0 * sinφ1 + cosφ0 * cosφ1 * cosΔλ);
    }
    ;
    d3.geo.graticule = function() {
        var x1, x0, X1, X0, y1, y0, Y1, Y0, dx = 10, dy = dx, DX = 90, DY = 360, x, y, X, Y, precision = 2.5;
        function graticule() {
            return {
                type: "MultiLineString",
                coordinates: lines()
            };
        }
        function lines() {
            return d3.range(Math.ceil(X0 / DX) * DX, X1, DX).map(X).concat(d3.range(Math.ceil(Y0 / DY) * DY, Y1, DY).map(Y)).concat(d3.range(Math.ceil(x0 / dx) * dx, x1, dx).filter(function(x) {
                return abs(x % DX) > ε;
            }).map(x)).concat(d3.range(Math.ceil(y0 / dy) * dy, y1, dy).filter(function(y) {
                return abs(y % DY) > ε;
            }).map(y));
        }
        graticule.lines = function() {
            return lines().map(function(coordinates) {
                return {
                    type: "LineString",
                    coordinates: coordinates
                };
            });
        }
        ;
        graticule.outline = function() {
            return {
                type: "Polygon",
                coordinates: [X(X0).concat(Y(Y1).slice(1), X(X1).reverse().slice(1), Y(Y0).reverse().slice(1))]
            };
        }
        ;
        graticule.extent = function(_) {
            if (!arguments.length)
                return graticule.minorExtent();
            return graticule.majorExtent(_).minorExtent(_);
        }
        ;
        graticule.majorExtent = function(_) {
            if (!arguments.length)
                return [[X0, Y0], [X1, Y1]];
            X0 = +_[0][0],
            X1 = +_[1][0];
            Y0 = +_[0][1],
            Y1 = +_[1][1];
            if (X0 > X1)
                _ = X0,
                X0 = X1,
                X1 = _;
            if (Y0 > Y1)
                _ = Y0,
                Y0 = Y1,
                Y1 = _;
            return graticule.precision(precision);
        }
        ;
        graticule.minorExtent = function(_) {
            if (!arguments.length)
                return [[x0, y0], [x1, y1]];
            x0 = +_[0][0],
            x1 = +_[1][0];
            y0 = +_[0][1],
            y1 = +_[1][1];
            if (x0 > x1)
                _ = x0,
                x0 = x1,
                x1 = _;
            if (y0 > y1)
                _ = y0,
                y0 = y1,
                y1 = _;
            return graticule.precision(precision);
        }
        ;
        graticule.step = function(_) {
            if (!arguments.length)
                return graticule.minorStep();
            return graticule.majorStep(_).minorStep(_);
        }
        ;
        graticule.majorStep = function(_) {
            if (!arguments.length)
                return [DX, DY];
            DX = +_[0],
            DY = +_[1];
            return graticule;
        }
        ;
        graticule.minorStep = function(_) {
            if (!arguments.length)
                return [dx, dy];
            dx = +_[0],
            dy = +_[1];
            return graticule;
        }
        ;
        graticule.precision = function(_) {
            if (!arguments.length)
                return precision;
            precision = +_;
            x = d3_geo_graticuleX(y0, y1, 90);
            y = d3_geo_graticuleY(x0, x1, precision);
            X = d3_geo_graticuleX(Y0, Y1, 90);
            Y = d3_geo_graticuleY(X0, X1, precision);
            return graticule;
        }
        ;
        return graticule.majorExtent([[-180, -90 + ε], [180, 90 - ε]]).minorExtent([[-180, -80 - ε], [180, 80 + ε]]);
    }
    ;
    function d3_geo_graticuleX(y0, y1, dy) {
        var y = d3.range(y0, y1 - ε, dy).concat(y1);
        return function(x) {
            return y.map(function(y) {
                return [x, y];
            });
        }
        ;
    }
    function d3_geo_graticuleY(x0, x1, dx) {
        var x = d3.range(x0, x1 - ε, dx).concat(x1);
        return function(y) {
            return x.map(function(x) {
                return [x, y];
            });
        }
        ;
    }
    function d3_source(d) {
        return d.source;
    }
    function d3_target(d) {
        return d.target;
    }
    d3.geo.greatArc = function() {
        var source = d3_source, source_, target = d3_target, target_;
        function greatArc() {
            return {
                type: "LineString",
                coordinates: [source_ || source.apply(this, arguments), target_ || target.apply(this, arguments)]
            };
        }
        greatArc.distance = function() {
            return d3.geo.distance(source_ || source.apply(this, arguments), target_ || target.apply(this, arguments));
        }
        ;
        greatArc.source = function(_) {
            if (!arguments.length)
                return source;
            source = _,
            source_ = typeof _ === "function" ? null : _;
            return greatArc;
        }
        ;
        greatArc.target = function(_) {
            if (!arguments.length)
                return target;
            target = _,
            target_ = typeof _ === "function" ? null : _;
            return greatArc;
        }
        ;
        greatArc.precision = function() {
            return arguments.length ? greatArc : 0;
        }
        ;
        return greatArc;
    }
    ;
    d3.geo.interpolate = function(source, target) {
        return d3_geo_interpolate(source[0] * d3_radians, source[1] * d3_radians, target[0] * d3_radians, target[1] * d3_radians);
    }
    ;
    function d3_geo_interpolate(x0, y0, x1, y1) {
        var cy0 = Math.cos(y0)
          , sy0 = Math.sin(y0)
          , cy1 = Math.cos(y1)
          , sy1 = Math.sin(y1)
          , kx0 = cy0 * Math.cos(x0)
          , ky0 = cy0 * Math.sin(x0)
          , kx1 = cy1 * Math.cos(x1)
          , ky1 = cy1 * Math.sin(x1)
          , d = 2 * Math.asin(Math.sqrt(d3_haversin(y1 - y0) + cy0 * cy1 * d3_haversin(x1 - x0)))
          , k = 1 / Math.sin(d);
        var interpolate = d ? function(t) {
            var B = Math.sin(t *= d) * k
              , A = Math.sin(d - t) * k
              , x = A * kx0 + B * kx1
              , y = A * ky0 + B * ky1
              , z = A * sy0 + B * sy1;
            return [Math.atan2(y, x) * d3_degrees, Math.atan2(z, Math.sqrt(x * x + y * y)) * d3_degrees];
        }
        : function() {
            return [x0 * d3_degrees, y0 * d3_degrees];
        }
        ;
        interpolate.distance = d;
        return interpolate;
    }
    d3.geo.length = function(object) {
        d3_geo_lengthSum = 0;
        d3.geo.stream(object, d3_geo_length);
        return d3_geo_lengthSum;
    }
    ;
    var d3_geo_lengthSum;
    var d3_geo_length = {
        sphere: d3_noop,
        point: d3_noop,
        lineStart: d3_geo_lengthLineStart,
        lineEnd: d3_noop,
        polygonStart: d3_noop,
        polygonEnd: d3_noop
    };
    function d3_geo_lengthLineStart() {
        var λ0, sinφ0, cosφ0;
        d3_geo_length.point = function(λ, φ) {
            λ0 = λ * d3_radians,
            sinφ0 = Math.sin(φ *= d3_radians),
            cosφ0 = Math.cos(φ);
            d3_geo_length.point = nextPoint;
        }
        ;
        d3_geo_length.lineEnd = function() {
            d3_geo_length.point = d3_geo_length.lineEnd = d3_noop;
        }
        ;
        function nextPoint(λ, φ) {
            var sinφ = Math.sin(φ *= d3_radians)
              , cosφ = Math.cos(φ)
              , t = abs((λ *= d3_radians) - λ0)
              , cosΔλ = Math.cos(t);
            d3_geo_lengthSum += Math.atan2(Math.sqrt((t = cosφ * Math.sin(t)) * t + (t = cosφ0 * sinφ - sinφ0 * cosφ * cosΔλ) * t), sinφ0 * sinφ + cosφ0 * cosφ * cosΔλ);
            λ0 = λ,
            sinφ0 = sinφ,
            cosφ0 = cosφ;
        }
    }
    function d3_geo_azimuthal(scale, angle) {
        function azimuthal(λ, φ) {
            var cosλ = Math.cos(λ)
              , cosφ = Math.cos(φ)
              , k = scale(cosλ * cosφ);
            return [k * cosφ * Math.sin(λ), k * Math.sin(φ)];
        }
        azimuthal.invert = function(x, y) {
            var ρ = Math.sqrt(x * x + y * y)
              , c = angle(ρ)
              , sinc = Math.sin(c)
              , cosc = Math.cos(c);
            return [Math.atan2(x * sinc, ρ * cosc), Math.asin(ρ && y * sinc / ρ)];
        }
        ;
        return azimuthal;
    }
    var d3_geo_azimuthalEqualArea = d3_geo_azimuthal(function(cosλcosφ) {
        return Math.sqrt(2 / (1 + cosλcosφ));
    }, function(ρ) {
        return 2 * Math.asin(ρ / 2);
    });
    (d3.geo.azimuthalEqualArea = function() {
        return d3_geo_projection(d3_geo_azimuthalEqualArea);
    }
    ).raw = d3_geo_azimuthalEqualArea;
    var d3_geo_azimuthalEquidistant = d3_geo_azimuthal(function(cosλcosφ) {
        var c = Math.acos(cosλcosφ);
        return c && c / Math.sin(c);
    }, d3_identity);
    (d3.geo.azimuthalEquidistant = function() {
        return d3_geo_projection(d3_geo_azimuthalEquidistant);
    }
    ).raw = d3_geo_azimuthalEquidistant;
    function d3_geo_conicConformal(φ0, φ1) {
        var cosφ0 = Math.cos(φ0)
          , t = function(φ) {
            return Math.tan(π / 4 + φ / 2);
        }
          , n = φ0 === φ1 ? Math.sin(φ0) : Math.log(cosφ0 / Math.cos(φ1)) / Math.log(t(φ1) / t(φ0))
          , F = cosφ0 * Math.pow(t(φ0), n) / n;
        if (!n)
            return d3_geo_mercator;
        function forward(λ, φ) {
            if (F > 0) {
                if (φ < -halfπ + ε)
                    φ = -halfπ + ε;
            } else {
                if (φ > halfπ - ε)
                    φ = halfπ - ε;
            }
            var ρ = F / Math.pow(t(φ), n);
            return [ρ * Math.sin(n * λ), F - ρ * Math.cos(n * λ)];
        }
        forward.invert = function(x, y) {
            var ρ0_y = F - y
              , ρ = d3_sgn(n) * Math.sqrt(x * x + ρ0_y * ρ0_y);
            return [Math.atan2(x, ρ0_y) / n, 2 * Math.atan(Math.pow(F / ρ, 1 / n)) - halfπ];
        }
        ;
        return forward;
    }
    (d3.geo.conicConformal = function() {
        return d3_geo_conic(d3_geo_conicConformal);
    }
    ).raw = d3_geo_conicConformal;
    function d3_geo_conicEquidistant(φ0, φ1) {
        var cosφ0 = Math.cos(φ0)
          , n = φ0 === φ1 ? Math.sin(φ0) : (cosφ0 - Math.cos(φ1)) / (φ1 - φ0)
          , G = cosφ0 / n + φ0;
        if (abs(n) < ε)
            return d3_geo_equirectangular;
        function forward(λ, φ) {
            var ρ = G - φ;
            return [ρ * Math.sin(n * λ), G - ρ * Math.cos(n * λ)];
        }
        forward.invert = function(x, y) {
            var ρ0_y = G - y;
            return [Math.atan2(x, ρ0_y) / n, G - d3_sgn(n) * Math.sqrt(x * x + ρ0_y * ρ0_y)];
        }
        ;
        return forward;
    }
    (d3.geo.conicEquidistant = function() {
        return d3_geo_conic(d3_geo_conicEquidistant);
    }
    ).raw = d3_geo_conicEquidistant;
    var d3_geo_gnomonic = d3_geo_azimuthal(function(cosλcosφ) {
        return 1 / cosλcosφ;
    }, Math.atan);
    (d3.geo.gnomonic = function() {
        return d3_geo_projection(d3_geo_gnomonic);
    }
    ).raw = d3_geo_gnomonic;
    function d3_geo_mercator(λ, φ) {
        return [λ, Math.log(Math.tan(π / 4 + φ / 2))];
    }
    d3_geo_mercator.invert = function(x, y) {
        return [x, 2 * Math.atan(Math.exp(y)) - halfπ];
    }
    ;
    function d3_geo_mercatorProjection(project) {
        var m = d3_geo_projection(project), scale = m.scale, translate = m.translate, clipExtent = m.clipExtent, clipAuto;
        m.scale = function() {
            var v = scale.apply(m, arguments);
            return v === m ? clipAuto ? m.clipExtent(null) : m : v;
        }
        ;
        m.translate = function() {
            var v = translate.apply(m, arguments);
            return v === m ? clipAuto ? m.clipExtent(null) : m : v;
        }
        ;
        m.clipExtent = function(_) {
            var v = clipExtent.apply(m, arguments);
            if (v === m) {
                if (clipAuto = _ == null) {
                    var k = π * scale()
                      , t = translate();
                    clipExtent([[t[0] - k, t[1] - k], [t[0] + k, t[1] + k]]);
                }
            } else if (clipAuto) {
                v = null;
            }
            return v;
        }
        ;
        return m.clipExtent(null);
    }
    (d3.geo.mercator = function() {
        return d3_geo_mercatorProjection(d3_geo_mercator);
    }
    ).raw = d3_geo_mercator;
    var d3_geo_orthographic = d3_geo_azimuthal(function() {
        return 1;
    }, Math.asin);
    (d3.geo.orthographic = function() {
        return d3_geo_projection(d3_geo_orthographic);
    }
    ).raw = d3_geo_orthographic;
    var d3_geo_stereographic = d3_geo_azimuthal(function(cosλcosφ) {
        return 1 / (1 + cosλcosφ);
    }, function(ρ) {
        return 2 * Math.atan(ρ);
    });
    (d3.geo.stereographic = function() {
        return d3_geo_projection(d3_geo_stereographic);
    }
    ).raw = d3_geo_stereographic;
    function d3_geo_transverseMercator(λ, φ) {
        return [Math.log(Math.tan(π / 4 + φ / 2)), -λ];
    }
    d3_geo_transverseMercator.invert = function(x, y) {
        return [-y, 2 * Math.atan(Math.exp(x)) - halfπ];
    }
    ;
    (d3.geo.transverseMercator = function() {
        var projection = d3_geo_mercatorProjection(d3_geo_transverseMercator)
          , center = projection.center
          , rotate = projection.rotate;
        projection.center = function(_) {
            return _ ? center([-_[1], _[0]]) : (_ = center(),
            [-_[1], _[0]]);
        }
        ;
        projection.rotate = function(_) {
            return _ ? rotate([_[0], _[1], _.length > 2 ? _[2] + 90 : 90]) : (_ = rotate(),
            [_[0], _[1], _[2] - 90]);
        }
        ;
        return projection.rotate([0, 0]);
    }
    ).raw = d3_geo_transverseMercator;
    d3.geom = {};
    function d3_geom_pointX(d) {
        return d[0];
    }
    function d3_geom_pointY(d) {
        return d[1];
    }
    d3.geom.hull = function(vertices) {
        var x = d3_geom_pointX
          , y = d3_geom_pointY;
        if (arguments.length)
            return hull(vertices);
        function hull(data) {
            if (data.length < 3)
                return [];
            var fx = d3_functor(x), fy = d3_functor(y), i, n = data.length, points = [], flippedPoints = [];
            for (i = 0; i < n; i++) {
                points.push([+fx.call(this, data[i], i), +fy.call(this, data[i], i), i]);
            }
            points.sort(d3_geom_hullOrder);
            for (i = 0; i < n; i++)
                flippedPoints.push([points[i][0], -points[i][1]]);
            var upper = d3_geom_hullUpper(points)
              , lower = d3_geom_hullUpper(flippedPoints);
            var skipLeft = lower[0] === upper[0]
              , skipRight = lower[lower.length - 1] === upper[upper.length - 1]
              , polygon = [];
            for (i = upper.length - 1; i >= 0; --i)
                polygon.push(data[points[upper[i]][2]]);
            for (i = +skipLeft; i < lower.length - skipRight; ++i)
                polygon.push(data[points[lower[i]][2]]);
            return polygon;
        }
        hull.x = function(_) {
            return arguments.length ? (x = _,
            hull) : x;
        }
        ;
        hull.y = function(_) {
            return arguments.length ? (y = _,
            hull) : y;
        }
        ;
        return hull;
    }
    ;
    function d3_geom_hullUpper(points) {
        var n = points.length
          , hull = [0, 1]
          , hs = 2;
        for (var i = 2; i < n; i++) {
            while (hs > 1 && d3_cross2d(points[hull[hs - 2]], points[hull[hs - 1]], points[i]) <= 0)
                --hs;
            hull[hs++] = i;
        }
        return hull.slice(0, hs);
    }
    function d3_geom_hullOrder(a, b) {
        return a[0] - b[0] || a[1] - b[1];
    }
    d3.geom.polygon = function(coordinates) {
        d3_subclass(coordinates, d3_geom_polygonPrototype);
        return coordinates;
    }
    ;
    var d3_geom_polygonPrototype = d3.geom.polygon.prototype = [];
    d3_geom_polygonPrototype.area = function() {
        var i = -1, n = this.length, a, b = this[n - 1], area = 0;
        while (++i < n) {
            a = b;
            b = this[i];
            area += a[1] * b[0] - a[0] * b[1];
        }
        return area * .5;
    }
    ;
    d3_geom_polygonPrototype.centroid = function(k) {
        var i = -1, n = this.length, x = 0, y = 0, a, b = this[n - 1], c;
        if (!arguments.length)
            k = -1 / (6 * this.area());
        while (++i < n) {
            a = b;
            b = this[i];
            c = a[0] * b[1] - b[0] * a[1];
            x += (a[0] + b[0]) * c;
            y += (a[1] + b[1]) * c;
        }
        return [x * k, y * k];
    }
    ;
    d3_geom_polygonPrototype.clip = function(subject) {
        var input, closed = d3_geom_polygonClosed(subject), i = -1, n = this.length - d3_geom_polygonClosed(this), j, m, a = this[n - 1], b, c, d;
        while (++i < n) {
            input = subject.slice();
            subject.length = 0;
            b = this[i];
            c = input[(m = input.length - closed) - 1];
            j = -1;
            while (++j < m) {
                d = input[j];
                if (d3_geom_polygonInside(d, a, b)) {
                    if (!d3_geom_polygonInside(c, a, b)) {
                        subject.push(d3_geom_polygonIntersect(c, d, a, b));
                    }
                    subject.push(d);
                } else if (d3_geom_polygonInside(c, a, b)) {
                    subject.push(d3_geom_polygonIntersect(c, d, a, b));
                }
                c = d;
            }
            if (closed)
                subject.push(subject[0]);
            a = b;
        }
        return subject;
    }
    ;
    function d3_geom_polygonInside(p, a, b) {
        return (b[0] - a[0]) * (p[1] - a[1]) < (b[1] - a[1]) * (p[0] - a[0]);
    }
    function d3_geom_polygonIntersect(c, d, a, b) {
        var x1 = c[0]
          , x3 = a[0]
          , x21 = d[0] - x1
          , x43 = b[0] - x3
          , y1 = c[1]
          , y3 = a[1]
          , y21 = d[1] - y1
          , y43 = b[1] - y3
          , ua = (x43 * (y1 - y3) - y43 * (x1 - x3)) / (y43 * x21 - x43 * y21);
        return [x1 + ua * x21, y1 + ua * y21];
    }
    function d3_geom_polygonClosed(coordinates) {
        var a = coordinates[0]
          , b = coordinates[coordinates.length - 1];
        return !(a[0] - b[0] || a[1] - b[1]);
    }
    var d3_geom_voronoiEdges, d3_geom_voronoiCells, d3_geom_voronoiBeaches, d3_geom_voronoiBeachPool = [], d3_geom_voronoiFirstCircle, d3_geom_voronoiCircles, d3_geom_voronoiCirclePool = [];
    function d3_geom_voronoiBeach() {
        d3_geom_voronoiRedBlackNode(this);
        this.edge = this.site = this.circle = null;
    }
    function d3_geom_voronoiCreateBeach(site) {
        var beach = d3_geom_voronoiBeachPool.pop() || new d3_geom_voronoiBeach();
        beach.site = site;
        return beach;
    }
    function d3_geom_voronoiDetachBeach(beach) {
        d3_geom_voronoiDetachCircle(beach);
        d3_geom_voronoiBeaches.remove(beach);
        d3_geom_voronoiBeachPool.push(beach);
        d3_geom_voronoiRedBlackNode(beach);
    }
    function d3_geom_voronoiRemoveBeach(beach) {
        var circle = beach.circle
          , x = circle.x
          , y = circle.cy
          , vertex = {
            x: x,
            y: y
        }
          , previous = beach.P
          , next = beach.N
          , disappearing = [beach];
        d3_geom_voronoiDetachBeach(beach);
        var lArc = previous;
        while (lArc.circle && abs(x - lArc.circle.x) < ε && abs(y - lArc.circle.cy) < ε) {
            previous = lArc.P;
            disappearing.unshift(lArc);
            d3_geom_voronoiDetachBeach(lArc);
            lArc = previous;
        }
        disappearing.unshift(lArc);
        d3_geom_voronoiDetachCircle(lArc);
        var rArc = next;
        while (rArc.circle && abs(x - rArc.circle.x) < ε && abs(y - rArc.circle.cy) < ε) {
            next = rArc.N;
            disappearing.push(rArc);
            d3_geom_voronoiDetachBeach(rArc);
            rArc = next;
        }
        disappearing.push(rArc);
        d3_geom_voronoiDetachCircle(rArc);
        var nArcs = disappearing.length, iArc;
        for (iArc = 1; iArc < nArcs; ++iArc) {
            rArc = disappearing[iArc];
            lArc = disappearing[iArc - 1];
            d3_geom_voronoiSetEdgeEnd(rArc.edge, lArc.site, rArc.site, vertex);
        }
        lArc = disappearing[0];
        rArc = disappearing[nArcs - 1];
        rArc.edge = d3_geom_voronoiCreateEdge(lArc.site, rArc.site, null, vertex);
        d3_geom_voronoiAttachCircle(lArc);
        d3_geom_voronoiAttachCircle(rArc);
    }
    function d3_geom_voronoiAddBeach(site) {
        var x = site.x, directrix = site.y, lArc, rArc, dxl, dxr, node = d3_geom_voronoiBeaches._;
        while (node) {
            dxl = d3_geom_voronoiLeftBreakPoint(node, directrix) - x;
            if (dxl > ε)
                node = node.L;
            else {
                dxr = x - d3_geom_voronoiRightBreakPoint(node, directrix);
                if (dxr > ε) {
                    if (!node.R) {
                        lArc = node;
                        break;
                    }
                    node = node.R;
                } else {
                    if (dxl > -ε) {
                        lArc = node.P;
                        rArc = node;
                    } else if (dxr > -ε) {
                        lArc = node;
                        rArc = node.N;
                    } else {
                        lArc = rArc = node;
                    }
                    break;
                }
            }
        }
        var newArc = d3_geom_voronoiCreateBeach(site);
        d3_geom_voronoiBeaches.insert(lArc, newArc);
        if (!lArc && !rArc)
            return;
        if (lArc === rArc) {
            d3_geom_voronoiDetachCircle(lArc);
            rArc = d3_geom_voronoiCreateBeach(lArc.site);
            d3_geom_voronoiBeaches.insert(newArc, rArc);
            newArc.edge = rArc.edge = d3_geom_voronoiCreateEdge(lArc.site, newArc.site);
            d3_geom_voronoiAttachCircle(lArc);
            d3_geom_voronoiAttachCircle(rArc);
            return;
        }
        if (!rArc) {
            newArc.edge = d3_geom_voronoiCreateEdge(lArc.site, newArc.site);
            return;
        }
        d3_geom_voronoiDetachCircle(lArc);
        d3_geom_voronoiDetachCircle(rArc);
        var lSite = lArc.site
          , ax = lSite.x
          , ay = lSite.y
          , bx = site.x - ax
          , by = site.y - ay
          , rSite = rArc.site
          , cx = rSite.x - ax
          , cy = rSite.y - ay
          , d = 2 * (bx * cy - by * cx)
          , hb = bx * bx + by * by
          , hc = cx * cx + cy * cy
          , vertex = {
            x: (cy * hb - by * hc) / d + ax,
            y: (bx * hc - cx * hb) / d + ay
        };
        d3_geom_voronoiSetEdgeEnd(rArc.edge, lSite, rSite, vertex);
        newArc.edge = d3_geom_voronoiCreateEdge(lSite, site, null, vertex);
        rArc.edge = d3_geom_voronoiCreateEdge(site, rSite, null, vertex);
        d3_geom_voronoiAttachCircle(lArc);
        d3_geom_voronoiAttachCircle(rArc);
    }
    function d3_geom_voronoiLeftBreakPoint(arc, directrix) {
        var site = arc.site
          , rfocx = site.x
          , rfocy = site.y
          , pby2 = rfocy - directrix;
        if (!pby2)
            return rfocx;
        var lArc = arc.P;
        if (!lArc)
            return -Infinity;
        site = lArc.site;
        var lfocx = site.x
          , lfocy = site.y
          , plby2 = lfocy - directrix;
        if (!plby2)
            return lfocx;
        var hl = lfocx - rfocx
          , aby2 = 1 / pby2 - 1 / plby2
          , b = hl / plby2;
        if (aby2)
            return (-b + Math.sqrt(b * b - 2 * aby2 * (hl * hl / (-2 * plby2) - lfocy + plby2 / 2 + rfocy - pby2 / 2))) / aby2 + rfocx;
        return (rfocx + lfocx) / 2;
    }
    function d3_geom_voronoiRightBreakPoint(arc, directrix) {
        var rArc = arc.N;
        if (rArc)
            return d3_geom_voronoiLeftBreakPoint(rArc, directrix);
        var site = arc.site;
        return site.y === directrix ? site.x : Infinity;
    }
    function d3_geom_voronoiCell(site) {
        this.site = site;
        this.edges = [];
    }
    d3_geom_voronoiCell.prototype.prepare = function() {
        var halfEdges = this.edges, iHalfEdge = halfEdges.length, edge;
        while (iHalfEdge--) {
            edge = halfEdges[iHalfEdge].edge;
            if (!edge.b || !edge.a)
                halfEdges.splice(iHalfEdge, 1);
        }
        halfEdges.sort(d3_geom_voronoiHalfEdgeOrder);
        return halfEdges.length;
    }
    ;
    function d3_geom_voronoiCloseCells(extent) {
        var x0 = extent[0][0], x1 = extent[1][0], y0 = extent[0][1], y1 = extent[1][1], x2, y2, x3, y3, cells = d3_geom_voronoiCells, iCell = cells.length, cell, iHalfEdge, halfEdges, nHalfEdges, start, end;
        while (iCell--) {
            cell = cells[iCell];
            if (!cell || !cell.prepare())
                continue;
            halfEdges = cell.edges;
            nHalfEdges = halfEdges.length;
            iHalfEdge = 0;
            while (iHalfEdge < nHalfEdges) {
                end = halfEdges[iHalfEdge].end(),
                x3 = end.x,
                y3 = end.y;
                start = halfEdges[++iHalfEdge % nHalfEdges].start(),
                x2 = start.x,
                y2 = start.y;
                if (abs(x3 - x2) > ε || abs(y3 - y2) > ε) {
                    halfEdges.splice(iHalfEdge, 0, new d3_geom_voronoiHalfEdge(d3_geom_voronoiCreateBorderEdge(cell.site, end, abs(x3 - x0) < ε && y1 - y3 > ε ? {
                        x: x0,
                        y: abs(x2 - x0) < ε ? y2 : y1
                    } : abs(y3 - y1) < ε && x1 - x3 > ε ? {
                        x: abs(y2 - y1) < ε ? x2 : x1,
                        y: y1
                    } : abs(x3 - x1) < ε && y3 - y0 > ε ? {
                        x: x1,
                        y: abs(x2 - x1) < ε ? y2 : y0
                    } : abs(y3 - y0) < ε && x3 - x0 > ε ? {
                        x: abs(y2 - y0) < ε ? x2 : x0,
                        y: y0
                    } : null),cell.site,null));
                    ++nHalfEdges;
                }
            }
        }
    }
    function d3_geom_voronoiHalfEdgeOrder(a, b) {
        return b.angle - a.angle;
    }
    function d3_geom_voronoiCircle() {
        d3_geom_voronoiRedBlackNode(this);
        this.x = this.y = this.arc = this.site = this.cy = null;
    }
    function d3_geom_voronoiAttachCircle(arc) {
        var lArc = arc.P
          , rArc = arc.N;
        if (!lArc || !rArc)
            return;
        var lSite = lArc.site
          , cSite = arc.site
          , rSite = rArc.site;
        if (lSite === rSite)
            return;
        var bx = cSite.x
          , by = cSite.y
          , ax = lSite.x - bx
          , ay = lSite.y - by
          , cx = rSite.x - bx
          , cy = rSite.y - by;
        var d = 2 * (ax * cy - ay * cx);
        if (d >= -ε2)
            return;
        var ha = ax * ax + ay * ay
          , hc = cx * cx + cy * cy
          , x = (cy * ha - ay * hc) / d
          , y = (ax * hc - cx * ha) / d
          , cy = y + by;
        var circle = d3_geom_voronoiCirclePool.pop() || new d3_geom_voronoiCircle();
        circle.arc = arc;
        circle.site = cSite;
        circle.x = x + bx;
        circle.y = cy + Math.sqrt(x * x + y * y);
        circle.cy = cy;
        arc.circle = circle;
        var before = null
          , node = d3_geom_voronoiCircles._;
        while (node) {
            if (circle.y < node.y || circle.y === node.y && circle.x <= node.x) {
                if (node.L)
                    node = node.L;
                else {
                    before = node.P;
                    break;
                }
            } else {
                if (node.R)
                    node = node.R;
                else {
                    before = node;
                    break;
                }
            }
        }
        d3_geom_voronoiCircles.insert(before, circle);
        if (!before)
            d3_geom_voronoiFirstCircle = circle;
    }
    function d3_geom_voronoiDetachCircle(arc) {
        var circle = arc.circle;
        if (circle) {
            if (!circle.P)
                d3_geom_voronoiFirstCircle = circle.N;
            d3_geom_voronoiCircles.remove(circle);
            d3_geom_voronoiCirclePool.push(circle);
            d3_geom_voronoiRedBlackNode(circle);
            arc.circle = null;
        }
    }
    function d3_geom_voronoiClipEdges(extent) {
        var edges = d3_geom_voronoiEdges, clip = d3_geom_clipLine(extent[0][0], extent[0][1], extent[1][0], extent[1][1]), i = edges.length, e;
        while (i--) {
            e = edges[i];
            if (!d3_geom_voronoiConnectEdge(e, extent) || !clip(e) || abs(e.a.x - e.b.x) < ε && abs(e.a.y - e.b.y) < ε) {
                e.a = e.b = null;
                edges.splice(i, 1);
            }
        }
    }
    function d3_geom_voronoiConnectEdge(edge, extent) {
        var vb = edge.b;
        if (vb)
            return true;
        var va = edge.a, x0 = extent[0][0], x1 = extent[1][0], y0 = extent[0][1], y1 = extent[1][1], lSite = edge.l, rSite = edge.r, lx = lSite.x, ly = lSite.y, rx = rSite.x, ry = rSite.y, fx = (lx + rx) / 2, fy = (ly + ry) / 2, fm, fb;
        if (ry === ly) {
            if (fx < x0 || fx >= x1)
                return;
            if (lx > rx) {
                if (!va)
                    va = {
                        x: fx,
                        y: y0
                    };
                else if (va.y >= y1)
                    return;
                vb = {
                    x: fx,
                    y: y1
                };
            } else {
                if (!va)
                    va = {
                        x: fx,
                        y: y1
                    };
                else if (va.y < y0)
                    return;
                vb = {
                    x: fx,
                    y: y0
                };
            }
        } else {
            fm = (lx - rx) / (ry - ly);
            fb = fy - fm * fx;
            if (fm < -1 || fm > 1) {
                if (lx > rx) {
                    if (!va)
                        va = {
                            x: (y0 - fb) / fm,
                            y: y0
                        };
                    else if (va.y >= y1)
                        return;
                    vb = {
                        x: (y1 - fb) / fm,
                        y: y1
                    };
                } else {
                    if (!va)
                        va = {
                            x: (y1 - fb) / fm,
                            y: y1
                        };
                    else if (va.y < y0)
                        return;
                    vb = {
                        x: (y0 - fb) / fm,
                        y: y0
                    };
                }
            } else {
                if (ly < ry) {
                    if (!va)
                        va = {
                            x: x0,
                            y: fm * x0 + fb
                        };
                    else if (va.x >= x1)
                        return;
                    vb = {
                        x: x1,
                        y: fm * x1 + fb
                    };
                } else {
                    if (!va)
                        va = {
                            x: x1,
                            y: fm * x1 + fb
                        };
                    else if (va.x < x0)
                        return;
                    vb = {
                        x: x0,
                        y: fm * x0 + fb
                    };
                }
            }
        }
        edge.a = va;
        edge.b = vb;
        return true;
    }
    function d3_geom_voronoiEdge(lSite, rSite) {
        this.l = lSite;
        this.r = rSite;
        this.a = this.b = null;
    }
    function d3_geom_voronoiCreateEdge(lSite, rSite, va, vb) {
        var edge = new d3_geom_voronoiEdge(lSite,rSite);
        d3_geom_voronoiEdges.push(edge);
        if (va)
            d3_geom_voronoiSetEdgeEnd(edge, lSite, rSite, va);
        if (vb)
            d3_geom_voronoiSetEdgeEnd(edge, rSite, lSite, vb);
        d3_geom_voronoiCells[lSite.i].edges.push(new d3_geom_voronoiHalfEdge(edge,lSite,rSite));
        d3_geom_voronoiCells[rSite.i].edges.push(new d3_geom_voronoiHalfEdge(edge,rSite,lSite));
        return edge;
    }
    function d3_geom_voronoiCreateBorderEdge(lSite, va, vb) {
        var edge = new d3_geom_voronoiEdge(lSite,null);
        edge.a = va;
        edge.b = vb;
        d3_geom_voronoiEdges.push(edge);
        return edge;
    }
    function d3_geom_voronoiSetEdgeEnd(edge, lSite, rSite, vertex) {
        if (!edge.a && !edge.b) {
            edge.a = vertex;
            edge.l = lSite;
            edge.r = rSite;
        } else if (edge.l === rSite) {
            edge.b = vertex;
        } else {
            edge.a = vertex;
        }
    }
    function d3_geom_voronoiHalfEdge(edge, lSite, rSite) {
        var va = edge.a
          , vb = edge.b;
        this.edge = edge;
        this.site = lSite;
        this.angle = rSite ? Math.atan2(rSite.y - lSite.y, rSite.x - lSite.x) : edge.l === lSite ? Math.atan2(vb.x - va.x, va.y - vb.y) : Math.atan2(va.x - vb.x, vb.y - va.y);
    }
    d3_geom_voronoiHalfEdge.prototype = {
        start: function() {
            return this.edge.l === this.site ? this.edge.a : this.edge.b;
        },
        end: function() {
            return this.edge.l === this.site ? this.edge.b : this.edge.a;
        }
    };
    function d3_geom_voronoiRedBlackTree() {
        this._ = null;
    }
    function d3_geom_voronoiRedBlackNode(node) {
        node.U = node.C = node.L = node.R = node.P = node.N = null;
    }
    d3_geom_voronoiRedBlackTree.prototype = {
        insert: function(after, node) {
            var parent, grandpa, uncle;
            if (after) {
                node.P = after;
                node.N = after.N;
                if (after.N)
                    after.N.P = node;
                after.N = node;
                if (after.R) {
                    after = after.R;
                    while (after.L)
                        after = after.L;
                    after.L = node;
                } else {
                    after.R = node;
                }
                parent = after;
            } else if (this._) {
                after = d3_geom_voronoiRedBlackFirst(this._);
                node.P = null;
                node.N = after;
                after.P = after.L = node;
                parent = after;
            } else {
                node.P = node.N = null;
                this._ = node;
                parent = null;
            }
            node.L = node.R = null;
            node.U = parent;
            node.C = true;
            after = node;
            while (parent && parent.C) {
                grandpa = parent.U;
                if (parent === grandpa.L) {
                    uncle = grandpa.R;
                    if (uncle && uncle.C) {
                        parent.C = uncle.C = false;
                        grandpa.C = true;
                        after = grandpa;
                    } else {
                        if (after === parent.R) {
                            d3_geom_voronoiRedBlackRotateLeft(this, parent);
                            after = parent;
                            parent = after.U;
                        }
                        parent.C = false;
                        grandpa.C = true;
                        d3_geom_voronoiRedBlackRotateRight(this, grandpa);
                    }
                } else {
                    uncle = grandpa.L;
                    if (uncle && uncle.C) {
                        parent.C = uncle.C = false;
                        grandpa.C = true;
                        after = grandpa;
                    } else {
                        if (after === parent.L) {
                            d3_geom_voronoiRedBlackRotateRight(this, parent);
                            after = parent;
                            parent = after.U;
                        }
                        parent.C = false;
                        grandpa.C = true;
                        d3_geom_voronoiRedBlackRotateLeft(this, grandpa);
                    }
                }
                parent = after.U;
            }
            this._.C = false;
        },
        remove: function(node) {
            if (node.N)
                node.N.P = node.P;
            if (node.P)
                node.P.N = node.N;
            node.N = node.P = null;
            var parent = node.U, sibling, left = node.L, right = node.R, next, red;
            if (!left)
                next = right;
            else if (!right)
                next = left;
            else
                next = d3_geom_voronoiRedBlackFirst(right);
            if (parent) {
                if (parent.L === node)
                    parent.L = next;
                else
                    parent.R = next;
            } else {
                this._ = next;
            }
            if (left && right) {
                red = next.C;
                next.C = node.C;
                next.L = left;
                left.U = next;
                if (next !== right) {
                    parent = next.U;
                    next.U = node.U;
                    node = next.R;
                    parent.L = node;
                    next.R = right;
                    right.U = next;
                } else {
                    next.U = parent;
                    parent = next;
                    node = next.R;
                }
            } else {
                red = node.C;
                node = next;
            }
            if (node)
                node.U = parent;
            if (red)
                return;
            if (node && node.C) {
                node.C = false;
                return;
            }
            do {
                if (node === this._)
                    break;
                if (node === parent.L) {
                    sibling = parent.R;
                    if (sibling.C) {
                        sibling.C = false;
                        parent.C = true;
                        d3_geom_voronoiRedBlackRotateLeft(this, parent);
                        sibling = parent.R;
                    }
                    if (sibling.L && sibling.L.C || sibling.R && sibling.R.C) {
                        if (!sibling.R || !sibling.R.C) {
                            sibling.L.C = false;
                            sibling.C = true;
                            d3_geom_voronoiRedBlackRotateRight(this, sibling);
                            sibling = parent.R;
                        }
                        sibling.C = parent.C;
                        parent.C = sibling.R.C = false;
                        d3_geom_voronoiRedBlackRotateLeft(this, parent);
                        node = this._;
                        break;
                    }
                } else {
                    sibling = parent.L;
                    if (sibling.C) {
                        sibling.C = false;
                        parent.C = true;
                        d3_geom_voronoiRedBlackRotateRight(this, parent);
                        sibling = parent.L;
                    }
                    if (sibling.L && sibling.L.C || sibling.R && sibling.R.C) {
                        if (!sibling.L || !sibling.L.C) {
                            sibling.R.C = false;
                            sibling.C = true;
                            d3_geom_voronoiRedBlackRotateLeft(this, sibling);
                            sibling = parent.L;
                        }
                        sibling.C = parent.C;
                        parent.C = sibling.L.C = false;
                        d3_geom_voronoiRedBlackRotateRight(this, parent);
                        node = this._;
                        break;
                    }
                }
                sibling.C = true;
                node = parent;
                parent = parent.U;
            } while (!node.C);if (node)
                node.C = false;
        }
    };
    function d3_geom_voronoiRedBlackRotateLeft(tree, node) {
        var p = node
          , q = node.R
          , parent = p.U;
        if (parent) {
            if (parent.L === p)
                parent.L = q;
            else
                parent.R = q;
        } else {
            tree._ = q;
        }
        q.U = parent;
        p.U = q;
        p.R = q.L;
        if (p.R)
            p.R.U = p;
        q.L = p;
    }
    function d3_geom_voronoiRedBlackRotateRight(tree, node) {
        var p = node
          , q = node.L
          , parent = p.U;
        if (parent) {
            if (parent.L === p)
                parent.L = q;
            else
                parent.R = q;
        } else {
            tree._ = q;
        }
        q.U = parent;
        p.U = q;
        p.L = q.R;
        if (p.L)
            p.L.U = p;
        q.R = p;
    }
    function d3_geom_voronoiRedBlackFirst(node) {
        while (node.L)
            node = node.L;
        return node;
    }
    function d3_geom_voronoi(sites, bbox) {
        var site = sites.sort(d3_geom_voronoiVertexOrder).pop(), x0, y0, circle;
        d3_geom_voronoiEdges = [];
        d3_geom_voronoiCells = new Array(sites.length);
        d3_geom_voronoiBeaches = new d3_geom_voronoiRedBlackTree();
        d3_geom_voronoiCircles = new d3_geom_voronoiRedBlackTree();
        while (true) {
            circle = d3_geom_voronoiFirstCircle;
            if (site && (!circle || site.y < circle.y || site.y === circle.y && site.x < circle.x)) {
                if (site.x !== x0 || site.y !== y0) {
                    d3_geom_voronoiCells[site.i] = new d3_geom_voronoiCell(site);
                    d3_geom_voronoiAddBeach(site);
                    x0 = site.x,
                    y0 = site.y;
                }
                site = sites.pop();
            } else if (circle) {
                d3_geom_voronoiRemoveBeach(circle.arc);
            } else {
                break;
            }
        }
        if (bbox)
            d3_geom_voronoiClipEdges(bbox),
            d3_geom_voronoiCloseCells(bbox);
        var diagram = {
            cells: d3_geom_voronoiCells,
            edges: d3_geom_voronoiEdges
        };
        d3_geom_voronoiBeaches = d3_geom_voronoiCircles = d3_geom_voronoiEdges = d3_geom_voronoiCells = null;
        return diagram;
    }
    function d3_geom_voronoiVertexOrder(a, b) {
        return b.y - a.y || b.x - a.x;
    }
    d3.geom.voronoi = function(points) {
        var x = d3_geom_pointX
          , y = d3_geom_pointY
          , fx = x
          , fy = y
          , clipExtent = d3_geom_voronoiClipExtent;
        if (points)
            return voronoi(points);
        function voronoi(data) {
            var polygons = new Array(data.length)
              , x0 = clipExtent[0][0]
              , y0 = clipExtent[0][1]
              , x1 = clipExtent[1][0]
              , y1 = clipExtent[1][1];
            d3_geom_voronoi(sites(data), clipExtent).cells.forEach(function(cell, i) {
                var edges = cell.edges
                  , site = cell.site
                  , polygon = polygons[i] = edges.length ? edges.map(function(e) {
                    var s = e.start();
                    return [s.x, s.y];
                }) : site.x >= x0 && site.x <= x1 && site.y >= y0 && site.y <= y1 ? [[x0, y1], [x1, y1], [x1, y0], [x0, y0]] : [];
                polygon.point = data[i];
            });
            return polygons;
        }
        function sites(data) {
            return data.map(function(d, i) {
                return {
                    x: Math.round(fx(d, i) / ε) * ε,
                    y: Math.round(fy(d, i) / ε) * ε,
                    i: i
                };
            });
        }
        voronoi.links = function(data) {
            return d3_geom_voronoi(sites(data)).edges.filter(function(edge) {
                return edge.l && edge.r;
            }).map(function(edge) {
                return {
                    source: data[edge.l.i],
                    target: data[edge.r.i]
                };
            });
        }
        ;
        voronoi.triangles = function(data) {
            var triangles = [];
            d3_geom_voronoi(sites(data)).cells.forEach(function(cell, i) {
                var site = cell.site, edges = cell.edges.sort(d3_geom_voronoiHalfEdgeOrder), j = -1, m = edges.length, e0, s0, e1 = edges[m - 1].edge, s1 = e1.l === site ? e1.r : e1.l;
                while (++j < m) {
                    e0 = e1;
                    s0 = s1;
                    e1 = edges[j].edge;
                    s1 = e1.l === site ? e1.r : e1.l;
                    if (i < s0.i && i < s1.i && d3_geom_voronoiTriangleArea(site, s0, s1) < 0) {
                        triangles.push([data[i], data[s0.i], data[s1.i]]);
                    }
                }
            });
            return triangles;
        }
        ;
        voronoi.x = function(_) {
            return arguments.length ? (fx = d3_functor(x = _),
            voronoi) : x;
        }
        ;
        voronoi.y = function(_) {
            return arguments.length ? (fy = d3_functor(y = _),
            voronoi) : y;
        }
        ;
        voronoi.clipExtent = function(_) {
            if (!arguments.length)
                return clipExtent === d3_geom_voronoiClipExtent ? null : clipExtent;
            clipExtent = _ == null ? d3_geom_voronoiClipExtent : _;
            return voronoi;
        }
        ;
        voronoi.size = function(_) {
            if (!arguments.length)
                return clipExtent === d3_geom_voronoiClipExtent ? null : clipExtent && clipExtent[1];
            return voronoi.clipExtent(_ && [[0, 0], _]);
        }
        ;
        return voronoi;
    }
    ;
    var d3_geom_voronoiClipExtent = [[-1e6, -1e6], [1e6, 1e6]];
    function d3_geom_voronoiTriangleArea(a, b, c) {
        return (a.x - c.x) * (b.y - a.y) - (a.x - b.x) * (c.y - a.y);
    }
    d3.geom.delaunay = function(vertices) {
        return d3.geom.voronoi().triangles(vertices);
    }
    ;
    d3.geom.quadtree = function(points, x1, y1, x2, y2) {
        var x = d3_geom_pointX, y = d3_geom_pointY, compat;
        if (compat = arguments.length) {
            x = d3_geom_quadtreeCompatX;
            y = d3_geom_quadtreeCompatY;
            if (compat === 3) {
                y2 = y1;
                x2 = x1;
                y1 = x1 = 0;
            }
            return quadtree(points);
        }
        function quadtree(data) {
            var d, fx = d3_functor(x), fy = d3_functor(y), xs, ys, i, n, x1_, y1_, x2_, y2_;
            if (x1 != null) {
                x1_ = x1,
                y1_ = y1,
                x2_ = x2,
                y2_ = y2;
            } else {
                x2_ = y2_ = -(x1_ = y1_ = Infinity);
                xs = [],
                ys = [];
                n = data.length;
                if (compat)
                    for (i = 0; i < n; ++i) {
                        d = data[i];
                        if (d.x < x1_)
                            x1_ = d.x;
                        if (d.y < y1_)
                            y1_ = d.y;
                        if (d.x > x2_)
                            x2_ = d.x;
                        if (d.y > y2_)
                            y2_ = d.y;
                        xs.push(d.x);
                        ys.push(d.y);
                    }
                else
                    for (i = 0; i < n; ++i) {
                        var x_ = +fx(d = data[i], i)
                          , y_ = +fy(d, i);
                        if (x_ < x1_)
                            x1_ = x_;
                        if (y_ < y1_)
                            y1_ = y_;
                        if (x_ > x2_)
                            x2_ = x_;
                        if (y_ > y2_)
                            y2_ = y_;
                        xs.push(x_);
                        ys.push(y_);
                    }
            }
            var dx = x2_ - x1_
              , dy = y2_ - y1_;
            if (dx > dy)
                y2_ = y1_ + dx;
            else
                x2_ = x1_ + dy;
            function insert(n, d, x, y, x1, y1, x2, y2) {
                if (isNaN(x) || isNaN(y))
                    return;
                if (n.leaf) {
                    var nx = n.x
                      , ny = n.y;
                    if (nx != null) {
                        if (abs(nx - x) + abs(ny - y) < .01) {
                            insertChild(n, d, x, y, x1, y1, x2, y2);
                        } else {
                            var nPoint = n.point;
                            n.x = n.y = n.point = null;
                            insertChild(n, nPoint, nx, ny, x1, y1, x2, y2);
                            insertChild(n, d, x, y, x1, y1, x2, y2);
                        }
                    } else {
                        n.x = x,
                        n.y = y,
                        n.point = d;
                    }
                } else {
                    insertChild(n, d, x, y, x1, y1, x2, y2);
                }
            }
            function insertChild(n, d, x, y, x1, y1, x2, y2) {
                var sx = (x1 + x2) * .5
                  , sy = (y1 + y2) * .5
                  , right = x >= sx
                  , bottom = y >= sy
                  , i = (bottom << 1) + right;
                n.leaf = false;
                n = n.nodes[i] || (n.nodes[i] = d3_geom_quadtreeNode());
                if (right)
                    x1 = sx;
                else
                    x2 = sx;
                if (bottom)
                    y1 = sy;
                else
                    y2 = sy;
                insert(n, d, x, y, x1, y1, x2, y2);
            }
            var root = d3_geom_quadtreeNode();
            root.add = function(d) {
                insert(root, d, +fx(d, ++i), +fy(d, i), x1_, y1_, x2_, y2_);
            }
            ;
            root.visit = function(f) {
                d3_geom_quadtreeVisit(f, root, x1_, y1_, x2_, y2_);
            }
            ;
            i = -1;
            if (x1 == null) {
                while (++i < n) {
                    insert(root, data[i], xs[i], ys[i], x1_, y1_, x2_, y2_);
                }
                --i;
            } else
                data.forEach(root.add);
            xs = ys = data = d = null;
            return root;
        }
        quadtree.x = function(_) {
            return arguments.length ? (x = _,
            quadtree) : x;
        }
        ;
        quadtree.y = function(_) {
            return arguments.length ? (y = _,
            quadtree) : y;
        }
        ;
        quadtree.extent = function(_) {
            if (!arguments.length)
                return x1 == null ? null : [[x1, y1], [x2, y2]];
            if (_ == null)
                x1 = y1 = x2 = y2 = null;
            else
                x1 = +_[0][0],
                y1 = +_[0][1],
                x2 = +_[1][0],
                y2 = +_[1][1];
            return quadtree;
        }
        ;
        quadtree.size = function(_) {
            if (!arguments.length)
                return x1 == null ? null : [x2 - x1, y2 - y1];
            if (_ == null)
                x1 = y1 = x2 = y2 = null;
            else
                x1 = y1 = 0,
                x2 = +_[0],
                y2 = +_[1];
            return quadtree;
        }
        ;
        return quadtree;
    }
    ;
    function d3_geom_quadtreeCompatX(d) {
        return d.x;
    }
    function d3_geom_quadtreeCompatY(d) {
        return d.y;
    }
    function d3_geom_quadtreeNode() {
        return {
            leaf: true,
            nodes: [],
            point: null,
            x: null,
            y: null
        };
    }
    function d3_geom_quadtreeVisit(f, node, x1, y1, x2, y2) {
        if (!f(node, x1, y1, x2, y2)) {
            var sx = (x1 + x2) * .5
              , sy = (y1 + y2) * .5
              , children = node.nodes;
            if (children[0])
                d3_geom_quadtreeVisit(f, children[0], x1, y1, sx, sy);
            if (children[1])
                d3_geom_quadtreeVisit(f, children[1], sx, y1, x2, sy);
            if (children[2])
                d3_geom_quadtreeVisit(f, children[2], x1, sy, sx, y2);
            if (children[3])
                d3_geom_quadtreeVisit(f, children[3], sx, sy, x2, y2);
        }
    }
    d3.interpolateRgb = d3_interpolateRgb;
    function d3_interpolateRgb(a, b) {
        a = d3.rgb(a);
        b = d3.rgb(b);
        var ar = a.r
          , ag = a.g
          , ab = a.b
          , br = b.r - ar
          , bg = b.g - ag
          , bb = b.b - ab;
        return function(t) {
            return "#" + d3_rgb_hex(Math.round(ar + br * t)) + d3_rgb_hex(Math.round(ag + bg * t)) + d3_rgb_hex(Math.round(ab + bb * t));
        }
        ;
    }
    d3.interpolateObject = d3_interpolateObject;
    function d3_interpolateObject(a, b) {
        var i = {}, c = {}, k;
        for (k in a) {
            if (k in b) {
                i[k] = d3_interpolate(a[k], b[k]);
            } else {
                c[k] = a[k];
            }
        }
        for (k in b) {
            if (!(k in a)) {
                c[k] = b[k];
            }
        }
        return function(t) {
            for (k in i)
                c[k] = i[k](t);
            return c;
        }
        ;
    }
    d3.interpolateNumber = d3_interpolateNumber;
    function d3_interpolateNumber(a, b) {
        b -= a = +a;
        return function(t) {
            return a + b * t;
        }
        ;
    }
    d3.interpolateString = d3_interpolateString;
    function d3_interpolateString(a, b) {
        var bi = d3_interpolate_numberA.lastIndex = d3_interpolate_numberB.lastIndex = 0, am, bm, bs, i = -1, s = [], q = [];
        a = a + "",
        b = b + "";
        while ((am = d3_interpolate_numberA.exec(a)) && (bm = d3_interpolate_numberB.exec(b))) {
            if ((bs = bm.index) > bi) {
                bs = b.substring(bi, bs);
                if (s[i])
                    s[i] += bs;
                else
                    s[++i] = bs;
            }
            if ((am = am[0]) === (bm = bm[0])) {
                if (s[i])
                    s[i] += bm;
                else
                    s[++i] = bm;
            } else {
                s[++i] = null;
                q.push({
                    i: i,
                    x: d3_interpolateNumber(am, bm)
                });
            }
            bi = d3_interpolate_numberB.lastIndex;
        }
        if (bi < b.length) {
            bs = b.substring(bi);
            if (s[i])
                s[i] += bs;
            else
                s[++i] = bs;
        }
        return s.length < 2 ? q[0] ? (b = q[0].x,
        function(t) {
            return b(t) + "";
        }
        ) : function() {
            return b;
        }
        : (b = q.length,
        function(t) {
            for (var i = 0, o; i < b; ++i)
                s[(o = q[i]).i] = o.x(t);
            return s.join("");
        }
        );
    }
    var d3_interpolate_numberA = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g
      , d3_interpolate_numberB = new RegExp(d3_interpolate_numberA.source,"g");
    d3.interpolate = d3_interpolate;
    function d3_interpolate(a, b) {
        var i = d3.interpolators.length, f;
        while (--i >= 0 && !(f = d3.interpolators[i](a, b)))
            ;
        return f;
    }
    d3.interpolators = [function(a, b) {
        var t = typeof b;
        return (t === "string" ? d3_rgb_names.has(b) || /^(#|rgb\(|hsl\()/.test(b) ? d3_interpolateRgb : d3_interpolateString : b instanceof d3_Color ? d3_interpolateRgb : Array.isArray(b) ? d3_interpolateArray : t === "object" && isNaN(b) ? d3_interpolateObject : d3_interpolateNumber)(a, b);
    }
    ];
    d3.interpolateArray = d3_interpolateArray;
    function d3_interpolateArray(a, b) {
        var x = [], c = [], na = a.length, nb = b.length, n0 = Math.min(a.length, b.length), i;
        for (i = 0; i < n0; ++i)
            x.push(d3_interpolate(a[i], b[i]));
        for (; i < na; ++i)
            c[i] = a[i];
        for (; i < nb; ++i)
            c[i] = b[i];
        return function(t) {
            for (i = 0; i < n0; ++i)
                c[i] = x[i](t);
            return c;
        }
        ;
    }
    var d3_ease_default = function() {
        return d3_identity;
    };
    var d3_ease = d3.map({
        linear: d3_ease_default,
        poly: d3_ease_poly,
        quad: function() {
            return d3_ease_quad;
        },
        cubic: function() {
            return d3_ease_cubic;
        },
        sin: function() {
            return d3_ease_sin;
        },
        exp: function() {
            return d3_ease_exp;
        },
        circle: function() {
            return d3_ease_circle;
        },
        elastic: d3_ease_elastic,
        back: d3_ease_back,
        bounce: function() {
            return d3_ease_bounce;
        }
    });
    var d3_ease_mode = d3.map({
        "in": d3_identity,
        out: d3_ease_reverse,
        "in-out": d3_ease_reflect,
        "out-in": function(f) {
            return d3_ease_reflect(d3_ease_reverse(f));
        }
    });
    d3.ease = function(name) {
        var i = name.indexOf("-")
          , t = i >= 0 ? name.substring(0, i) : name
          , m = i >= 0 ? name.substring(i + 1) : "in";
        t = d3_ease.get(t) || d3_ease_default;
        m = d3_ease_mode.get(m) || d3_identity;
        return d3_ease_clamp(m(t.apply(null, d3_arraySlice.call(arguments, 1))));
    }
    ;
    function d3_ease_clamp(f) {
        return function(t) {
            return t <= 0 ? 0 : t >= 1 ? 1 : f(t);
        }
        ;
    }
    function d3_ease_reverse(f) {
        return function(t) {
            return 1 - f(1 - t);
        }
        ;
    }
    function d3_ease_reflect(f) {
        return function(t) {
            return .5 * (t < .5 ? f(2 * t) : 2 - f(2 - 2 * t));
        }
        ;
    }
    function d3_ease_quad(t) {
        return t * t;
    }
    function d3_ease_cubic(t) {
        return t * t * t;
    }
    function d3_ease_cubicInOut(t) {
        if (t <= 0)
            return 0;
        if (t >= 1)
            return 1;
        var t2 = t * t
          , t3 = t2 * t;
        return 4 * (t < .5 ? t3 : 3 * (t - t2) + t3 - .75);
    }
    function d3_ease_poly(e) {
        return function(t) {
            return Math.pow(t, e);
        }
        ;
    }
    function d3_ease_sin(t) {
        return 1 - Math.cos(t * halfπ);
    }
    function d3_ease_exp(t) {
        return Math.pow(2, 10 * (t - 1));
    }
    function d3_ease_circle(t) {
        return 1 - Math.sqrt(1 - t * t);
    }
    function d3_ease_elastic(a, p) {
        var s;
        if (arguments.length < 2)
            p = .45;
        if (arguments.length)
            s = p / τ * Math.asin(1 / a);
        else
            a = 1,
            s = p / 4;
        return function(t) {
            return 1 + a * Math.pow(2, -10 * t) * Math.sin((t - s) * τ / p);
        }
        ;
    }
    function d3_ease_back(s) {
        if (!s)
            s = 1.70158;
        return function(t) {
            return t * t * ((s + 1) * t - s);
        }
        ;
    }
    function d3_ease_bounce(t) {
        return t < 1 / 2.75 ? 7.5625 * t * t : t < 2 / 2.75 ? 7.5625 * (t -= 1.5 / 2.75) * t + .75 : t < 2.5 / 2.75 ? 7.5625 * (t -= 2.25 / 2.75) * t + .9375 : 7.5625 * (t -= 2.625 / 2.75) * t + .984375;
    }
    d3.interpolateHcl = d3_interpolateHcl;
    function d3_interpolateHcl(a, b) {
        a = d3.hcl(a);
        b = d3.hcl(b);
        var ah = a.h
          , ac = a.c
          , al = a.l
          , bh = b.h - ah
          , bc = b.c - ac
          , bl = b.l - al;
        if (isNaN(bc))
            bc = 0,
            ac = isNaN(ac) ? b.c : ac;
        if (isNaN(bh))
            bh = 0,
            ah = isNaN(ah) ? b.h : ah;
        else if (bh > 180)
            bh -= 360;
        else if (bh < -180)
            bh += 360;
        return function(t) {
            return d3_hcl_lab(ah + bh * t, ac + bc * t, al + bl * t) + "";
        }
        ;
    }
    d3.interpolateHsl = d3_interpolateHsl;
    function d3_interpolateHsl(a, b) {
        a = d3.hsl(a);
        b = d3.hsl(b);
        var ah = a.h
          , as = a.s
          , al = a.l
          , bh = b.h - ah
          , bs = b.s - as
          , bl = b.l - al;
        if (isNaN(bs))
            bs = 0,
            as = isNaN(as) ? b.s : as;
        if (isNaN(bh))
            bh = 0,
            ah = isNaN(ah) ? b.h : ah;
        else if (bh > 180)
            bh -= 360;
        else if (bh < -180)
            bh += 360;
        return function(t) {
            return d3_hsl_rgb(ah + bh * t, as + bs * t, al + bl * t) + "";
        }
        ;
    }
    d3.interpolateLab = d3_interpolateLab;
    function d3_interpolateLab(a, b) {
        a = d3.lab(a);
        b = d3.lab(b);
        var al = a.l
          , aa = a.a
          , ab = a.b
          , bl = b.l - al
          , ba = b.a - aa
          , bb = b.b - ab;
        return function(t) {
            return d3_lab_rgb(al + bl * t, aa + ba * t, ab + bb * t) + "";
        }
        ;
    }
    d3.interpolateRound = d3_interpolateRound;
    function d3_interpolateRound(a, b) {
        b -= a;
        return function(t) {
            return Math.round(a + b * t);
        }
        ;
    }
    d3.transform = function(string) {
        var g = d3_document.createElementNS(d3.ns.prefix.svg, "g");
        return (d3.transform = function(string) {
            if (string != null) {
                g.setAttribute("transform", string);
                var t = g.transform.baseVal.consolidate();
            }
            return new d3_transform(t ? t.matrix : d3_transformIdentity);
        }
        )(string);
    }
    ;
    function d3_transform(m) {
        var r0 = [m.a, m.b]
          , r1 = [m.c, m.d]
          , kx = d3_transformNormalize(r0)
          , kz = d3_transformDot(r0, r1)
          , ky = d3_transformNormalize(d3_transformCombine(r1, r0, -kz)) || 0;
        if (r0[0] * r1[1] < r1[0] * r0[1]) {
            r0[0] *= -1;
            r0[1] *= -1;
            kx *= -1;
            kz *= -1;
        }
        this.rotate = (kx ? Math.atan2(r0[1], r0[0]) : Math.atan2(-r1[0], r1[1])) * d3_degrees;
        this.translate = [m.e, m.f];
        this.scale = [kx, ky];
        this.skew = ky ? Math.atan2(kz, ky) * d3_degrees : 0;
    }
    d3_transform.prototype.toString = function() {
        return "translate(" + this.translate + ")rotate(" + this.rotate + ")skewX(" + this.skew + ")scale(" + this.scale + ")";
    }
    ;
    function d3_transformDot(a, b) {
        return a[0] * b[0] + a[1] * b[1];
    }
    function d3_transformNormalize(a) {
        var k = Math.sqrt(d3_transformDot(a, a));
        if (k) {
            a[0] /= k;
            a[1] /= k;
        }
        return k;
    }
    function d3_transformCombine(a, b, k) {
        a[0] += k * b[0];
        a[1] += k * b[1];
        return a;
    }
    var d3_transformIdentity = {
        a: 1,
        b: 0,
        c: 0,
        d: 1,
        e: 0,
        f: 0
    };
    d3.interpolateTransform = d3_interpolateTransform;
    function d3_interpolateTransform(a, b) {
        var s = [], q = [], n, A = d3.transform(a), B = d3.transform(b), ta = A.translate, tb = B.translate, ra = A.rotate, rb = B.rotate, wa = A.skew, wb = B.skew, ka = A.scale, kb = B.scale;
        if (ta[0] != tb[0] || ta[1] != tb[1]) {
            s.push("translate(", null, ",", null, ")");
            q.push({
                i: 1,
                x: d3_interpolateNumber(ta[0], tb[0])
            }, {
                i: 3,
                x: d3_interpolateNumber(ta[1], tb[1])
            });
        } else if (tb[0] || tb[1]) {
            s.push("translate(" + tb + ")");
        } else {
            s.push("");
        }
        if (ra != rb) {
            if (ra - rb > 180)
                rb += 360;
            else if (rb - ra > 180)
                ra += 360;
            q.push({
                i: s.push(s.pop() + "rotate(", null, ")") - 2,
                x: d3_interpolateNumber(ra, rb)
            });
        } else if (rb) {
            s.push(s.pop() + "rotate(" + rb + ")");
        }
        if (wa != wb) {
            q.push({
                i: s.push(s.pop() + "skewX(", null, ")") - 2,
                x: d3_interpolateNumber(wa, wb)
            });
        } else if (wb) {
            s.push(s.pop() + "skewX(" + wb + ")");
        }
        if (ka[0] != kb[0] || ka[1] != kb[1]) {
            n = s.push(s.pop() + "scale(", null, ",", null, ")");
            q.push({
                i: n - 4,
                x: d3_interpolateNumber(ka[0], kb[0])
            }, {
                i: n - 2,
                x: d3_interpolateNumber(ka[1], kb[1])
            });
        } else if (kb[0] != 1 || kb[1] != 1) {
            s.push(s.pop() + "scale(" + kb + ")");
        }
        n = q.length;
        return function(t) {
            var i = -1, o;
            while (++i < n)
                s[(o = q[i]).i] = o.x(t);
            return s.join("");
        }
        ;
    }
    function d3_uninterpolateNumber(a, b) {
        b = b - (a = +a) ? 1 / (b - a) : 0;
        return function(x) {
            return (x - a) * b;
        }
        ;
    }
    function d3_uninterpolateClamp(a, b) {
        b = b - (a = +a) ? 1 / (b - a) : 0;
        return function(x) {
            return Math.max(0, Math.min(1, (x - a) * b));
        }
        ;
    }
    d3.layout = {};
    d3.layout.bundle = function() {
        return function(links) {
            var paths = []
              , i = -1
              , n = links.length;
            while (++i < n)
                paths.push(d3_layout_bundlePath(links[i]));
            return paths;
        }
        ;
    }
    ;
    function d3_layout_bundlePath(link) {
        var start = link.source
          , end = link.target
          , lca = d3_layout_bundleLeastCommonAncestor(start, end)
          , points = [start];
        while (start !== lca) {
            start = start.parent;
            points.push(start);
        }
        var k = points.length;
        while (end !== lca) {
            points.splice(k, 0, end);
            end = end.parent;
        }
        return points;
    }
    function d3_layout_bundleAncestors(node) {
        var ancestors = []
          , parent = node.parent;
        while (parent != null) {
            ancestors.push(node);
            node = parent;
            parent = parent.parent;
        }
        ancestors.push(node);
        return ancestors;
    }
    function d3_layout_bundleLeastCommonAncestor(a, b) {
        if (a === b)
            return a;
        var aNodes = d3_layout_bundleAncestors(a)
          , bNodes = d3_layout_bundleAncestors(b)
          , aNode = aNodes.pop()
          , bNode = bNodes.pop()
          , sharedNode = null;
        while (aNode === bNode) {
            sharedNode = aNode;
            aNode = aNodes.pop();
            bNode = bNodes.pop();
        }
        return sharedNode;
    }
    d3.layout.chord = function() {
        var chord = {}, chords, groups, matrix, n, padding = 0, sortGroups, sortSubgroups, sortChords;
        function relayout() {
            var subgroups = {}, groupSums = [], groupIndex = d3.range(n), subgroupIndex = [], k, x, x0, i, j;
            chords = [];
            groups = [];
            k = 0,
            i = -1;
            while (++i < n) {
                x = 0,
                j = -1;
                while (++j < n) {
                    x += matrix[i][j];
                }
                groupSums.push(x);
                subgroupIndex.push(d3.range(n));
                k += x;
            }
            if (sortGroups) {
                groupIndex.sort(function(a, b) {
                    return sortGroups(groupSums[a], groupSums[b]);
                });
            }
            if (sortSubgroups) {
                subgroupIndex.forEach(function(d, i) {
                    d.sort(function(a, b) {
                        return sortSubgroups(matrix[i][a], matrix[i][b]);
                    });
                });
            }
            k = (τ - padding * n) / k;
            x = 0,
            i = -1;
            while (++i < n) {
                x0 = x,
                j = -1;
                while (++j < n) {
                    var di = groupIndex[i]
                      , dj = subgroupIndex[di][j]
                      , v = matrix[di][dj]
                      , a0 = x
                      , a1 = x += v * k;
                    subgroups[di + "-" + dj] = {
                        index: di,
                        subindex: dj,
                        startAngle: a0,
                        endAngle: a1,
                        value: v
                    };
                }
                groups[di] = {
                    index: di,
                    startAngle: x0,
                    endAngle: x,
                    value: (x - x0) / k
                };
                x += padding;
            }
            i = -1;
            while (++i < n) {
                j = i - 1;
                while (++j < n) {
                    var source = subgroups[i + "-" + j]
                      , target = subgroups[j + "-" + i];
                    if (source.value || target.value) {
                        chords.push(source.value < target.value ? {
                            source: target,
                            target: source
                        } : {
                            source: source,
                            target: target
                        });
                    }
                }
            }
            if (sortChords)
                resort();
        }
        function resort() {
            chords.sort(function(a, b) {
                return sortChords((a.source.value + a.target.value) / 2, (b.source.value + b.target.value) / 2);
            });
        }
        chord.matrix = function(x) {
            if (!arguments.length)
                return matrix;
            n = (matrix = x) && matrix.length;
            chords = groups = null;
            return chord;
        }
        ;
        chord.padding = function(x) {
            if (!arguments.length)
                return padding;
            padding = x;
            chords = groups = null;
            return chord;
        }
        ;
        chord.sortGroups = function(x) {
            if (!arguments.length)
                return sortGroups;
            sortGroups = x;
            chords = groups = null;
            return chord;
        }
        ;
        chord.sortSubgroups = function(x) {
            if (!arguments.length)
                return sortSubgroups;
            sortSubgroups = x;
            chords = null;
            return chord;
        }
        ;
        chord.sortChords = function(x) {
            if (!arguments.length)
                return sortChords;
            sortChords = x;
            if (chords)
                resort();
            return chord;
        }
        ;
        chord.chords = function() {
            if (!chords)
                relayout();
            return chords;
        }
        ;
        chord.groups = function() {
            if (!groups)
                relayout();
            return groups;
        }
        ;
        return chord;
    }
    ;
    d3.layout.force = function() {
        var force = {}, event = d3.dispatch("start", "tick", "end"), size = [1, 1], drag, alpha, friction = .9, linkDistance = d3_layout_forceLinkDistance, linkStrength = d3_layout_forceLinkStrength, charge = -30, chargeDistance2 = d3_layout_forceChargeDistance2, gravity = .1, theta2 = .64, nodes = [], links = [], distances, strengths, charges;
        function repulse(node) {
            return function(quad, x1, _, x2) {
                if (quad.point !== node) {
                    var dx = quad.cx - node.x
                      , dy = quad.cy - node.y
                      , dw = x2 - x1
                      , dn = dx * dx + dy * dy;
                    if (dw * dw / theta2 < dn) {
                        if (dn < chargeDistance2) {
                            var k = quad.charge / dn;
                            node.px -= dx * k;
                            node.py -= dy * k;
                        }
                        return true;
                    }
                    if (quad.point && dn && dn < chargeDistance2) {
                        var k = quad.pointCharge / dn;
                        node.px -= dx * k;
                        node.py -= dy * k;
                    }
                }
                return !quad.charge;
            }
            ;
        }
        force.tick = function() {
            if ((alpha *= .99) < .005) {
                event.end({
                    type: "end",
                    alpha: alpha = 0
                });
                return true;
            }
            var n = nodes.length, m = links.length, q, i, o, s, t, l, k, x, y;
            for (i = 0; i < m; ++i) {
                o = links[i];
                s = o.source;
                t = o.target;
                x = t.x - s.x;
                y = t.y - s.y;
                if (l = x * x + y * y) {
                    l = alpha * strengths[i] * ((l = Math.sqrt(l)) - distances[i]) / l;
                    x *= l;
                    y *= l;
                    t.x -= x * (k = s.weight / (t.weight + s.weight));
                    t.y -= y * k;
                    s.x += x * (k = 1 - k);
                    s.y += y * k;
                }
            }
            if (k = alpha * gravity) {
                x = size[0] / 2;
                y = size[1] / 2;
                i = -1;
                if (k)
                    while (++i < n) {
                        o = nodes[i];
                        o.x += (x - o.x) * k;
                        o.y += (y - o.y) * k;
                    }
            }
            if (charge) {
                d3_layout_forceAccumulate(q = d3.geom.quadtree(nodes), alpha, charges);
                i = -1;
                while (++i < n) {
                    if (!(o = nodes[i]).fixed) {
                        q.visit(repulse(o));
                    }
                }
            }
            i = -1;
            while (++i < n) {
                o = nodes[i];
                if (o.fixed) {
                    o.x = o.px;
                    o.y = o.py;
                } else {
                    o.x -= (o.px - (o.px = o.x)) * friction;
                    o.y -= (o.py - (o.py = o.y)) * friction;
                }
            }
            event.tick({
                type: "tick",
                alpha: alpha
            });
        }
        ;
        force.nodes = function(x) {
            if (!arguments.length)
                return nodes;
            nodes = x;
            return force;
        }
        ;
        force.links = function(x) {
            if (!arguments.length)
                return links;
            links = x;
            return force;
        }
        ;
        force.size = function(x) {
            if (!arguments.length)
                return size;
            size = x;
            return force;
        }
        ;
        force.linkDistance = function(x) {
            if (!arguments.length)
                return linkDistance;
            linkDistance = typeof x === "function" ? x : +x;
            return force;
        }
        ;
        force.distance = force.linkDistance;
        force.linkStrength = function(x) {
            if (!arguments.length)
                return linkStrength;
            linkStrength = typeof x === "function" ? x : +x;
            return force;
        }
        ;
        force.friction = function(x) {
            if (!arguments.length)
                return friction;
            friction = +x;
            return force;
        }
        ;
        force.charge = function(x) {
            if (!arguments.length)
                return charge;
            charge = typeof x === "function" ? x : +x;
            return force;
        }
        ;
        force.chargeDistance = function(x) {
            if (!arguments.length)
                return Math.sqrt(chargeDistance2);
            chargeDistance2 = x * x;
            return force;
        }
        ;
        force.gravity = function(x) {
            if (!arguments.length)
                return gravity;
            gravity = +x;
            return force;
        }
        ;
        force.theta = function(x) {
            if (!arguments.length)
                return Math.sqrt(theta2);
            theta2 = x * x;
            return force;
        }
        ;
        force.alpha = function(x) {
            if (!arguments.length)
                return alpha;
            x = +x;
            if (alpha) {
                if (x > 0)
                    alpha = x;
                else
                    alpha = 0;
            } else if (x > 0) {
                event.start({
                    type: "start",
                    alpha: alpha = x
                });
                d3.timer(force.tick);
            }
            return force;
        }
        ;
        force.start = function() {
            var i, n = nodes.length, m = links.length, w = size[0], h = size[1], neighbors, o;
            for (i = 0; i < n; ++i) {
                (o = nodes[i]).index = i;
                o.weight = 0;
            }
            for (i = 0; i < m; ++i) {
                o = links[i];
                if (typeof o.source == "number")
                    o.source = nodes[o.source];
                if (typeof o.target == "number")
                    o.target = nodes[o.target];
                ++o.source.weight;
                ++o.target.weight;
            }
            for (i = 0; i < n; ++i) {
                o = nodes[i];
                if (isNaN(o.x))
                    o.x = position("x", w);
                if (isNaN(o.y))
                    o.y = position("y", h);
                if (isNaN(o.px))
                    o.px = o.x;
                if (isNaN(o.py))
                    o.py = o.y;
            }
            distances = [];
            if (typeof linkDistance === "function")
                for (i = 0; i < m; ++i)
                    distances[i] = +linkDistance.call(this, links[i], i);
            else
                for (i = 0; i < m; ++i)
                    distances[i] = linkDistance;
            strengths = [];
            if (typeof linkStrength === "function")
                for (i = 0; i < m; ++i)
                    strengths[i] = +linkStrength.call(this, links[i], i);
            else
                for (i = 0; i < m; ++i)
                    strengths[i] = linkStrength;
            charges = [];
            if (typeof charge === "function")
                for (i = 0; i < n; ++i)
                    charges[i] = +charge.call(this, nodes[i], i);
            else
                for (i = 0; i < n; ++i)
                    charges[i] = charge;
            function position(dimension, size) {
                if (!neighbors) {
                    neighbors = new Array(n);
                    for (j = 0; j < n; ++j) {
                        neighbors[j] = [];
                    }
                    for (j = 0; j < m; ++j) {
                        var o = links[j];
                        neighbors[o.source.index].push(o.target);
                        neighbors[o.target.index].push(o.source);
                    }
                }
                var candidates = neighbors[i], j = -1, m = candidates.length, x;
                while (++j < m)
                    if (!isNaN(x = candidates[j][dimension]))
                        return x;
                return Math.random() * size;
            }
            return force.resume();
        }
        ;
        force.resume = function() {
            return force.alpha(.1);
        }
        ;
        force.stop = function() {
            return force.alpha(0);
        }
        ;
        force.drag = function() {
            if (!drag)
                drag = d3.behavior.drag().origin(d3_identity).on("dragstart.force", d3_layout_forceDragstart).on("drag.force", dragmove).on("dragend.force", d3_layout_forceDragend);
            if (!arguments.length)
                return drag;
            this.on("mouseover.force", d3_layout_forceMouseover).on("mouseout.force", d3_layout_forceMouseout).call(drag);
        }
        ;
        function dragmove(d) {
            d.px = d3.event.x,
            d.py = d3.event.y;
            force.resume();
        }
        return d3.rebind(force, event, "on");
    }
    ;
    function d3_layout_forceDragstart(d) {
        d.fixed |= 2;
    }
    function d3_layout_forceDragend(d) {
        d.fixed &= ~6;
    }
    function d3_layout_forceMouseover(d) {
        d.fixed |= 4;
        d.px = d.x,
        d.py = d.y;
    }
    function d3_layout_forceMouseout(d) {
        d.fixed &= ~4;
    }
    function d3_layout_forceAccumulate(quad, alpha, charges) {
        var cx = 0
          , cy = 0;
        quad.charge = 0;
        if (!quad.leaf) {
            var nodes = quad.nodes, n = nodes.length, i = -1, c;
            while (++i < n) {
                c = nodes[i];
                if (c == null)
                    continue;
                d3_layout_forceAccumulate(c, alpha, charges);
                quad.charge += c.charge;
                cx += c.charge * c.cx;
                cy += c.charge * c.cy;
            }
        }
        if (quad.point) {
            if (!quad.leaf) {
                quad.point.x += Math.random() - .5;
                quad.point.y += Math.random() - .5;
            }
            var k = alpha * charges[quad.point.index];
            quad.charge += quad.pointCharge = k;
            cx += k * quad.point.x;
            cy += k * quad.point.y;
        }
        quad.cx = cx / quad.charge;
        quad.cy = cy / quad.charge;
    }
    var d3_layout_forceLinkDistance = 20
      , d3_layout_forceLinkStrength = 1
      , d3_layout_forceChargeDistance2 = Infinity;
    d3.layout.hierarchy = function() {
        var sort = d3_layout_hierarchySort
          , children = d3_layout_hierarchyChildren
          , value = d3_layout_hierarchyValue;
        function recurse(node, depth, nodes) {
            var childs = children.call(hierarchy, node, depth);
            node.depth = depth;
            nodes.push(node);
            if (childs && (n = childs.length)) {
                var i = -1, n, c = node.children = new Array(n), v = 0, j = depth + 1, d;
                while (++i < n) {
                    d = c[i] = recurse(childs[i], j, nodes);
                    d.parent = node;
                    v += d.value;
                }
                if (sort)
                    c.sort(sort);
                if (value)
                    node.value = v;
            } else {
                delete node.children;
                if (value) {
                    node.value = +value.call(hierarchy, node, depth) || 0;
                }
            }
            return node;
        }
        function revalue(node, depth) {
            var children = node.children
              , v = 0;
            if (children && (n = children.length)) {
                var i = -1, n, j = depth + 1;
                while (++i < n)
                    v += revalue(children[i], j);
            } else if (value) {
                v = +value.call(hierarchy, node, depth) || 0;
            }
            if (value)
                node.value = v;
            return v;
        }
        function hierarchy(d) {
            var nodes = [];
            recurse(d, 0, nodes);
            return nodes;
        }
        hierarchy.sort = function(x) {
            if (!arguments.length)
                return sort;
            sort = x;
            return hierarchy;
        }
        ;
        hierarchy.children = function(x) {
            if (!arguments.length)
                return children;
            children = x;
            return hierarchy;
        }
        ;
        hierarchy.value = function(x) {
            if (!arguments.length)
                return value;
            value = x;
            return hierarchy;
        }
        ;
        hierarchy.revalue = function(root) {
            revalue(root, 0);
            return root;
        }
        ;
        return hierarchy;
    }
    ;
    function d3_layout_hierarchyRebind(object, hierarchy) {
        d3.rebind(object, hierarchy, "sort", "children", "value");
        object.nodes = object;
        object.links = d3_layout_hierarchyLinks;
        return object;
    }
    function d3_layout_hierarchyChildren(d) {
        return d.children;
    }
    function d3_layout_hierarchyValue(d) {
        return d.value;
    }
    function d3_layout_hierarchySort(a, b) {
        return b.value - a.value;
    }
    function d3_layout_hierarchyLinks(nodes) {
        return d3.merge(nodes.map(function(parent) {
            return (parent.children || []).map(function(child) {
                return {
                    source: parent,
                    target: child
                };
            });
        }));
    }
    d3.layout.partition = function() {
        var hierarchy = d3.layout.hierarchy()
          , size = [1, 1];
        function position(node, x, dx, dy) {
            var children = node.children;
            node.x = x;
            node.y = node.depth * dy;
            node.dx = dx;
            node.dy = dy;
            if (children && (n = children.length)) {
                var i = -1, n, c, d;
                dx = node.value ? dx / node.value : 0;
                while (++i < n) {
                    position(c = children[i], x, d = c.value * dx, dy);
                    x += d;
                }
            }
        }
        function depth(node) {
            var children = node.children
              , d = 0;
            if (children && (n = children.length)) {
                var i = -1, n;
                while (++i < n)
                    d = Math.max(d, depth(children[i]));
            }
            return 1 + d;
        }
        function partition(d, i) {
            var nodes = hierarchy.call(this, d, i);
            position(nodes[0], 0, size[0], size[1] / depth(nodes[0]));
            return nodes;
        }
        partition.size = function(x) {
            if (!arguments.length)
                return size;
            size = x;
            return partition;
        }
        ;
        return d3_layout_hierarchyRebind(partition, hierarchy);
    }
    ;
    d3.layout.pie = function() {
        var value = Number
          , sort = d3_layout_pieSortByValue
          , startAngle = 0
          , endAngle = τ;
        function pie(data) {
            var values = data.map(function(d, i) {
                return +value.call(pie, d, i);
            });
            var a = +(typeof startAngle === "function" ? startAngle.apply(this, arguments) : startAngle);
            var k = ((typeof endAngle === "function" ? endAngle.apply(this, arguments) : endAngle) - a) / d3.sum(values);
            var index = d3.range(data.length);
            if (sort != null)
                index.sort(sort === d3_layout_pieSortByValue ? function(i, j) {
                    return values[j] - values[i];
                }
                : function(i, j) {
                    return sort(data[i], data[j]);
                }
                );
            var arcs = [];
            index.forEach(function(i) {
                var d;
                arcs[i] = {
                    data: data[i],
                    value: d = values[i],
                    startAngle: a,
                    endAngle: a += d * k
                };
            });
            return arcs;
        }
        pie.value = function(x) {
            if (!arguments.length)
                return value;
            value = x;
            return pie;
        }
        ;
        pie.sort = function(x) {
            if (!arguments.length)
                return sort;
            sort = x;
            return pie;
        }
        ;
        pie.startAngle = function(x) {
            if (!arguments.length)
                return startAngle;
            startAngle = x;
            return pie;
        }
        ;
        pie.endAngle = function(x) {
            if (!arguments.length)
                return endAngle;
            endAngle = x;
            return pie;
        }
        ;
        return pie;
    }
    ;
    var d3_layout_pieSortByValue = {};
    d3.layout.stack = function() {
        var values = d3_identity
          , order = d3_layout_stackOrderDefault
          , offset = d3_layout_stackOffsetZero
          , out = d3_layout_stackOut
          , x = d3_layout_stackX
          , y = d3_layout_stackY;
        function stack(data, index) {
            var series = data.map(function(d, i) {
                return values.call(stack, d, i);
            });
            var points = series.map(function(d) {
                return d.map(function(v, i) {
                    return [x.call(stack, v, i), y.call(stack, v, i)];
                });
            });
            var orders = order.call(stack, points, index);
            series = d3.permute(series, orders);
            points = d3.permute(points, orders);
            var offsets = offset.call(stack, points, index);
            var n = series.length, m = series[0].length, i, j, o;
            for (j = 0; j < m; ++j) {
                out.call(stack, series[0][j], o = offsets[j], points[0][j][1]);
                for (i = 1; i < n; ++i) {
                    out.call(stack, series[i][j], o += points[i - 1][j][1], points[i][j][1]);
                }
            }
            return data;
        }
        stack.values = function(x) {
            if (!arguments.length)
                return values;
            values = x;
            return stack;
        }
        ;
        stack.order = function(x) {
            if (!arguments.length)
                return order;
            order = typeof x === "function" ? x : d3_layout_stackOrders.get(x) || d3_layout_stackOrderDefault;
            return stack;
        }
        ;
        stack.offset = function(x) {
            if (!arguments.length)
                return offset;
            offset = typeof x === "function" ? x : d3_layout_stackOffsets.get(x) || d3_layout_stackOffsetZero;
            return stack;
        }
        ;
        stack.x = function(z) {
            if (!arguments.length)
                return x;
            x = z;
            return stack;
        }
        ;
        stack.y = function(z) {
            if (!arguments.length)
                return y;
            y = z;
            return stack;
        }
        ;
        stack.out = function(z) {
            if (!arguments.length)
                return out;
            out = z;
            return stack;
        }
        ;
        return stack;
    }
    ;
    function d3_layout_stackX(d) {
        return d.x;
    }
    function d3_layout_stackY(d) {
        return d.y;
    }
    function d3_layout_stackOut(d, y0, y) {
        d.y0 = y0;
        d.y = y;
    }
    var d3_layout_stackOrders = d3.map({
        "inside-out": function(data) {
            var n = data.length, i, j, max = data.map(d3_layout_stackMaxIndex), sums = data.map(d3_layout_stackReduceSum), index = d3.range(n).sort(function(a, b) {
                return max[a] - max[b];
            }), top = 0, bottom = 0, tops = [], bottoms = [];
            for (i = 0; i < n; ++i) {
                j = index[i];
                if (top < bottom) {
                    top += sums[j];
                    tops.push(j);
                } else {
                    bottom += sums[j];
                    bottoms.push(j);
                }
            }
            return bottoms.reverse().concat(tops);
        },
        reverse: function(data) {
            return d3.range(data.length).reverse();
        },
        "default": d3_layout_stackOrderDefault
    });
    var d3_layout_stackOffsets = d3.map({
        silhouette: function(data) {
            var n = data.length, m = data[0].length, sums = [], max = 0, i, j, o, y0 = [];
            for (j = 0; j < m; ++j) {
                for (i = 0,
                o = 0; i < n; i++)
                    o += data[i][j][1];
                if (o > max)
                    max = o;
                sums.push(o);
            }
            for (j = 0; j < m; ++j) {
                y0[j] = (max - sums[j]) / 2;
            }
            return y0;
        },
        wiggle: function(data) {
            var n = data.length, x = data[0], m = x.length, i, j, k, s1, s2, s3, dx, o, o0, y0 = [];
            y0[0] = o = o0 = 0;
            for (j = 1; j < m; ++j) {
                for (i = 0,
                s1 = 0; i < n; ++i)
                    s1 += data[i][j][1];
                for (i = 0,
                s2 = 0,
                dx = x[j][0] - x[j - 1][0]; i < n; ++i) {
                    for (k = 0,
                    s3 = (data[i][j][1] - data[i][j - 1][1]) / (2 * dx); k < i; ++k) {
                        s3 += (data[k][j][1] - data[k][j - 1][1]) / dx;
                    }
                    s2 += s3 * data[i][j][1];
                }
                y0[j] = o -= s1 ? s2 / s1 * dx : 0;
                if (o < o0)
                    o0 = o;
            }
            for (j = 0; j < m; ++j)
                y0[j] -= o0;
            return y0;
        },
        expand: function(data) {
            var n = data.length, m = data[0].length, k = 1 / n, i, j, o, y0 = [];
            for (j = 0; j < m; ++j) {
                for (i = 0,
                o = 0; i < n; i++)
                    o += data[i][j][1];
                if (o)
                    for (i = 0; i < n; i++)
                        data[i][j][1] /= o;
                else
                    for (i = 0; i < n; i++)
                        data[i][j][1] = k;
            }
            for (j = 0; j < m; ++j)
                y0[j] = 0;
            return y0;
        },
        zero: d3_layout_stackOffsetZero
    });
    function d3_layout_stackOrderDefault(data) {
        return d3.range(data.length);
    }
    function d3_layout_stackOffsetZero(data) {
        var j = -1
          , m = data[0].length
          , y0 = [];
        while (++j < m)
            y0[j] = 0;
        return y0;
    }
    function d3_layout_stackMaxIndex(array) {
        var i = 1, j = 0, v = array[0][1], k, n = array.length;
        for (; i < n; ++i) {
            if ((k = array[i][1]) > v) {
                j = i;
                v = k;
            }
        }
        return j;
    }
    function d3_layout_stackReduceSum(d) {
        return d.reduce(d3_layout_stackSum, 0);
    }
    function d3_layout_stackSum(p, d) {
        return p + d[1];
    }
    d3.layout.histogram = function() {
        var frequency = true
          , valuer = Number
          , ranger = d3_layout_histogramRange
          , binner = d3_layout_histogramBinSturges;
        function histogram(data, i) {
            var bins = [], values = data.map(valuer, this), range = ranger.call(this, values, i), thresholds = binner.call(this, range, values, i), bin, i = -1, n = values.length, m = thresholds.length - 1, k = frequency ? 1 : 1 / n, x;
            while (++i < m) {
                bin = bins[i] = [];
                bin.dx = thresholds[i + 1] - (bin.x = thresholds[i]);
                bin.y = 0;
            }
            if (m > 0) {
                i = -1;
                while (++i < n) {
                    x = values[i];
                    if (x >= range[0] && x <= range[1]) {
                        bin = bins[d3.bisect(thresholds, x, 1, m) - 1];
                        bin.y += k;
                        bin.push(data[i]);
                    }
                }
            }
            return bins;
        }
        histogram.value = function(x) {
            if (!arguments.length)
                return valuer;
            valuer = x;
            return histogram;
        }
        ;
        histogram.range = function(x) {
            if (!arguments.length)
                return ranger;
            ranger = d3_functor(x);
            return histogram;
        }
        ;
        histogram.bins = function(x) {
            if (!arguments.length)
                return binner;
            binner = typeof x === "number" ? function(range) {
                return d3_layout_histogramBinFixed(range, x);
            }
            : d3_functor(x);
            return histogram;
        }
        ;
        histogram.frequency = function(x) {
            if (!arguments.length)
                return frequency;
            frequency = !!x;
            return histogram;
        }
        ;
        return histogram;
    }
    ;
    function d3_layout_histogramBinSturges(range, values) {
        return d3_layout_histogramBinFixed(range, Math.ceil(Math.log(values.length) / Math.LN2 + 1));
    }
    function d3_layout_histogramBinFixed(range, n) {
        var x = -1
          , b = +range[0]
          , m = (range[1] - b) / n
          , f = [];
        while (++x <= n)
            f[x] = m * x + b;
        return f;
    }
    function d3_layout_histogramRange(values) {
        return [d3.min(values), d3.max(values)];
    }
    d3.layout.tree = function() {
        var hierarchy = d3.layout.hierarchy().sort(null).value(null)
          , separation = d3_layout_treeSeparation
          , size = [1, 1]
          , nodeSize = false;
        function tree(d, i) {
            var nodes = hierarchy.call(this, d, i)
              , root = nodes[0];
            function firstWalk(node, previousSibling) {
                var children = node.children
                  , layout = node._tree;
                if (children && (n = children.length)) {
                    var n, firstChild = children[0], previousChild, ancestor = firstChild, child, i = -1;
                    while (++i < n) {
                        child = children[i];
                        firstWalk(child, previousChild);
                        ancestor = apportion(child, previousChild, ancestor);
                        previousChild = child;
                    }
                    d3_layout_treeShift(node);
                    var midpoint = .5 * (firstChild._tree.prelim + child._tree.prelim);
                    if (previousSibling) {
                        layout.prelim = previousSibling._tree.prelim + separation(node, previousSibling);
                        layout.mod = layout.prelim - midpoint;
                    } else {
                        layout.prelim = midpoint;
                    }
                } else {
                    if (previousSibling) {
                        layout.prelim = previousSibling._tree.prelim + separation(node, previousSibling);
                    }
                }
            }
            function secondWalk(node, x) {
                node.x = node._tree.prelim + x;
                var children = node.children;
                if (children && (n = children.length)) {
                    var i = -1, n;
                    x += node._tree.mod;
                    while (++i < n) {
                        secondWalk(children[i], x);
                    }
                }
            }
            function apportion(node, previousSibling, ancestor) {
                if (previousSibling) {
                    var vip = node, vop = node, vim = previousSibling, vom = node.parent.children[0], sip = vip._tree.mod, sop = vop._tree.mod, sim = vim._tree.mod, som = vom._tree.mod, shift;
                    while (vim = d3_layout_treeRight(vim),
                    vip = d3_layout_treeLeft(vip),
                    vim && vip) {
                        vom = d3_layout_treeLeft(vom);
                        vop = d3_layout_treeRight(vop);
                        vop._tree.ancestor = node;
                        shift = vim._tree.prelim + sim - vip._tree.prelim - sip + separation(vim, vip);
                        if (shift > 0) {
                            d3_layout_treeMove(d3_layout_treeAncestor(vim, node, ancestor), node, shift);
                            sip += shift;
                            sop += shift;
                        }
                        sim += vim._tree.mod;
                        sip += vip._tree.mod;
                        som += vom._tree.mod;
                        sop += vop._tree.mod;
                    }
                    if (vim && !d3_layout_treeRight(vop)) {
                        vop._tree.thread = vim;
                        vop._tree.mod += sim - sop;
                    }
                    if (vip && !d3_layout_treeLeft(vom)) {
                        vom._tree.thread = vip;
                        vom._tree.mod += sip - som;
                        ancestor = node;
                    }
                }
                return ancestor;
            }
            d3_layout_treeVisitAfter(root, function(node, previousSibling) {
                node._tree = {
                    ancestor: node,
                    prelim: 0,
                    mod: 0,
                    change: 0,
                    shift: 0,
                    number: previousSibling ? previousSibling._tree.number + 1 : 0
                };
            });
            firstWalk(root);
            secondWalk(root, -root._tree.prelim);
            var left = d3_layout_treeSearch(root, d3_layout_treeLeftmost)
              , right = d3_layout_treeSearch(root, d3_layout_treeRightmost)
              , deep = d3_layout_treeSearch(root, d3_layout_treeDeepest)
              , x0 = left.x - separation(left, right) / 2
              , x1 = right.x + separation(right, left) / 2
              , y1 = deep.depth || 1;
            d3_layout_treeVisitAfter(root, nodeSize ? function(node) {
                node.x *= size[0];
                node.y = node.depth * size[1];
                delete node._tree;
            }
            : function(node) {
                node.x = (node.x - x0) / (x1 - x0) * size[0];
                node.y = node.depth / y1 * size[1];
                delete node._tree;
            }
            );
            return nodes;
        }
        tree.separation = function(x) {
            if (!arguments.length)
                return separation;
            separation = x;
            return tree;
        }
        ;
        tree.size = function(x) {
            if (!arguments.length)
                return nodeSize ? null : size;
            nodeSize = (size = x) == null;
            return tree;
        }
        ;
        tree.nodeSize = function(x) {
            if (!arguments.length)
                return nodeSize ? size : null;
            nodeSize = (size = x) != null;
            return tree;
        }
        ;
        return d3_layout_hierarchyRebind(tree, hierarchy);
    }
    ;
    function d3_layout_treeSeparation(a, b) {
        return a.parent == b.parent ? 1 : 2;
    }
    function d3_layout_treeLeft(node) {
        var children = node.children;
        return children && children.length ? children[0] : node._tree.thread;
    }
    function d3_layout_treeRight(node) {
        var children = node.children, n;
        return children && (n = children.length) ? children[n - 1] : node._tree.thread;
    }
    function d3_layout_treeSearch(node, compare) {
        var children = node.children;
        if (children && (n = children.length)) {
            var child, n, i = -1;
            while (++i < n) {
                if (compare(child = d3_layout_treeSearch(children[i], compare), node) > 0) {
                    node = child;
                }
            }
        }
        return node;
    }
    function d3_layout_treeRightmost(a, b) {
        return a.x - b.x;
    }
    function d3_layout_treeLeftmost(a, b) {
        return b.x - a.x;
    }
    function d3_layout_treeDeepest(a, b) {
        return a.depth - b.depth;
    }
    function d3_layout_treeVisitAfter(node, callback) {
        function visit(node, previousSibling) {
            var children = node.children;
            if (children && (n = children.length)) {
                var child, previousChild = null, i = -1, n;
                while (++i < n) {
                    child = children[i];
                    visit(child, previousChild);
                    previousChild = child;
                }
            }
            callback(node, previousSibling);
        }
        visit(node, null);
    }
    function d3_layout_treeShift(node) {
        var shift = 0, change = 0, children = node.children, i = children.length, child;
        while (--i >= 0) {
            child = children[i]._tree;
            child.prelim += shift;
            child.mod += shift;
            shift += child.shift + (change += child.change);
        }
    }
    function d3_layout_treeMove(ancestor, node, shift) {
        ancestor = ancestor._tree;
        node = node._tree;
        var change = shift / (node.number - ancestor.number);
        ancestor.change += change;
        node.change -= change;
        node.shift += shift;
        node.prelim += shift;
        node.mod += shift;
    }
    function d3_layout_treeAncestor(vim, node, ancestor) {
        return vim._tree.ancestor.parent == node.parent ? vim._tree.ancestor : ancestor;
    }
    d3.layout.pack = function() {
        var hierarchy = d3.layout.hierarchy().sort(d3_layout_packSort), padding = 0, size = [1, 1], radius;
        function pack(d, i) {
            var nodes = hierarchy.call(this, d, i)
              , root = nodes[0]
              , w = size[0]
              , h = size[1]
              , r = radius == null ? Math.sqrt : typeof radius === "function" ? radius : function() {
                return radius;
            }
            ;
            root.x = root.y = 0;
            d3_layout_treeVisitAfter(root, function(d) {
                d.r = +r(d.value);
            });
            d3_layout_treeVisitAfter(root, d3_layout_packSiblings);
            if (padding) {
                var dr = padding * (radius ? 1 : Math.max(2 * root.r / w, 2 * root.r / h)) / 2;
                d3_layout_treeVisitAfter(root, function(d) {
                    d.r += dr;
                });
                d3_layout_treeVisitAfter(root, d3_layout_packSiblings);
                d3_layout_treeVisitAfter(root, function(d) {
                    d.r -= dr;
                });
            }
            d3_layout_packTransform(root, w / 2, h / 2, radius ? 1 : 1 / Math.max(2 * root.r / w, 2 * root.r / h));
            return nodes;
        }
        pack.size = function(_) {
            if (!arguments.length)
                return size;
            size = _;
            return pack;
        }
        ;
        pack.radius = function(_) {
            if (!arguments.length)
                return radius;
            radius = _ == null || typeof _ === "function" ? _ : +_;
            return pack;
        }
        ;
        pack.padding = function(_) {
            if (!arguments.length)
                return padding;
            padding = +_;
            return pack;
        }
        ;
        return d3_layout_hierarchyRebind(pack, hierarchy);
    }
    ;
    function d3_layout_packSort(a, b) {
        return a.value - b.value;
    }
    function d3_layout_packInsert(a, b) {
        var c = a._pack_next;
        a._pack_next = b;
        b._pack_prev = a;
        b._pack_next = c;
        c._pack_prev = b;
    }
    function d3_layout_packSplice(a, b) {
        a._pack_next = b;
        b._pack_prev = a;
    }
    function d3_layout_packIntersects(a, b) {
        var dx = b.x - a.x
          , dy = b.y - a.y
          , dr = a.r + b.r;
        return .999 * dr * dr > dx * dx + dy * dy;
    }
    function d3_layout_packSiblings(node) {
        if (!(nodes = node.children) || !(n = nodes.length))
            return;
        var nodes, xMin = Infinity, xMax = -Infinity, yMin = Infinity, yMax = -Infinity, a, b, c, i, j, k, n;
        function bound(node) {
            xMin = Math.min(node.x - node.r, xMin);
            xMax = Math.max(node.x + node.r, xMax);
            yMin = Math.min(node.y - node.r, yMin);
            yMax = Math.max(node.y + node.r, yMax);
        }
        nodes.forEach(d3_layout_packLink);
        a = nodes[0];
        a.x = -a.r;
        a.y = 0;
        bound(a);
        if (n > 1) {
            b = nodes[1];
            b.x = b.r;
            b.y = 0;
            bound(b);
            if (n > 2) {
                c = nodes[2];
                d3_layout_packPlace(a, b, c);
                bound(c);
                d3_layout_packInsert(a, c);
                a._pack_prev = c;
                d3_layout_packInsert(c, b);
                b = a._pack_next;
                for (i = 3; i < n; i++) {
                    d3_layout_packPlace(a, b, c = nodes[i]);
                    var isect = 0
                      , s1 = 1
                      , s2 = 1;
                    for (j = b._pack_next; j !== b; j = j._pack_next,
                    s1++) {
                        if (d3_layout_packIntersects(j, c)) {
                            isect = 1;
                            break;
                        }
                    }
                    if (isect == 1) {
                        for (k = a._pack_prev; k !== j._pack_prev; k = k._pack_prev,
                        s2++) {
                            if (d3_layout_packIntersects(k, c)) {
                                break;
                            }
                        }
                    }
                    if (isect) {
                        if (s1 < s2 || s1 == s2 && b.r < a.r)
                            d3_layout_packSplice(a, b = j);
                        else
                            d3_layout_packSplice(a = k, b);
                        i--;
                    } else {
                        d3_layout_packInsert(a, c);
                        b = c;
                        bound(c);
                    }
                }
            }
        }
        var cx = (xMin + xMax) / 2
          , cy = (yMin + yMax) / 2
          , cr = 0;
        for (i = 0; i < n; i++) {
            c = nodes[i];
            c.x -= cx;
            c.y -= cy;
            cr = Math.max(cr, c.r + Math.sqrt(c.x * c.x + c.y * c.y));
        }
        node.r = cr;
        nodes.forEach(d3_layout_packUnlink);
    }
    function d3_layout_packLink(node) {
        node._pack_next = node._pack_prev = node;
    }
    function d3_layout_packUnlink(node) {
        delete node._pack_next;
        delete node._pack_prev;
    }
    function d3_layout_packTransform(node, x, y, k) {
        var children = node.children;
        node.x = x += k * node.x;
        node.y = y += k * node.y;
        node.r *= k;
        if (children) {
            var i = -1
              , n = children.length;
            while (++i < n)
                d3_layout_packTransform(children[i], x, y, k);
        }
    }
    function d3_layout_packPlace(a, b, c) {
        var db = a.r + c.r
          , dx = b.x - a.x
          , dy = b.y - a.y;
        if (db && (dx || dy)) {
            var da = b.r + c.r
              , dc = dx * dx + dy * dy;
            da *= da;
            db *= db;
            var x = .5 + (db - da) / (2 * dc)
              , y = Math.sqrt(Math.max(0, 2 * da * (db + dc) - (db -= dc) * db - da * da)) / (2 * dc);
            c.x = a.x + x * dx + y * dy;
            c.y = a.y + x * dy - y * dx;
        } else {
            c.x = a.x + db;
            c.y = a.y;
        }
    }
    d3.layout.cluster = function() {
        var hierarchy = d3.layout.hierarchy().sort(null).value(null)
          , separation = d3_layout_treeSeparation
          , size = [1, 1]
          , nodeSize = false;
        function cluster(d, i) {
            var nodes = hierarchy.call(this, d, i), root = nodes[0], previousNode, x = 0;
            d3_layout_treeVisitAfter(root, function(node) {
                var children = node.children;
                if (children && children.length) {
                    node.x = d3_layout_clusterX(children);
                    node.y = d3_layout_clusterY(children);
                } else {
                    node.x = previousNode ? x += separation(node, previousNode) : 0;
                    node.y = 0;
                    previousNode = node;
                }
            });
            var left = d3_layout_clusterLeft(root)
              , right = d3_layout_clusterRight(root)
              , x0 = left.x - separation(left, right) / 2
              , x1 = right.x + separation(right, left) / 2;
            d3_layout_treeVisitAfter(root, nodeSize ? function(node) {
                node.x = (node.x - root.x) * size[0];
                node.y = (root.y - node.y) * size[1];
            }
            : function(node) {
                node.x = (node.x - x0) / (x1 - x0) * size[0];
                node.y = (1 - (root.y ? node.y / root.y : 1)) * size[1];
            }
            );
            return nodes;
        }
        cluster.separation = function(x) {
            if (!arguments.length)
                return separation;
            separation = x;
            return cluster;
        }
        ;
        cluster.size = function(x) {
            if (!arguments.length)
                return nodeSize ? null : size;
            nodeSize = (size = x) == null;
            return cluster;
        }
        ;
        cluster.nodeSize = function(x) {
            if (!arguments.length)
                return nodeSize ? size : null;
            nodeSize = (size = x) != null;
            return cluster;
        }
        ;
        return d3_layout_hierarchyRebind(cluster, hierarchy);
    }
    ;
    function d3_layout_clusterY(children) {
        return 1 + d3.max(children, function(child) {
            return child.y;
        });
    }
    function d3_layout_clusterX(children) {
        return children.reduce(function(x, child) {
            return x + child.x;
        }, 0) / children.length;
    }
    function d3_layout_clusterLeft(node) {
        var children = node.children;
        return children && children.length ? d3_layout_clusterLeft(children[0]) : node;
    }
    function d3_layout_clusterRight(node) {
        var children = node.children, n;
        return children && (n = children.length) ? d3_layout_clusterRight(children[n - 1]) : node;
    }
    d3.layout.treemap = function() {
        var hierarchy = d3.layout.hierarchy(), round = Math.round, size = [1, 1], padding = null, pad = d3_layout_treemapPadNull, sticky = false, stickies, mode = "squarify", ratio = .5 * (1 + Math.sqrt(5));
        function scale(children, k) {
            var i = -1, n = children.length, child, area;
            while (++i < n) {
                area = (child = children[i]).value * (k < 0 ? 0 : k);
                child.area = isNaN(area) || area <= 0 ? 0 : area;
            }
        }
        function squarify(node) {
            var children = node.children;
            if (children && children.length) {
                var rect = pad(node), row = [], remaining = children.slice(), child, best = Infinity, score, u = mode === "slice" ? rect.dx : mode === "dice" ? rect.dy : mode === "slice-dice" ? node.depth & 1 ? rect.dy : rect.dx : Math.min(rect.dx, rect.dy), n;
                scale(remaining, rect.dx * rect.dy / node.value);
                row.area = 0;
                while ((n = remaining.length) > 0) {
                    row.push(child = remaining[n - 1]);
                    row.area += child.area;
                    if (mode !== "squarify" || (score = worst(row, u)) <= best) {
                        remaining.pop();
                        best = score;
                    } else {
                        row.area -= row.pop().area;
                        position(row, u, rect, false);
                        u = Math.min(rect.dx, rect.dy);
                        row.length = row.area = 0;
                        best = Infinity;
                    }
                }
                if (row.length) {
                    position(row, u, rect, true);
                    row.length = row.area = 0;
                }
                children.forEach(squarify);
            }
        }
        function stickify(node) {
            var children = node.children;
            if (children && children.length) {
                var rect = pad(node), remaining = children.slice(), child, row = [];
                scale(remaining, rect.dx * rect.dy / node.value);
                row.area = 0;
                while (child = remaining.pop()) {
                    row.push(child);
                    row.area += child.area;
                    if (child.z != null) {
                        position(row, child.z ? rect.dx : rect.dy, rect, !remaining.length);
                        row.length = row.area = 0;
                    }
                }
                children.forEach(stickify);
            }
        }
        function worst(row, u) {
            var s = row.area, r, rmax = 0, rmin = Infinity, i = -1, n = row.length;
            while (++i < n) {
                if (!(r = row[i].area))
                    continue;
                if (r < rmin)
                    rmin = r;
                if (r > rmax)
                    rmax = r;
            }
            s *= s;
            u *= u;
            return s ? Math.max(u * rmax * ratio / s, s / (u * rmin * ratio)) : Infinity;
        }
        function position(row, u, rect, flush) {
            var i = -1, n = row.length, x = rect.x, y = rect.y, v = u ? round(row.area / u) : 0, o;
            if (u == rect.dx) {
                if (flush || v > rect.dy)
                    v = rect.dy;
                while (++i < n) {
                    o = row[i];
                    o.x = x;
                    o.y = y;
                    o.dy = v;
                    x += o.dx = Math.min(rect.x + rect.dx - x, v ? round(o.area / v) : 0);
                }
                o.z = true;
                o.dx += rect.x + rect.dx - x;
                rect.y += v;
                rect.dy -= v;
            } else {
                if (flush || v > rect.dx)
                    v = rect.dx;
                while (++i < n) {
                    o = row[i];
                    o.x = x;
                    o.y = y;
                    o.dx = v;
                    y += o.dy = Math.min(rect.y + rect.dy - y, v ? round(o.area / v) : 0);
                }
                o.z = false;
                o.dy += rect.y + rect.dy - y;
                rect.x += v;
                rect.dx -= v;
            }
        }
        function treemap(d) {
            var nodes = stickies || hierarchy(d)
              , root = nodes[0];
            root.x = 0;
            root.y = 0;
            root.dx = size[0];
            root.dy = size[1];
            if (stickies)
                hierarchy.revalue(root);
            scale([root], root.dx * root.dy / root.value);
            (stickies ? stickify : squarify)(root);
            if (sticky)
                stickies = nodes;
            return nodes;
        }
        treemap.size = function(x) {
            if (!arguments.length)
                return size;
            size = x;
            return treemap;
        }
        ;
        treemap.padding = function(x) {
            if (!arguments.length)
                return padding;
            function padFunction(node) {
                var p = x.call(treemap, node, node.depth);
                return p == null ? d3_layout_treemapPadNull(node) : d3_layout_treemapPad(node, typeof p === "number" ? [p, p, p, p] : p);
            }
            function padConstant(node) {
                return d3_layout_treemapPad(node, x);
            }
            var type;
            pad = (padding = x) == null ? d3_layout_treemapPadNull : (type = typeof x) === "function" ? padFunction : type === "number" ? (x = [x, x, x, x],
            padConstant) : padConstant;
            return treemap;
        }
        ;
        treemap.round = function(x) {
            if (!arguments.length)
                return round != Number;
            round = x ? Math.round : Number;
            return treemap;
        }
        ;
        treemap.sticky = function(x) {
            if (!arguments.length)
                return sticky;
            sticky = x;
            stickies = null;
            return treemap;
        }
        ;
        treemap.ratio = function(x) {
            if (!arguments.length)
                return ratio;
            ratio = x;
            return treemap;
        }
        ;
        treemap.mode = function(x) {
            if (!arguments.length)
                return mode;
            mode = x + "";
            return treemap;
        }
        ;
        return d3_layout_hierarchyRebind(treemap, hierarchy);
    }
    ;
    function d3_layout_treemapPadNull(node) {
        return {
            x: node.x,
            y: node.y,
            dx: node.dx,
            dy: node.dy
        };
    }
    function d3_layout_treemapPad(node, padding) {
        var x = node.x + padding[3]
          , y = node.y + padding[0]
          , dx = node.dx - padding[1] - padding[3]
          , dy = node.dy - padding[0] - padding[2];
        if (dx < 0) {
            x += dx / 2;
            dx = 0;
        }
        if (dy < 0) {
            y += dy / 2;
            dy = 0;
        }
        return {
            x: x,
            y: y,
            dx: dx,
            dy: dy
        };
    }
    d3.random = {
        normal: function(µ, σ) {
            var n = arguments.length;
            if (n < 2)
                σ = 1;
            if (n < 1)
                µ = 0;
            return function() {
                var x, y, r;
                do {
                    x = Math.random() * 2 - 1;
                    y = Math.random() * 2 - 1;
                    r = x * x + y * y;
                } while (!r || r > 1);return µ + σ * x * Math.sqrt(-2 * Math.log(r) / r);
            }
            ;
        },
        logNormal: function() {
            var random = d3.random.normal.apply(d3, arguments);
            return function() {
                return Math.exp(random());
            }
            ;
        },
        bates: function(m) {
            var random = d3.random.irwinHall(m);
            return function() {
                return random() / m;
            }
            ;
        },
        irwinHall: function(m) {
            return function() {
                for (var s = 0, j = 0; j < m; j++)
                    s += Math.random();
                return s;
            }
            ;
        }
    };
    d3.scale = {};
    function d3_scaleExtent(domain) {
        var start = domain[0]
          , stop = domain[domain.length - 1];
        return start < stop ? [start, stop] : [stop, start];
    }
    function d3_scaleRange(scale) {
        return scale.rangeExtent ? scale.rangeExtent() : d3_scaleExtent(scale.range());
    }
    function d3_scale_bilinear(domain, range, uninterpolate, interpolate) {
        var u = uninterpolate(domain[0], domain[1])
          , i = interpolate(range[0], range[1]);
        return function(x) {
            return i(u(x));
        }
        ;
    }
    function d3_scale_nice(domain, nice) {
        var i0 = 0, i1 = domain.length - 1, x0 = domain[i0], x1 = domain[i1], dx;
        if (x1 < x0) {
            dx = i0,
            i0 = i1,
            i1 = dx;
            dx = x0,
            x0 = x1,
            x1 = dx;
        }
        domain[i0] = nice.floor(x0);
        domain[i1] = nice.ceil(x1);
        return domain;
    }
    function d3_scale_niceStep(step) {
        return step ? {
            floor: function(x) {
                return Math.floor(x / step) * step;
            },
            ceil: function(x) {
                return Math.ceil(x / step) * step;
            }
        } : d3_scale_niceIdentity;
    }
    var d3_scale_niceIdentity = {
        floor: d3_identity,
        ceil: d3_identity
    };
    function d3_scale_polylinear(domain, range, uninterpolate, interpolate) {
        var u = []
          , i = []
          , j = 0
          , k = Math.min(domain.length, range.length) - 1;
        if (domain[k] < domain[0]) {
            domain = domain.slice().reverse();
            range = range.slice().reverse();
        }
        while (++j <= k) {
            u.push(uninterpolate(domain[j - 1], domain[j]));
            i.push(interpolate(range[j - 1], range[j]));
        }
        return function(x) {
            var j = d3.bisect(domain, x, 1, k) - 1;
            return i[j](u[j](x));
        }
        ;
    }
    d3.scale.linear = function() {
        return d3_scale_linear([0, 1], [0, 1], d3_interpolate, false);
    }
    ;
    function d3_scale_linear(domain, range, interpolate, clamp) {
        var output, input;
        function rescale() {
            var linear = Math.min(domain.length, range.length) > 2 ? d3_scale_polylinear : d3_scale_bilinear
              , uninterpolate = clamp ? d3_uninterpolateClamp : d3_uninterpolateNumber;
            output = linear(domain, range, uninterpolate, interpolate);
            input = linear(range, domain, uninterpolate, d3_interpolate);
            return scale;
        }
        function scale(x) {
            return output(x);
        }
        scale.invert = function(y) {
            return input(y);
        }
        ;
        scale.domain = function(x) {
            if (!arguments.length)
                return domain;
            domain = x.map(Number);
            return rescale();
        }
        ;
        scale.range = function(x) {
            if (!arguments.length)
                return range;
            range = x;
            return rescale();
        }
        ;
        scale.rangeRound = function(x) {
            return scale.range(x).interpolate(d3_interpolateRound);
        }
        ;
        scale.clamp = function(x) {
            if (!arguments.length)
                return clamp;
            clamp = x;
            return rescale();
        }
        ;
        scale.interpolate = function(x) {
            if (!arguments.length)
                return interpolate;
            interpolate = x;
            return rescale();
        }
        ;
        scale.ticks = function(m) {
            return d3_scale_linearTicks(domain, m);
        }
        ;
        scale.tickFormat = function(m, format) {
            return d3_scale_linearTickFormat(domain, m, format);
        }
        ;
        scale.nice = function(m) {
            d3_scale_linearNice(domain, m);
            return rescale();
        }
        ;
        scale.copy = function() {
            return d3_scale_linear(domain, range, interpolate, clamp);
        }
        ;
        return rescale();
    }
    function d3_scale_linearRebind(scale, linear) {
        return d3.rebind(scale, linear, "range", "rangeRound", "interpolate", "clamp");
    }
    function d3_scale_linearNice(domain, m) {
        return d3_scale_nice(domain, d3_scale_niceStep(d3_scale_linearTickRange(domain, m)[2]));
    }
    function d3_scale_linearTickRange(domain, m) {
        if (m == null)
            m = 10;
        var extent = d3_scaleExtent(domain)
          , span = extent[1] - extent[0]
          , step = Math.pow(10, Math.floor(Math.log(span / m) / Math.LN10))
          , err = m / span * step;
        if (err <= .15)
            step *= 10;
        else if (err <= .35)
            step *= 5;
        else if (err <= .75)
            step *= 2;
        extent[0] = Math.ceil(extent[0] / step) * step;
        extent[1] = Math.floor(extent[1] / step) * step + step * .5;
        extent[2] = step;
        return extent;
    }
    function d3_scale_linearTicks(domain, m) {
        return d3.range.apply(d3, d3_scale_linearTickRange(domain, m));
    }
    function d3_scale_linearTickFormat(domain, m, format) {
        var range = d3_scale_linearTickRange(domain, m);
        if (format) {
            var match = d3_format_re.exec(format);
            match.shift();
            if (match[8] === "s") {
                var prefix = d3.formatPrefix(Math.max(abs(range[0]), abs(range[1])));
                if (!match[7])
                    match[7] = "." + d3_scale_linearPrecision(prefix.scale(range[2]));
                match[8] = "f";
                format = d3.format(match.join(""));
                return function(d) {
                    return format(prefix.scale(d)) + prefix.symbol;
                }
                ;
            }
            if (!match[7])
                match[7] = "." + d3_scale_linearFormatPrecision(match[8], range);
            format = match.join("");
        } else {
            format = ",." + d3_scale_linearPrecision(range[2]) + "f";
        }
        return d3.format(format);
    }
    var d3_scale_linearFormatSignificant = {
        s: 1,
        g: 1,
        p: 1,
        r: 1,
        e: 1
    };
    function d3_scale_linearPrecision(value) {
        return -Math.floor(Math.log(value) / Math.LN10 + .01);
    }
    function d3_scale_linearFormatPrecision(type, range) {
        var p = d3_scale_linearPrecision(range[2]);
        return type in d3_scale_linearFormatSignificant ? Math.abs(p - d3_scale_linearPrecision(Math.max(abs(range[0]), abs(range[1])))) + (+(type !== "e")) : p - (type === "%") * 2;
    }
    d3.scale.log = function() {
        return d3_scale_log(d3.scale.linear().domain([0, 1]), 10, true, [1, 10]);
    }
    ;
    function d3_scale_log(linear, base, positive, domain) {
        function log(x) {
            return (positive ? Math.log(x < 0 ? 0 : x) : -Math.log(x > 0 ? 0 : -x)) / Math.log(base);
        }
        function pow(x) {
            return positive ? Math.pow(base, x) : -Math.pow(base, -x);
        }
        function scale(x) {
            return linear(log(x));
        }
        scale.invert = function(x) {
            return pow(linear.invert(x));
        }
        ;
        scale.domain = function(x) {
            if (!arguments.length)
                return domain;
            positive = x[0] >= 0;
            linear.domain((domain = x.map(Number)).map(log));
            return scale;
        }
        ;
        scale.base = function(_) {
            if (!arguments.length)
                return base;
            base = +_;
            linear.domain(domain.map(log));
            return scale;
        }
        ;
        scale.nice = function() {
            var niced = d3_scale_nice(domain.map(log), positive ? Math : d3_scale_logNiceNegative);
            linear.domain(niced);
            domain = niced.map(pow);
            return scale;
        }
        ;
        scale.ticks = function() {
            var extent = d3_scaleExtent(domain)
              , ticks = []
              , u = extent[0]
              , v = extent[1]
              , i = Math.floor(log(u))
              , j = Math.ceil(log(v))
              , n = base % 1 ? 2 : base;
            if (isFinite(j - i)) {
                if (positive) {
                    for (; i < j; i++)
                        for (var k = 1; k < n; k++)
                            ticks.push(pow(i) * k);
                    ticks.push(pow(i));
                } else {
                    ticks.push(pow(i));
                    for (; i++ < j; )
                        for (var k = n - 1; k > 0; k--)
                            ticks.push(pow(i) * k);
                }
                for (i = 0; ticks[i] < u; i++) {}
                for (j = ticks.length; ticks[j - 1] > v; j--) {}
                ticks = ticks.slice(i, j);
            }
            return ticks;
        }
        ;
        scale.tickFormat = function(n, format) {
            if (!arguments.length)
                return d3_scale_logFormat;
            if (arguments.length < 2)
                format = d3_scale_logFormat;
            else if (typeof format !== "function")
                format = d3.format(format);
            var k = Math.max(.1, n / scale.ticks().length), f = positive ? (e = 1e-12,
            Math.ceil) : (e = -1e-12,
            Math.floor), e;
            return function(d) {
                return d / pow(f(log(d) + e)) <= k ? format(d) : "";
            }
            ;
        }
        ;
        scale.copy = function() {
            return d3_scale_log(linear.copy(), base, positive, domain);
        }
        ;
        return d3_scale_linearRebind(scale, linear);
    }
    var d3_scale_logFormat = d3.format(".0e")
      , d3_scale_logNiceNegative = {
        floor: function(x) {
            return -Math.ceil(-x);
        },
        ceil: function(x) {
            return -Math.floor(-x);
        }
    };
    d3.scale.pow = function() {
        return d3_scale_pow(d3.scale.linear(), 1, [0, 1]);
    }
    ;
    function d3_scale_pow(linear, exponent, domain) {
        var powp = d3_scale_powPow(exponent)
          , powb = d3_scale_powPow(1 / exponent);
        function scale(x) {
            return linear(powp(x));
        }
        scale.invert = function(x) {
            return powb(linear.invert(x));
        }
        ;
        scale.domain = function(x) {
            if (!arguments.length)
                return domain;
            linear.domain((domain = x.map(Number)).map(powp));
            return scale;
        }
        ;
        scale.ticks = function(m) {
            return d3_scale_linearTicks(domain, m);
        }
        ;
        scale.tickFormat = function(m, format) {
            return d3_scale_linearTickFormat(domain, m, format);
        }
        ;
        scale.nice = function(m) {
            return scale.domain(d3_scale_linearNice(domain, m));
        }
        ;
        scale.exponent = function(x) {
            if (!arguments.length)
                return exponent;
            powp = d3_scale_powPow(exponent = x);
            powb = d3_scale_powPow(1 / exponent);
            linear.domain(domain.map(powp));
            return scale;
        }
        ;
        scale.copy = function() {
            return d3_scale_pow(linear.copy(), exponent, domain);
        }
        ;
        return d3_scale_linearRebind(scale, linear);
    }
    function d3_scale_powPow(e) {
        return function(x) {
            return x < 0 ? -Math.pow(-x, e) : Math.pow(x, e);
        }
        ;
    }
    d3.scale.sqrt = function() {
        return d3.scale.pow().exponent(.5);
    }
    ;
    d3.scale.ordinal = function() {
        return d3_scale_ordinal([], {
            t: "range",
            a: [[]]
        });
    }
    ;
    function d3_scale_ordinal(domain, ranger) {
        var index, range, rangeBand;
        function scale(x) {
            return range[((index.get(x) || (ranger.t === "range" ? index.set(x, domain.push(x)) : NaN)) - 1) % range.length];
        }
        function steps(start, step) {
            return d3.range(domain.length).map(function(i) {
                return start + step * i;
            });
        }
        scale.domain = function(x) {
            if (!arguments.length)
                return domain;
            domain = [];
            index = new d3_Map();
            var i = -1, n = x.length, xi;
            while (++i < n)
                if (!index.has(xi = x[i]))
                    index.set(xi, domain.push(xi));
            return scale[ranger.t].apply(scale, ranger.a);
        }
        ;
        scale.range = function(x) {
            if (!arguments.length)
                return range;
            range = x;
            rangeBand = 0;
            ranger = {
                t: "range",
                a: arguments
            };
            return scale;
        }
        ;
        scale.rangePoints = function(x, padding) {
            if (arguments.length < 2)
                padding = 0;
            var start = x[0]
              , stop = x[1]
              , step = (stop - start) / (Math.max(1, domain.length - 1) + padding);
            range = steps(domain.length < 2 ? (start + stop) / 2 : start + step * padding / 2, step);
            rangeBand = 0;
            ranger = {
                t: "rangePoints",
                a: arguments
            };
            return scale;
        }
        ;
        scale.rangeBands = function(x, padding, outerPadding) {
            if (arguments.length < 2)
                padding = 0;
            if (arguments.length < 3)
                outerPadding = padding;
            var reverse = x[1] < x[0]
              , start = x[reverse - 0]
              , stop = x[1 - reverse]
              , step = (stop - start) / (domain.length - padding + 2 * outerPadding);
            range = steps(start + step * outerPadding, step);
            if (reverse)
                range.reverse();
            rangeBand = step * (1 - padding);
            ranger = {
                t: "rangeBands",
                a: arguments
            };
            return scale;
        }
        ;
        scale.rangeRoundBands = function(x, padding, outerPadding) {
            if (arguments.length < 2)
                padding = 0;
            if (arguments.length < 3)
                outerPadding = padding;
            var reverse = x[1] < x[0]
              , start = x[reverse - 0]
              , stop = x[1 - reverse]
              , step = Math.floor((stop - start) / (domain.length - padding + 2 * outerPadding))
              , error = stop - start - (domain.length - padding) * step;
            range = steps(start + Math.round(error / 2), step);
            if (reverse)
                range.reverse();
            rangeBand = Math.round(step * (1 - padding));
            ranger = {
                t: "rangeRoundBands",
                a: arguments
            };
            return scale;
        }
        ;
        scale.rangeBand = function() {
            return rangeBand;
        }
        ;
        scale.rangeExtent = function() {
            return d3_scaleExtent(ranger.a[0]);
        }
        ;
        scale.copy = function() {
            return d3_scale_ordinal(domain, ranger);
        }
        ;
        return scale.domain(domain);
    }
    d3.scale.category10 = function() {
        return d3.scale.ordinal().range(d3_category10);
    }
    ;
    d3.scale.category20 = function() {
        return d3.scale.ordinal().range(d3_category20);
    }
    ;
    d3.scale.category20b = function() {
        return d3.scale.ordinal().range(d3_category20b);
    }
    ;
    d3.scale.category20c = function() {
        return d3.scale.ordinal().range(d3_category20c);
    }
    ;
    var d3_category10 = [2062260, 16744206, 2924588, 14034728, 9725885, 9197131, 14907330, 8355711, 12369186, 1556175].map(d3_rgbString);
    var d3_category20 = [2062260, 11454440, 16744206, 16759672, 2924588, 10018698, 14034728, 16750742, 9725885, 12955861, 9197131, 12885140, 14907330, 16234194, 8355711, 13092807, 12369186, 14408589, 1556175, 10410725].map(d3_rgbString);
    var d3_category20b = [3750777, 5395619, 7040719, 10264286, 6519097, 9216594, 11915115, 13556636, 9202993, 12426809, 15186514, 15190932, 8666169, 11356490, 14049643, 15177372, 8077683, 10834324, 13528509, 14589654].map(d3_rgbString);
    var d3_category20c = [3244733, 7057110, 10406625, 13032431, 15095053, 16616764, 16625259, 16634018, 3253076, 7652470, 10607003, 13101504, 7695281, 10394312, 12369372, 14342891, 6513507, 9868950, 12434877, 14277081].map(d3_rgbString);
    d3.scale.quantile = function() {
        return d3_scale_quantile([], []);
    }
    ;
    function d3_scale_quantile(domain, range) {
        var thresholds;
        function rescale() {
            var k = 0
              , q = range.length;
            thresholds = [];
            while (++k < q)
                thresholds[k - 1] = d3.quantile(domain, k / q);
            return scale;
        }
        function scale(x) {
            if (!isNaN(x = +x))
                return range[d3.bisect(thresholds, x)];
        }
        scale.domain = function(x) {
            if (!arguments.length)
                return domain;
            domain = x.filter(d3_number).sort(d3_ascending);
            return rescale();
        }
        ;
        scale.range = function(x) {
            if (!arguments.length)
                return range;
            range = x;
            return rescale();
        }
        ;
        scale.quantiles = function() {
            return thresholds;
        }
        ;
        scale.invertExtent = function(y) {
            y = range.indexOf(y);
            return y < 0 ? [NaN, NaN] : [y > 0 ? thresholds[y - 1] : domain[0], y < thresholds.length ? thresholds[y] : domain[domain.length - 1]];
        }
        ;
        scale.copy = function() {
            return d3_scale_quantile(domain, range);
        }
        ;
        return rescale();
    }
    d3.scale.quantize = function() {
        return d3_scale_quantize(0, 1, [0, 1]);
    }
    ;
    function d3_scale_quantize(x0, x1, range) {
        var kx, i;
        function scale(x) {
            return range[Math.max(0, Math.min(i, Math.floor(kx * (x - x0))))];
        }
        function rescale() {
            kx = range.length / (x1 - x0);
            i = range.length - 1;
            return scale;
        }
        scale.domain = function(x) {
            if (!arguments.length)
                return [x0, x1];
            x0 = +x[0];
            x1 = +x[x.length - 1];
            return rescale();
        }
        ;
        scale.range = function(x) {
            if (!arguments.length)
                return range;
            range = x;
            return rescale();
        }
        ;
        scale.invertExtent = function(y) {
            y = range.indexOf(y);
            y = y < 0 ? NaN : y / kx + x0;
            return [y, y + 1 / kx];
        }
        ;
        scale.copy = function() {
            return d3_scale_quantize(x0, x1, range);
        }
        ;
        return rescale();
    }
    d3.scale.threshold = function() {
        return d3_scale_threshold([.5], [0, 1]);
    }
    ;
    function d3_scale_threshold(domain, range) {
        function scale(x) {
            if (x <= x)
                return range[d3.bisect(domain, x)];
        }
        scale.domain = function(_) {
            if (!arguments.length)
                return domain;
            domain = _;
            return scale;
        }
        ;
        scale.range = function(_) {
            if (!arguments.length)
                return range;
            range = _;
            return scale;
        }
        ;
        scale.invertExtent = function(y) {
            y = range.indexOf(y);
            return [domain[y - 1], domain[y]];
        }
        ;
        scale.copy = function() {
            return d3_scale_threshold(domain, range);
        }
        ;
        return scale;
    }
    d3.scale.identity = function() {
        return d3_scale_identity([0, 1]);
    }
    ;
    function d3_scale_identity(domain) {
        function identity(x) {
            return +x;
        }
        identity.invert = identity;
        identity.domain = identity.range = function(x) {
            if (!arguments.length)
                return domain;
            domain = x.map(identity);
            return identity;
        }
        ;
        identity.ticks = function(m) {
            return d3_scale_linearTicks(domain, m);
        }
        ;
        identity.tickFormat = function(m, format) {
            return d3_scale_linearTickFormat(domain, m, format);
        }
        ;
        identity.copy = function() {
            return d3_scale_identity(domain);
        }
        ;
        return identity;
    }
    d3.svg = {};
    d3.svg.arc = function() {
        var innerRadius = d3_svg_arcInnerRadius
          , outerRadius = d3_svg_arcOuterRadius
          , startAngle = d3_svg_arcStartAngle
          , endAngle = d3_svg_arcEndAngle;
        function arc() {
            var r0 = innerRadius.apply(this, arguments)
              , r1 = outerRadius.apply(this, arguments)
              , a0 = startAngle.apply(this, arguments) + d3_svg_arcOffset
              , a1 = endAngle.apply(this, arguments) + d3_svg_arcOffset
              , da = (a1 < a0 && (da = a0,
            a0 = a1,
            a1 = da),
            a1 - a0)
              , df = da < π ? "0" : "1"
              , c0 = Math.cos(a0)
              , s0 = Math.sin(a0)
              , c1 = Math.cos(a1)
              , s1 = Math.sin(a1);
            return da >= d3_svg_arcMax ? r0 ? "M0," + r1 + "A" + r1 + "," + r1 + " 0 1,1 0," + -r1 + "A" + r1 + "," + r1 + " 0 1,1 0," + r1 + "M0," + r0 + "A" + r0 + "," + r0 + " 0 1,0 0," + -r0 + "A" + r0 + "," + r0 + " 0 1,0 0," + r0 + "Z" : "M0," + r1 + "A" + r1 + "," + r1 + " 0 1,1 0," + -r1 + "A" + r1 + "," + r1 + " 0 1,1 0," + r1 + "Z" : r0 ? "M" + r1 * c0 + "," + r1 * s0 + "A" + r1 + "," + r1 + " 0 " + df + ",1 " + r1 * c1 + "," + r1 * s1 + "L" + r0 * c1 + "," + r0 * s1 + "A" + r0 + "," + r0 + " 0 " + df + ",0 " + r0 * c0 + "," + r0 * s0 + "Z" : "M" + r1 * c0 + "," + r1 * s0 + "A" + r1 + "," + r1 + " 0 " + df + ",1 " + r1 * c1 + "," + r1 * s1 + "L0,0" + "Z";
        }
        arc.innerRadius = function(v) {
            if (!arguments.length)
                return innerRadius;
            innerRadius = d3_functor(v);
            return arc;
        }
        ;
        arc.outerRadius = function(v) {
            if (!arguments.length)
                return outerRadius;
            outerRadius = d3_functor(v);
            return arc;
        }
        ;
        arc.startAngle = function(v) {
            if (!arguments.length)
                return startAngle;
            startAngle = d3_functor(v);
            return arc;
        }
        ;
        arc.endAngle = function(v) {
            if (!arguments.length)
                return endAngle;
            endAngle = d3_functor(v);
            return arc;
        }
        ;
        arc.centroid = function() {
            var r = (innerRadius.apply(this, arguments) + outerRadius.apply(this, arguments)) / 2
              , a = (startAngle.apply(this, arguments) + endAngle.apply(this, arguments)) / 2 + d3_svg_arcOffset;
            return [Math.cos(a) * r, Math.sin(a) * r];
        }
        ;
        return arc;
    }
    ;
    var d3_svg_arcOffset = -halfπ
      , d3_svg_arcMax = τ - ε;
    function d3_svg_arcInnerRadius(d) {
        return d.innerRadius;
    }
    function d3_svg_arcOuterRadius(d) {
        return d.outerRadius;
    }
    function d3_svg_arcStartAngle(d) {
        return d.startAngle;
    }
    function d3_svg_arcEndAngle(d) {
        return d.endAngle;
    }
    function d3_svg_line(projection) {
        var x = d3_geom_pointX
          , y = d3_geom_pointY
          , defined = d3_true
          , interpolate = d3_svg_lineLinear
          , interpolateKey = interpolate.key
          , tension = .7;
        function line(data) {
            var segments = [], points = [], i = -1, n = data.length, d, fx = d3_functor(x), fy = d3_functor(y);
            function segment() {
                segments.push("M", interpolate(projection(points), tension));
            }
            while (++i < n) {
                if (defined.call(this, d = data[i], i)) {
                    points.push([+fx.call(this, d, i), +fy.call(this, d, i)]);
                } else if (points.length) {
                    segment();
                    points = [];
                }
            }
            if (points.length)
                segment();
            return segments.length ? segments.join("") : null;
        }
        line.x = function(_) {
            if (!arguments.length)
                return x;
            x = _;
            return line;
        }
        ;
        line.y = function(_) {
            if (!arguments.length)
                return y;
            y = _;
            return line;
        }
        ;
        line.defined = function(_) {
            if (!arguments.length)
                return defined;
            defined = _;
            return line;
        }
        ;
        line.interpolate = function(_) {
            if (!arguments.length)
                return interpolateKey;
            if (typeof _ === "function")
                interpolateKey = interpolate = _;
            else
                interpolateKey = (interpolate = d3_svg_lineInterpolators.get(_) || d3_svg_lineLinear).key;
            return line;
        }
        ;
        line.tension = function(_) {
            if (!arguments.length)
                return tension;
            tension = _;
            return line;
        }
        ;
        return line;
    }
    d3.svg.line = function() {
        return d3_svg_line(d3_identity);
    }
    ;
    var d3_svg_lineInterpolators = d3.map({
        linear: d3_svg_lineLinear,
        "linear-closed": d3_svg_lineLinearClosed,
        step: d3_svg_lineStep,
        "step-before": d3_svg_lineStepBefore,
        "step-after": d3_svg_lineStepAfter,
        basis: d3_svg_lineBasis,
        "basis-open": d3_svg_lineBasisOpen,
        "basis-closed": d3_svg_lineBasisClosed,
        bundle: d3_svg_lineBundle,
        cardinal: d3_svg_lineCardinal,
        "cardinal-open": d3_svg_lineCardinalOpen,
        "cardinal-closed": d3_svg_lineCardinalClosed,
        monotone: d3_svg_lineMonotone
    });
    d3_svg_lineInterpolators.forEach(function(key, value) {
        value.key = key;
        value.closed = /-closed$/.test(key);
    });
    function d3_svg_lineLinear(points) {
        return points.join("L");
    }
    function d3_svg_lineLinearClosed(points) {
        return d3_svg_lineLinear(points) + "Z";
    }
    function d3_svg_lineStep(points) {
        var i = 0
          , n = points.length
          , p = points[0]
          , path = [p[0], ",", p[1]];
        while (++i < n)
            path.push("H", (p[0] + (p = points[i])[0]) / 2, "V", p[1]);
        if (n > 1)
            path.push("H", p[0]);
        return path.join("");
    }
    function d3_svg_lineStepBefore(points) {
        var i = 0
          , n = points.length
          , p = points[0]
          , path = [p[0], ",", p[1]];
        while (++i < n)
            path.push("V", (p = points[i])[1], "H", p[0]);
        return path.join("");
    }
    function d3_svg_lineStepAfter(points) {
        var i = 0
          , n = points.length
          , p = points[0]
          , path = [p[0], ",", p[1]];
        while (++i < n)
            path.push("H", (p = points[i])[0], "V", p[1]);
        return path.join("");
    }
    function d3_svg_lineCardinalOpen(points, tension) {
        return points.length < 4 ? d3_svg_lineLinear(points) : points[1] + d3_svg_lineHermite(points.slice(1, points.length - 1), d3_svg_lineCardinalTangents(points, tension));
    }
    function d3_svg_lineCardinalClosed(points, tension) {
        return points.length < 3 ? d3_svg_lineLinear(points) : points[0] + d3_svg_lineHermite((points.push(points[0]),
        points), d3_svg_lineCardinalTangents([points[points.length - 2]].concat(points, [points[1]]), tension));
    }
    function d3_svg_lineCardinal(points, tension) {
        return points.length < 3 ? d3_svg_lineLinear(points) : points[0] + d3_svg_lineHermite(points, d3_svg_lineCardinalTangents(points, tension));
    }
    function d3_svg_lineHermite(points, tangents) {
        if (tangents.length < 1 || points.length != tangents.length && points.length != tangents.length + 2) {
            return d3_svg_lineLinear(points);
        }
        var quad = points.length != tangents.length
          , path = ""
          , p0 = points[0]
          , p = points[1]
          , t0 = tangents[0]
          , t = t0
          , pi = 1;
        if (quad) {
            path += "Q" + (p[0] - t0[0] * 2 / 3) + "," + (p[1] - t0[1] * 2 / 3) + "," + p[0] + "," + p[1];
            p0 = points[1];
            pi = 2;
        }
        if (tangents.length > 1) {
            t = tangents[1];
            p = points[pi];
            pi++;
            path += "C" + (p0[0] + t0[0]) + "," + (p0[1] + t0[1]) + "," + (p[0] - t[0]) + "," + (p[1] - t[1]) + "," + p[0] + "," + p[1];
            for (var i = 2; i < tangents.length; i++,
            pi++) {
                p = points[pi];
                t = tangents[i];
                path += "S" + (p[0] - t[0]) + "," + (p[1] - t[1]) + "," + p[0] + "," + p[1];
            }
        }
        if (quad) {
            var lp = points[pi];
            path += "Q" + (p[0] + t[0] * 2 / 3) + "," + (p[1] + t[1] * 2 / 3) + "," + lp[0] + "," + lp[1];
        }
        return path;
    }
    function d3_svg_lineCardinalTangents(points, tension) {
        var tangents = [], a = (1 - tension) / 2, p0, p1 = points[0], p2 = points[1], i = 1, n = points.length;
        while (++i < n) {
            p0 = p1;
            p1 = p2;
            p2 = points[i];
            tangents.push([a * (p2[0] - p0[0]), a * (p2[1] - p0[1])]);
        }
        return tangents;
    }
    function d3_svg_lineBasis(points) {
        if (points.length < 3)
            return d3_svg_lineLinear(points);
        var i = 1
          , n = points.length
          , pi = points[0]
          , x0 = pi[0]
          , y0 = pi[1]
          , px = [x0, x0, x0, (pi = points[1])[0]]
          , py = [y0, y0, y0, pi[1]]
          , path = [x0, ",", y0, "L", d3_svg_lineDot4(d3_svg_lineBasisBezier3, px), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier3, py)];
        points.push(points[n - 1]);
        while (++i <= n) {
            pi = points[i];
            px.shift();
            px.push(pi[0]);
            py.shift();
            py.push(pi[1]);
            d3_svg_lineBasisBezier(path, px, py);
        }
        points.pop();
        path.push("L", pi);
        return path.join("");
    }
    function d3_svg_lineBasisOpen(points) {
        if (points.length < 4)
            return d3_svg_lineLinear(points);
        var path = [], i = -1, n = points.length, pi, px = [0], py = [0];
        while (++i < 3) {
            pi = points[i];
            px.push(pi[0]);
            py.push(pi[1]);
        }
        path.push(d3_svg_lineDot4(d3_svg_lineBasisBezier3, px) + "," + d3_svg_lineDot4(d3_svg_lineBasisBezier3, py));
        --i;
        while (++i < n) {
            pi = points[i];
            px.shift();
            px.push(pi[0]);
            py.shift();
            py.push(pi[1]);
            d3_svg_lineBasisBezier(path, px, py);
        }
        return path.join("");
    }
    function d3_svg_lineBasisClosed(points) {
        var path, i = -1, n = points.length, m = n + 4, pi, px = [], py = [];
        while (++i < 4) {
            pi = points[i % n];
            px.push(pi[0]);
            py.push(pi[1]);
        }
        path = [d3_svg_lineDot4(d3_svg_lineBasisBezier3, px), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier3, py)];
        --i;
        while (++i < m) {
            pi = points[i % n];
            px.shift();
            px.push(pi[0]);
            py.shift();
            py.push(pi[1]);
            d3_svg_lineBasisBezier(path, px, py);
        }
        return path.join("");
    }
    function d3_svg_lineBundle(points, tension) {
        var n = points.length - 1;
        if (n) {
            var x0 = points[0][0], y0 = points[0][1], dx = points[n][0] - x0, dy = points[n][1] - y0, i = -1, p, t;
            while (++i <= n) {
                p = points[i];
                t = i / n;
                p[0] = tension * p[0] + (1 - tension) * (x0 + t * dx);
                p[1] = tension * p[1] + (1 - tension) * (y0 + t * dy);
            }
        }
        return d3_svg_lineBasis(points);
    }
    function d3_svg_lineDot4(a, b) {
        return a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3] * b[3];
    }
    var d3_svg_lineBasisBezier1 = [0, 2 / 3, 1 / 3, 0]
      , d3_svg_lineBasisBezier2 = [0, 1 / 3, 2 / 3, 0]
      , d3_svg_lineBasisBezier3 = [0, 1 / 6, 2 / 3, 1 / 6];
    function d3_svg_lineBasisBezier(path, x, y) {
        path.push("C", d3_svg_lineDot4(d3_svg_lineBasisBezier1, x), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier1, y), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier2, x), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier2, y), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier3, x), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier3, y));
    }
    function d3_svg_lineSlope(p0, p1) {
        return (p1[1] - p0[1]) / (p1[0] - p0[0]);
    }
    function d3_svg_lineFiniteDifferences(points) {
        var i = 0
          , j = points.length - 1
          , m = []
          , p0 = points[0]
          , p1 = points[1]
          , d = m[0] = d3_svg_lineSlope(p0, p1);
        while (++i < j) {
            m[i] = (d + (d = d3_svg_lineSlope(p0 = p1, p1 = points[i + 1]))) / 2;
        }
        m[i] = d;
        return m;
    }
    function d3_svg_lineMonotoneTangents(points) {
        var tangents = [], d, a, b, s, m = d3_svg_lineFiniteDifferences(points), i = -1, j = points.length - 1;
        while (++i < j) {
            d = d3_svg_lineSlope(points[i], points[i + 1]);
            if (abs(d) < ε) {
                m[i] = m[i + 1] = 0;
            } else {
                a = m[i] / d;
                b = m[i + 1] / d;
                s = a * a + b * b;
                if (s > 9) {
                    s = d * 3 / Math.sqrt(s);
                    m[i] = s * a;
                    m[i + 1] = s * b;
                }
            }
        }
        i = -1;
        while (++i <= j) {
            s = (points[Math.min(j, i + 1)][0] - points[Math.max(0, i - 1)][0]) / (6 * (1 + m[i] * m[i]));
            tangents.push([s || 0, m[i] * s || 0]);
        }
        return tangents;
    }
    function d3_svg_lineMonotone(points) {
        return points.length < 3 ? d3_svg_lineLinear(points) : points[0] + d3_svg_lineHermite(points, d3_svg_lineMonotoneTangents(points));
    }
    d3.svg.line.radial = function() {
        var line = d3_svg_line(d3_svg_lineRadial);
        line.radius = line.x,
        delete line.x;
        line.angle = line.y,
        delete line.y;
        return line;
    }
    ;
    function d3_svg_lineRadial(points) {
        var point, i = -1, n = points.length, r, a;
        while (++i < n) {
            point = points[i];
            r = point[0];
            a = point[1] + d3_svg_arcOffset;
            point[0] = r * Math.cos(a);
            point[1] = r * Math.sin(a);
        }
        return points;
    }
    function d3_svg_area(projection) {
        var x0 = d3_geom_pointX
          , x1 = d3_geom_pointX
          , y0 = 0
          , y1 = d3_geom_pointY
          , defined = d3_true
          , interpolate = d3_svg_lineLinear
          , interpolateKey = interpolate.key
          , interpolateReverse = interpolate
          , L = "L"
          , tension = .7;
        function area(data) {
            var segments = [], points0 = [], points1 = [], i = -1, n = data.length, d, fx0 = d3_functor(x0), fy0 = d3_functor(y0), fx1 = x0 === x1 ? function() {
                return x;
            }
            : d3_functor(x1), fy1 = y0 === y1 ? function() {
                return y;
            }
            : d3_functor(y1), x, y;
            function segment() {
                segments.push("M", interpolate(projection(points1), tension), L, interpolateReverse(projection(points0.reverse()), tension), "Z");
            }
            while (++i < n) {
                if (defined.call(this, d = data[i], i)) {
                    points0.push([x = +fx0.call(this, d, i), y = +fy0.call(this, d, i)]);
                    points1.push([+fx1.call(this, d, i), +fy1.call(this, d, i)]);
                } else if (points0.length) {
                    segment();
                    points0 = [];
                    points1 = [];
                }
            }
            if (points0.length)
                segment();
            return segments.length ? segments.join("") : null;
        }
        area.x = function(_) {
            if (!arguments.length)
                return x1;
            x0 = x1 = _;
            return area;
        }
        ;
        area.x0 = function(_) {
            if (!arguments.length)
                return x0;
            x0 = _;
            return area;
        }
        ;
        area.x1 = function(_) {
            if (!arguments.length)
                return x1;
            x1 = _;
            return area;
        }
        ;
        area.y = function(_) {
            if (!arguments.length)
                return y1;
            y0 = y1 = _;
            return area;
        }
        ;
        area.y0 = function(_) {
            if (!arguments.length)
                return y0;
            y0 = _;
            return area;
        }
        ;
        area.y1 = function(_) {
            if (!arguments.length)
                return y1;
            y1 = _;
            return area;
        }
        ;
        area.defined = function(_) {
            if (!arguments.length)
                return defined;
            defined = _;
            return area;
        }
        ;
        area.interpolate = function(_) {
            if (!arguments.length)
                return interpolateKey;
            if (typeof _ === "function")
                interpolateKey = interpolate = _;
            else
                interpolateKey = (interpolate = d3_svg_lineInterpolators.get(_) || d3_svg_lineLinear).key;
            interpolateReverse = interpolate.reverse || interpolate;
            L = interpolate.closed ? "M" : "L";
            return area;
        }
        ;
        area.tension = function(_) {
            if (!arguments.length)
                return tension;
            tension = _;
            return area;
        }
        ;
        return area;
    }
    d3_svg_lineStepBefore.reverse = d3_svg_lineStepAfter;
    d3_svg_lineStepAfter.reverse = d3_svg_lineStepBefore;
    d3.svg.area = function() {
        return d3_svg_area(d3_identity);
    }
    ;
    d3.svg.area.radial = function() {
        var area = d3_svg_area(d3_svg_lineRadial);
        area.radius = area.x,
        delete area.x;
        area.innerRadius = area.x0,
        delete area.x0;
        area.outerRadius = area.x1,
        delete area.x1;
        area.angle = area.y,
        delete area.y;
        area.startAngle = area.y0,
        delete area.y0;
        area.endAngle = area.y1,
        delete area.y1;
        return area;
    }
    ;
    d3.svg.chord = function() {
        var source = d3_source
          , target = d3_target
          , radius = d3_svg_chordRadius
          , startAngle = d3_svg_arcStartAngle
          , endAngle = d3_svg_arcEndAngle;
        function chord(d, i) {
            var s = subgroup(this, source, d, i)
              , t = subgroup(this, target, d, i);
            return "M" + s.p0 + arc(s.r, s.p1, s.a1 - s.a0) + (equals(s, t) ? curve(s.r, s.p1, s.r, s.p0) : curve(s.r, s.p1, t.r, t.p0) + arc(t.r, t.p1, t.a1 - t.a0) + curve(t.r, t.p1, s.r, s.p0)) + "Z";
        }
        function subgroup(self, f, d, i) {
            var subgroup = f.call(self, d, i)
              , r = radius.call(self, subgroup, i)
              , a0 = startAngle.call(self, subgroup, i) + d3_svg_arcOffset
              , a1 = endAngle.call(self, subgroup, i) + d3_svg_arcOffset;
            return {
                r: r,
                a0: a0,
                a1: a1,
                p0: [r * Math.cos(a0), r * Math.sin(a0)],
                p1: [r * Math.cos(a1), r * Math.sin(a1)]
            };
        }
        function equals(a, b) {
            return a.a0 == b.a0 && a.a1 == b.a1;
        }
        function arc(r, p, a) {
            return "A" + r + "," + r + " 0 " + (+(a > π)) + ",1 " + p;
        }
        function curve(r0, p0, r1, p1) {
            return "Q 0,0 " + p1;
        }
        chord.radius = function(v) {
            if (!arguments.length)
                return radius;
            radius = d3_functor(v);
            return chord;
        }
        ;
        chord.source = function(v) {
            if (!arguments.length)
                return source;
            source = d3_functor(v);
            return chord;
        }
        ;
        chord.target = function(v) {
            if (!arguments.length)
                return target;
            target = d3_functor(v);
            return chord;
        }
        ;
        chord.startAngle = function(v) {
            if (!arguments.length)
                return startAngle;
            startAngle = d3_functor(v);
            return chord;
        }
        ;
        chord.endAngle = function(v) {
            if (!arguments.length)
                return endAngle;
            endAngle = d3_functor(v);
            return chord;
        }
        ;
        return chord;
    }
    ;
    function d3_svg_chordRadius(d) {
        return d.radius;
    }
    d3.svg.diagonal = function() {
        var source = d3_source
          , target = d3_target
          , projection = d3_svg_diagonalProjection;
        function diagonal(d, i) {
            var p0 = source.call(this, d, i)
              , p3 = target.call(this, d, i)
              , m = (p0.y + p3.y) / 2
              , p = [p0, {
                x: p0.x,
                y: m
            }, {
                x: p3.x,
                y: m
            }, p3];
            p = p.map(projection);
            return "M" + p[0] + "C" + p[1] + " " + p[2] + " " + p[3];
        }
        diagonal.source = function(x) {
            if (!arguments.length)
                return source;
            source = d3_functor(x);
            return diagonal;
        }
        ;
        diagonal.target = function(x) {
            if (!arguments.length)
                return target;
            target = d3_functor(x);
            return diagonal;
        }
        ;
        diagonal.projection = function(x) {
            if (!arguments.length)
                return projection;
            projection = x;
            return diagonal;
        }
        ;
        return diagonal;
    }
    ;
    function d3_svg_diagonalProjection(d) {
        return [d.x, d.y];
    }
    d3.svg.diagonal.radial = function() {
        var diagonal = d3.svg.diagonal()
          , projection = d3_svg_diagonalProjection
          , projection_ = diagonal.projection;
        diagonal.projection = function(x) {
            return arguments.length ? projection_(d3_svg_diagonalRadialProjection(projection = x)) : projection;
        }
        ;
        return diagonal;
    }
    ;
    function d3_svg_diagonalRadialProjection(projection) {
        return function() {
            var d = projection.apply(this, arguments)
              , r = d[0]
              , a = d[1] + d3_svg_arcOffset;
            return [r * Math.cos(a), r * Math.sin(a)];
        }
        ;
    }
    d3.svg.symbol = function() {
        var type = d3_svg_symbolType
          , size = d3_svg_symbolSize;
        function symbol(d, i) {
            return (d3_svg_symbols.get(type.call(this, d, i)) || d3_svg_symbolCircle)(size.call(this, d, i));
        }
        symbol.type = function(x) {
            if (!arguments.length)
                return type;
            type = d3_functor(x);
            return symbol;
        }
        ;
        symbol.size = function(x) {
            if (!arguments.length)
                return size;
            size = d3_functor(x);
            return symbol;
        }
        ;
        return symbol;
    }
    ;
    function d3_svg_symbolSize() {
        return 64;
    }
    function d3_svg_symbolType() {
        return "circle";
    }
    function d3_svg_symbolCircle(size) {
        var r = Math.sqrt(size / π);
        return "M0," + r + "A" + r + "," + r + " 0 1,1 0," + -r + "A" + r + "," + r + " 0 1,1 0," + r + "Z";
    }
    var d3_svg_symbols = d3.map({
        circle: d3_svg_symbolCircle,
        cross: function(size) {
            var r = Math.sqrt(size / 5) / 2;
            return "M" + -3 * r + "," + -r + "H" + -r + "V" + -3 * r + "H" + r + "V" + -r + "H" + 3 * r + "V" + r + "H" + r + "V" + 3 * r + "H" + -r + "V" + r + "H" + -3 * r + "Z";
        },
        diamond: function(size) {
            var ry = Math.sqrt(size / (2 * d3_svg_symbolTan30))
              , rx = ry * d3_svg_symbolTan30;
            return "M0," + -ry + "L" + rx + ",0" + " 0," + ry + " " + -rx + ",0" + "Z";
        },
        square: function(size) {
            var r = Math.sqrt(size) / 2;
            return "M" + -r + "," + -r + "L" + r + "," + -r + " " + r + "," + r + " " + -r + "," + r + "Z";
        },
        "triangle-down": function(size) {
            var rx = Math.sqrt(size / d3_svg_symbolSqrt3)
              , ry = rx * d3_svg_symbolSqrt3 / 2;
            return "M0," + ry + "L" + rx + "," + -ry + " " + -rx + "," + -ry + "Z";
        },
        "triangle-up": function(size) {
            var rx = Math.sqrt(size / d3_svg_symbolSqrt3)
              , ry = rx * d3_svg_symbolSqrt3 / 2;
            return "M0," + -ry + "L" + rx + "," + ry + " " + -rx + "," + ry + "Z";
        }
    });
    d3.svg.symbolTypes = d3_svg_symbols.keys();
    var d3_svg_symbolSqrt3 = Math.sqrt(3)
      , d3_svg_symbolTan30 = Math.tan(30 * d3_radians);
    function d3_transition(groups, id) {
        d3_subclass(groups, d3_transitionPrototype);
        groups.id = id;
        return groups;
    }
    var d3_transitionPrototype = [], d3_transitionId = 0, d3_transitionInheritId, d3_transitionInherit;
    d3_transitionPrototype.call = d3_selectionPrototype.call;
    d3_transitionPrototype.empty = d3_selectionPrototype.empty;
    d3_transitionPrototype.node = d3_selectionPrototype.node;
    d3_transitionPrototype.size = d3_selectionPrototype.size;
    d3.transition = function(selection) {
        return arguments.length ? d3_transitionInheritId ? selection.transition() : selection : d3_selectionRoot.transition();
    }
    ;
    d3.transition.prototype = d3_transitionPrototype;
    d3_transitionPrototype.select = function(selector) {
        var id = this.id, subgroups = [], subgroup, subnode, node;
        selector = d3_selection_selector(selector);
        for (var j = -1, m = this.length; ++j < m; ) {
            subgroups.push(subgroup = []);
            for (var group = this[j], i = -1, n = group.length; ++i < n; ) {
                if ((node = group[i]) && (subnode = selector.call(node, node.__data__, i, j))) {
                    if ("__data__"in node)
                        subnode.__data__ = node.__data__;
                    d3_transitionNode(subnode, i, id, node.__transition__[id]);
                    subgroup.push(subnode);
                } else {
                    subgroup.push(null);
                }
            }
        }
        return d3_transition(subgroups, id);
    }
    ;
    d3_transitionPrototype.selectAll = function(selector) {
        var id = this.id, subgroups = [], subgroup, subnodes, node, subnode, transition;
        selector = d3_selection_selectorAll(selector);
        for (var j = -1, m = this.length; ++j < m; ) {
            for (var group = this[j], i = -1, n = group.length; ++i < n; ) {
                if (node = group[i]) {
                    transition = node.__transition__[id];
                    subnodes = selector.call(node, node.__data__, i, j);
                    subgroups.push(subgroup = []);
                    for (var k = -1, o = subnodes.length; ++k < o; ) {
                        if (subnode = subnodes[k])
                            d3_transitionNode(subnode, k, id, transition);
                        subgroup.push(subnode);
                    }
                }
            }
        }
        return d3_transition(subgroups, id);
    }
    ;
    d3_transitionPrototype.filter = function(filter) {
        var subgroups = [], subgroup, group, node;
        if (typeof filter !== "function")
            filter = d3_selection_filter(filter);
        for (var j = 0, m = this.length; j < m; j++) {
            subgroups.push(subgroup = []);
            for (var group = this[j], i = 0, n = group.length; i < n; i++) {
                if ((node = group[i]) && filter.call(node, node.__data__, i, j)) {
                    subgroup.push(node);
                }
            }
        }
        return d3_transition(subgroups, this.id);
    }
    ;
    d3_transitionPrototype.tween = function(name, tween) {
        var id = this.id;
        if (arguments.length < 2)
            return this.node().__transition__[id].tween.get(name);
        return d3_selection_each(this, tween == null ? function(node) {
            node.__transition__[id].tween.remove(name);
        }
        : function(node) {
            node.__transition__[id].tween.set(name, tween);
        }
        );
    }
    ;
    function d3_transition_tween(groups, name, value, tween) {
        var id = groups.id;
        return d3_selection_each(groups, typeof value === "function" ? function(node, i, j) {
            node.__transition__[id].tween.set(name, tween(value.call(node, node.__data__, i, j)));
        }
        : (value = tween(value),
        function(node) {
            node.__transition__[id].tween.set(name, value);
        }
        ));
    }
    d3_transitionPrototype.attr = function(nameNS, value) {
        if (arguments.length < 2) {
            for (value in nameNS)
                this.attr(value, nameNS[value]);
            return this;
        }
        var interpolate = nameNS == "transform" ? d3_interpolateTransform : d3_interpolate
          , name = d3.ns.qualify(nameNS);
        function attrNull() {
            this.removeAttribute(name);
        }
        function attrNullNS() {
            this.removeAttributeNS(name.space, name.local);
        }
        function attrTween(b) {
            return b == null ? attrNull : (b += "",
            function() {
                var a = this.getAttribute(name), i;
                return a !== b && (i = interpolate(a, b),
                function(t) {
                    this.setAttribute(name, i(t));
                }
                );
            }
            );
        }
        function attrTweenNS(b) {
            return b == null ? attrNullNS : (b += "",
            function() {
                var a = this.getAttributeNS(name.space, name.local), i;
                return a !== b && (i = interpolate(a, b),
                function(t) {
                    this.setAttributeNS(name.space, name.local, i(t));
                }
                );
            }
            );
        }
        return d3_transition_tween(this, "attr." + nameNS, value, name.local ? attrTweenNS : attrTween);
    }
    ;
    d3_transitionPrototype.attrTween = function(nameNS, tween) {
        var name = d3.ns.qualify(nameNS);
        function attrTween(d, i) {
            var f = tween.call(this, d, i, this.getAttribute(name));
            return f && function(t) {
                this.setAttribute(name, f(t));
            }
            ;
        }
        function attrTweenNS(d, i) {
            var f = tween.call(this, d, i, this.getAttributeNS(name.space, name.local));
            return f && function(t) {
                this.setAttributeNS(name.space, name.local, f(t));
            }
            ;
        }
        return this.tween("attr." + nameNS, name.local ? attrTweenNS : attrTween);
    }
    ;
    d3_transitionPrototype.style = function(name, value, priority) {
        var n = arguments.length;
        if (n < 3) {
            if (typeof name !== "string") {
                if (n < 2)
                    value = "";
                for (priority in name)
                    this.style(priority, name[priority], value);
                return this;
            }
            priority = "";
        }
        function styleNull() {
            this.style.removeProperty(name);
        }
        function styleString(b) {
            return b == null ? styleNull : (b += "",
            function() {
                var a = d3_window.getComputedStyle(this, null).getPropertyValue(name), i;
                return a !== b && (i = d3_interpolate(a, b),
                function(t) {
                    this.style.setProperty(name, i(t), priority);
                }
                );
            }
            );
        }
        return d3_transition_tween(this, "style." + name, value, styleString);
    }
    ;
    d3_transitionPrototype.styleTween = function(name, tween, priority) {
        if (arguments.length < 3)
            priority = "";
        function styleTween(d, i) {
            var f = tween.call(this, d, i, d3_window.getComputedStyle(this, null).getPropertyValue(name));
            return f && function(t) {
                this.style.setProperty(name, f(t), priority);
            }
            ;
        }
        return this.tween("style." + name, styleTween);
    }
    ;
    d3_transitionPrototype.text = function(value) {
        return d3_transition_tween(this, "text", value, d3_transition_text);
    }
    ;
    function d3_transition_text(b) {
        if (b == null)
            b = "";
        return function() {
            this.textContent = b;
        }
        ;
    }
    d3_transitionPrototype.remove = function() {
        return this.each("end.transition", function() {
            var p;
            if (this.__transition__.count < 2 && (p = this.parentNode))
                p.removeChild(this);
        });
    }
    ;
    d3_transitionPrototype.ease = function(value) {
        var id = this.id;
        if (arguments.length < 1)
            return this.node().__transition__[id].ease;
        if (typeof value !== "function")
            value = d3.ease.apply(d3, arguments);
        return d3_selection_each(this, function(node) {
            node.__transition__[id].ease = value;
        });
    }
    ;
    d3_transitionPrototype.delay = function(value) {
        var id = this.id;
        if (arguments.length < 1)
            return this.node().__transition__[id].delay;
        return d3_selection_each(this, typeof value === "function" ? function(node, i, j) {
            node.__transition__[id].delay = +value.call(node, node.__data__, i, j);
        }
        : (value = +value,
        function(node) {
            node.__transition__[id].delay = value;
        }
        ));
    }
    ;
    d3_transitionPrototype.duration = function(value) {
        var id = this.id;
        if (arguments.length < 1)
            return this.node().__transition__[id].duration;
        return d3_selection_each(this, typeof value === "function" ? function(node, i, j) {
            node.__transition__[id].duration = Math.max(1, value.call(node, node.__data__, i, j));
        }
        : (value = Math.max(1, value),
        function(node) {
            node.__transition__[id].duration = value;
        }
        ));
    }
    ;
    d3_transitionPrototype.each = function(type, listener) {
        var id = this.id;
        if (arguments.length < 2) {
            var inherit = d3_transitionInherit
              , inheritId = d3_transitionInheritId;
            d3_transitionInheritId = id;
            d3_selection_each(this, function(node, i, j) {
                d3_transitionInherit = node.__transition__[id];
                type.call(node, node.__data__, i, j);
            });
            d3_transitionInherit = inherit;
            d3_transitionInheritId = inheritId;
        } else {
            d3_selection_each(this, function(node) {
                var transition = node.__transition__[id];
                (transition.event || (transition.event = d3.dispatch("start", "end"))).on(type, listener);
            });
        }
        return this;
    }
    ;
    d3_transitionPrototype.transition = function() {
        var id0 = this.id, id1 = ++d3_transitionId, subgroups = [], subgroup, group, node, transition;
        for (var j = 0, m = this.length; j < m; j++) {
            subgroups.push(subgroup = []);
            for (var group = this[j], i = 0, n = group.length; i < n; i++) {
                if (node = group[i]) {
                    transition = Object.create(node.__transition__[id0]);
                    transition.delay += transition.duration;
                    d3_transitionNode(node, i, id1, transition);
                }
                subgroup.push(node);
            }
        }
        return d3_transition(subgroups, id1);
    }
    ;
    function d3_transitionNode(node, i, id, inherit) {
        var lock = node.__transition__ || (node.__transition__ = {
            active: 0,
            count: 0
        })
          , transition = lock[id];
        if (!transition) {
            var time = inherit.time;
            transition = lock[id] = {
                tween: new d3_Map(),
                time: time,
                ease: inherit.ease,
                delay: inherit.delay,
                duration: inherit.duration
            };
            ++lock.count;
            d3.timer(function(elapsed) {
                var d = node.__data__
                  , ease = transition.ease
                  , delay = transition.delay
                  , duration = transition.duration
                  , timer = d3_timer_active
                  , tweened = [];
                timer.t = delay + time;
                if (delay <= elapsed)
                    return start(elapsed - delay);
                timer.c = start;
                function start(elapsed) {
                    if (lock.active > id)
                        return stop();
                    lock.active = id;
                    transition.event && transition.event.start.call(node, d, i);
                    transition.tween.forEach(function(key, value) {
                        if (value = value.call(node, d, i)) {
                            tweened.push(value);
                        }
                    });
                    d3.timer(function() {
                        timer.c = tick(elapsed || 1) ? d3_true : tick;
                        return 1;
                    }, 0, time);
                }
                function tick(elapsed) {
                    if (lock.active !== id)
                        return stop();
                    var t = elapsed / duration
                      , e = ease(t)
                      , n = tweened.length;
                    while (n > 0) {
                        tweened[--n].call(node, e);
                    }
                    if (t >= 1) {
                        transition.event && transition.event.end.call(node, d, i);
                        return stop();
                    }
                }
                function stop() {
                    if (--lock.count)
                        delete lock[id];
                    else
                        delete node.__transition__;
                    return 1;
                }
            }, 0, time);
        }
    }
    d3.svg.axis = function() {
        var scale = d3.scale.linear(), orient = d3_svg_axisDefaultOrient, innerTickSize = 6, outerTickSize = 6, tickPadding = 3, tickArguments_ = [10], tickValues = null, tickFormat_;
        function axis(g) {
            g.each(function() {
                var g = d3.select(this);
                var scale0 = this.__chart__ || scale
                  , scale1 = this.__chart__ = scale.copy();
                var ticks = tickValues == null ? scale1.ticks ? scale1.ticks.apply(scale1, tickArguments_) : scale1.domain() : tickValues, tickFormat = tickFormat_ == null ? scale1.tickFormat ? scale1.tickFormat.apply(scale1, tickArguments_) : d3_identity : tickFormat_, tick = g.selectAll(".tick").data(ticks, scale1), tickEnter = tick.enter().insert("g", ".domain").attr("class", "tick").style("opacity", ε), tickExit = d3.transition(tick.exit()).style("opacity", ε).remove(), tickUpdate = d3.transition(tick.order()).style("opacity", 1), tickTransform;
                var range = d3_scaleRange(scale1)
                  , path = g.selectAll(".domain").data([0])
                  , pathUpdate = (path.enter().append("path").attr("class", "domain"),
                d3.transition(path));
                tickEnter.append("line");
                tickEnter.append("text");
                var lineEnter = tickEnter.select("line")
                  , lineUpdate = tickUpdate.select("line")
                  , text = tick.select("text").text(tickFormat)
                  , textEnter = tickEnter.select("text")
                  , textUpdate = tickUpdate.select("text");
                switch (orient) {
                case "bottom":
                    {
                        tickTransform = d3_svg_axisX;
                        lineEnter.attr("y2", innerTickSize);
                        textEnter.attr("y", Math.max(innerTickSize, 0) + tickPadding);
                        lineUpdate.attr("x2", 0).attr("y2", innerTickSize);
                        textUpdate.attr("x", 0).attr("y", Math.max(innerTickSize, 0) + tickPadding);
                        text.attr("dy", ".71em").style("text-anchor", "middle");
                        pathUpdate.attr("d", "M" + range[0] + "," + outerTickSize + "V0H" + range[1] + "V" + outerTickSize);
                        break;
                    }

                case "top":
                    {
                        tickTransform = d3_svg_axisX;
                        lineEnter.attr("y2", -innerTickSize);
                        textEnter.attr("y", -(Math.max(innerTickSize, 0) + tickPadding));
                        lineUpdate.attr("x2", 0).attr("y2", -innerTickSize);
                        textUpdate.attr("x", 0).attr("y", -(Math.max(innerTickSize, 0) + tickPadding));
                        text.attr("dy", "0em").style("text-anchor", "middle");
                        pathUpdate.attr("d", "M" + range[0] + "," + -outerTickSize + "V0H" + range[1] + "V" + -outerTickSize);
                        break;
                    }

                case "left":
                    {
                        tickTransform = d3_svg_axisY;
                        lineEnter.attr("x2", -innerTickSize);
                        textEnter.attr("x", -(Math.max(innerTickSize, 0) + tickPadding));
                        lineUpdate.attr("x2", -innerTickSize).attr("y2", 0);
                        textUpdate.attr("x", -(Math.max(innerTickSize, 0) + tickPadding)).attr("y", 0);
                        text.attr("dy", ".32em").style("text-anchor", "end");
                        pathUpdate.attr("d", "M" + -outerTickSize + "," + range[0] + "H0V" + range[1] + "H" + -outerTickSize);
                        break;
                    }

                case "right":
                    {
                        tickTransform = d3_svg_axisY;
                        lineEnter.attr("x2", innerTickSize);
                        textEnter.attr("x", Math.max(innerTickSize, 0) + tickPadding);
                        lineUpdate.attr("x2", innerTickSize).attr("y2", 0);
                        textUpdate.attr("x", Math.max(innerTickSize, 0) + tickPadding).attr("y", 0);
                        text.attr("dy", ".32em").style("text-anchor", "start");
                        pathUpdate.attr("d", "M" + outerTickSize + "," + range[0] + "H0V" + range[1] + "H" + outerTickSize);
                        break;
                    }
                }
                if (scale1.rangeBand) {
                    var x = scale1
                      , dx = x.rangeBand() / 2;
                    scale0 = scale1 = function(d) {
                        return x(d) + dx;
                    }
                    ;
                } else if (scale0.rangeBand) {
                    scale0 = scale1;
                } else {
                    tickExit.call(tickTransform, scale1);
                }
                tickEnter.call(tickTransform, scale0);
                tickUpdate.call(tickTransform, scale1);
            });
        }
        axis.scale = function(x) {
            if (!arguments.length)
                return scale;
            scale = x;
            return axis;
        }
        ;
        axis.orient = function(x) {
            if (!arguments.length)
                return orient;
            orient = x in d3_svg_axisOrients ? x + "" : d3_svg_axisDefaultOrient;
            return axis;
        }
        ;
        axis.ticks = function() {
            if (!arguments.length)
                return tickArguments_;
            tickArguments_ = arguments;
            return axis;
        }
        ;
        axis.tickValues = function(x) {
            if (!arguments.length)
                return tickValues;
            tickValues = x;
            return axis;
        }
        ;
        axis.tickFormat = function(x) {
            if (!arguments.length)
                return tickFormat_;
            tickFormat_ = x;
            return axis;
        }
        ;
        axis.tickSize = function(x) {
            var n = arguments.length;
            if (!n)
                return innerTickSize;
            innerTickSize = +x;
            outerTickSize = +arguments[n - 1];
            return axis;
        }
        ;
        axis.innerTickSize = function(x) {
            if (!arguments.length)
                return innerTickSize;
            innerTickSize = +x;
            return axis;
        }
        ;
        axis.outerTickSize = function(x) {
            if (!arguments.length)
                return outerTickSize;
            outerTickSize = +x;
            return axis;
        }
        ;
        axis.tickPadding = function(x) {
            if (!arguments.length)
                return tickPadding;
            tickPadding = +x;
            return axis;
        }
        ;
        axis.tickSubdivide = function() {
            return arguments.length && axis;
        }
        ;
        return axis;
    }
    ;
    var d3_svg_axisDefaultOrient = "bottom"
      , d3_svg_axisOrients = {
        top: 1,
        right: 1,
        bottom: 1,
        left: 1
    };
    function d3_svg_axisX(selection, x) {
        selection.attr("transform", function(d) {
            return "translate(" + x(d) + ",0)";
        });
    }
    function d3_svg_axisY(selection, y) {
        selection.attr("transform", function(d) {
            return "translate(0," + y(d) + ")";
        });
    }
    d3.svg.brush = function() {
        var event = d3_eventDispatch(brush, "brushstart", "brush", "brushend"), x = null, y = null, xExtent = [0, 0], yExtent = [0, 0], xExtentDomain, yExtentDomain, xClamp = true, yClamp = true, resizes = d3_svg_brushResizes[0];
        function brush(g) {
            g.each(function() {
                var g = d3.select(this).style("pointer-events", "all").style("-webkit-tap-highlight-color", "rgba(0,0,0,0)").on("mousedown.brush", brushstart).on("touchstart.brush", brushstart);
                var background = g.selectAll(".background").data([0]);
                background.enter().append("rect").attr("class", "background").style("visibility", "hidden").style("cursor", "crosshair");
                g.selectAll(".extent").data([0]).enter().append("rect").attr("class", "extent").style("cursor", "move");
                var resize = g.selectAll(".resize").data(resizes, d3_identity);
                resize.exit().remove();
                resize.enter().append("g").attr("class", function(d) {
                    return "resize " + d;
                }).style("cursor", function(d) {
                    return d3_svg_brushCursor[d];
                }).append("rect").attr("x", function(d) {
                    return /[ew]$/.test(d) ? -3 : null;
                }).attr("y", function(d) {
                    return /^[ns]/.test(d) ? -3 : null;
                }).attr("width", 6).attr("height", 6).style("visibility", "hidden");
                resize.style("display", brush.empty() ? "none" : null);
                var gUpdate = d3.transition(g), backgroundUpdate = d3.transition(background), range;
                if (x) {
                    range = d3_scaleRange(x);
                    backgroundUpdate.attr("x", range[0]).attr("width", range[1] - range[0]);
                    redrawX(gUpdate);
                }
                if (y) {
                    range = d3_scaleRange(y);
                    backgroundUpdate.attr("y", range[0]).attr("height", range[1] - range[0]);
                    redrawY(gUpdate);
                }
                redraw(gUpdate);
            });
        }
        brush.event = function(g) {
            g.each(function() {
                var event_ = event.of(this, arguments)
                  , extent1 = {
                    x: xExtent,
                    y: yExtent,
                    i: xExtentDomain,
                    j: yExtentDomain
                }
                  , extent0 = this.__chart__ || extent1;
                this.__chart__ = extent1;
                if (d3_transitionInheritId) {
                    d3.select(this).transition().each("start.brush", function() {
                        xExtentDomain = extent0.i;
                        yExtentDomain = extent0.j;
                        xExtent = extent0.x;
                        yExtent = extent0.y;
                        event_({
                            type: "brushstart"
                        });
                    }).tween("brush:brush", function() {
                        var xi = d3_interpolateArray(xExtent, extent1.x)
                          , yi = d3_interpolateArray(yExtent, extent1.y);
                        xExtentDomain = yExtentDomain = null;
                        return function(t) {
                            xExtent = extent1.x = xi(t);
                            yExtent = extent1.y = yi(t);
                            event_({
                                type: "brush",
                                mode: "resize"
                            });
                        }
                        ;
                    }).each("end.brush", function() {
                        xExtentDomain = extent1.i;
                        yExtentDomain = extent1.j;
                        event_({
                            type: "brush",
                            mode: "resize"
                        });
                        event_({
                            type: "brushend"
                        });
                    });
                } else {
                    event_({
                        type: "brushstart"
                    });
                    event_({
                        type: "brush",
                        mode: "resize"
                    });
                    event_({
                        type: "brushend"
                    });
                }
            });
        }
        ;
        function redraw(g) {
            g.selectAll(".resize").attr("transform", function(d) {
                return "translate(" + xExtent[+/e$/.test(d)] + "," + yExtent[+/^s/.test(d)] + ")";
            });
        }
        function redrawX(g) {
            g.select(".extent").attr("x", xExtent[0]);
            g.selectAll(".extent,.n>rect,.s>rect").attr("width", xExtent[1] - xExtent[0]);
        }
        function redrawY(g) {
            g.select(".extent").attr("y", yExtent[0]);
            g.selectAll(".extent,.e>rect,.w>rect").attr("height", yExtent[1] - yExtent[0]);
        }
        function brushstart() {
            var target = this, eventTarget = d3.select(d3.event.target), event_ = event.of(target, arguments), g = d3.select(target), resizing = eventTarget.datum(), resizingX = !/^(n|s)$/.test(resizing) && x, resizingY = !/^(e|w)$/.test(resizing) && y, dragging = eventTarget.classed("extent"), dragRestore = d3_event_dragSuppress(), center, origin = d3.mouse(target), offset;
            var w = d3.select(d3_window).on("keydown.brush", keydown).on("keyup.brush", keyup);
            if (d3.event.changedTouches) {
                w.on("touchmove.brush", brushmove).on("touchend.brush", brushend);
            } else {
                w.on("mousemove.brush", brushmove).on("mouseup.brush", brushend);
            }
            g.interrupt().selectAll("*").interrupt();
            if (dragging) {
                origin[0] = xExtent[0] - origin[0];
                origin[1] = yExtent[0] - origin[1];
            } else if (resizing) {
                var ex = +/w$/.test(resizing)
                  , ey = +/^n/.test(resizing);
                offset = [xExtent[1 - ex] - origin[0], yExtent[1 - ey] - origin[1]];
                origin[0] = xExtent[ex];
                origin[1] = yExtent[ey];
            } else if (d3.event.altKey)
                center = origin.slice();
            g.style("pointer-events", "none").selectAll(".resize").style("display", null);
            d3.select("body").style("cursor", eventTarget.style("cursor"));
            event_({
                type: "brushstart"
            });
            brushmove();
            function keydown() {
                if (d3.event.keyCode == 32) {
                    if (!dragging) {
                        center = null;
                        origin[0] -= xExtent[1];
                        origin[1] -= yExtent[1];
                        dragging = 2;
                    }
                    d3_eventPreventDefault();
                }
            }
            function keyup() {
                if (d3.event.keyCode == 32 && dragging == 2) {
                    origin[0] += xExtent[1];
                    origin[1] += yExtent[1];
                    dragging = 0;
                    d3_eventPreventDefault();
                }
            }
            function brushmove() {
                var point = d3.mouse(target)
                  , moved = false;
                if (offset) {
                    point[0] += offset[0];
                    point[1] += offset[1];
                }
                if (!dragging) {
                    if (d3.event.altKey) {
                        if (!center)
                            center = [(xExtent[0] + xExtent[1]) / 2, (yExtent[0] + yExtent[1]) / 2];
                        origin[0] = xExtent[+(point[0] < center[0])];
                        origin[1] = yExtent[+(point[1] < center[1])];
                    } else
                        center = null;
                }
                if (resizingX && move1(point, x, 0)) {
                    redrawX(g);
                    moved = true;
                }
                if (resizingY && move1(point, y, 1)) {
                    redrawY(g);
                    moved = true;
                }
                if (moved) {
                    redraw(g);
                    event_({
                        type: "brush",
                        mode: dragging ? "move" : "resize"
                    });
                }
            }
            function move1(point, scale, i) {
                var range = d3_scaleRange(scale), r0 = range[0], r1 = range[1], position = origin[i], extent = i ? yExtent : xExtent, size = extent[1] - extent[0], min, max;
                if (dragging) {
                    r0 -= position;
                    r1 -= size + position;
                }
                min = (i ? yClamp : xClamp) ? Math.max(r0, Math.min(r1, point[i])) : point[i];
                if (dragging) {
                    max = (min += position) + size;
                } else {
                    if (center)
                        position = Math.max(r0, Math.min(r1, 2 * center[i] - min));
                    if (position < min) {
                        max = min;
                        min = position;
                    } else {
                        max = position;
                    }
                }
                if (extent[0] != min || extent[1] != max) {
                    if (i)
                        yExtentDomain = null;
                    else
                        xExtentDomain = null;
                    extent[0] = min;
                    extent[1] = max;
                    return true;
                }
            }
            function brushend() {
                brushmove();
                g.style("pointer-events", "all").selectAll(".resize").style("display", brush.empty() ? "none" : null);
                d3.select("body").style("cursor", null);
                w.on("mousemove.brush", null).on("mouseup.brush", null).on("touchmove.brush", null).on("touchend.brush", null).on("keydown.brush", null).on("keyup.brush", null);
                dragRestore();
                event_({
                    type: "brushend"
                });
            }
        }
        brush.x = function(z) {
            if (!arguments.length)
                return x;
            x = z;
            resizes = d3_svg_brushResizes[!x << 1 | !y];
            return brush;
        }
        ;
        brush.y = function(z) {
            if (!arguments.length)
                return y;
            y = z;
            resizes = d3_svg_brushResizes[!x << 1 | !y];
            return brush;
        }
        ;
        brush.clamp = function(z) {
            if (!arguments.length)
                return x && y ? [xClamp, yClamp] : x ? xClamp : y ? yClamp : null;
            if (x && y)
                xClamp = !!z[0],
                yClamp = !!z[1];
            else if (x)
                xClamp = !!z;
            else if (y)
                yClamp = !!z;
            return brush;
        }
        ;
        brush.extent = function(z) {
            var x0, x1, y0, y1, t;
            if (!arguments.length) {
                if (x) {
                    if (xExtentDomain) {
                        x0 = xExtentDomain[0],
                        x1 = xExtentDomain[1];
                    } else {
                        x0 = xExtent[0],
                        x1 = xExtent[1];
                        if (x.invert)
                            x0 = x.invert(x0),
                            x1 = x.invert(x1);
                        if (x1 < x0)
                            t = x0,
                            x0 = x1,
                            x1 = t;
                    }
                }
                if (y) {
                    if (yExtentDomain) {
                        y0 = yExtentDomain[0],
                        y1 = yExtentDomain[1];
                    } else {
                        y0 = yExtent[0],
                        y1 = yExtent[1];
                        if (y.invert)
                            y0 = y.invert(y0),
                            y1 = y.invert(y1);
                        if (y1 < y0)
                            t = y0,
                            y0 = y1,
                            y1 = t;
                    }
                }
                return x && y ? [[x0, y0], [x1, y1]] : x ? [x0, x1] : y && [y0, y1];
            }
            if (x) {
                x0 = z[0],
                x1 = z[1];
                if (y)
                    x0 = x0[0],
                    x1 = x1[0];
                xExtentDomain = [x0, x1];
                if (x.invert)
                    x0 = x(x0),
                    x1 = x(x1);
                if (x1 < x0)
                    t = x0,
                    x0 = x1,
                    x1 = t;
                if (x0 != xExtent[0] || x1 != xExtent[1])
                    xExtent = [x0, x1];
            }
            if (y) {
                y0 = z[0],
                y1 = z[1];
                if (x)
                    y0 = y0[1],
                    y1 = y1[1];
                yExtentDomain = [y0, y1];
                if (y.invert)
                    y0 = y(y0),
                    y1 = y(y1);
                if (y1 < y0)
                    t = y0,
                    y0 = y1,
                    y1 = t;
                if (y0 != yExtent[0] || y1 != yExtent[1])
                    yExtent = [y0, y1];
            }
            return brush;
        }
        ;
        brush.clear = function() {
            if (!brush.empty()) {
                xExtent = [0, 0],
                yExtent = [0, 0];
                xExtentDomain = yExtentDomain = null;
            }
            return brush;
        }
        ;
        brush.empty = function() {
            return !!x && xExtent[0] == xExtent[1] || !!y && yExtent[0] == yExtent[1];
        }
        ;
        return d3.rebind(brush, event, "on");
    }
    ;
    var d3_svg_brushCursor = {
        n: "ns-resize",
        e: "ew-resize",
        s: "ns-resize",
        w: "ew-resize",
        nw: "nwse-resize",
        ne: "nesw-resize",
        se: "nwse-resize",
        sw: "nesw-resize"
    };
    var d3_svg_brushResizes = [["n", "e", "s", "w", "nw", "ne", "se", "sw"], ["e", "w"], ["n", "s"], []];
    var d3_time_format = d3_time.format = d3_locale_enUS.timeFormat;
    var d3_time_formatUtc = d3_time_format.utc;
    var d3_time_formatIso = d3_time_formatUtc("%Y-%m-%dT%H:%M:%S.%LZ");
    d3_time_format.iso = Date.prototype.toISOString && +new Date("2000-01-01T00:00:00.000Z") ? d3_time_formatIsoNative : d3_time_formatIso;
    function d3_time_formatIsoNative(date) {
        return date.toISOString();
    }
    d3_time_formatIsoNative.parse = function(string) {
        var date = new Date(string);
        return isNaN(date) ? null : date;
    }
    ;
    d3_time_formatIsoNative.toString = d3_time_formatIso.toString;
    d3_time.second = d3_time_interval(function(date) {
        return new d3_date(Math.floor(date / 1e3) * 1e3);
    }, function(date, offset) {
        date.setTime(date.getTime() + Math.floor(offset) * 1e3);
    }, function(date) {
        return date.getSeconds();
    });
    d3_time.seconds = d3_time.second.range;
    d3_time.seconds.utc = d3_time.second.utc.range;
    d3_time.minute = d3_time_interval(function(date) {
        return new d3_date(Math.floor(date / 6e4) * 6e4);
    }, function(date, offset) {
        date.setTime(date.getTime() + Math.floor(offset) * 6e4);
    }, function(date) {
        return date.getMinutes();
    });
    d3_time.minutes = d3_time.minute.range;
    d3_time.minutes.utc = d3_time.minute.utc.range;
    d3_time.hour = d3_time_interval(function(date) {
        var timezone = date.getTimezoneOffset() / 60;
        return new d3_date((Math.floor(date / 36e5 - timezone) + timezone) * 36e5);
    }, function(date, offset) {
        date.setTime(date.getTime() + Math.floor(offset) * 36e5);
    }, function(date) {
        return date.getHours();
    });
    d3_time.hours = d3_time.hour.range;
    d3_time.hours.utc = d3_time.hour.utc.range;
    d3_time.month = d3_time_interval(function(date) {
        date = d3_time.day(date);
        date.setDate(1);
        return date;
    }, function(date, offset) {
        date.setMonth(date.getMonth() + offset);
    }, function(date) {
        return date.getMonth();
    });
    d3_time.months = d3_time.month.range;
    d3_time.months.utc = d3_time.month.utc.range;
    function d3_time_scale(linear, methods, format) {
        function scale(x) {
            return linear(x);
        }
        scale.invert = function(x) {
            return d3_time_scaleDate(linear.invert(x));
        }
        ;
        scale.domain = function(x) {
            if (!arguments.length)
                return linear.domain().map(d3_time_scaleDate);
            linear.domain(x);
            return scale;
        }
        ;
        function tickMethod(extent, count) {
            var span = extent[1] - extent[0]
              , target = span / count
              , i = d3.bisect(d3_time_scaleSteps, target);
            return i == d3_time_scaleSteps.length ? [methods.year, d3_scale_linearTickRange(extent.map(function(d) {
                return d / 31536e6;
            }), count)[2]] : !i ? [d3_time_scaleMilliseconds, d3_scale_linearTickRange(extent, count)[2]] : methods[target / d3_time_scaleSteps[i - 1] < d3_time_scaleSteps[i] / target ? i - 1 : i];
        }
        scale.nice = function(interval, skip) {
            var domain = scale.domain()
              , extent = d3_scaleExtent(domain)
              , method = interval == null ? tickMethod(extent, 10) : typeof interval === "number" && tickMethod(extent, interval);
            if (method)
                interval = method[0],
                skip = method[1];
            function skipped(date) {
                return !isNaN(date) && !interval.range(date, d3_time_scaleDate(+date + 1), skip).length;
            }
            return scale.domain(d3_scale_nice(domain, skip > 1 ? {
                floor: function(date) {
                    while (skipped(date = interval.floor(date)))
                        date = d3_time_scaleDate(date - 1);
                    return date;
                },
                ceil: function(date) {
                    while (skipped(date = interval.ceil(date)))
                        date = d3_time_scaleDate(+date + 1);
                    return date;
                }
            } : interval));
        }
        ;
        scale.ticks = function(interval, skip) {
            var extent = d3_scaleExtent(scale.domain())
              , method = interval == null ? tickMethod(extent, 10) : typeof interval === "number" ? tickMethod(extent, interval) : !interval.range && [{
                range: interval
            }, skip];
            if (method)
                interval = method[0],
                skip = method[1];
            return interval.range(extent[0], d3_time_scaleDate(+extent[1] + 1), skip < 1 ? 1 : skip);
        }
        ;
        scale.tickFormat = function() {
            return format;
        }
        ;
        scale.copy = function() {
            return d3_time_scale(linear.copy(), methods, format);
        }
        ;
        return d3_scale_linearRebind(scale, linear);
    }
    function d3_time_scaleDate(t) {
        return new Date(t);
    }
    var d3_time_scaleSteps = [1e3, 5e3, 15e3, 3e4, 6e4, 3e5, 9e5, 18e5, 36e5, 108e5, 216e5, 432e5, 864e5, 1728e5, 6048e5, 2592e6, 7776e6, 31536e6];
    var d3_time_scaleLocalMethods = [[d3_time.second, 1], [d3_time.second, 5], [d3_time.second, 15], [d3_time.second, 30], [d3_time.minute, 1], [d3_time.minute, 5], [d3_time.minute, 15], [d3_time.minute, 30], [d3_time.hour, 1], [d3_time.hour, 3], [d3_time.hour, 6], [d3_time.hour, 12], [d3_time.day, 1], [d3_time.day, 2], [d3_time.week, 1], [d3_time.month, 1], [d3_time.month, 3], [d3_time.year, 1]];
    var d3_time_scaleLocalFormat = d3_time_format.multi([[".%L", function(d) {
        return d.getMilliseconds();
    }
    ], [":%S", function(d) {
        return d.getSeconds();
    }
    ], ["%I:%M", function(d) {
        return d.getMinutes();
    }
    ], ["%I %p", function(d) {
        return d.getHours();
    }
    ], ["%a %d", function(d) {
        return d.getDay() && d.getDate() != 1;
    }
    ], ["%b %d", function(d) {
        return d.getDate() != 1;
    }
    ], ["%B", function(d) {
        return d.getMonth();
    }
    ], ["%Y", d3_true]]);
    var d3_time_scaleMilliseconds = {
        range: function(start, stop, step) {
            return d3.range(Math.ceil(start / step) * step, +stop, step).map(d3_time_scaleDate);
        },
        floor: d3_identity,
        ceil: d3_identity
    };
    d3_time_scaleLocalMethods.year = d3_time.year;
    d3_time.scale = function() {
        return d3_time_scale(d3.scale.linear(), d3_time_scaleLocalMethods, d3_time_scaleLocalFormat);
    }
    ;
    var d3_time_scaleUtcMethods = d3_time_scaleLocalMethods.map(function(m) {
        return [m[0].utc, m[1]];
    });
    var d3_time_scaleUtcFormat = d3_time_formatUtc.multi([[".%L", function(d) {
        return d.getUTCMilliseconds();
    }
    ], [":%S", function(d) {
        return d.getUTCSeconds();
    }
    ], ["%I:%M", function(d) {
        return d.getUTCMinutes();
    }
    ], ["%I %p", function(d) {
        return d.getUTCHours();
    }
    ], ["%a %d", function(d) {
        return d.getUTCDay() && d.getUTCDate() != 1;
    }
    ], ["%b %d", function(d) {
        return d.getUTCDate() != 1;
    }
    ], ["%B", function(d) {
        return d.getUTCMonth();
    }
    ], ["%Y", d3_true]]);
    d3_time_scaleUtcMethods.year = d3_time.year.utc;
    d3_time.scale.utc = function() {
        return d3_time_scale(d3.scale.linear(), d3_time_scaleUtcMethods, d3_time_scaleUtcFormat);
    }
    ;
    d3.text = d3_xhrType(function(request) {
        return request.responseText;
    });
    d3.json = function(url, callback) {
        return d3_xhr(url, "application/json", d3_json, callback);
    }
    ;
    function d3_json(request) {
        return JSON.parse(request.responseText);
    }
    d3.html = function(url, callback) {
        return d3_xhr(url, "text/html", d3_html, callback);
    }
    ;
    function d3_html(request) {
        var range = d3_document.createRange();
        range.selectNode(d3_document.body);
        return range.createContextualFragment(request.responseText);
    }
    d3.xml = d3_xhrType(function(request) {
        return request.responseXML;
    });
    if (typeof define === "function" && define.amd) {
        define(d3);
    } else if (typeof module === "object" && module.exports) {
        module.exports = d3;
    } else {
        this.d3 = d3;
    }
}();

/*! Copyright 2010 Stanford Visualization Group, Mike Bostock, BSD license. */

/*! 10fd5c729c201633f0967565b7cc78a0d507bab7 */

/*
 * TERMS OF USE - EASING EQUATIONS
 *
 * Open source under the BSD License.
 *
 * Copyright 2001 Robert Penner
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * - Redistributions of source code must retain the above copyright notice, this
 *   list of conditions and the following disclaimer.
 *
 * - Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 *
 * - Neither the name of the author nor the names of contributors may be used to
 *   endorse or promote products derived from this software without specific
 *   prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

function genNumberTicks(N, min, max, options) {
    var ticks, span = max - min;
    if (span && isFinite(span)) {
        var precision = pv.parseNumNonNeg(pv.get(options, "precision", 0))
          , precisionMin = pv.parseNumNonNeg(pv.get(options, "precisionMin", 0))
          , precisionMax = pv.parseNumNonNeg(pv.get(options, "precisionMax", 1 / 0))
          , roundInside = pv.get(options, "roundInside", !0);
        isFinite(precision) || (precision = 0);
        isFinite(precisionMin) || (precisionMin = 0);
        precisionMax || (precisionMax = 1 / 0);
        var exponentMin = pv.get(options, "numberExponentMin")
          , exponentMax = pv.get(options, "numberExponentMax");
        null != exponentMin && isFinite(exponentMin) && (precisionMin = Math.max(precisionMin, Math.pow(10, Math.floor(exponentMin))));
        null != exponentMax && isFinite(exponentMax) && (precisionMax = Math.min(precisionMax, 5 * Math.pow(10, Math.floor(exponentMax))));
        if (roundInside) {
            precisionMin > span && (precisionMin = span);
            precisionMax > span && (precisionMax = span);
        }
        precisionMin > precisionMax && (precisionMax = precisionMin);
        precision ? precision = Math.max(Math.min(precision, precisionMax), precisionMin) : precisionMin === precisionMax && (precision = precisionMin);
        var result, precMin, precMax, NObtained, overflow = 0, fixed = !!precision;
        if (fixed) {
            result = {
                base: Math.abs(precision),
                mult: 1,
                value: 1
            };
            result.value = result.base;
        } else {
            var NMax = pv.parseNumNonNeg(pv.get(options, "tickCountMax", 1 / 0));
            1 > NMax && (NMax = 1);
            null == N ? N = Math.min(10, NMax) : isFinite(N) ? N > NMax && (N = NMax) : N = isFinite(NMax) ? NMax : 10;
            result = {
                base: isFinite(N) ? pv.logFloor(span / N, 10) : 0,
                mult: 1,
                value: 1
            };
            result.value = result.base;
            if (precisionMin > 0) {
                precMin = readNumberPrecision(precisionMin, !0);
                if (result.value < precMin.value) {
                    numberCopyResult(result, precMin);
                    overflow = -1;
                }
            }
            if (isFinite(precisionMax)) {
                precMax = readNumberPrecision(precisionMax, !1);
                if (precMin && precMax.value <= precMin.value)
                    precMax = null;
                else if (precMax.value < result.value) {
                    numberCopyResult(result, precMax);
                    overflow = 1;
                }
            }
            if (1 !== overflow && isFinite(N) && result.mult < 10) {
                NObtained = span / result.base;
                if (NObtained > N) {
                    var err = N / NObtained;
                    .15 >= err ? result.mult = 10 : result.mult < 5 && (.35 >= err ? result.mult = 5 : result.mult < 2 && .75 >= err && (result.mult = 2));
                    if (result.mult > 1) {
                        result.value = result.base * result.mult;
                        if (precMin && result.value < precMin.value) {
                            numberCopyResult(result, precMin);
                            overflow = -1;
                        } else if (precMax && precMax.value < result.value) {
                            numberCopyResult(result, precMax);
                            overflow = 1;
                        } else if (10 === result.mult) {
                            result.base *= 10;
                            result.mult = 1;
                        }
                    }
                }
            }
        }
        for (var resultPrev; ; ) {
            var step = result.value
              , start = step * Math[roundInside ? "ceil" : "floor"](min / step)
              , end = step * Math[roundInside ? "floor" : "ceil"](max / step);
            if (resultPrev && (start > end || precMax && end - start > precMax.value)) {
                result = resultPrev;
                break;
            }
            var exponent = Math.floor(pv.log(step, 10) + 1e-10);
            result.decPlaces = Math.max(0, -exponent);
            result.ticks = pv.range(start, end + step, step);
            if (fixed || overflow > 0 || result.ticks.length <= NMax)
                break;
            if (resultPrev && resultPrev.ticks.length <= result.ticks.length) {
                result = resultPrev;
                break;
            }
            result = numberResultAbove(resultPrev = result);
        }
        ticks = result.ticks;
        ticks.step = result.value;
        ticks.base = result.base;
        ticks.mult = result.mult;
        ticks.decPlaces = result.decPlaces;
        ticks.format = pv.Format.number().fractionDigits(result.decPlaces);
    } else {
        ticks = [+min];
        ticks.step = ticks.base = ticks.mult = 1;
        ticks.decPlaces = 0;
        ticks.format = pv.Format.number().fractionDigits(0);
    }
    return ticks;
}

function numberCopyResult(to, from) {
    to.base = from.base;
    to.mult = from.mult;
    to.value = from.value;
    return to;
}

function numberResultAbove(result) {
    var out = numberCopyResult({}, result);
    switch (out.mult) {
    case 5:
        out.mult = 1;
        out.base *= 10;
        break;

    case 2:
        out.mult = 5;
        break;

    case 1:
        out.mult = 2;
    }
    out.value = out.base * out.mult;
    return out;
}

function readNumberPrecision(precision, isMin) {
    0 > precision && (precision = -precision);
    var base = pv.logFloor(precision, 10)
      , mult = precision / base;
    isMin ? mult > 5 ? (mult = 1,
    base *= 10) : mult = mult > 2 ? 5 : mult > 1 ? 2 : 1 : mult = mult >= 5 ? 5 : mult >= 2 ? 2 : 1;
    return {
        base: base,
        mult: mult,
        value: base * mult,
        source: precision
    };
}

function newDate(x) {
    return new Date(x);
}

function genDateTicks(N, min, max, precision, format, weekStart, options) {
    var ticks, span = max - min;
    if (span && isFinite(span)) {
        precision = parseDatePrecision(pv.get(options, "precision"), precision);
        var precisionMin = parseDatePrecision(pv.get(options, "precisionMin"), 0)
          , precisionMax = parseDatePrecision(pv.get(options, "precisionMax"), 1 / 0);
        precisionMin > precisionMax && (precisionMax = precisionMin);
        precision ? precision = Math.max(Math.min(precision, precisionMax), precisionMin) : precisionMin === precisionMax && (precision = precisionMin);
        var NMax = pv.parseNumNonNeg(pv.get(options, "tickCountMax", 1 / 0));
        2 > NMax && (NMax = 2);
        N = Math.min(null == N ? 5 : N, NMax);
        for (var precResultPrev, keyArgs = {
            weekStart: weekStart,
            roundInside: pv.get(options, "roundInside", 1)
        }, precResult = chooseDatePrecision(N, span, precision, precisionMin, precisionMax, keyArgs), fixed = precResult.fixed, overflow = precResult.overflow; ; ) {
            precResult.ticks = ticks = precResult.comp.ticks(min, max, precResult.mult, keyArgs);
            if (precResultPrev && precResult.precMax && ticks[ticks.length - 1] - ticks[0] > precResult.precMax.value) {
                precResult = precResultPrev;
                break;
            }
            if (fixed || overflow > 0 || precResult.ticks.length <= NMax)
                break;
            if (precResultPrev && precResultPrev.ticks.length <= precResult.ticks.length) {
                precResult = precResultPrev;
                break;
            }
            precResultPrev = precResult;
            precResult = precResult.comp.resultAbove(precResult.mult);
        }
        ticks = precResult.ticks;
        ticks.step = precResult.value;
        ticks.base = precResult.comp.value;
        ticks.mult = precResult.mult;
        ticks.format = parseTickDateFormat(format) || precResult.comp.format;
    } else {
        ticks = [newDate(min)];
        ticks.step = ticks.base = ticks.mult = 1;
        ticks.format = pv.Format.date("%x");
    }
    return ticks;
}

function chooseDatePrecision(N, span, precision, precisionMin, precisionMax, options) {
    var dateComp, castResult, precMin, precMax, overflow = 0, mult = 1, fixed = !!precision;
    if (precision) {
        castResult = readDatePrecision(precision, !1);
        if (castResult.value !== precision)
            dateComp = castResult.comp.withPrecision(precision);
        else {
            dateComp = castResult.comp;
            mult = castResult.mult;
        }
    } else {
        if (isFinite(N)) {
            dateComp = getGreatestLessOrEqualDateComp(span, N);
            mult = dateComp.multiple(span / dateComp.value, options);
        } else {
            dateComp = lowestPrecisionValueDateComp();
            mult = 1;
        }
        precision = dateComp.value * mult;
        precisionMin > precision && (precMin = readDatePrecision(precisionMin, !0));
        precision > precisionMax && (precMax = readDatePrecision(precisionMax, !1));
        if (precMin && precision < precMin.value) {
            dateComp = precMin.comp;
            mult = precMin.mult;
            overflow = -1;
        } else if (precMax && precisionMin < precMax.value && precMax.value < precision) {
            dateComp = precMax.comp;
            mult = precMax.mult;
            overflow = 1;
        }
    }
    return {
        comp: dateComp,
        mult: mult,
        value: dateComp.value * mult,
        source: precision,
        overflow: overflow,
        fixed: fixed,
        precMin: precMin,
        precMax: precMax
    };
}

function readDatePrecision(precision, ceil) {
    return null == precision || 0 >= precision || !isFinite(precision) ? null : (ceil ? lowestPrecisionValueDateComp : highestPrecisionValueDateComp)().castValue(precision, ceil);
}

function DateComponent(value, prev, keyArgs) {
    this.value = value;
    this.mult = keyArgs.mult || 1;
    this.base = 1 === this.mult ? this.value : Math.floor(this.value / this.mult);
    dateCompCopyArgs.forEach(function(p) {
        null != keyArgs[p] && (this[p] = keyArgs[p]);
    }, this);
    keyArgs.floor && (this.floorLocal = keyArgs.floor);
    this.format = parseTickDateFormat(keyArgs.format);
    this.first = pv.functor(keyArgs.first || 0);
    this.prev = prev;
    this.next = null;
    prev && (prev.next = this);
}

function parseTickDateFormat(format) {
    return null == format ? null : "function" == typeof format ? format : pv.Format.date(format);
}

function firstWeekStartOfMonth(date, dateTickWeekStart) {
    var d = new Date(date.getFullYear(),date.getMonth(),1)
      , wd = dateTickWeekStart - d.getDay();
    if (wd) {
        0 > wd && (wd += 7);
        d.setDate(d.getDate() + wd);
    }
    return d;
}

function parseDatePrecision(value, dv) {
    if ("string" == typeof value) {
        var n = +value;
        if (isNaN(n)) {
            if (value) {
                var m = /^(\d*)([a-zA-Z]+)$/.exec(value);
                if (m) {
                    value = parseDateInterval(m[2]);
                    value && (value *= +m[1] || 1);
                }
            }
        } else
            value = n;
    }
    ("number" != typeof value || 0 > value) && (value = null != dv ? dv : 0);
    return value;
}

function parseDateInterval(s) {
    switch (s) {
    case "y":
        return 31536e6;

    case "m":
        return 2592e6;

    case "w":
        return 6048e5;

    case "d":
        return 864e5;

    case "h":
        return 36e5;

    case "M":
        return 6e4;

    case "s":
        return 1e3;

    case "ms":
        return 1;
    }
}

function defDateComp(value, keyArgs) {
    var prev = highestPrecisionValueDateComp();
    _dateComps.push(new DateComponent(value,prev,keyArgs));
}

function lowestPrecisionValueDateComp() {
    return _dateComps[0];
}

function highestPrecisionValueDateComp() {
    return _dateComps.length ? _dateComps[_dateComps.length - 1] : null;
}

function getGreatestLessOrEqualDateComp(length, N) {
    null == N && (N = 1);
    var comp, prev = highestPrecisionValueDateComp();
    do
        comp = prev;
    while (length < N * comp.value && (prev = comp.prev));return comp;
}

Array.prototype.map || (Array.prototype.map = function(f, o) {
    for (var n = this.length, result = new Array(n), i = 0; n > i; i++)
        i in this && (result[i] = f.call(o, this[i], i, this));
    return result;
}
);

Array.prototype.filter || (Array.prototype.filter = function(f, o) {
    for (var n = this.length, result = new Array(), i = 0; n > i; i++)
        if (i in this) {
            var v = this[i];
            f.call(o, v, i, this) && result.push(v);
        }
    return result;
}
);

Array.prototype.forEach || (Array.prototype.forEach = function(f, o) {
    for (var n = this.length >>> 0, i = 0; n > i; i++)
        i in this && f.call(o, this[i], i, this);
}
);

Array.prototype.reduce || (Array.prototype.reduce = function(f, v) {
    var len = this.length;
    if (!len && 1 == arguments.length)
        throw new Error("reduce: empty array, no initial value");
    var i = 0;
    if (arguments.length < 2)
        for (; ; ) {
            if (i in this) {
                v = this[i++];
                break;
            }
            if (++i >= len)
                throw new Error("reduce: no values, no initial value");
        }
    for (; len > i; i++)
        i in this && (v = f(v, this[i], i, this));
    return v;
}
);

Array.prototype.indexOf || (Array.prototype.indexOf = function(s, from) {
    for (var n = this.length >>> 0, i = !isFinite(from) || 0 > from ? 0 : from > this.length ? this.length : from; n > i; i++)
        if (this[i] === s)
            return i;
    return -1;
}
);

Date.now || (Date.now = function() {
    return +new Date();
}
);

Object.create || (Object.create = function(proto) {
    function g() {}
    g.prototype = proto;
    return new g();
}
);

var pv = {};

pv.version = {
    major: 3,
    minor: 3
};

pv.identity = function(x) {
    return x;
}
;

pv.index = function() {
    return this.index;
}
;

pv.child = function() {
    return this.childIndex;
}
;

pv.parent = function() {
    return this.parent.index;
}
;

!function() {
    pv.extend = function(f) {
        return Object.create(f.prototype || f);
    }
    ;
    pv.extendType = function(g, f) {
        var sub = g.prototype = pv.extend(f);
        sub.constructor = g;
        return g;
    }
    ;
    pv.parse = function(js) {
        for (var m, d, re = new RegExp("function\\s*(\\b\\w+)?\\s*\\([^)]*\\)\\s*","mg"), i = 0, s = ""; m = re.exec(js); ) {
            var j = m.index + m[0].length;
            if ("{" != js.charAt(j)) {
                s += js.substring(i, j) + "{return ";
                i = j;
                for (var p = 0; p >= 0 && j < js.length; j++) {
                    var c = js.charAt(j);
                    switch (c) {
                    case '"':
                    case "'":
                        for (; ++j < js.length && (d = js.charAt(j)) != c; )
                            "\\" == d && j++;
                        break;

                    case "[":
                    case "(":
                        p++;
                        break;

                    case "]":
                    case ")":
                        p--;
                        break;

                    case ";":
                    case ",":
                        0 == p && p--;
                    }
                }
                s += pv.parse(js.substring(i, --j)) + ";}";
                i = j;
            }
            re.lastIndex = j;
        }
        s += js.substring(i);
        return s;
    }
    ;
    pv.error = function(e) {
        "undefined" != typeof console && console.error ? console.error(e) : alert(e);
    }
    ;
    pv.listen = function(target, type, listener) {
        listener = pv.listener(listener);
        if ("load" === type || "onload" === type)
            return pv.listenForPageLoad(listener);
        if (target.addEventListener)
            target.addEventListener(type, listener, !1);
        else {
            target === window && (target = document.documentElement);
            target.attachEvent("on" + type, listener);
        }
        return listener;
    }
    ;
    pv.unlisten = function(target, type, listener) {
        listener.$listener && (listener = listener.$listener);
        target.removeEventListener ? target.removeEventListener(type, listener, !1) : target.detachEvent("on" + type, listener);
    }
    ;
    pv.listenForPageLoad = function(listener) {
        "complete" !== document.readyState ? document.addEventListener ? window.addEventListener("load", listener, !1) : document.attachEvent && window.attachEvent("onload", listener) : listener(null);
    }
    ;
    pv.listener = function(f) {
        return f.$listener || (f.$listener = function(ev) {
            try {
                pv.event = ev = ev && pv.fixEvent(ev);
                return f.call(this, ev);
            } catch (ex) {
                pv.error(ex);
            } finally {
                delete pv.event;
            }
        }
        );
    }
    ;
    pv.fixEvent = function(ev) {
        if (null == ev.pageX && null != ev.clientX) {
            var eventDoc = ev.target && ev.target.ownerDocument || document
              , doc = eventDoc.documentElement
              , body = eventDoc.body;
            ev.pageX = 1 * ev.clientX + (doc && doc.scrollLeft || body && body.scrollLeft || 0) - (doc && doc.clientLeft || body && body.clientLeft || 0);
            ev.pageY = 1 * ev.clientY + (doc && doc.scrollTop || body && body.scrollTop || 0) - (doc && doc.clientTop || body && body.clientTop || 0);
        }
        return ev;
    }
    ;
    pv.ancestor = function(a, e) {
        for (; e; ) {
            if (e === a)
                return !0;
            e = e.parentNode;
        }
        return !1;
    }
    ;
    pv.removeChildren = function(p) {
        for (; p.lastChild; )
            p.removeChild(p.lastChild);
    }
    ;
    pv.getWindow = function(elem) {
        return null != elem && elem == elem.window ? elem : 9 === elem.nodeType ? elem.defaultView || elem.parentWindow : !1;
    }
    ;
    var _reHiphenSep = /\-([a-z])/g;
    pv.hiphen2camel = function(prop) {
        return _reHiphenSep.test(prop) ? prop.replace(_reHiphenSep, function($0, $1) {
            return $1.toUpperCase();
        }) : prop;
    }
    ;
    var _getCompStyle = window.getComputedStyle;
    pv.css = function(e, p) {
        return _getCompStyle ? _getCompStyle.call(window, e, null).getPropertyValue(p) : e.currentStyle["float" === p ? "styleFloat" : pv.hiphen2camel(p)];
    }
    ;
    pv.cssStyle = function(e) {
        var style;
        if (_getCompStyle) {
            style = _getCompStyle.call(window, e, null);
            return function(p) {
                return style.getPropertyValue(p);
            }
            ;
        }
        style = e.currentStyle;
        return function(p) {
            return style["float" === p ? "styleFloat" : pv.hiphen2camel(p)];
        }
        ;
    }
    ;
    pv._getElementsByClass = function(searchClass, node) {
        null == node && (node = document);
        for (var classElements = [], els = node.getElementsByTagName("*"), L = els.length, pattern = new RegExp("(^|\\s)" + searchClass + "(\\s|$)"), i = 0, j = 0; L > i; i++)
            if (pattern.test(els[i].className)) {
                classElements[j] = els[i];
                j++;
            }
        return classElements;
    }
    ;
    pv.getElementsByClassName = function(node, classname) {
        return node.getElementsByClassName ? node.getElementsByClassName(classname) : pv._getElementsByClass(classname, node);
    }
    ;
    pv.elementOffset = function(elem) {
        var doc = elem && elem.ownerDocument;
        if (doc) {
            var body = doc.body;
            if (body !== elem) {
                var box;
                box = "undefined" != typeof elem.getBoundingClientRect ? elem.getBoundingClientRect() : {
                    top: 0,
                    left: 0
                };
                var win = pv.getWindow(doc)
                  , docElem = doc.documentElement
                  , clientTop = docElem.clientTop || body.clientTop || 0
                  , clientLeft = docElem.clientLeft || body.clientLeft || 0
                  , scrollTop = win.pageYOffset || docElem.scrollTop
                  , scrollLeft = win.pageXOffset || docElem.scrollLeft;
                return {
                    top: box.top + scrollTop - clientTop,
                    left: box.left + scrollLeft - clientLeft
                };
            }
        }
    }
    ;
    pv.renderer = function() {
        var renderer = document.svgImplementation || "nativesvg";
        pv.renderer = function() {
            return renderer;
        }
        ;
        return renderer;
    }
    ;
    var _id = 1;
    pv.id = function() {
        return _id++;
    }
    ;
    pv.functor = function(v) {
        return "function" == typeof v ? v : function() {
            return v;
        }
        ;
    }
    ;
    pv.stringLowerCase = function(s) {
        return String(s).toLowerCase();
    }
    ;
    pv.get = function(o, p, dv) {
        var v;
        return o && null != (v = o[p]) ? v : dv;
    }
    ;
    var hasOwn = Object.prototype.hasOwnProperty;
    pv.lazyArrayOwn = function(o, p) {
        var v;
        return o && hasOwn.call(o, p) && (v = o[p]) ? v : o[p] = [];
    }
    ;
    pv.parseNumNonNeg = function(v, dv) {
        null != v && ("string" == typeof v ? v = +v : "number" != typeof v && (v = null));
        return null == v || isNaN(v) || 0 > v ? null == dv ? 0 : dv : v;
    }
    ;
    var epsilon = pv.epsilon = 1e-6;
    pv.floatLess = function(a, b) {
        return !pv.floatEqual(a, b) && b > a;
    }
    ;
    pv.floatLessOrEqual = function(a, b) {
        return b > a || pv.floatEqual(a, b);
    }
    ;
    pv.floatGreater = function(a, b) {
        return !pv.floatEqual(a, b) && a > b;
    }
    ;
    pv.floatEqual = function(a, b) {
        return Math.abs(b - a) < epsilon;
    }
    ;
    pv.floatZero = function(value) {
        return Math.abs(value) < epsilon;
    }
    ;
    pv.floatBelongsOpen = function(min, value, max) {
        return pv.floatLess(min, value) && pv.floatLess(value, max);
    }
    ;
    pv.floatBelongsClosed = function(min, value, max) {
        return pv.floatLessOrEqual(min, value) && pv.floatLessOrEqual(value, max);
    }
    ;
}();

pv.listen(window, "load", function() {
    pv.$ = {
        i: 0,
        x: document.getElementsByTagName("script")
    };
    pv.$.xlen = pv.$.x.length;
    for (; pv.$.i < pv.$.xlen; pv.$.i++) {
        pv.$.s = pv.$.x[pv.$.i];
        if ("text/javascript+protovis" == pv.$.s.type)
            try {
                window.eval(pv.parse(pv.$.s.text));
            } catch (e) {
                pv.error(e);
            }
    }
    delete pv.$;
});

pv.Format = {};

pv.Format.re = function(s) {
    return s.replace(/[\\\^\$\*\+\?\[\]\(\)\.\{\}]/g, "\\$&");
}
;

pv.Format.pad = function(c, n, s) {
    var m = n - String(s).length;
    return 1 > m ? s : new Array(m + 1).join(c) + s;
}
;

pv.Format.date = function(pattern) {
    function format(d) {
        return pattern.replace(/%[a-zA-Z0-9]/g, function(s) {
            switch (s) {
            case "%a":
                return ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"][d.getDay()];

            case "%A":
                return ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"][d.getDay()];

            case "%h":
            case "%b":
                return ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"][d.getMonth()];

            case "%B":
                return ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"][d.getMonth()];

            case "%c":
                return d.toLocaleString();

            case "%C":
                return pad("0", 2, Math.floor(d.getFullYear() / 100) % 100);

            case "%d":
                return pad("0", 2, d.getDate());

            case "%x":
            case "%D":
                return pad("0", 2, d.getMonth() + 1) + "/" + pad("0", 2, d.getDate()) + "/" + pad("0", 2, d.getFullYear() % 100);

            case "%e":
                return pad(" ", 2, d.getDate());

            case "%H":
                return pad("0", 2, d.getHours());

            case "%I":
                var h = d.getHours() % 12;
                return h ? pad("0", 2, h) : 12;

            case "%m":
                return pad("0", 2, d.getMonth() + 1);

            case "%M":
                return pad("0", 2, d.getMinutes());

            case "%n":
                return "\n";

            case "%p":
                return d.getHours() < 12 ? "AM" : "PM";

            case "%T":
            case "%X":
            case "%r":
                var h = d.getHours() % 12;
                return (h ? pad("0", 2, h) : 12) + ":" + pad("0", 2, d.getMinutes()) + ":" + pad("0", 2, d.getSeconds()) + " " + (d.getHours() < 12 ? "AM" : "PM");

            case "%R":
                return pad("0", 2, d.getHours()) + ":" + pad("0", 2, d.getMinutes());

            case "%S":
                return pad("0", 2, d.getSeconds());

            case "%Q":
                return pad("0", 3, d.getMilliseconds());

            case "%t":
                return "	";

            case "%u":
                var w = d.getDay();
                return w ? w : 1;

            case "%w":
                return d.getDay();

            case "%y":
                return pad("0", 2, d.getFullYear() % 100);

            case "%Y":
                return d.getFullYear();

            case "%%":
                return "%";
            }
            return s;
        });
    }
    var pad = pv.Format.pad;
    format.format = format;
    format.parse = function(s) {
        var year = 1970
          , month = 0
          , date = 1
          , hour = 0
          , minute = 0
          , second = 0
          , fields = [function() {}
        ]
          , re = pv.Format.re(pattern).replace(/%[a-zA-Z0-9]/g, function(s) {
            switch (s) {
            case "%b":
                fields.push(function(x) {
                    month = {
                        Jan: 0,
                        Feb: 1,
                        Mar: 2,
                        Apr: 3,
                        May: 4,
                        Jun: 5,
                        Jul: 6,
                        Aug: 7,
                        Sep: 8,
                        Oct: 9,
                        Nov: 10,
                        Dec: 11
                    }[x];
                });
                return "([A-Za-z]+)";

            case "%h":
            case "%B":
                fields.push(function(x) {
                    month = {
                        January: 0,
                        February: 1,
                        March: 2,
                        April: 3,
                        May: 4,
                        June: 5,
                        July: 6,
                        August: 7,
                        September: 8,
                        October: 9,
                        November: 10,
                        December: 11
                    }[x];
                });
                return "([A-Za-z]+)";

            case "%e":
            case "%d":
                fields.push(function(x) {
                    date = x;
                });
                return "([0-9]+)";

            case "%I":
            case "%H":
                fields.push(function(x) {
                    hour = x;
                });
                return "([0-9]+)";

            case "%m":
                fields.push(function(x) {
                    month = x - 1;
                });
                return "([0-9]+)";

            case "%M":
                fields.push(function(x) {
                    minute = x;
                });
                return "([0-9]+)";

            case "%p":
                fields.push(function(x) {
                    12 == hour ? "am" == x && (hour = 0) : "pm" == x && (hour = Number(hour) + 12);
                });
                return "(am|pm)";

            case "%S":
                fields.push(function(x) {
                    second = x;
                });
                return "([0-9]+)";

            case "%y":
                fields.push(function(x) {
                    x = Number(x);
                    year = x + (x >= 0 && 69 > x ? 2e3 : x >= 69 && 100 > x ? 1900 : 0);
                });
                return "([0-9]+)";

            case "%Y":
                fields.push(function(x) {
                    year = x;
                });
                return "([0-9]+)";

            case "%%":
                fields.push(function() {});
                return "%";
            }
            return s;
        })
          , match = s.match(re);
        match && match.forEach(function(m, i) {
            fields[i](m);
        });
        return new Date(year,month,date,hour,minute,second);
    }
    ;
    return format;
}
;

pv.Format.time = function(type) {
    function format(t) {
        t = Number(t);
        switch (type) {
        case "short":
            return t >= 31536e6 ? (t / 31536e6).toFixed(1) + " years" : t >= 6048e5 ? (t / 6048e5).toFixed(1) + " weeks" : t >= 864e5 ? (t / 864e5).toFixed(1) + " days" : t >= 36e5 ? (t / 36e5).toFixed(1) + " hours" : t >= 6e4 ? (t / 6e4).toFixed(1) + " minutes" : (t / 1e3).toFixed(1) + " seconds";

        case "long":
            var a = []
              , s = t % 6e4 / 1e3 >> 0
              , m = t % 36e5 / 6e4 >> 0;
            a.push(pad("0", 2, s));
            if (t >= 36e5) {
                var h = t % 864e5 / 36e5 >> 0;
                a.push(pad("0", 2, m));
                if (t >= 864e5) {
                    a.push(pad("0", 2, h));
                    a.push(Math.floor(t / 864e5).toFixed());
                } else
                    a.push(h.toFixed());
            } else
                a.push(m.toFixed());
            return a.reverse().join(":");
        }
    }
    var pad = pv.Format.pad;
    format.format = format;
    format.parse = function(s) {
        switch (type) {
        case "short":
            for (var a, re = /([0-9,.]+)\s*([a-z]+)/g, t = 0; a = re.exec(s); ) {
                var f = parseFloat(a[0].replace(",", ""))
                  , u = 0;
                switch (a[2].toLowerCase()) {
                case "year":
                case "years":
                    u = 31536e6;
                    break;

                case "week":
                case "weeks":
                    u = 6048e5;
                    break;

                case "day":
                case "days":
                    u = 864e5;
                    break;

                case "hour":
                case "hours":
                    u = 36e5;
                    break;

                case "minute":
                case "minutes":
                    u = 6e4;
                    break;

                case "second":
                case "seconds":
                    u = 1e3;
                }
                t += f * u;
            }
            return t;

        case "long":
            var a = s.replace(",", "").split(":").reverse()
              , t = 0;
            a.length && (t += 1e3 * parseFloat(a[0]));
            a.length > 1 && (t += 6e4 * parseFloat(a[1]));
            a.length > 2 && (t += 36e5 * parseFloat(a[2]));
            a.length > 3 && (t += 864e5 * parseFloat(a[3]));
            return t;
        }
    }
    ;
    return format;
}
;

pv.Format.number = function() {
    function format(x) {
        1 / 0 > maxf && (x = Math.round(x * maxk) / maxk);
        var s = String(Math.abs(x)).split(".")
          , i = s[0];
        i.length > maxi && (i = i.substring(i.length - maxi));
        padg && i.length < mini && (i = new Array(mini - i.length + 1).join(padi) + i);
        i.length > 3 && (i = i.replace(/\B(?=(?:\d{3})+(?!\d))/g, group));
        !padg && i.length < mins && (i = new Array(mins - i.length + 1).join(padi) + i);
        s[0] = 0 > x ? np + i + ns : i;
        var f = s[1] || "";
        f.length > maxf && (f = s[1] = f.substr(0, maxf));
        f.length < minf && (s[1] = f + new Array(minf - f.length + 1).join(padf));
        return s.join(decimal);
    }
    var mini = 0
      , maxi = 1 / 0
      , mins = 0
      , minf = 0
      , maxf = 0
      , maxk = 1
      , padi = "0"
      , padf = "0"
      , padg = !0
      , decimal = "."
      , group = ","
      , np = "−"
      , ns = "";
    format.format = format;
    format.parse = function(x) {
        var re = pv.Format.re
          , s = String(x).split(decimal);
        1 == s.length && (s[1] = "");
        s[0].replace(new RegExp("^(" + re(padi) + ")*"), "");
        s[1].replace(new RegExp("(" + re(padf) + ")*$"), "");
        var i = s[0].replace(new RegExp(re(group),"g"), "");
        i.length > maxi && (i = i.substring(i.length - maxi));
        var f = s[1] ? Number("0." + s[1]) : 0;
        1 / 0 > maxf && (f = Math.round(f * maxk) / maxk);
        return Math.round(i) + f;
    }
    ;
    format.integerDigits = function(min, max) {
        if (arguments.length) {
            mini = Number(min);
            maxi = arguments.length > 1 ? Number(max) : mini;
            mins = mini + Math.floor(mini / 3) * group.length;
            return this;
        }
        return [mini, maxi];
    }
    ;
    format.fractionDigits = function(min, max) {
        if (arguments.length) {
            minf = Number(min);
            maxf = arguments.length > 1 ? Number(max) : minf;
            maxk = Math.pow(10, maxf);
            return this;
        }
        return [minf, maxf];
    }
    ;
    format.integerPad = function(x) {
        if (arguments.length) {
            padi = String(x);
            padg = /\d/.test(padi);
            return this;
        }
        return padi;
    }
    ;
    format.fractionPad = function(x) {
        if (arguments.length) {
            padf = String(x);
            return this;
        }
        return padf;
    }
    ;
    format.decimal = function(x) {
        if (arguments.length) {
            decimal = String(x);
            return this;
        }
        return decimal;
    }
    ;
    format.group = function(x) {
        if (arguments.length) {
            group = x ? String(x) : "";
            mins = mini + Math.floor(mini / 3) * group.length;
            return this;
        }
        return group;
    }
    ;
    format.negativeAffix = function(x, y) {
        if (arguments.length) {
            np = String(x || "");
            ns = String(y || "");
            return this;
        }
        return [np, ns];
    }
    ;
    return format;
}
;

!function() {
    var _cache;
    pv.Text = {};
    pv.Text.createCache = function() {
        return new FontSizeCache();
    }
    ;
    pv.Text.usingCache = function(cache, fun, ctx) {
        if (!(cache instanceof FontSizeCache))
            throw new Error("Not a valid cache.");
        var prevCache = _cache;
        _cache = cache;
        try {
            return fun.call(ctx);
        } finally {
            _cache = prevCache;
        }
    }
    ;
    pv.Text.measure = function(text, font) {
        text = null == text ? "" : String(text);
        var bbox = _cache && _cache.get(font, text);
        if (!bbox) {
            bbox = text ? this.measureCore(text, font) : {
                width: 0,
                height: 0
            };
            _cache && _cache.put(font, text, bbox);
        }
        return bbox;
    }
    ;
    pv.Text.measureWidth = function(text, font) {
        return pv.Text.measure(text, font).width;
    }
    ;
    pv.Text.fontHeight = function(font) {
        return pv.Text.measure("M", font).height;
    }
    ;
    pv.Text.measureCore = function() {
        function getTextSizeElement() {
            return _svgText || (_svgText = createTextSizeElement());
        }
        function createTextSizeElement() {
            var div = document.createElement("div");
            div.id = "pvSVGText_" + new Date().getTime();
            var style = div.style;
            style.position = "absolute";
            style.visibility = "hidden";
            style.width = 0;
            style.height = 0;
            style.left = 0;
            style.top = 0;
            style.lineHeight = 1;
            style.textTransform = "none";
            style.letterSpacing = "normal";
            style.whiteSpace = "nowrap";
            var svgElem = pv.SvgScene.create("svg");
            svgElem.setAttribute("font-size", "10px");
            svgElem.setAttribute("font-family", "sans-serif");
            div.appendChild(svgElem);
            var svgText = pv.SvgScene.create("text");
            svgElem.appendChild(svgText);
            svgText.appendChild(document.createTextNode(""));
            document.body.appendChild(div);
            return svgText;
        }
        var _svgText, _lastFont = "10px sans-serif";
        return function(text, font) {
            font || (font = null);
            var svgText = getTextSizeElement();
            if (_lastFont !== font) {
                _lastFont = font;
                pv.SvgScene.setStyle(svgText, {
                    font: font
                });
            }
            svgText.firstChild.nodeValue = String(text);
            var box;
            try {
                box = svgText.getBBox();
            } catch (ex) {
                "function" == typeof console.error && console.error("GetBBox failed: ", ex);
                throw ex;
            }
            return {
                width: box.width,
                height: box.height
            };
        }
        ;
    }();
    var FontSizeCache = function() {
        this._fontsCache = {};
    }
      , hasOwnProp = Object.prototype.hasOwnProperty;
    FontSizeCache.prototype._getFont = function(font) {
        font = font || "";
        return hasOwnProp.call(this._fontsCache, font) ? this._fontsCache[font] : this._fontsCache[font] = {};
    }
    ;
    FontSizeCache.prototype.get = function(font, text) {
        text = text || "";
        var fontCache = this._getFont(font);
        return hasOwnProp.call(fontCache, text) ? fontCache[text] : null;
    }
    ;
    FontSizeCache.prototype.put = function(font, text, size) {
        return this._getFont(font)[text || ""] = size;
    }
    ;
}();

pv.map = function(array, f) {
    var o = {};
    return f ? array.map(function(d, i) {
        o.index = i;
        return f.call(o, d);
    }) : array.slice();
}
;

pv.repeat = function(array, n) {
    1 == arguments.length && (n = 2);
    return pv.blend(pv.range(n).map(function() {
        return array;
    }));
}
;

pv.array = function(len, dv) {
    var a = len >= 0 ? new Array(len) : [];
    if (void 0 !== dv)
        for (var i = 0; len > i; i++)
            a[i] = dv;
    return a;
}
;

pv.cross = function(a, b) {
    for (var array = [], i = 0, n = a.length, m = b.length; n > i; i++)
        for (var j = 0, x = a[i]; m > j; j++)
            array.push([x, b[j]]);
    return array;
}
;

pv.blend = function(arrays) {
    return Array.prototype.concat.apply([], arrays);
}
;

pv.transpose = function(arrays) {
    var n = arrays.length
      , m = pv.max(arrays, function(d) {
        return d.length;
    });
    if (m > n) {
        arrays.length = m;
        for (var i = n; m > i; i++)
            arrays[i] = new Array(n);
        for (var i = 0; n > i; i++)
            for (var j = i + 1; m > j; j++) {
                var t = arrays[i][j];
                arrays[i][j] = arrays[j][i];
                arrays[j][i] = t;
            }
    } else {
        for (var i = 0; m > i; i++)
            arrays[i].length = n;
        for (var i = 0; n > i; i++)
            for (var j = 0; i > j; j++) {
                var t = arrays[i][j];
                arrays[i][j] = arrays[j][i];
                arrays[j][i] = t;
            }
    }
    arrays.length = m;
    for (var i = 0; m > i; i++)
        arrays[i].length = n;
    return arrays;
}
;

pv.normalize = function(array, f) {
    for (var norm = pv.map(array, f), sum = pv.sum(norm), i = 0; i < norm.length; i++)
        norm[i] /= sum;
    return norm;
}
;

pv.permute = function(array, indexes, f) {
    f || (f = pv.identity);
    var p = new Array(indexes.length)
      , o = {};
    indexes.forEach(function(j, i) {
        o.index = j;
        p[i] = f.call(o, array[j]);
    });
    return p;
}
;

pv.numerate = function(keys, f) {
    f || (f = pv.identity);
    var map = {}
      , o = {};
    keys.forEach(function(x, i) {
        o.index = i;
        map[f.call(o, x)] = i;
    });
    return map;
}
;

pv.uniq = function(array, f) {
    f || (f = pv.identity);
    var y, map = {}, keys = [], o = {};
    array.forEach(function(x, i) {
        o.index = i;
        y = f.call(o, x);
        y in map || (map[y] = keys.push(y));
    });
    return keys;
}
;

pv.naturalOrder = function(a, b) {
    return b > a ? -1 : a > b ? 1 : 0;
}
;

pv.reverseOrder = function(b, a) {
    return b > a ? -1 : a > b ? 1 : 0;
}
;

pv.search = function(array, value, f) {
    f || (f = pv.identity);
    for (var low = 0, high = array.length - 1; high >= low; ) {
        var mid = low + high >> 1
          , midValue = f(array[mid]);
        if (value > midValue)
            low = mid + 1;
        else {
            if (!(midValue > value))
                return mid;
            high = mid - 1;
        }
    }
    return -low - 1;
}
;

pv.search.index = function(array, value, f) {
    var i = pv.search(array, value, f);
    return 0 > i ? -i - 1 : i;
}
;

pv.range = function(start, stop, step) {
    if (1 == arguments.length) {
        stop = start;
        start = 0;
    }
    void 0 == step && (step = 1);
    if ((stop - start) / step == 1 / 0)
        throw new Error("range must be finite");
    var j, array = [], i = 0;
    stop -= 1e-10 * (stop - start);
    if (0 > step)
        for (; (j = start + step * i++) > stop; )
            array.push(j);
    else
        for (; (j = start + step * i++) < stop; )
            array.push(j);
    return array;
}
;

pv.random = function(start, stop, step) {
    if (1 == arguments.length) {
        stop = start;
        start = 0;
    }
    void 0 == step && (step = 1);
    return step ? Math.floor(Math.random() * (stop - start) / step) * step + start : Math.random() * (stop - start) + start;
}
;

pv.sum = function(array, f) {
    var o = {};
    return array.reduce(f ? function(p, d, i) {
        o.index = i;
        return p + f.call(o, d);
    }
    : function(p, d) {
        return p + d;
    }
    , 0);
}
;

pv.max = function(array, f) {
    return f == pv.index ? array.length - 1 : Math.max.apply(null, f ? pv.map(array, f) : array);
}
;

pv.max.index = function(array, f) {
    if (!array.length)
        return -1;
    if (f == pv.index)
        return array.length - 1;
    f || (f = pv.identity);
    for (var maxi = 0, maxx = -(1 / 0), o = {}, i = 0; i < array.length; i++) {
        o.index = i;
        var x = f.call(o, array[i]);
        if (x > maxx) {
            maxx = x;
            maxi = i;
        }
    }
    return maxi;
}
;

pv.min = function(array, f) {
    return f == pv.index ? 0 : Math.min.apply(null, f ? pv.map(array, f) : array);
}
;

pv.min.index = function(array, f) {
    if (!array.length)
        return -1;
    if (f == pv.index)
        return 0;
    f || (f = pv.identity);
    for (var mini = 0, minx = 1 / 0, o = {}, i = 0; i < array.length; i++) {
        o.index = i;
        var x = f.call(o, array[i]);
        if (minx > x) {
            minx = x;
            mini = i;
        }
    }
    return mini;
}
;

pv.mean = function(array, f) {
    return pv.sum(array, f) / array.length;
}
;

pv.median = function(array, f) {
    if (f == pv.index)
        return (array.length - 1) / 2;
    array = pv.map(array, f).sort(pv.naturalOrder);
    if (array.length % 2)
        return array[Math.floor(array.length / 2)];
    var i = array.length / 2;
    return (array[i - 1] + array[i]) / 2;
}
;

pv.variance = function(array, f) {
    if (array.length < 1)
        return NaN;
    if (1 == array.length)
        return 0;
    var mean = pv.mean(array, f)
      , sum = 0
      , o = {};
    f || (f = pv.identity);
    for (var i = 0; i < array.length; i++) {
        o.index = i;
        var d = f.call(o, array[i]) - mean;
        sum += d * d;
    }
    return sum;
}
;

pv.deviation = function(array, f) {
    return Math.sqrt(pv.variance(array, f) / (array.length - 1));
}
;

pv.log = function(x, b) {
    return Math.log(x) / Math.log(b);
}
;

pv.logSymmetric = function(x, b) {
    return 0 == x ? 0 : 0 > x ? -pv.log(-x, b) : pv.log(x, b);
}
;

pv.logAdjusted = function(x, b) {
    if (!isFinite(x))
        return x;
    var negative = 0 > x;
    b > x && (x += (b - x) / b);
    return negative ? -pv.log(x, b) : pv.log(x, b);
}
;

pv.logFloor = function(x, b) {
    return x > 0 ? Math.pow(b, Math.floor(pv.log(x, b))) : -Math.pow(b, -Math.floor(-pv.log(-x, b)));
}
;

pv.logCeil = function(x, b) {
    return x > 0 ? Math.pow(b, Math.ceil(pv.log(x, b))) : -Math.pow(b, -Math.ceil(-pv.log(-x, b)));
}
;

!function() {
    var _radians = Math.PI / 180
      , _degrees = 180 / Math.PI;
    pv.radians = function(degrees) {
        return _radians * degrees;
    }
    ;
    pv.degrees = function(radians) {
        return _degrees * radians;
    }
    ;
}();

pv.keys = function(map) {
    var array = [];
    for (var key in map)
        array.push(key);
    return array;
}
;

pv.entries = function(map) {
    var array = [];
    for (var key in map)
        array.push({
            key: key,
            value: map[key]
        });
    return array;
}
;

pv.values = function(map) {
    var array = [];
    for (var key in map)
        array.push(map[key]);
    return array;
}
;

pv.dict = function(keys, f) {
    for (var m = {}, o = {}, i = 0; i < keys.length; i++)
        if (i in keys) {
            var k = keys[i];
            o.index = i;
            m[k] = f.call(o, k);
        }
    return m;
}
;

pv.hasOwnProp = Object.prototype.hasOwnProperty;

pv.copyOwn = function(a, b) {
    if (b) {
        var hop = pv.hasOwnProp;
        for (var p in b)
            hop.call(b, p) && (a[p] = b[p]);
    }
    return a;
}
;

pv.dom = function(map) {
    return new pv.Dom(map);
}
;

pv.Dom = function(map) {
    this.$map = map;
}
;

pv.Dom.prototype.$leaf = function(n) {
    return "object" != typeof n;
}
;

pv.Dom.prototype.leaf = function(f) {
    if (arguments.length) {
        this.$leaf = f;
        return this;
    }
    return this.$leaf;
}
;

pv.Dom.prototype.root = function(nodeName) {
    function recurse(map) {
        var n = new pv.Dom.Node();
        for (var k in map) {
            var v = map[k];
            n.appendChild(leaf(v) ? new pv.Dom.Node(v) : recurse(v)).nodeName = k;
        }
        return n;
    }
    var leaf = this.$leaf
      , root = recurse(this.$map);
    root.nodeName = nodeName;
    return root;
}
;

pv.Dom.prototype.nodes = function() {
    return this.root().nodes();
}
;

pv.Dom.Node = function(value) {
    void 0 !== value && (this.nodeValue = value);
}
;

pv.Dom.Node.prototype.nodeValue = void 0;

pv.Dom.Node.prototype.childNodes = [];

pv.Dom.Node.prototype.parentNode = null;

pv.Dom.Node.prototype.firstChild = null;

pv.Dom.Node.prototype.lastChild = null;

pv.Dom.Node.prototype.previousSibling = null;

pv.Dom.Node.prototype.nextSibling = null;

pv.Dom.Node.prototype._firstDirtyChildIndex = 1 / 0;

pv.Dom.Node.prototype._childIndex = -1;

pv.Dom.Node.prototype.findChildIndex = function(n) {
    if (!n)
        throw new Error("Argument 'n' required");
    if (n.parentNode === this) {
        var i = n.childIndex(!0);
        if (i > -1)
            return i;
    }
    throw new Error("child not found");
}
;

pv.Dom.Node.prototype._childRemoved = function(n, i) {}
;

pv.Dom.Node.prototype._childAdded = function(n, i) {}
;

pv.Dom.Node.prototype.removeChild = function(n) {
    var i = this.findChildIndex(n);
    return this.removeAt(i);
}
;

pv.Dom.Node.prototype.appendChild = function(n) {
    var pn = n.parentNode;
    pn && pn.removeChild(n);
    var lc = this.lastChild;
    n.parentNode = this;
    n.previousSibling = lc;
    if (lc) {
        lc.nextSibling = n;
        n._childIndex = lc._childIndex + 1;
    } else {
        this.firstChild = n;
        n._childIndex = 0;
    }
    this.lastChild = n;
    var L = pv.lazyArrayOwn(this, "childNodes").push(n);
    this._childAdded(n, L - 1);
    return n;
}
;

pv.Dom.Node.prototype.insertBefore = function(n, r) {
    if (!r)
        return this.appendChild(n);
    var i = this.findChildIndex(r);
    return this.insertAt(n, i);
}
;

pv.Dom.Node.prototype.insertAt = function(n, i) {
    if (null == i)
        return this.appendChild(n);
    var ns = this.childNodes
      , L = ns.length;
    if (i === L)
        return this.appendChild(n);
    if (0 > i || i > L)
        throw new Error("Index out of range.");
    var pn = n.parentNode;
    pn && pn.removeChild(n);
    var ni = i + 1;
    ni < this._firstDirtyChildIndex && (this._firstDirtyChildIndex = ni);
    var r = ns[i];
    n.parentNode = this;
    n.nextSibling = r;
    n._childIndex = i;
    var psib = n.previousSibling = r.previousSibling;
    r.previousSibling = n;
    if (psib)
        psib.nextSibling = n;
    else {
        r === this.lastChild && (this.lastChild = n);
        this.firstChild = n;
    }
    ns.splice(i, 0, n);
    this._childAdded(n, i);
    return n;
}
;

pv.Dom.Node.prototype.removeAt = function(i) {
    var ns = this.childNodes
      , L = ns.length;
    if (!(0 > i || i >= L)) {
        var n = ns[i];
        ns.splice(i, 1);
        L - 1 > i && i < this._firstDirtyChildIndex && (this._firstDirtyChildIndex = i);
        var psib = n.previousSibling
          , nsib = n.nextSibling;
        psib ? psib.nextSibling = nsib : this.firstChild = nsib;
        nsib ? nsib.previousSibling = psib : this.lastChild = psib;
        n.nextSibling = n.previousSibling = n.parentNode = null;
        this._childRemoved(n, i);
        return n;
    }
}
;

pv.Dom.Node.prototype.replaceChild = function(n, r) {
    var i = this.findChildIndex(r)
      , pn = n.parentNode;
    pn && pn.removeChild(n);
    n.parentNode = this;
    n.nextSibling = r.nextSibling;
    n._childIndex = r._childIndex;
    var psib = n.previousSibling = r.previousSibling;
    psib ? psib.nextSibling = n : this.firstChild = n;
    var nsib = r.nextSibling;
    nsib ? nsib.previousSibling = n : this.lastChild = n;
    this.childNodes[i] = n;
    this._childRemoved(r, i);
    this._childAdded(n, i);
    return r;
}
;

pv.Dom.Node.prototype.childIndex = function(noRebuild) {
    var p = this.parentNode;
    if (p) {
        var di = p._firstDirtyChildIndex;
        if (1 / 0 > di) {
            var ns = p.childNodes;
            if (!noRebuild)
                return ns.indexOf(this);
            for (var L = ns.length; L > di; ) {
                ns[di]._childIndex = di;
                di++;
            }
            p._firstDirtyChildIndex = 1 / 0;
        }
        return this._childIndex;
    }
    return -1;
}
;

pv.Dom.Node.prototype.visitBefore = function(f) {
    function visit(n, d) {
        f(n, d);
        for (var c = n.firstChild; c; c = c.nextSibling)
            visit(c, d + 1);
    }
    visit(this, 0);
}
;

pv.Dom.Node.prototype.visitAfter = function(f) {
    function visit(n, d) {
        for (var c = n.firstChild; c; c = c.nextSibling)
            visit(c, d + 1);
        f(n, d);
    }
    visit(this, 0);
}
;

pv.Dom.Node.prototype.sort = function(f) {
    if (this.firstChild) {
        this._firstDirtyChildIndex = 1 / 0;
        var cs = this.childNodes;
        cs.sort(f);
        var c, p = this.firstChild = cs[0];
        delete p.previousSibling;
        p._childIndex = 0;
        for (var i = 1, L = cs.length; L > i; i++) {
            p.sort(f);
            c = cs[i];
            c._childIndex = i;
            c.previousSibling = p;
            p = p.nextSibling = c;
        }
        this.lastChild = p;
        delete p.nextSibling;
        p.sort(f);
    }
    return this;
}
;

pv.Dom.Node.prototype.reverse = function() {
    var childNodes = [];
    this.visitAfter(function(n) {
        this._firstDirtyChildIndex = 1 / 0;
        for (var c; c = n.lastChild; )
            childNodes.push(n.removeChild(c));
        if (childNodes.length)
            for (; c = childNodes.pop(); )
                n.insertBefore(c, n.firstChild);
    });
    return this;
}
;

pv.Dom.Node.prototype.nodes = function() {
    var array = [];
    this.visitBefore(function(n) {
        array.push(n);
    });
    return array;
}
;

pv.Dom.Node.prototype.toggle = function(recursive) {
    if (recursive)
        return this.toggled ? this.visitBefore(function(n) {
            n.toggled && n.toggle();
        }) : this.visitAfter(function(n) {
            n.toggled || n.toggle();
        });
    var c, n = this;
    if (n.toggled) {
        for (; c = n.toggled.pop(); )
            n.appendChild(c);
        delete n.toggled;
    } else if (c = n.lastChild) {
        n.toggled = [];
        do
            n.toggled.push(n.removeChild(c));
        while (c = n.lastChild);
    }
}
;

pv.nodes = function(values) {
    for (var root = new pv.Dom.Node(), i = 0, V = values.length; V > i; i++)
        root.appendChild(new pv.Dom.Node(values[i]));
    return root.nodes();
}
;

pv.tree = function(array) {
    return new pv.Tree(array);
}
;

pv.Tree = function(array) {
    this.array = array;
}
;

pv.Tree.prototype.keys = function(k) {
    this.k = k;
    return this;
}
;

pv.Tree.prototype.value = function(v) {
    this.v = v;
    return this;
}
;

pv.Tree.prototype.map = function() {
    for (var map = {}, o = {}, i = 0; i < this.array.length; i++) {
        o.index = i;
        for (var value = this.array[i], keys = this.k.call(o, value), node = map, j = 0; j < keys.length - 1; j++)
            node = node[keys[j]] || (node[keys[j]] = {});
        node[keys[j]] = this.v ? this.v.call(o, value) : value;
    }
    return map;
}
;

pv.nest = function(array) {
    return new pv.Nest(array);
}
;

pv.Nest = function(array) {
    this.array = array;
    this.keys = [];
}
;

pv.Nest.prototype.key = function(key) {
    this.keys.push(key);
    return this;
}
;

pv.Nest.prototype.sortKeys = function(order) {
    this.keys[this.keys.length - 1].order = order || pv.naturalOrder;
    return this;
}
;

pv.Nest.prototype.sortValues = function(order) {
    this.order = order || pv.naturalOrder;
    return this;
}
;

pv.Nest.prototype.map = function() {
    for (var i, map = {}, values = [], j = 0; j < this.array.length; j++) {
        var x = this.array[j]
          , m = map;
        for (i = 0; i < this.keys.length - 1; i++) {
            var k = this.keys[i](x);
            m[k] || (m[k] = {});
            m = m[k];
        }
        k = this.keys[i](x);
        if (!m[k]) {
            var a = [];
            values.push(a);
            m[k] = a;
        }
        m[k].push(x);
    }
    if (this.order)
        for (var i = 0; i < values.length; i++)
            values[i].sort(this.order);
    return map;
}
;

pv.Nest.prototype.entries = function() {
    function entries(map) {
        var array = [];
        for (var k in map) {
            var v = map[k];
            array.push({
                key: k,
                values: v instanceof Array ? v : entries(v)
            });
        }
        return array;
    }
    function sort(array, i) {
        var o = this.keys[i].order;
        o && array.sort(function(a, b) {
            return o(a.key, b.key);
        });
        if (++i < this.keys.length)
            for (var j = 0; j < array.length; j++)
                sort.call(this, array[j].values, i);
        return array;
    }
    return sort.call(this, entries(this.map()), 0);
}
;

pv.Nest.prototype.rollup = function(f) {
    function rollup(map) {
        for (var key in map) {
            var value = map[key];
            value instanceof Array ? map[key] = f(value) : rollup(value);
        }
        return map;
    }
    return rollup(this.map());
}
;

pv.flatten = function(map) {
    return new pv.Flatten(map);
}
;

pv.Flatten = function(map) {
    this.map = map;
    this.keys = [];
}
;

pv.Flatten.prototype.key = function(key, f) {
    this.keys.push({
        name: key,
        value: f
    });
    delete this.$leaf;
    return this;
}
;

pv.Flatten.prototype.leaf = function(f) {
    this.keys.length = 0;
    this.$leaf = f;
    return this;
}
;

pv.Flatten.prototype.array = function() {
    function recurse(value, i) {
        if (leaf(value))
            entries.push({
                keys: stack.slice(),
                value: value
            });
        else
            for (var key in value) {
                stack.push(key);
                recurse(value[key], i + 1);
                stack.pop();
            }
    }
    function visit(value, i) {
        if (i < keys.length - 1)
            for (var key in value) {
                stack.push(key);
                visit(value[key], i + 1);
                stack.pop();
            }
        else
            entries.push(stack.concat(value));
    }
    var entries = []
      , stack = []
      , keys = this.keys
      , leaf = this.$leaf;
    if (leaf) {
        recurse(this.map, 0);
        return entries;
    }
    visit(this.map, 0);
    return entries.map(function(stack) {
        for (var m = {}, i = 0; i < keys.length; i++) {
            var k = keys[i]
              , v = stack[i];
            m[k.name] = k.value ? k.value.call(null, v) : v;
        }
        return m;
    });
}
;

pv.Transform = function() {}
;

pv.Transform.prototype = {
    k: 1,
    x: 0,
    y: 0
};

pv.Transform.identity = new pv.Transform();

pv.Transform.prototype.translate = function(x, y) {
    var v = new pv.Transform();
    v.k = this.k;
    v.x = this.k * x + this.x;
    v.y = this.k * y + this.y;
    return v;
}
;

pv.Transform.prototype.scale = function(k) {
    var v = new pv.Transform();
    v.k = this.k * k;
    v.x = this.x;
    v.y = this.y;
    return v;
}
;

pv.Transform.prototype.invert = function() {
    var v = new pv.Transform()
      , k = 1 / this.k;
    v.k = k;
    v.x = -this.x * k;
    v.y = -this.y * k;
    return v;
}
;

pv.Transform.prototype.times = function(m) {
    var v = new pv.Transform();
    v.k = this.k * m.k;
    v.x = this.k * m.x + this.x;
    v.y = this.k * m.y + this.y;
    return v;
}
;

pv.Scale = function() {}
;

pv.Scale.interpolator = function(start, end) {
    if ("number" == typeof start)
        return function(t) {
            return t * (end - start) + start;
        }
        ;
    var startGradient = start.type && "solid" !== start.type
      , endGradient = end.type && "solid" !== end.type;
    if (startGradient || endGradient) {
        start = startGradient ? start : pv.color(start).rgb();
        end = endGradient ? end : pv.color(end).rgb();
        return function(t) {
            return .5 > t ? start : end;
        }
        ;
    }
    start = pv.color(start).rgb();
    end = pv.color(end).rgb();
    return function(t) {
        var a = start.a * (1 - t) + end.a * t;
        1e-5 > a && (a = 0);
        return 0 == start.a ? pv.rgb(end.r, end.g, end.b, a) : 0 == end.a ? pv.rgb(start.r, start.g, start.b, a) : pv.rgb(Math.round(start.r * (1 - t) + end.r * t), Math.round(start.g * (1 - t) + end.g * t), Math.round(start.b * (1 - t) + end.b * t), a);
    }
    ;
}
;

pv.Scale.common = {
    by: function(f) {
        function by() {
            return scale(f.apply(this, arguments));
        }
        var scale = this;
        for (var method in scale)
            by[method] = scale[method];
        return by;
    },
    by1: function(f) {
        function by1(x) {
            return scale(f.call(this, x));
        }
        var scale = this;
        for (var method in scale)
            by1[method] = scale[method];
        return by1;
    },
    transform: function(t) {
        function transfScale() {
            return t.call(this, scale.apply(scale, arguments));
        }
        var scale = this;
        for (var method in scale)
            transfScale[method] = scale[method];
        return transfScale;
    }
};

pv.Scale.quantitative = function() {
    function scale(x) {
        var j = pv.search(d, x);
        0 > j && (j = -j - 2);
        j = Math.max(0, Math.min(i.length - 1, j));
        return i[j]((f(x) - l[j]) / (l[j + 1] - l[j]));
    }
    var dateTickFormat, dateTickPrecision, lastTicks, d = [0, 1], l = [0, 1], r = [0, 1], i = [pv.identity], type = Number, n = !1, f = pv.identity, g = pv.identity, tickFormatter = null, dateTickWeekStart = 0;
    scale.transform = function(forward, inverse) {
        f = function(x) {
            return n ? -forward(-x) : forward(x);
        }
        ;
        g = function(y) {
            return n ? -inverse(-y) : inverse(y);
        }
        ;
        l = d.map(f);
        return this;
    }
    ;
    scale.domain = function(array, min, max) {
        if (arguments.length) {
            var o;
            if (array instanceof Array) {
                arguments.length < 2 && (min = pv.identity);
                arguments.length < 3 && (max = min);
                o = array.length && min(array[0]);
                d = array.length ? [pv.min(array, min), pv.max(array, max)] : [];
            } else {
                o = array;
                d = Array.prototype.slice.call(arguments).map(Number);
            }
            d.length ? 1 == d.length && (d = [d[0], d[0]]) : d = [-(1 / 0), 1 / 0];
            n = (d[0] || d[d.length - 1]) < 0;
            l = d.map(f);
            type = o instanceof Date ? newDate : Number;
            return this;
        }
        return d.map(type);
    }
    ;
    scale.range = function() {
        if (arguments.length) {
            r = Array.prototype.slice.call(arguments);
            r.length ? 1 == r.length && (r = [r[0], r[0]]) : r = [-(1 / 0), 1 / 0];
            i = [];
            for (var j = 0; j < r.length - 1; j++)
                i.push(pv.Scale.interpolator(r[j], r[j + 1]));
            return this;
        }
        return r;
    }
    ;
    scale.invert = function(y) {
        var j = pv.search(r, y);
        0 > j && (j = -j - 2);
        j = Math.max(0, Math.min(i.length - 1, j));
        return type(g(l[j] + (y - r[j]) / (r[j + 1] - r[j]) * (l[j + 1] - l[j])));
    }
    ;
    scale.ticks = function(N, options) {
        var start = d[0]
          , end = d[d.length - 1]
          , reverse = start > end
          , min = reverse ? end : start
          , max = reverse ? start : end;
        lastTicks = type === newDate ? genDateTicks(N, min, max, dateTickPrecision, dateTickFormat, dateTickWeekStart, options) : genNumberTicks(N, min, max, options);
        return reverse ? lastTicks.reverse() : lastTicks;
    }
    ;
    scale.dateTickFormat = function() {
        if (arguments.length) {
            dateTickFormat = arguments[0];
            return this;
        }
        return dateTickFormat;
    }
    ;
    scale.dateTickPrecision = function() {
        if (arguments.length) {
            dateTickPrecision = parseDatePrecision(arguments[0], 0);
            return this;
        }
        return dateTickPrecision;
    }
    ;
    scale.dateTickWeekStart = function(weekStart) {
        if (arguments.length) {
            switch (("" + weekStart).toLowerCase()) {
            case "0":
            case "sunday":
                dateTickWeekStart = 0;
                break;

            case "1":
            case "monday":
                dateTickWeekStart = 1;
                break;

            case "2":
            case "tuesday":
                dateTickWeekStart = 2;
                break;

            case "3":
            case "wednesday":
                dateTickWeekStart = 3;
                break;

            case "4":
            case "thursday":
                dateTickWeekStart = 4;
                break;

            case "5":
            case "friday":
                dateTickWeekStart = 5;
                break;

            case "6":
            case "saturday":
                dateTickWeekStart = 6;
                break;

            default:
                dateTickWeekStart = 0;
            }
            return this;
        }
        return dateTickWeekStart;
    }
    ;
    scale.tickFormatter = function(f) {
        if (arguments.length) {
            tickFormatter = f;
            return this;
        }
        return tickFormatter;
    }
    ;
    scale.tickFormat = function(t, index) {
        var text;
        if (tickFormatter) {
            if (!lastTicks) {
                lastTicks = [];
                lastTicks.step = lastTicks.base = lastTicks.mult = 1;
                lastTicks.decPlaces = 0;
                lastTicks.format = String;
            }
            var precision = type !== Number ? lastTicks.step : lastTicks.decPlaces;
            text = tickFormatter.call(lastTicks, t, precision, null != index ? index : -1);
        } else
            text = lastTicks ? lastTicks.format(t) : String(t);
        return text;
    }
    ;
    scale.nice = function() {
        if (2 != d.length)
            return this;
        var start = d[0]
          , end = d[d.length - 1]
          , reverse = start > end
          , min = reverse ? end : start
          , max = reverse ? start : end
          , span = max - min;
        if (!span || !isFinite(span))
            return this;
        var step = Math.pow(10, Math.round(Math.log(span) / Math.log(10)) - 1);
        d = [Math.floor(min / step) * step, Math.ceil(max / step) * step];
        reverse && d.reverse();
        l = d.map(f);
        return this;
    }
    ;
    pv.copyOwn(scale, pv.Scale.common);
    scale.domain.apply(scale, arguments);
    return scale;
}
;

var dateCompCopyArgs = ["get", "set", "multiple", "multiples", "thresholds", "closeds", "castValue"];

DateComponent.prototype.increment = function(d, n) {
    null == n && (n = 1);
    1 !== this.mult && (n *= this.mult);
    this.set(d, this.get(d) + n);
}
;

DateComponent.prototype.get = function(d) {
    return d.getMilliseconds();
}
;

DateComponent.prototype.set = function(d, v) {
    d.setMilliseconds(v);
}
;

DateComponent.prototype.floorLocal = function(d, options) {}
;

DateComponent.prototype.floor = function(d, options) {
    var skip = 0;
    if (1 !== this.mult) {
        this.floorLocal(d, options);
        skip = this.base;
    }
    for (var comp = this.prev; comp; ) {
        1 === comp.mult && comp.value !== skip && comp.clear(d, options);
        comp = comp.prev;
    }
}
;

DateComponent.prototype.floorMultiple = function(d, n, options) {
    var first = this.first(d, options)
      , delta = this.get(d) - first;
    if (delta) {
        var M = n * this.mult
          , offset = Math.floor(delta / M) * M;
        this.set(d, first + offset);
    }
}
;

DateComponent.prototype.clear = function(d, options) {
    this.set(d, this.first(d, options));
}
;

DateComponent.prototype.multiple = function(N, options) {
    for (var ms = this.multiples, ts = this.thresholds, cl = this.closeds, L = ms.length, i = -1; ++i < L; )
        if (cl[i] ? N <= ts[i] : N < ts[i])
            return ms[i];
    throw new Error("Invalid configuration.");
}
;

DateComponent.prototype.resultAbove = function(mult) {
    return this.castValue(this.value * mult + .1, !0);
}
;

DateComponent.prototype.castValue = function(value, ceil) {
    var ms = this.multiples;
    if (!ms)
        return this._castValueResult(1, value, 1);
    var i, m = value / this.value, L = ms.length;
    if (ceil) {
        i = -1;
        for (; ++i < L; )
            if (m <= ms[i])
                return this._castValueResult(ms[i], value, 0);
        return this.next ? this.next.castValue(value, ceil) : this._castValueResult(ms[L - 1], value, 1);
    }
    i = L;
    for (; i--; )
        if (ms[i] <= m)
            return this._castValueResult(ms[i], value, 0);
    return this.prev ? this.prev.castValue(value, ceil) : this._castValueResult(ms[0], value, -1);
}
;

DateComponent.prototype._castValueResult = function(mult, value, overflow) {
    return {
        comp: this,
        mult: mult,
        value: this.value * mult,
        source: value,
        overflow: overflow
    };
}
;

DateComponent.prototype.withPrecision = function(value) {
    var comp = this;
    this.value !== value && (comp = new DateComponent(value,null,{
        mult: value,
        format: this.format
    }));
    return comp;
}
;

DateComponent.prototype.ticks = function(min, max, mult, options) {
    var ticks = []
      , tick = new Date(min);
    this.floor(tick, options);
    mult > 1 && this.floorMultiple(tick, mult, options);
    if (pv.get(options, "roundInside", 1)) {
        min !== +tick && this.increment(tick, mult);
        do {
            ticks.push(new Date(tick));
            this.increment(tick, mult);
        } while (max >= tick);
    } else {
        ticks.push(new Date(tick));
        do {
            this.increment(tick, mult);
            ticks.push(new Date(tick));
        } while (max > tick);
    }
    return ticks;
}
;

var _dateComps = [];

defDateComp(1, {
    format: "%S.%Qs",
    multiples: [1, 5, 25, 50, 100, 250],
    thresholds: [10, 50, 100, 200, 1e3, 1 / 0],
    closeds: [1, 1, 1, 1, 1, 1]
});

defDateComp(1e3, {
    get: function(d) {
        return d.getSeconds();
    },
    set: function(d, v) {
        d.setSeconds(v);
    },
    format: "%I:%M:%S",
    multiples: [1, 5, 10, 15],
    thresholds: [10, 60, 90, 1 / 0],
    closeds: [1, 1, 1, 1]
});

defDateComp(6e4, {
    get: function(d) {
        return d.getMinutes();
    },
    set: function(d, v) {
        d.setMinutes(v);
    },
    format: "%I:%M %p",
    multiples: [1, 5, 10, 15],
    thresholds: [10, 15, 30, 1 / 0],
    closeds: [1, 1, 1, 1]
});

defDateComp(36e5, {
    get: function(d) {
        return d.getHours();
    },
    set: function(d, v) {
        d.setHours(v);
    },
    format: "%I:%M %p",
    multiples: [1, 3, 6],
    thresholds: [10, 20, 1 / 0],
    closeds: [1, 1, 1]
});

defDateComp(864e5, {
    get: function(d) {
        return d.getDate();
    },
    set: function(d, v) {
        d.setDate(v);
    },
    format: "%m/%d",
    first: 1,
    multiples: [1, 2, 3, 5],
    thresholds: [10, 15, 30, 1 / 0],
    closeds: [1, 0, 0, 1]
});

defDateComp(6048e5, {
    get: function(d) {
        return d.getDate();
    },
    set: function(d, v) {
        d.setDate(v);
    },
    mult: 7,
    floor: function(d, options) {
        var wd = d.getDay() - pv.get(options, "weekStart", 0);
        if (0 !== wd) {
            0 > wd && (wd += 7);
            this.set(d, this.get(d) - wd);
        }
    },
    first: function(d, options) {
        return this.get(firstWeekStartOfMonth(d, pv.get(options, "weekStart", 0)));
    },
    format: "%m/%d",
    multiples: [1, 2, 3],
    thresholds: [10, 15, 1 / 0],
    closeds: [1, 1, 1]
});

defDateComp(2592e6, {
    get: function(d) {
        return d.getMonth();
    },
    set: function(d, v) {
        d.setMonth(v);
    },
    format: "%m/%Y",
    multiples: [1, 2, 3],
    thresholds: [12, 24, 1 / 0],
    closeds: [1, 1, 1]
});

defDateComp(31536e6, {
    get: function(d) {
        return d.getFullYear();
    },
    set: function(d, v) {
        d.setFullYear(v);
    },
    format: "%Y",
    multiple: function(N) {
        if (10 >= N)
            return 1;
        var mult = pv.logCeil(N / 15, 10);
        2 > N / mult ? mult /= 5 : 5 > N / mult && (mult /= 2);
        return mult;
    },
    castValue: function(value, ceil) {
        var base, mult, M = value / this.value;
        if (1 > M) {
            if (!ceil)
                return this.prev ? this.prev.castValue(value, ceil) : this._castValueResult(1, value, -1);
            base = 1;
        } else
            base = pv.logFloor(M, 10);
        mult = M / base;
        if (ceil)
            if (mult > 5) {
                base *= 10;
                mult = 1;
            } else
                mult = mult > 2 ? 5 : mult > 1 ? 2 : 1;
        else if (mult > 5)
            mult = 5;
        else if (mult > 2)
            mult = 2;
        else if (mult > 1)
            mult = 1;
        else if (1 > mult)
            return this.prev ? this.prev.castValue(value, ceil) : this._castValueResult(base, value, -1);
        return this._castValueResult(base * mult, value, 0);
    }
});

pv.Scale.linear = function() {
    var scale = pv.Scale.quantitative();
    scale.domain.apply(scale, arguments);
    return scale;
}
;

pv.Scale.log = function() {
    var b, p, scale = pv.Scale.quantitative(1, 10), log = function(x) {
        return Math.log(x) / p;
    }, pow = function(y) {
        return Math.pow(b, y);
    };
    scale.ticks = function() {
        var d = scale.domain()
          , n = d[0] < 0
          , i = Math.floor(n ? -log(-d[0]) : log(d[0]))
          , j = Math.ceil(n ? -log(-d[1]) : log(d[1]))
          , ticks = [];
        if (n) {
            ticks.push(-pow(-i));
            for (; i++ < j; )
                for (var k = b - 1; k > 0; k--)
                    ticks.push(-pow(-i) * k);
        } else {
            for (; j > i; i++)
                for (var k = 1; b > k; k++)
                    ticks.push(pow(i) * k);
            ticks.push(pow(i));
        }
        for (i = 0; ticks[i] < d[0]; i++)
            ;
        for (j = ticks.length; ticks[j - 1] > d[1]; j--)
            ;
        return ticks.slice(i, j);
    }
    ;
    scale.tickFormat = function(t) {
        return t.toPrecision(1);
    }
    ;
    scale.nice = function() {
        var d = scale.domain();
        return scale.domain(pv.logFloor(d[0], b), pv.logCeil(d[1], b));
    }
    ;
    scale.base = function(v) {
        if (arguments.length) {
            b = Number(v);
            p = Math.log(b);
            scale.transform(log, pow);
            return this;
        }
        return b;
    }
    ;
    scale.domain.apply(scale, arguments);
    return scale.base(10);
}
;

pv.Scale.root = function() {
    var scale = pv.Scale.quantitative();
    scale.power = function(v) {
        if (arguments.length) {
            var b = Number(v)
              , p = 1 / b;
            scale.transform(function(x) {
                return Math.pow(x, p);
            }, function(y) {
                return Math.pow(y, b);
            });
            return this;
        }
        return b;
    }
    ;
    scale.domain.apply(scale, arguments);
    return scale.power(2);
}
;

pv.Scale.ordinal = function() {
    function scale(x) {
        x in i || (i[x] = d.push(x) - 1);
        return r[i[x] % r.length];
    }
    var d = []
      , i = {}
      , r = [];
    scale.domain = function(array, f) {
        if (arguments.length) {
            array = array instanceof Array ? arguments.length > 1 ? pv.map(array, f) : array : Array.prototype.slice.call(arguments);
            d = [];
            for (var seen = {}, j = 0; j < array.length; j++) {
                var o = array[j];
                if (!(o in seen)) {
                    seen[o] = !0;
                    d.push(o);
                }
            }
            i = pv.numerate(d);
            return this;
        }
        return d;
    }
    ;
    scale.range = function(array, f) {
        if (arguments.length) {
            r = array instanceof Array ? arguments.length > 1 ? pv.map(array, f) : array : Array.prototype.slice.call(arguments);
            "string" == typeof r[0] && (r = r.map(pv.fillStyle));
            r.min = r[0];
            r.max = r[r.length - 1];
            return this;
        }
        return r;
    }
    ;
    scale.split = function(min, max) {
        var R = max - min
          , N = this.domain().length
          , step = 0;
        if (0 === R)
            r = pv.array(N, min);
        else if (N) {
            step = (max - min) / N;
            r = pv.range(min + step / 2, max, step);
        }
        r.min = min;
        r.max = max;
        r.step = step;
        return this;
    }
    ;
    scale.splitBandedCenter = function(min, max, bandRatio) {
        null == bandRatio && (bandRatio = 1);
        return this._splitBandedCore(min, max, function(info) {
            var S = info.range / info.count;
            info.step = S;
            info.band = S * bandRatio;
            info.offset = S / 2;
        });
    }
    ;
    scale.splitBandedCenterAbs = function(min, max, band, margin) {
        return this._splitBandedCore(min, max, function(info) {
            var step;
            if (null == band || null == margin) {
                step = info.range / info.count;
                if (null == band)
                    if (null == margin) {
                        band = step;
                        margin = 0;
                    } else {
                        margin = Math.min(margin, step);
                        band = step - margin;
                    }
                else {
                    band = Math.min(band, step);
                    margin = step - band;
                }
            } else
                step = band + margin;
            info.step = step;
            info.band = band;
            info.offset = step / 2;
        });
    }
    ;
    scale._splitBandedCore = function(min, max, fSplit) {
        var margin, info = {
            min: min,
            max: max,
            range: max - min,
            count: this.domain().length,
            offset: 0,
            step: 0,
            band: 0
        };
        if (0 === info.range) {
            r = pv.array(info.count, min);
            margin = 0;
        } else if (info.count) {
            fSplit(info);
            margin = info.step - info.band;
            r = pv.range(min + info.offset, max, info.step);
        }
        r.offset = info.offset;
        r.step = info.step;
        r.band = info.band;
        r.margin = margin;
        r.min = min;
        r.max = max;
        return this;
    }
    ;
    scale.splitBandedFlushCenter = function(min, max, bandRatio) {
        null == bandRatio && (bandRatio = 1);
        return this._splitBandedCore(min, max, function(info) {
            var R = info.range
              , N = info.count
              , B = R * bandRatio / N
              , M = N > 1 ? (R - N * B) / (N - 1) : 0;
            info.band = B;
            info.step = M + B;
            info.offset = B / 2;
        });
    }
    ;
    scale.splitFlush = function(min, max) {
        var n = this.domain().length
          , step = (max - min) / (n - 1);
        r = 1 == n ? [(min + max) / 2] : pv.range(min, max + step / 2, step);
        r.min = min;
        r.max = max;
        return this;
    }
    ;
    scale.splitBanded = function(min, max, band) {
        arguments.length < 3 && (band = 1);
        if (0 > band) {
            var n = this.domain().length
              , total = -band * n
              , remaining = max - min - total
              , padding = remaining / (n + 1);
            r = pv.range(min + padding, max, padding - band);
            r.band = -band;
        } else {
            var step = (max - min) / (this.domain().length + (1 - band));
            r = pv.range(min + step * (1 - band), max, step);
            r.band = step * band;
            r.step = step;
            r.margin = step - r.band;
        }
        r.min = min;
        r.max = max;
        return this;
    }
    ;
    scale.invertIndex = function(y, noRound) {
        var N = this.domain().length;
        if (0 === N)
            return -1;
        var r = this.range()
          , R = r.max - r.min;
        if (0 === R)
            return 0;
        var S = R / N;
        if (y >= r.max)
            return N;
        if (y < r.min)
            return 0;
        var i = (y - r.min) / S;
        return noRound ? i : Math.round(i);
    }
    ;
    pv.copyOwn(scale, pv.Scale.common);
    scale.domain.apply(scale, arguments);
    return scale;
}
;

pv.Scale.quantile = function() {
    function scale(x) {
        return y(Math.max(0, Math.min(j, pv.search.index(q, x) - 1)) / j);
    }
    var n = -1
      , j = -1
      , q = []
      , d = []
      , y = pv.Scale.linear();
    scale.quantiles = function(x) {
        if (arguments.length) {
            n = Number(x);
            if (0 > n) {
                q = [d[0]].concat(d);
                j = d.length - 1;
            } else {
                q = [];
                q[0] = d[0];
                for (var i = 1; n >= i; i++)
                    q[i] = d[~~(i * (d.length - 1) / n)];
                j = n - 1;
            }
            return this;
        }
        return q;
    }
    ;
    scale.domain = function(array, f) {
        if (arguments.length) {
            d = array instanceof Array ? pv.map(array, f) : Array.prototype.slice.call(arguments);
            d.sort(pv.naturalOrder);
            scale.quantiles(n);
            return this;
        }
        return d;
    }
    ;
    scale.range = function() {
        if (arguments.length) {
            y.range.apply(y, arguments);
            return this;
        }
        return y.range();
    }
    ;
    pv.copyOwn(scale, pv.Scale.common);
    scale.domain.apply(scale, arguments);
    return scale;
}
;

pv.histogram = function(data, f) {
    var frequency = !0;
    return {
        bins: function(ticks) {
            var x = pv.map(data, f)
              , bins = [];
            arguments.length || (ticks = pv.Scale.linear(x).ticks());
            for (var i = 0; i < ticks.length - 1; i++) {
                var bin = bins[i] = [];
                bin.x = ticks[i];
                bin.dx = ticks[i + 1] - ticks[i];
                bin.y = 0;
            }
            for (var i = 0; i < x.length; i++) {
                var j = pv.search.index(ticks, x[i]) - 1
                  , bin = bins[Math.max(0, Math.min(bins.length - 1, j))];
                bin.y++;
                bin.push(data[i]);
            }
            if (!frequency)
                for (var i = 0; i < bins.length; i++)
                    bins[i].y /= x.length;
            return bins;
        },
        frequency: function(x) {
            if (arguments.length) {
                frequency = Boolean(x);
                return this;
            }
            return frequency;
        }
    };
}
;

!function() {
    pv.Shape = function() {}
    ;
    var _k0 = {
        x: 1,
        y: 1
    };
    pv.Shape.dist2 = function(v, w, k) {
        k = k || _k0;
        var dx = v.x - w.x
          , dy = v.y - w.y
          , dx2 = dx * dx
          , dy2 = dy * dy;
        return {
            cost: dx2 + dy2,
            dist2: k.x * dx2 + k.y * dy2
        };
    }
    ;
    var pi = Math.PI
      , pi2 = 2 * pi
      , atan2 = Math.atan2;
    pv.Shape.normalizeAngle = function(a) {
        a %= pi2;
        pv.floatLess(a, 0) && (a += pi2);
        return a;
    }
    ;
    pv.Shape.atan2Norm = function(dy, dx) {
        var a = atan2(dy, dx);
        pv.floatLess(a, 0) && (a += pi2);
        return a;
    }
    ;
    pv.Shape.prototype.hasArea = function() {
        return !0;
    }
    ;
    pv.Shape.prototype.bbox = function() {
        return this._bbox || (this._bbox = this._calcBBox());
    }
    ;
    pv.Shape.prototype._calcBBox = function() {
        var minX, minY, maxX, maxY;
        this.points().forEach(function(point) {
            var x = point.x
              , y = point.y;
            if (null == minX) {
                minX = maxX = x;
                minY = maxY = y;
            } else {
                minX > x ? minX = x : x > maxX && (maxX = x);
                minY > y ? minY = y : y > maxY && (maxY = y);
            }
        });
        return null != minX ? new pv.Shape.Rect(minX,minY,maxX - minX,maxY - minY) : void 0;
    }
    ;
    pv.Shape.prototype.containsPoint = function(p, k) {
        if (k) {
            var bbox;
            if (!k.y)
                return bbox = this.bbox(),
                pv.floatBelongsClosed(bbox.x, p.x, bbox.x2);
            if (!k.x)
                return bbox = this.bbox(),
                pv.floatBelongsClosed(bbox.y, p.y, bbox.y2);
        }
        return this._containsPointCore(p);
    }
    ;
    pv.Shape.prototype._containsPointCore = function() {
        return !1;
    }
    ;
}();

!function() {
    var dist2 = pv.Shape.dist2
      , cos = Math.cos
      , sin = Math.sin
      , sqrt = Math.sqrt;
    pv.vector = function(x, y) {
        return new Point(x,y);
    }
    ;
    pv.Vector = function(x, y) {
        this.x = x;
        this.y = y;
    }
    ;
    var Point = pv.Shape.Point = pv.Vector;
    pv.Vector.prototype = pv.extend(pv.Shape);
    pv.Vector.prototype.perp = function() {
        return new Point(-this.y,this.x);
    }
    ;
    pv.Vector.prototype.rotate = function(angle) {
        var c = cos(angle)
          , s = sin(angle);
        return new Point(c * this.x - s * this.y,s * this.x + c * this.y);
    }
    ;
    pv.Vector.prototype.norm = function() {
        var l = this.length();
        return this.times(l ? 1 / l : 1);
    }
    ;
    pv.Vector.prototype.length = function() {
        return sqrt(this.x * this.x + this.y * this.y);
    }
    ;
    pv.Vector.prototype.times = function(k) {
        return new Point(this.x * k,this.y * k);
    }
    ;
    pv.Vector.prototype.plus = function(x, y) {
        return 1 === arguments.length ? new Point(this.x + x.x,this.y + x.y) : new Point(this.x + x,this.y + y);
    }
    ;
    pv.Vector.prototype.minus = function(x, y) {
        return 1 === arguments.length ? new Point(this.x - x.x,this.y - x.y) : new Point(this.x - x,this.y - y);
    }
    ;
    pv.Vector.prototype.dot = function(x, y) {
        return 1 == arguments.length ? this.x * x.x + this.y * x.y : this.x * x + this.y * y;
    }
    ;
    pv.Vector.prototype.hasArea = function() {
        return !1;
    }
    ;
    pv.Vector.prototype.clone = function() {
        return new Point(this.x,this.y);
    }
    ;
    pv.Vector.prototype.apply = function(t) {
        return new Point(t.x + t.k * this.x,t.y + t.k * this.y);
    }
    ;
    pv.Vector.prototype.intersectsRect = function(rect) {
        return pv.floatBelongsClosed(rect.x, this.x, rect.x2) && pv.floatBelongsClosed(rect.y, this.y, rect.y2);
    }
    ;
    pv.Vector.prototype._containsPointCore = function(p) {
        return this.x === p.x && this.y === p.y;
    }
    ;
    pv.Vector.prototype.points = function() {
        return [this];
    }
    ;
    pv.Vector.prototype.edges = function() {
        return [];
    }
    ;
    pv.Vector.prototype.center = function() {
        return this;
    }
    ;
    pv.Vector.prototype.distance2 = function(p, k) {
        return dist2(this, p, k);
    }
    ;
}();

!function() {
    var Point = pv.Shape.Point
      , dist2 = pv.Shape.dist2;
    pv.Shape.Line = function(x, y, x2, y2) {
        this.x = x || 0;
        this.y = y || 0;
        this.x2 = x2 || 0;
        this.y2 = y2 || 0;
    }
    ;
    var Line = pv.Shape.Line;
    Line.prototype = pv.extend(pv.Shape);
    Line.prototype.hasArea = function() {
        return !1;
    }
    ;
    Line.prototype.clone = function() {
        return new Line(this.x,this.y,this.x2,this.x2);
    }
    ;
    Line.prototype.apply = function(t) {
        var x = t.x + t.k * this.x
          , y = t.y + t.k * this.y
          , x2 = t.x + t.k * this.x2
          , y2 = t.y + t.k * this.y2;
        return new Line(x,y,x2,y2);
    }
    ;
    Line.prototype.points = function() {
        return [new Point(this.x,this.y), new Point(this.x2,this.y2)];
    }
    ;
    Line.prototype.edges = function() {
        return [this];
    }
    ;
    Line.prototype.center = function() {
        return new Point((this.x + this.x2) / 2,(this.y + this.y2) / 2);
    }
    ;
    Line.prototype.normal = function(at, shapeCenter) {
        var points = this.points()
          , norm = points[1].minus(points[0]).perp().norm();
        if (shapeCenter) {
            var outside = points[0].minus(shapeCenter);
            outside.dot(norm) < 0 && (norm = norm.times(-1));
        }
        return norm;
    }
    ;
    Line.prototype.intersectsRect = function(rect) {
        var i, L, points = this.points();
        L = points.length;
        for (i = 0; L > i; i++)
            if (points[i].intersectsRect(rect))
                return !0;
        var edges = rect.edges();
        L = edges.length;
        for (i = 0; L > i; i++)
            if (this.intersectsLine(edges[i]))
                return !0;
        return !1;
    }
    ;
    Line.prototype._containsPointCore = function(p) {
        var x = this.x
          , x2 = this.x2
          , y = this.y
          , y2 = this.y2;
        return pv.floatBelongsClosed(x, p.x, x2) && (pv.floatEqual(x, x2) ? pv.floatBelongsClosed(Math.min(y, y2), p.y, Math.max(y, y2)) : pv.floatZero((y2 - y) / (x2 - x) * (p.x - x) + y - p.y));
    }
    ;
    Line.prototype.intersectsLine = function(b) {
        var a = this
          , x21 = a.x2 - a.x
          , y21 = a.y2 - a.y
          , x43 = b.x2 - b.x
          , y43 = b.y2 - b.y
          , denom = y43 * x21 - x43 * y21;
        if (pv.floatZero(denom))
            return !1;
        var y13 = a.y - b.y
          , x13 = a.x - b.x
          , numa = x43 * y13 - y43 * x13
          , numb = x21 * y13 - y21 * x13;
        if (pv.floatZero(denom))
            return pv.floatZero(numa) && pv.floatZero(numb);
        var ua = numa / denom;
        if (!pv.floatBelongsClosed(0, ua, 1))
            return !1;
        var ub = numb / denom;
        return pv.floatBelongsClosed(0, ub, 1) ? !0 : !1;
    }
    ;
    Line.prototype.distance2 = function(p, k) {
        var v = this
          , w = {
            x: this.x2,
            y: this.y2
        }
          , l2 = dist2(v, w).cost;
        if (pv.floatZero(l2))
            return dist2(p, v, k);
        var wvx = w.x - v.x
          , wvy = w.y - v.y
          , t = ((p.x - v.x) * wvx + (p.y - v.y) * wvy) / l2;
        if (pv.floatLess(t, 0))
            return dist2(p, v, k);
        if (pv.floatGreater(t, 1))
            return dist2(p, w, k);
        var proj = {
            x: v.x + t * wvx,
            y: v.y + t * wvy
        };
        return dist2(p, proj, k);
    }
    ;
}();

!function() {
    var Point = pv.Shape.Point
      , Line = pv.Shape.Line;
    pv.Shape.Polygon = function(points) {
        this._points = points || [];
    }
    ;
    var Polygon = pv.Shape.Polygon;
    Polygon.prototype = pv.extend(pv.Shape);
    Polygon.prototype.points = function() {
        return this._points;
    }
    ;
    Polygon.prototype.clone = function() {
        return new Polygon(this.points().slice());
    }
    ;
    Polygon.prototype.apply = function(t) {
        for (var points = this.points(), L = points.length, points2 = new Array(L), i = 0; L > i; i++)
            points2[i] = points[i].apply(t);
        return new Polygon(points2);
    }
    ;
    Polygon.prototype.intersectsRect = function(rect) {
        var i, L, points = this.points();
        L = points.length;
        for (i = 0; L > i; i++)
            if (points[i].intersectsRect(rect))
                return !0;
        var edges = this.edges();
        L = edges.length;
        for (i = 0; L > i; i++)
            if (edges[i].intersectsRect(rect))
                return !0;
        return !1;
    }
    ;
    Polygon.prototype.edges = function() {
        var edges = this._edges;
        if (!edges) {
            edges = this._edges = [];
            var points = this.points()
              , L = points.length;
            if (L) {
                for (var point, prevPoint = points[0], firstPoint = prevPoint, i = 1; L > i; i++) {
                    point = points[i];
                    edges.push(new Line(prevPoint.x,prevPoint.y,point.x,point.y));
                    prevPoint = point;
                }
                L > 2 && edges.push(new Line(point.x,point.y,firstPoint.x,firstPoint.y));
            }
        }
        return edges;
    }
    ;
    Polygon.prototype.distance2 = function(p, k) {
        var min = {
            cost: 1 / 0,
            dist2: 1 / 0
        };
        this.edges().forEach(function(edge) {
            var d = edge.distance2(p, k);
            pv.floatLess(d.cost, min.cost) && (min = d);
        }, this);
        return min;
    }
    ;
    Polygon.prototype.center = function() {
        for (var points = this.points(), x = 0, y = 0, i = 0, L = points.length; L > i; i++) {
            var p = points[i];
            x += p.x;
            y += p.y;
        }
        return new Point(x / L,y / L);
    }
    ;
    Polygon.prototype._containsPointCore = function(p) {
        var bbox = this.bbox();
        if (!bbox._containsPointCore(p))
            return !1;
        var e = .01 * bbox.dx
          , ray = new Line(bbox.x - e,p.y,p.x,p.y)
          , intersectCount = 0
          , edges = this.edges();
        edges.forEach(function(edge) {
            edge.intersectsLine(ray) && intersectCount++;
        });
        return 1 === (1 & intersectCount);
    }
    ;
}();

!function() {
    var Point = pv.Shape.Point
      , Line = pv.Shape.Line;
    pv.Shape.Rect = function(x, y, dx, dy) {
        this.x = x || 0;
        this.y = y || 0;
        this.dx = dx || 0;
        this.dy = dy || 0;
        if (this.dx < 0) {
            this.dx = Math.max(0, -this.dx);
            this.x = this.x - this.dx;
        }
        if (this.dy < 0) {
            this.dy = Math.max(0, -this.dy);
            this.y = this.y - this.dy;
        }
        this.x2 = this.x + this.dx;
        this.y2 = this.y + this.dy;
    }
    ;
    var Rect = pv.Shape.Rect;
    Rect.prototype = pv.extend(pv.Shape.Polygon);
    Rect.prototype.clone = function() {
        var r2 = Object.create(Rect.prototype);
        r2.x = this.x;
        r2.y = this.y;
        r2.dx = this.dx;
        r2.dy = this.dy;
        r2.x2 = this.x2;
        r2.y2 = this.y2;
        return r2;
    }
    ;
    Rect.prototype.apply = function(t) {
        var x = t.x + t.k * this.x
          , y = t.y + t.k * this.y
          , dx = t.k * this.dx
          , dy = t.k * this.dy;
        return new Rect(x,y,dx,dy);
    }
    ;
    Rect.prototype._containsPointCore = function(p) {
        return pv.floatBelongsClosed(this.x, p.x, this.x2) && pv.floatBelongsClosed(this.y, p.y, this.y2);
    }
    ;
    Rect.prototype.intersectsRect = function(rect) {
        return pv.floatGreater(this.x2, rect.x) && pv.floatLess(this.x, rect.x2) && pv.floatGreater(this.y2, rect.y) && pv.floatLess(this.y, rect.y2);
    }
    ;
    Rect.prototype.edges = function() {
        if (!this._edges) {
            var x = this.x
              , y = this.y
              , x2 = this.x2
              , y2 = this.y2;
            this._edges = [new Line(x,y,x2,y), new Line(x2,y,x2,y2), new Line(x2,y2,x,y2), new Line(x,y2,x,y)];
        }
        return this._edges;
    }
    ;
    Rect.prototype.center = function() {
        return new Point(this.x + this.dx / 2,this.y + this.dy / 2);
    }
    ;
    Rect.prototype.points = function() {
        var points = this._points;
        if (!points) {
            var x = this.x
              , y = this.y
              , x2 = this.x2
              , y2 = this.y2;
            points = this._points = [new Point(x,y), new Point(x2,y), new Point(x2,y2), new Point(x,y2)];
        }
        return points;
    }
    ;
    Rect.prototype._calcBBox = function() {
        return this;
    }
    ;
}();

!function() {
    var Point = pv.Shape.Point
      , dist2 = pv.Shape.dist2
      , sqrt = Math.sqrt
      , abs = Math.abs
      , pow = Math.pow;
    pv.Shape.Circle = function(x, y, radius) {
        this.x = x || 0;
        this.y = y || 0;
        this.radius = radius || 0;
    }
    ;
    var Circle = pv.Shape.Circle;
    Circle.prototype = pv.extend(pv.Shape);
    Circle.prototype.clone = function() {
        return new Circle(this.x,this.y,this.radius);
    }
    ;
    Circle.prototype.apply = function(t) {
        var x = t.x + t.k * this.x
          , y = t.y + t.k * this.y
          , r = t.k * this.radius;
        return new Circle(x,y,r);
    }
    ;
    Circle.prototype.intersectsRect = function(rect) {
        var dx2 = rect.dx / 2
          , dy2 = rect.dy / 2
          , r = this.radius
          , circleDistX = abs(this.x - rect.x - dx2)
          , circleDistY = abs(this.y - rect.y - dy2);
        if (circleDistX > dx2 + r || circleDistY > dy2 + r)
            return !1;
        if (dx2 >= circleDistX || dy2 >= circleDistY)
            return !0;
        var sqCornerDistance = pow(circleDistX - dx2, 2) + pow(circleDistY - dy2, 2);
        return r * r >= sqCornerDistance;
    }
    ;
    Circle.prototype.intersectLine = function(line, isInfiniteLine) {
        var baX = line.x2 - line.x
          , baY = line.y2 - line.y
          , caX = this.x - line.x
          , caY = this.y - line.y
          , ba2 = baX * baX + baY * baY
          , bBy2 = baX * caX + baY * caY
          , r = this.radius
          , c = caX * caX + caY * caY - r * r
          , pBy2 = bBy2 / ba2
          , disc = pBy2 * pBy2 - c / ba2;
        if (!(0 > disc)) {
            var discSqrt = sqrt(disc)
              , t1 = pBy2 - discSqrt
              , t2 = pBy2 + discSqrt
              , ps = [];
            (isInfiniteLine || t1 >= 0 && 1 >= t1) && ps.push(new Point(line.x + baX * t1,line.y + baY * t1));
            0 !== disc && (isInfiniteLine || t2 >= 0 && 1 >= t2) && ps.push(new Point(line.x + baX * t2,line.y + baY * t2));
            return ps;
        }
    }
    ;
    Circle.prototype.points = function() {
        return [this.center()];
    }
    ;
    Circle.prototype.center = function() {
        return new Point(this.x,this.y);
    }
    ;
    Circle.prototype.normal = function(at) {
        return at.minus(this.x, this.y).norm();
    }
    ;
    Circle.prototype._containsPointCore = function(p) {
        var dx = p.x - this.x
          , dy = p.y - this.y
          , r = this.radius;
        return r * r >= dx * dx + dy * dy;
    }
    ;
    Circle.prototype.distance2 = function(p, k) {
        var r = this.radius
          , b = p.minus(this).norm().times(r).plus(this)
          , dBorder = dist2(p, b, k);
        return dBorder;
    }
    ;
    Circle.prototype._calcBBox = function() {
        var r = this.radius
          , r_2 = 2 * r;
        return new pv.Shape.Rect(this.x - r,this.y - r,r_2,r_2);
    }
    ;
}();

!function() {
    var Point = pv.Shape.Point
      , dist2 = pv.Shape.dist2
      , normalizeAngle = pv.Shape.normalizeAngle
      , atan2Norm = pv.Shape.atan2Norm
      , cos = Math.cos
      , sin = Math.sin
      , sqrt = Math.sqrt
      , pi = Math.PI
      , pi_2 = 2 * pi
      , pi_1_2 = pi / 2
      , pi_3_2 = 3 * pi / 2;
    pv.Shape.Arc = function(x, y, radius, startAngle, angleSpan) {
        this.x = x;
        this.y = y;
        this.radius = radius;
        pv.floatBelongsClosed(0, angleSpan, pi_2) || (angleSpan = normalizeAngle(angleSpan));
        this.startAngle = normalizeAngle(startAngle);
        this.angleSpan = angleSpan;
        this.endAngle = this.startAngle + this.angleSpan;
    }
    ;
    var Arc = pv.Shape.Arc;
    Arc.prototype = pv.extend(pv.Shape);
    Arc.prototype.hasArea = function() {
        return !1;
    }
    ;
    Arc.prototype.clone = function() {
        var arc = Object.create(Arc.prototype)
          , me = this;
        arc.x = me.x;
        arc.y = me.y;
        arc.radius = me.radius;
        arc.startAngle = me.startAngle;
        arc.angleSpan = me.angleSpan;
        arc.endAngle = me.endAngle;
        return arc;
    }
    ;
    Arc.prototype.apply = function(t) {
        var x = t.x + t.k * this.x
          , y = t.y + t.k * this.y
          , r = t.k * this.radius;
        return new Arc(x,y,r,this.startAngle,this.angleSpan);
    }
    ;
    Arc.prototype.containsAngle = function(a, inside) {
        pv.floatBelongsClosed(0, a, pi_2) || (a = normalizeAngle(a));
        var ai = this.startAngle
          , af = this.endAngle;
        if (inside ? pv.floatBelongsOpen(ai, a, af) : pv.floatBelongsClosed(ai, a, af))
            return !0;
        if (pv.floatLessOrEqual(af, pi_2))
            return !1;
        a += pi_2;
        return inside ? pv.floatBelongsOpen(ai, a, af) : pv.floatBelongsClosed(ai, a, af);
    }
    ;
    Arc.prototype._containsPointCore = function(p) {
        var dx = p.x - this.x
          , dy = p.y - this.y
          , r = sqrt(dx * dx + dy * dy);
        return pv.floatEqual(r, this.radius) && this.containsAngle(atan2Norm(dy, dx));
    }
    ;
    Arc.prototype.intersectsRect = function(rect) {
        var i, points = this.points(), L = points.length;
        for (i = 0; L > i; i++)
            if (points[i].intersectsRect(rect))
                return !0;
        var edges = rect.edges();
        L = edges.length;
        for (i = 0; L > i; i++)
            if (this.intersectLine(edges[i]))
                return !0;
        return !1;
    }
    ;
    var circleIntersectLine = pv.Shape.Circle.prototype.intersectLine;
    Arc.prototype.intersectLine = function(line, isInfiniteLine) {
        var ps = circleIntersectLine.call(this, line, isInfiniteLine);
        if (ps) {
            ps = ps.filter(function(p) {
                return this._containsPointCore(p);
            }, this);
            if (ps.length)
                return ps;
        }
    }
    ;
    Arc.prototype.points = function() {
        function addAngle(a) {
            me.containsAngle(a, !0) && points.push(new Point(x + r * cos(a),y + r * sin(a)));
        }
        var me = this
          , x = me.x
          , y = me.y
          , r = me.radius
          , ai = me.startAngle
          , af = me.endAngle
          , points = [new Point(x + r * cos(ai),y + r * sin(ai)), new Point(x + r * cos(af),y + r * sin(af))];
        addAngle(0);
        addAngle(pi_1_2);
        addAngle(pi);
        addAngle(pi_3_2);
        return points;
    }
    ;
    Arc.prototype.center = function() {
        var x = this.x
          , y = this.y
          , r = this.radius
          , am = (this.startAngle + this.endAngle) / 2;
        return new Point(x + r * cos(am),y + r * sin(am));
    }
    ;
    Arc.prototype.normal = function(at, shapeCenter) {
        var norm = at.minus(this.x, this.y).norm();
        if (shapeCenter) {
            var outside = this.center().minus(shapeCenter);
            outside.dot(norm) < 0 && (norm = norm.times(-1));
        }
        return norm;
    }
    ;
    Arc.prototype.distance2 = function(p, k) {
        var dx = p.x - this.x
          , dy = p.y - this.y
          , a = atan2Norm(dy, dx);
        if (this.containsAngle(a)) {
            var b = new Point(this.x + this.radius * cos(a),this.y + this.radius * sin(a));
            return dist2(p, b, k);
        }
        var points = this.points()
          , d1 = dist2(p, points[0], k)
          , d2 = dist2(p, points[1], k);
        return pv.floatLess(d1.cost, d2.cost) ? d1 : d2;
    }
    ;
}();

!function() {
    var Arc = pv.Shape.Arc
      , Line = pv.Shape.Line
      , Point = pv.Shape.Point
      , cos = Math.cos
      , sin = Math.sin
      , sqrt = Math.sqrt
      , pi = Math.PI
      , pi_2 = 2 * pi
      , pi_1_2 = pi / 2
      , pi_3_2 = 3 * pi / 2
      , atan2Norm = pv.Shape.atan2Norm
      , normalizeAngle = pv.Shape.normalizeAngle;
    pv.Shape.Wedge = function(x, y, innerRadius, outerRadius, startAngle, angleSpan) {
        this.x = x;
        this.y = y;
        this.innerRadius = innerRadius;
        this.outerRadius = outerRadius;
        pv.floatBelongsClosed(0, angleSpan, pi_2) || (angleSpan = normalizeAngle(angleSpan));
        this.startAngle = normalizeAngle(startAngle);
        this.angleSpan = angleSpan;
        this.endAngle = this.startAngle + angleSpan;
    }
    ;
    var Wedge = pv.Shape.Wedge;
    Wedge.prototype = pv.extend(pv.Shape);
    Wedge.prototype.clone = function() {
        return new Wedge(this.x,this.y,this.innerRadius,this.outerRadius,this.startAngle,this.angleSpan);
    }
    ;
    Wedge.prototype.apply = function(t) {
        var x = t.x + t.k * this.x
          , y = t.y + t.k * this.y
          , ir = t.k * this.innerRadius
          , or = t.k * this.outerRadius;
        return new Wedge(x,y,ir,or,this.startAngle,this.angleSpan);
    }
    ;
    Wedge.prototype.containsAngle = Arc.prototype.containsAngle;
    Wedge.prototype._containsPointCore = function(p) {
        var dx = p.x - this.x
          , dy = p.y - this.y
          , r = sqrt(dx * dx + dy * dy);
        return pv.floatBelongsClosed(this.innerRadius, r, this.outerRadius) && this.containsAngle(atan2Norm(dy, dx));
    }
    ;
    Wedge.prototype.intersectsRect = function(rect) {
        var i, L, points, edges;
        points = this.points();
        L = points.length;
        for (i = 0; L > i; i++)
            if (points[i].intersectsRect(rect))
                return !0;
        points = rect.points();
        L = points.length;
        for (i = 0; L > i; i++)
            if (this._containsPointCore(points[i]))
                return !0;
        edges = this.edges();
        L = edges.length;
        for (i = 0; L > i; i++)
            if (edges[i].intersectsRect(rect))
                return !0;
        return !1;
    }
    ;
    Wedge.prototype.points = function() {
        this._points || this.edges();
        return this._points;
    }
    ;
    Wedge.prototype.edges = function() {
        function addAngle(a) {
            me.containsAngle(a, !0) && points.push(new Point(x + or * cos(a),y + or * sin(a)));
        }
        var me = this
          , edges = me._edges;
        if (!edges) {
            var pii, pfi, x = me.x, y = me.y, ir = me.innerRadius, irPositive = pv.floatGreater(ir, 0), or = me.outerRadius, ai = me.startAngle, af = me.endAngle, aa = me.angleSpan, cai = cos(ai), sai = sin(ai), caf = cos(af), saf = sin(af);
            if (irPositive) {
                pii = new Point(x + ir * cai,y + ir * sai);
                pfi = new Point(x + ir * caf,y + ir * saf);
            } else
                pii = pfi = new Point(x,y);
            var pio = new Point(x + or * cai,y + or * sai)
              , pfo = new Point(x + or * caf,y + or * saf);
            edges = me._edges = [];
            irPositive && edges.push(new Arc(x,y,ir,ai,aa));
            edges.push(new Line(pii.x,pii.y,pio.x,pio.y), new Arc(x,y,or,ai,aa), new Line(pfi.x,pfi.y,pfo.x,pfo.y));
            var points = me._points = [pii, pio, pfo];
            irPositive && points.push(pfi);
            addAngle(0);
            addAngle(pi_1_2);
            addAngle(pi);
            addAngle(pi_3_2);
        }
        return edges;
    }
    ;
    Wedge.prototype.distance2 = function(p, k) {
        var min = {
            cost: 1 / 0,
            dist2: 1 / 0
        };
        this.edges().forEach(function(edge) {
            var d = edge.distance2(p, k);
            pv.floatLess(d.cost, min.cost) && (min = d);
        });
        return min;
    }
    ;
    Wedge.prototype.center = function() {
        var midAngle = (this.startAngle + this.endAngle) / 2
          , midRadius = (this.innerRadius + this.outerRadius) / 2;
        return new Point(this.x + midRadius * cos(midAngle),this.y + midRadius * sin(midAngle));
    }
    ;
}();

!function() {
    var round = Math.round
      , parseRgb = function(c) {
        var f = parseFloat(c);
        return "%" == c[c.length - 1] ? round(2.55 * f) : f;
    }
      , reSysColor = /([a-z]+)\((.*)\)/i
      , createColor = function(format) {
        if ("#" === format.charAt(0)) {
            var r, g, b;
            if (4 === format.length) {
                r = format.charAt(1);
                r += r;
                g = format.charAt(2);
                g += g;
                b = format.charAt(3);
                b += b;
            } else if (7 === format.length) {
                r = format.substring(1, 3);
                g = format.substring(3, 5);
                b = format.substring(5, 7);
            }
            return pv.rgb(parseInt(r, 16), parseInt(g, 16), parseInt(b, 16), 1);
        }
        var m1 = reSysColor.exec(format);
        if (m1) {
            var m2 = m1[2].split(",")
              , a = 1;
            switch (m1[1]) {
            case "hsla":
            case "rgba":
                a = parseFloat(m2[3]);
                if (!a)
                    return pv.Color.transparent;
            }
            switch (m1[1]) {
            case "hsla":
            case "hsl":
                var h = parseFloat(m2[0])
                  , s = parseFloat(m2[1]) / 100
                  , l = parseFloat(m2[2]) / 100;
                return new pv.Color.Hsl(h,s,l,a).rgb();

            case "rgba":
            case "rgb":
                var r = parseRgb(m2[0])
                  , g = parseRgb(m2[1])
                  , b = parseRgb(m2[2]);
                return pv.rgb(r, g, b, a);
            }
        }
        return new pv.Color(format,1);
    }
      , colorsByFormat = {};
    pv.color = function(format) {
        if (format.rgb)
            return format.rgb();
        var color = pv.Color.names[format];
        color || (color = colorsByFormat[format] || (colorsByFormat[format] = createColor(format)));
        return color;
    }
    ;
}();

pv.Color = function(color, opacity) {
    this.color = color;
    this.opacity = opacity;
    this.key = "solid " + color + " alpha(" + opacity + ")";
}
;

pv.Color.prototype.hsl = function() {
    return this.rgb().hsl();
}
;

pv.Color.prototype.brighter = function(k) {
    return this.rgb().brighter(k);
}
;

pv.Color.prototype.darker = function(k) {
    return this.rgb().darker(k);
}
;

pv.Color.prototype.alphaBlend = function(mate) {
    var rgb = this.rgb()
      , a = rgb.a;
    if (1 === a)
        return this;
    mate = mate ? pv.color(mate) : pv.Color.names.white;
    mate = mate.rgb();
    var z = 1 - a;
    return pv.rgb(z * rgb.r + a * mate.r, z * rgb.g + a * mate.g, z * rgb.b + a * mate.b, 1);
}
;

pv.Color.prototype.rgbDecimal = function(mate) {
    var rgb = this.alphaBlend(mate);
    return rgb.r << 16 | rgb.g << 8 | rgb.b;
}
;

pv.Color.prototype.isDark = function() {
    return this.rgbDecimal() < 8388607.5;
}
;

pv.rgb = function(r, g, b, a) {
    return new pv.Color.Rgb(r,g,b,4 == arguments.length ? a : 1);
}
;

pv.Color.Rgb = function(r, g, b, a) {
    pv.Color.call(this, a ? "rgb(" + r + "," + g + "," + b + ")" : "none", a);
    this.r = r;
    this.g = g;
    this.b = b;
    this.a = a;
}
;

pv.Color.Rgb.prototype = pv.extend(pv.Color);

pv.Color.Rgb.prototype.red = function(r) {
    return pv.rgb(r, this.g, this.b, this.a);
}
;

pv.Color.Rgb.prototype.green = function(g) {
    return pv.rgb(this.r, g, this.b, this.a);
}
;

pv.Color.Rgb.prototype.blue = function(b) {
    return pv.rgb(this.r, this.g, b, this.a);
}
;

pv.Color.Rgb.prototype.alpha = function(a) {
    return pv.rgb(this.r, this.g, this.b, a);
}
;

pv.Color.Rgb.prototype.rgb = function() {
    return this;
}
;

pv.Color.Rgb.prototype.brighter = function(k) {
    k = Math.pow(.7, null != k ? k : 1);
    var r = this.r
      , g = this.g
      , b = this.b
      , i = 30;
    if (!r && !g && !b)
        return pv.rgb(i, i, i, this.a);
    r && i > r && (r = i);
    g && i > g && (g = i);
    b && i > b && (b = i);
    return pv.rgb(Math.min(255, Math.floor(r / k)), Math.min(255, Math.floor(g / k)), Math.min(255, Math.floor(b / k)), this.a);
}
;

pv.Color.Rgb.prototype.darker = function(k) {
    k = Math.pow(.7, null != k ? k : 1);
    return pv.rgb(Math.max(0, Math.floor(k * this.r)), Math.max(0, Math.floor(k * this.g)), Math.max(0, Math.floor(k * this.b)), this.a);
}
;

pv.Color.Rgb.prototype.hsl = function() {
    var h, s, r = this.r / 255, g = this.g / 255, b = this.b / 255, max = Math.max(r, g, b), min = Math.min(r, g, b), l = (max + min) / 2;
    if (max === min)
        h = s = 0;
    else {
        var d = max - min;
        s = l > .5 ? d / (2 - max - min) : d / (max + min);
        switch (max) {
        case r:
            h = (g - b) / d + (b > g ? 6 : 0);
            break;

        case g:
            h = (b - r) / d + 2;
            break;

        case b:
            h = (r - g) / d + 4;
        }
        h /= 6;
    }
    return pv.hsl(360 * h, s, l, this.a);
}
;

pv.Color.Rgb.prototype.complementary = function() {
    return this.hsl().complementary().rgb();
}
;

pv.hsl = function(h, s, l, a) {
    return new pv.Color.Hsl(h,s,l,4 == arguments.length ? a : 1);
}
;

pv.Color.Hsl = function(h, s, l, a) {
    pv.Color.call(this, "hsl(" + h + "," + 100 * s + "%," + 100 * l + "%)", a);
    this.h = h;
    this.s = s;
    this.l = l;
    this.a = a;
}
;

pv.Color.Hsl.prototype = pv.extend(pv.Color);

pv.Color.Hsl.prototype.hsl = function() {
    return this;
}
;

pv.Color.Hsl.prototype.hue = function(h) {
    return pv.hsl(h, this.s, this.l, this.a);
}
;

pv.Color.Hsl.prototype.saturation = function(s) {
    return pv.hsl(this.h, s, this.l, this.a);
}
;

pv.Color.Hsl.prototype.lightness = function(l) {
    return pv.hsl(this.h, this.s, l, this.a);
}
;

pv.Color.Hsl.prototype.alpha = function(a) {
    return pv.hsl(this.h, this.s, this.l, a);
}
;

pv.Color.Hsl.prototype.complementary = function() {
    return pv.hsl((this.h + 180) % 360, 1 - this.s, 1 - this.l, this.a);
}
;

pv.Color.Hsl.prototype.rgb = function() {
    function v(h) {
        h > 360 ? h -= 360 : 0 > h && (h += 360);
        return 60 > h ? m1 + (m2 - m1) * h / 60 : 180 > h ? m2 : 240 > h ? m1 + (m2 - m1) * (240 - h) / 60 : m1;
    }
    function vv(h) {
        return Math.round(255 * v(h));
    }
    var h = this.h
      , s = this.s
      , l = this.l;
    h %= 360;
    0 > h && (h += 360);
    s = Math.max(0, Math.min(s, 1));
    l = Math.max(0, Math.min(l, 1));
    var m2 = .5 >= l ? l * (1 + s) : l + s - l * s
      , m1 = 2 * l - m2;
    return pv.rgb(vv(h + 120), vv(h), vv(h - 120), this.a);
}
;

pv.Color.names = {
    aliceblue: "#f0f8ff",
    antiquewhite: "#faebd7",
    aqua: "#00ffff",
    aquamarine: "#7fffd4",
    azure: "#f0ffff",
    beige: "#f5f5dc",
    bisque: "#ffe4c4",
    black: "#000000",
    blanchedalmond: "#ffebcd",
    blue: "#0000ff",
    blueviolet: "#8a2be2",
    brown: "#a52a2a",
    burlywood: "#deb887",
    cadetblue: "#5f9ea0",
    chartreuse: "#7fff00",
    chocolate: "#d2691e",
    coral: "#ff7f50",
    cornflowerblue: "#6495ed",
    cornsilk: "#fff8dc",
    crimson: "#dc143c",
    cyan: "#00ffff",
    darkblue: "#00008b",
    darkcyan: "#008b8b",
    darkgoldenrod: "#b8860b",
    darkgray: "#a9a9a9",
    darkgreen: "#006400",
    darkgrey: "#a9a9a9",
    darkkhaki: "#bdb76b",
    darkmagenta: "#8b008b",
    darkolivegreen: "#556b2f",
    darkorange: "#ff8c00",
    darkorchid: "#9932cc",
    darkred: "#8b0000",
    darksalmon: "#e9967a",
    darkseagreen: "#8fbc8f",
    darkslateblue: "#483d8b",
    darkslategray: "#2f4f4f",
    darkslategrey: "#2f4f4f",
    darkturquoise: "#00ced1",
    darkviolet: "#9400d3",
    deeppink: "#ff1493",
    deepskyblue: "#00bfff",
    dimgray: "#696969",
    dimgrey: "#696969",
    dodgerblue: "#1e90ff",
    firebrick: "#b22222",
    floralwhite: "#fffaf0",
    forestgreen: "#228b22",
    fuchsia: "#ff00ff",
    gainsboro: "#dcdcdc",
    ghostwhite: "#f8f8ff",
    gold: "#ffd700",
    goldenrod: "#daa520",
    gray: "#808080",
    green: "#008000",
    greenyellow: "#adff2f",
    grey: "#808080",
    honeydew: "#f0fff0",
    hotpink: "#ff69b4",
    indianred: "#cd5c5c",
    indigo: "#4b0082",
    ivory: "#fffff0",
    khaki: "#f0e68c",
    lavender: "#e6e6fa",
    lavenderblush: "#fff0f5",
    lawngreen: "#7cfc00",
    lemonchiffon: "#fffacd",
    lightblue: "#add8e6",
    lightcoral: "#f08080",
    lightcyan: "#e0ffff",
    lightgoldenrodyellow: "#fafad2",
    lightgray: "#d3d3d3",
    lightgreen: "#90ee90",
    lightgrey: "#d3d3d3",
    lightpink: "#ffb6c1",
    lightsalmon: "#ffa07a",
    lightseagreen: "#20b2aa",
    lightskyblue: "#87cefa",
    lightslategray: "#778899",
    lightslategrey: "#778899",
    lightsteelblue: "#b0c4de",
    lightyellow: "#ffffe0",
    lime: "#00ff00",
    limegreen: "#32cd32",
    linen: "#faf0e6",
    magenta: "#ff00ff",
    maroon: "#800000",
    mediumaquamarine: "#66cdaa",
    mediumblue: "#0000cd",
    mediumorchid: "#ba55d3",
    mediumpurple: "#9370db",
    mediumseagreen: "#3cb371",
    mediumslateblue: "#7b68ee",
    mediumspringgreen: "#00fa9a",
    mediumturquoise: "#48d1cc",
    mediumvioletred: "#c71585",
    midnightblue: "#191970",
    mintcream: "#f5fffa",
    mistyrose: "#ffe4e1",
    moccasin: "#ffe4b5",
    navajowhite: "#ffdead",
    navy: "#000080",
    oldlace: "#fdf5e6",
    olive: "#808000",
    olivedrab: "#6b8e23",
    orange: "#ffa500",
    orangered: "#ff4500",
    orchid: "#da70d6",
    palegoldenrod: "#eee8aa",
    palegreen: "#98fb98",
    paleturquoise: "#afeeee",
    palevioletred: "#db7093",
    papayawhip: "#ffefd5",
    peachpuff: "#ffdab9",
    peru: "#cd853f",
    pink: "#ffc0cb",
    plum: "#dda0dd",
    powderblue: "#b0e0e6",
    purple: "#800080",
    red: "#ff0000",
    rosybrown: "#bc8f8f",
    royalblue: "#4169e1",
    saddlebrown: "#8b4513",
    salmon: "#fa8072",
    sandybrown: "#f4a460",
    seagreen: "#2e8b57",
    seashell: "#fff5ee",
    sienna: "#a0522d",
    silver: "#c0c0c0",
    skyblue: "#87ceeb",
    slateblue: "#6a5acd",
    slategray: "#708090",
    slategrey: "#708090",
    snow: "#fffafa",
    springgreen: "#00ff7f",
    steelblue: "#4682b4",
    tan: "#d2b48c",
    teal: "#008080",
    thistle: "#d8bfd8",
    tomato: "#ff6347",
    turquoise: "#40e0d0",
    violet: "#ee82ee",
    wheat: "#f5deb3",
    white: "#ffffff",
    whitesmoke: "#f5f5f5",
    yellow: "#ffff00",
    yellowgreen: "#9acd32",
    transparent: pv.Color.transparent = pv.rgb(0, 0, 0, 0)
};

!function() {
    var names = pv.Color.names;
    names.none = names.transparent;
    for (var name in names)
        names[name] = pv.color(names[name]);
}();

pv.colors = function() {
    var scale = pv.Scale.ordinal();
    scale.range.apply(scale, arguments);
    return scale;
}
;

pv.Colors = {};

pv.Colors.category10 = function() {
    var scale = pv.colors("#1f77b4", "#ff7f0e", "#2ca02c", "#d62728", "#9467bd", "#8c564b", "#e377c2", "#7f7f7f", "#bcbd22", "#17becf");
    scale.domain.apply(scale, arguments);
    return scale;
}
;

pv.Colors.category20 = function() {
    var scale = pv.colors("#1f77b4", "#aec7e8", "#ff7f0e", "#ffbb78", "#2ca02c", "#98df8a", "#d62728", "#ff9896", "#9467bd", "#c5b0d5", "#8c564b", "#c49c94", "#e377c2", "#f7b6d2", "#7f7f7f", "#c7c7c7", "#bcbd22", "#dbdb8d", "#17becf", "#9edae5");
    scale.domain.apply(scale, arguments);
    return scale;
}
;

pv.Colors.category19 = function() {
    var scale = pv.colors("#9c9ede", "#7375b5", "#4a5584", "#cedb9c", "#b5cf6b", "#8ca252", "#637939", "#e7cb94", "#e7ba52", "#bd9e39", "#8c6d31", "#e7969c", "#d6616b", "#ad494a", "#843c39", "#de9ed6", "#ce6dbd", "#a55194", "#7b4173");
    scale.domain.apply(scale, arguments);
    return scale;
}
;

!function() {
    function parseLinearGradient(text) {
        var terms = parseText(text);
        if (!terms.length)
            return null;
        var keyAngle, m, f, angle = Math.PI, term = terms[0];
        if (0 === term.indexOf("to ")) {
            m = /^to\s+(?:((top|bottom)(?:\s+(left|right))?)|((left|right)(?:\\s+(top|bottom))?))$/.exec(term);
            if (m) {
                if (m[1]) {
                    keyAngle = m[2];
                    m[3] && (keyAngle += " " + m[3]);
                } else {
                    keyAngle = m[5];
                    m[6] && (keyAngle = m[6] + " " + keyAngle);
                }
                angle = pv.radians(keyAnglesDeg[keyAngle]);
                terms.shift();
            }
        } else {
            f = parseFloat(term);
            if (!isNaN(f)) {
                angle = f;
                /^.*?deg$/.test(term) && (angle = pv.radians(angle));
                terms.shift();
            }
        }
        var stops = parseStops(terms);
        switch (stops.length) {
        case 0:
            return null;

        case 1:
            return new pv.FillStyle.Solid(stops[0].color,1);
        }
        return new pv.FillStyle.LinearGradient(angle,stops,text);
    }
    function parseRadialGradient(text) {
        var terms = parseText(text);
        if (!terms.length)
            return null;
        var stops = parseStops(terms);
        switch (stops.length) {
        case 0:
            return null;

        case 1:
            return new pv.FillStyle.Solid(stops[0].color,1);
        }
        return new pv.FillStyle.RadialGradient(50,50,stops,text);
    }
    function parseText(text) {
        var colorFuns = {}
          , colorFunId = 0;
        text = text.replace(/\b\w+?\(.*?\)/g, function($0) {
            var id = "__color" + colorFunId++;
            colorFuns[id] = $0;
            return id;
        });
        var terms = text.split(/\s*,\s*/);
        if (!terms.length)
            return null;
        colorFunId && terms.forEach(function(id, index) {
            colorFuns.hasOwnProperty(id) && (terms[index] = colorFuns[id]);
        });
        return terms;
    }
    function parseStops(terms) {
        function processPendingStops(lastOffset) {
            var count = pendingOffsetStops.length;
            if (count) {
                for (var firstOffset = maxOffsetPercent, step = (lastOffset - firstOffset) / (count + 1), i = 0; count > i; i++) {
                    firstOffset += step;
                    pendingOffsetStops[i].offset = firstOffset;
                }
                pendingOffsetStops.length = 0;
            }
        }
        for (var stops = [], minOffsetPercent = +(1 / 0), maxOffsetPercent = -(1 / 0), pendingOffsetStops = [], i = 0, T = terms.length; T > i; ) {
            var term = terms[i++]
              , m = /^(.+?)\s*([+\-]?[e\.\d]+%)?$/i.exec(term);
            if (m) {
                var stop = {
                    color: pv.color(m[1])
                }
                  , offsetPercent = parseFloat(m[2]);
                isNaN(offsetPercent) && (stops.length ? i === T && (offsetPercent = Math.max(maxOffsetPercent, 100)) : offsetPercent = 0);
                stops.push(stop);
                if (isNaN(offsetPercent))
                    pendingOffsetStops.push(stop);
                else {
                    stop.offset = offsetPercent;
                    processPendingStops(offsetPercent);
                    offsetPercent > maxOffsetPercent ? maxOffsetPercent = offsetPercent : maxOffsetPercent > offsetPercent && (offsetPercent = maxOffsetPercent);
                    minOffsetPercent > offsetPercent && (minOffsetPercent = offsetPercent);
                }
            }
        }
        if (stops.length >= 2 && (0 > minOffsetPercent || maxOffsetPercent > 100)) {
            var colorDomain = []
              , colorRange = [];
            stops.forEach(function(stop) {
                colorDomain.push(stop.offset);
                colorRange.push(stop.color);
            });
            var colorScale = pv.scale.linear().domain(colorDomain).range(colorRange);
            if (0 > minOffsetPercent) {
                for (; stops.length && stops[0].offset <= 0; )
                    stops.shift();
                stops.unshift({
                    offset: 0,
                    color: colorScale(0)
                });
            }
            if (maxOffsetPercent > 100) {
                for (; stops.length && stops[stops.length - 1].offset >= 100; )
                    stops.pop();
                stops.push({
                    offset: 100,
                    color: colorScale(100)
                });
            }
        }
        return stops;
    }
    pv.fillStyle = function(format) {
        if (format.type)
            return format;
        var k = format.key || format
          , fillStyle = fillStylesByKey[k];
        fillStyle = fillStyle ? fillStyle.clone() : fillStylesByKey[k] = createFillStyle(format);
        return fillStyle;
    }
    ;
    var fillStylesByKey = {}
      , createFillStyle = function(format) {
        if (format.rgb)
            return new pv.FillStyle.Solid(format.color,format.opacity);
        var match = /^\s*([a-z\-]+)\(\s*(.*?)\s*\)\s*$/.exec(format);
        if (match)
            switch (match[1]) {
            case "linear-gradient":
                return parseLinearGradient(match[2]);

            case "radial-gradient":
                return parseRadialGradient(match[2]);
            }
        return new pv.FillStyle.Solid(pv.color(format));
    }
      , keyAnglesDeg = {
        top: 0,
        "top right": 45,
        right: 90,
        "bottom right": 135,
        bottom: 180,
        "bottom left": 225,
        left: 270,
        "top left": 315
    }
      , FillStyle = pv.FillStyle = function(type) {
        this.type = type;
        this.key = type;
    }
    ;
    pv.extendType(FillStyle, new pv.Color("none",1));
    FillStyle.prototype.rgb = function() {
        var color = pv.color(this.color);
        this.opacity !== color.opacity && (color = color.alpha(this.opacity));
        return color;
    }
    ;
    FillStyle.prototype.alphaBlend = function(mate) {
        return this.rgb().alphaBlend(mate);
    }
    ;
    FillStyle.prototype.rgbDecimal = function(mate) {
        return this.rgb().rgbDecimal(mate);
    }
    ;
    FillStyle.prototype.isDark = function() {
        return this.rgb().isDark();
    }
    ;
    var Solid = pv.FillStyle.Solid = function(color, opacity) {
        FillStyle.call(this, "solid");
        if (color.rgb) {
            this.color = color.color;
            this.opacity = color.opacity;
        } else {
            this.color = color;
            this.opacity = opacity;
        }
        this.key += " " + this.color + " alpha(" + this.opacity + ")";
    }
    ;
    pv.extendType(Solid, FillStyle);
    Solid.prototype.alpha = function(opacity) {
        return new Solid(this.color,opacity);
    }
    ;
    Solid.prototype.brighter = function(k) {
        return new Solid(this.rgb().brighter(k));
    }
    ;
    Solid.prototype.darker = function(k) {
        return new Solid(this.rgb().darker(k));
    }
    ;
    Solid.prototype.complementary = function() {
        return new Solid(this.rgb().complementary());
    }
    ;
    Solid.prototype.clone = function() {
        var o = pv.extend(Solid);
        o.type = this.type;
        o.key = this.key;
        o.color = this.color;
        o.opacity = this.opacity;
        return o;
    }
    ;
    pv.FillStyle.transparent = new Solid(pv.Color.transparent);
    var gradient_id = 0
      , Gradient = pv.FillStyle.Gradient = function(type, stops) {
        FillStyle.call(this, type);
        this.id = ++gradient_id;
        this.stops = stops;
        stops.length && (this.color = stops[0].color.color);
        this.key += " stops(" + stops.map(function(stop) {
            var color = stop.color;
            return color.color + " alpha(" + color.opacity + ") at(" + stop.offset + ")";
        }).join(", ") + ")";
    }
    ;
    pv.extendType(Gradient, FillStyle);
    Gradient.prototype.rgb = function() {
        return this.stops.length ? this.stops[0].color : void 0;
    }
    ;
    Gradient.prototype.alpha = function(opacity) {
        return this._cloneWithStops(this.stops.map(function(stop) {
            return {
                offset: stop.offset,
                color: stop.color.alpha(opacity)
            };
        }));
    }
    ;
    Gradient.prototype.darker = function(k) {
        return this._cloneWithStops(this.stops.map(function(stop) {
            return {
                offset: stop.offset,
                color: stop.color.darker(k)
            };
        }));
    }
    ;
    Gradient.prototype.brighter = function(k) {
        return this._cloneWithStops(this.stops.map(function(stop) {
            return {
                offset: stop.offset,
                color: stop.color.brighter(k)
            };
        }));
    }
    ;
    Gradient.prototype.complementary = function() {
        return this._cloneWithStops(this.stops.map(function(stop) {
            return {
                offset: stop.offset,
                color: stop.color.complementary()
            };
        }));
    }
    ;
    Gradient.prototype.alphaBlend = function(mate) {
        return this._cloneWithStops(this.stops.map(function(stop) {
            return {
                offset: stop.offset,
                color: stop.color.alphaBlend(mate)
            };
        }));
    }
    ;
    Gradient.prototype.clone = function() {
        var Type = this.constructor
          , o = pv.extend(Type);
        o.constructor = Type;
        o.id = ++gradient_id;
        o.type = this.type;
        o.key = this.key;
        var stops = this.stops;
        o.stops = stops;
        stops.length && (o.color = stops[0].color.color);
        this._initClone(o);
        return o;
    }
    ;
    var LinearGradient = pv.FillStyle.LinearGradient = function(angle, stops) {
        Gradient.call(this, "lineargradient", stops);
        this.angle = angle;
        this.key += " angle(" + angle + ")";
    }
    ;
    pv.extendType(LinearGradient, Gradient);
    LinearGradient.prototype._cloneWithStops = function(stops) {
        return new LinearGradient(this.angle,stops);
    }
    ;
    LinearGradient.prototype._initClone = function(o) {
        o.angle = this.angle;
    }
    ;
    var RadialGradient = pv.FillStyle.RadialGradient = function(cx, cy, stops) {
        Gradient.call(this, "radialgradient", stops);
        this.cx = cx;
        this.cy = cy;
        this.key += " center(" + cx + "," + cy + ")";
    }
    ;
    pv.extendType(RadialGradient, Gradient);
    RadialGradient.prototype._cloneWithStops = function(stops) {
        return new RadialGradient(this.cx,this.cy,stops);
    }
    ;
    RadialGradient.prototype._initClone = function(o) {
        o.cx = this.cx;
        o.cy = this.cy;
    }
    ;
}();

pv.ramp = function(start, end) {
    var scale = pv.Scale.linear();
    scale.range.apply(scale, arguments);
    return scale;
}
;

pv.Scene = pv.SvgScene = {
    svg: "http://www.w3.org/2000/svg",
    xmlns: "http://www.w3.org/2000/xmlns",
    xlink: "http://www.w3.org/1999/xlink",
    xhtml: "http://www.w3.org/1999/xhtml",
    scale: 1,
    events: ["DOMMouseScroll", "mousewheel", "mousedown", "mouseup", "mouseover", "mouseout", "mousemove", "click", "dblclick", "contextmenu"],
    mousePositionEventSet: {
        mousedown: 1,
        mouseup: 1,
        mouseover: 1,
        mouseout: 1,
        mousemove: 1,
        click: 1,
        dblclick: 1,
        contextmenu: 1
    },
    implicit: {
        svg: {
            "shape-rendering": "auto",
            "pointer-events": "painted",
            x: 0,
            y: 0,
            dy: 0,
            "text-anchor": "start",
            transform: "translate(0,0)",
            fill: "none",
            "fill-opacity": 1,
            stroke: "none",
            "stroke-opacity": 1,
            "stroke-width": 1.5,
            "stroke-linejoin": "miter",
            "stroke-linecap": "butt",
            "stroke-miterlimit": 8,
            "stroke-dasharray": "none"
        },
        css: {
            font: "10px sans-serif"
        }
    }
};

pv.SvgScene.updateAll = function(scenes) {
    if (scenes.length && scenes[0].reverse && "line" !== scenes.type && "area" !== scenes.type) {
        for (var reversed = Object.create(scenes), i = 0, j = scenes.length - 1; j >= 0; i++,
        j--)
            reversed[i] = scenes[j];
        scenes = reversed;
    }
    this.removeSiblings(this[scenes.type](scenes));
}
;

pv.SvgScene.create = function(type) {
    return document.createElementNS(this.svg, type);
}
;

pv.SvgScene.expect = function(e, type, scenes, i, attributes, style) {
    var tagName;
    if (e) {
        tagName = e.tagName;
        if ("defs" === tagName) {
            e = e.nextSibling;
            e && (tagName = e.tagName);
        } else
            "a" === tagName && (e = e.firstChild);
    }
    if (e) {
        if (tagName !== type) {
            var n = this.create(type);
            e.parentNode.replaceChild(n, e);
            e = n;
        }
    } else
        e = this.create(type);
    attributes && this.setAttributes(e, attributes);
    style && this.setStyle(e, style);
    return e;
}
;

pv.SvgScene.setAttributes = function(e, attributes) {
    var implicitSvg = this.implicit.svg
      , prevAttrs = e.__attributes__;
    prevAttrs === attributes && (prevAttrs = null);
    for (var name in attributes) {
        var value = attributes[name];
        prevAttrs && value === prevAttrs[name] || (null == value || value == implicitSvg[name] ? e.removeAttribute(name) : e.setAttribute(name, value));
    }
    e.__attributes__ = attributes;
}
;

pv.SvgScene.setStyle = function(e, style) {
    var implicitCss = this.implicit.css
      , prevStyle = e.__style__;
    prevStyle === style && (prevStyle = null);
    for (var name in style) {
        var value = style[name];
        prevStyle && value === prevStyle[name] || (null == value || value == implicitCss[name] ? e.style.removeProperty(name) : e.style[name] = value);
    }
    e.__style__ = style;
}
;

pv.SvgScene.append = function(e, scenes, index) {
    e.$scene = {
        scenes: scenes,
        index: index
    };
    e = this.title(e, scenes[index]);
    e.parentNode || scenes.$g.appendChild(e);
    return e.nextSibling;
}
;

pv.SvgScene.title = function(e, s) {
    var a = e.parentNode;
    a && "a" != a.tagName && (a = null);
    if (s.title) {
        if (!a) {
            a = this.create("a");
            a.setAttributeNS(this.xlink, "xlink:href", "");
            e.parentNode && e.parentNode.replaceChild(a, e);
            a.appendChild(e);
        }
        a.setAttributeNS(this.xlink, "xlink:title", s.title);
        for (var t = null, c = e.firstChild; null != c; c = c.nextSibling)
            if ("title" == c.nodeName) {
                t = c;
                break;
            }
        if (t)
            t.removeChild(t.firstChild);
        else {
            t = this.create("title");
            e.appendChild(t);
        }
        t.appendChild(document.createTextNode(s.title));
        return a;
    }
    a && a.parentNode.replaceChild(e, a);
    return e;
}
;

pv.SvgScene.dispatch = pv.listener(function(e) {
    var t = e.target.$scene;
    if (t) {
        var type = e.type;
        switch (type) {
        case "DOMMouseScroll":
            type = "mousewheel";
            e.wheel = -480 * e.detail;
            break;

        case "mousewheel":
            e.wheel = (window.opera ? 12 : 1) * e.wheelDelta;
        }
        if (pv.Mark.dispatch(type, t.scenes, t.index, e)) {
            e.preventDefault();
            e.stopPropagation();
        }
    }
});

pv.SvgScene.removeSiblings = function(e) {
    for (; e; ) {
        var n = e.nextSibling;
        "defs" !== e.nodeName && e.parentNode.removeChild(e);
        e = n;
    }
}
;

pv.SvgScene.undefined = function() {}
;

!function() {
    var dashAliasMap = {
        "-": "shortdash",
        ".": "shortdot",
        "-.": "shortdashdot",
        "-..": "shortdashdotdot",
        ". ": "dot",
        "- ": "dash",
        "--": "longdash",
        "- .": "dashdot",
        "--.": "longdashdot",
        "--..": "longdashdotdot"
    }
      , dashMap = {
        shortdash: [3, 1],
        shortdot: [1, 1],
        shortdashdot: [3, 1, 1, 1],
        shortdashdotdot: [3, 1, 1, 1, 1, 1],
        dot: [1, 3],
        dash: [4, 3],
        longdash: [8, 3],
        dashdot: [4, 3, 1, 3],
        longdashdot: [8, 3, 1, 3],
        longdashdotdot: [8, 3, 1, 3, 1, 3]
    };
    pv.SvgScene.isStandardDashStyle = function(dashArray) {
        return dashMap.hasOwnProperty(dashArray);
    }
    ;
    pv.SvgScene.translateDashStyleAlias = function(dashArray) {
        return dashAliasMap.hasOwnProperty(dashArray) ? dashAliasMap[dashArray] : dashArray;
    }
    ;
    pv.SvgScene.parseDasharray = function(s) {
        var dashArray = s.strokeDasharray;
        if (dashArray && "none" !== dashArray) {
            dashArray = this.translateDashStyleAlias(dashArray);
            var standardDashArray = dashMap[dashArray];
            dashArray = standardDashArray ? standardDashArray : dashArray.split(/[\s,]+/);
            var lineWidth = s.lineWidth
              , lineCap = s.lineCap || "butt"
              , isButtCap = "butt" === lineCap;
            dashArray = dashArray.map(function(num, index) {
                num = +num;
                isButtCap || (index % 2 ? num++ : num -= 1);
                0 >= num && (num = .001);
                return num * lineWidth / this.scale;
            }, this).join(" ");
        } else
            dashArray = null;
        return dashArray;
    }
    ;
}();

!function() {
    var reTestUrlColor = /^url\(#/
      , next_gradient_id = 1
      , pi2 = Math.PI / 2
      , pi4 = pi2 / 2
      , sqrt22 = Math.SQRT2 / 2
      , abs = Math.abs
      , sin = Math.sin
      , cos = Math.cos
      , zr = function(x) {
        return abs(x) <= 1e-12 ? 0 : x;
    };
    pv.SvgScene.addFillStyleDefinition = function(scenes, fill) {
        if (fill.type && "solid" !== fill.type && !reTestUrlColor.test(fill.color)) {
            var rootMark = scenes.mark.root
              , fillStyleMap = rootMark.__fillStyleMap__ || (rootMark.__fillStyleMap__ = {})
              , k = fill.key
              , instId = fillStyleMap[k];
            if (!instId) {
                instId = fillStyleMap[k] = "__pvGradient" + next_gradient_id++;
                var elem = createGradientDef.call(this, scenes, fill, instId);
                rootMark.scene.$defs.appendChild(elem);
            }
            fill.color = "url(#" + instId + ")";
        }
    }
    ;
    var createGradientDef = function(scenes, fill, instId) {
        var isLinear = "lineargradient" === fill.type
          , elem = this.create(isLinear ? "linearGradient" : "radialGradient");
        elem.setAttribute("id", instId);
        if (isLinear) {
            var svgAngle = fill.angle - pi2
              , diagAngle = abs(svgAngle % pi2) - pi4
              , r = abs(sqrt22 * cos(diagAngle))
              , dirx = r * cos(svgAngle)
              , diry = r * sin(svgAngle);
            elem.setAttribute("x1", zr(.5 - dirx));
            elem.setAttribute("y1", zr(.5 - diry));
            elem.setAttribute("x2", zr(.5 + dirx));
            elem.setAttribute("y2", zr(.5 + diry));
        }
        for (var stops = fill.stops, S = stops.length, i = 0; S > i; i++) {
            var stop = stops[i]
              , stopElem = elem.appendChild(this.create("stop"))
              , color = stop.color;
            stopElem.setAttribute("offset", stop.offset + "%");
            stopElem.setAttribute("stop-color", color.color);
            stopElem.setAttribute("stop-opacity", color.opacity + "");
        }
        return elem;
    };
}();

pv.SvgScene.pathBasis = function() {
    function weight(w, p0, p1, p2, p3) {
        return {
            x: w[0] * p0.left + w[1] * p1.left + w[2] * p2.left + w[3] * p3.left,
            y: w[0] * p0.top + w[1] * p1.top + w[2] * p2.top + w[3] * p3.top
        };
    }
    var basis = [[1 / 6, 2 / 3, 1 / 6, 0], [0, 2 / 3, 1 / 3, 0], [0, 1 / 3, 2 / 3, 0], [0, 1 / 6, 2 / 3, 1 / 6]]
      , convert = function(p0, p1, p2, p3) {
        var b1 = weight(basis[1], p0, p1, p2, p3)
          , b2 = weight(basis[2], p0, p1, p2, p3)
          , b3 = weight(basis[3], p0, p1, p2, p3);
        return "C" + b1.x + "," + b1.y + "," + b2.x + "," + b2.y + "," + b3.x + "," + b3.y;
    };
    convert.segment = function(p0, p1, p2, p3) {
        var b0 = weight(basis[0], p0, p1, p2, p3)
          , b1 = weight(basis[1], p0, p1, p2, p3)
          , b2 = weight(basis[2], p0, p1, p2, p3)
          , b3 = weight(basis[3], p0, p1, p2, p3);
        return ["M" + b0.x + "," + b0.y, "C" + b1.x + "," + b1.y + "," + b2.x + "," + b2.y + "," + b3.x + "," + b3.y];
    }
    ;
    return convert;
}();

pv.SvgScene.curveBasis = function(points, from, to) {
    var L;
    if (null == from) {
        L = points.length;
        from = 0;
        to = L - 1;
    } else
        L = to - from + 1;
    if (2 >= L)
        return "";
    var path = ""
      , p0 = points[from]
      , p1 = p0
      , p2 = p0
      , p3 = points[from + 1];
    path += this.pathBasis(p0, p1, p2, p3);
    for (var i = from + 2; to >= i; i++) {
        p0 = p1;
        p1 = p2;
        p2 = p3;
        p3 = points[i];
        path += this.pathBasis(p0, p1, p2, p3);
    }
    path += this.pathBasis(p1, p2, p3, p3);
    path += this.pathBasis(p2, p3, p3, p3);
    return path;
}
;

pv.SvgScene.curveBasisSegments = function(points, from, to) {
    var L;
    if (null == from) {
        L = points.length;
        from = 0;
        to = L - 1;
    } else
        L = to - from + 1;
    if (2 >= L)
        return "";
    var paths = []
      , p0 = points[from]
      , p1 = p0
      , p2 = p0
      , p3 = points[from + 1]
      , firstPath = this.pathBasis.segment(p0, p1, p2, p3);
    p0 = p1;
    p1 = p2;
    p2 = p3;
    p3 = points[from + 2];
    firstPath[1] += this.pathBasis(p0, p1, p2, p3);
    paths.push(firstPath);
    for (var i = from + 3; to >= i; i++) {
        p0 = p1;
        p1 = p2;
        p2 = p3;
        p3 = points[i];
        paths.push(this.pathBasis.segment(p0, p1, p2, p3));
    }
    var lastPath = this.pathBasis.segment(p1, p2, p3, p3);
    lastPath[1] += this.pathBasis(p2, p3, p3, p3);
    paths.push(lastPath);
    return paths;
}
;

pv.SvgScene.curveHermite = function(points, tangents, from, to) {
    var L;
    if (null == from) {
        L = points.length;
        from = 0;
        to = L - 1;
    } else
        L = to - from + 1;
    var T = tangents.length;
    if (1 > T || L !== T && L !== T + 2)
        return "";
    var quad = L !== T
      , path = ""
      , p0 = points[from]
      , p = points[from + 1]
      , t0 = tangents[0]
      , t = t0
      , pi = from + 1;
    if (quad) {
        path += "Q" + (p.left - 2 * t0.x / 3) + "," + (p.top - 2 * t0.y / 3) + "," + p.left + "," + p.top;
        p0 = points[from + 1];
        pi = from + 2;
    }
    if (T > 1) {
        t = tangents[1];
        p = points[pi];
        pi++;
        path += "C" + (p0.left + t0.x) + "," + (p0.top + t0.y) + "," + (p.left - t.x) + "," + (p.top - t.y) + "," + p.left + "," + p.top;
        for (var i = 2; T > i; i++,
        pi++) {
            p = points[pi];
            t = tangents[i];
            path += "S" + (p.left - t.x) + "," + (p.top - t.y) + "," + p.left + "," + p.top;
        }
    }
    if (quad) {
        var lp = points[pi];
        path += "Q" + (p.left + 2 * t.x / 3) + "," + (p.top + 2 * t.y / 3) + "," + lp.left + "," + lp.top;
    }
    return path;
}
;

pv.SvgScene.curveHermiteSegments = function(points, tangents, from, to) {
    var L;
    if (null == from) {
        L = points.length;
        from = 0;
        to = L - 1;
    } else
        L = to - from + 1;
    var T = tangents.length;
    if (1 > T || L !== T && L !== T + 2)
        return [];
    var quad = L !== T
      , paths = []
      , p0 = points[from]
      , p = p0
      , t0 = tangents[0]
      , t = t0
      , pi = from + 1;
    if (quad) {
        p = points[from + 1];
        paths.push(["M" + p0.left + "," + p0.top, "Q" + (p.left - 2 * t.x / 3) + "," + (p.top - 2 * t.y / 3) + "," + p.left + "," + p.top]);
        pi = from + 2;
    }
    for (var i = 1; T > i; i++,
    pi++) {
        p0 = p;
        t0 = t;
        p = points[pi];
        t = tangents[i];
        paths.push(["M" + p0.left + "," + p0.top, "C" + (p0.left + t0.x) + "," + (p0.top + t0.y) + "," + (p.left - t.x) + "," + (p.top - t.y) + "," + p.left + "," + p.top]);
    }
    if (quad) {
        var lp = points[pi];
        paths.push(["M" + p.left + "," + p.top, "Q" + (p.left + 2 * t.x / 3) + "," + (p.top + 2 * t.y / 3) + "," + lp.left + "," + lp.top]);
    }
    return paths;
}
;

pv.SvgScene.cardinalTangents = function(points, tension, from, to) {
    var L;
    if (null == from) {
        L = points.length;
        from = 0;
        to = L - 1;
    } else
        L = to - from + 1;
    for (var tangents = [], a = (1 - tension) / 2, p0 = points[from], p1 = points[from + 1], p2 = points[from + 2], i = from + 3; to >= i; i++) {
        tangents.push({
            x: a * (p2.left - p0.left),
            y: a * (p2.top - p0.top)
        });
        p0 = p1;
        p1 = p2;
        p2 = points[i];
    }
    tangents.push({
        x: a * (p2.left - p0.left),
        y: a * (p2.top - p0.top)
    });
    return tangents;
}
;

pv.SvgScene.curveCardinal = function(points, tension, from, to) {
    var L;
    if (null == from) {
        L = points.length;
        from = 0;
        to = L - 1;
    } else
        L = to - from + 1;
    return 2 >= L ? "" : this.curveHermite(points, this.cardinalTangents(points, tension, from, to), from, to);
}
;

pv.SvgScene.curveCardinalSegments = function(points, tension, from, to) {
    var L;
    if (null == from) {
        L = points.length;
        from = 0;
        to = L - 1;
    } else
        L = to - from + 1;
    return 2 >= L ? "" : this.curveHermiteSegments(points, this.cardinalTangents(points, tension, from, to), from, to);
}
;

pv.SvgScene.monotoneTangents = function(points, from, to) {
    var L;
    if (null == from) {
        L = points.length;
        from = 0;
        to = L - 1;
    } else
        L = to - from + 1;
    var j, tangents = [], d = [], m = [], dx = [], k = 0;
    for (k = 0; L - 1 > k; k++) {
        j = from + k;
        var den = points[j + 1].left - points[j].left;
        d[k] = Math.abs(den) <= 1e-12 ? 0 : (points[j + 1].top - points[j].top) / den;
    }
    m[0] = d[0];
    dx[0] = points[from + 1].left - points[from].left;
    for (k = 1,
    j = from + k; L - 1 > k; k++,
    j++) {
        m[k] = (d[k - 1] + d[k]) / 2;
        dx[k] = (points[j + 1].left - points[j - 1].left) / 2;
    }
    m[k] = d[k - 1];
    dx[k] = points[j].left - points[j - 1].left;
    for (k = 0; L - 1 > k; k++)
        if (0 == d[k]) {
            m[k] = 0;
            m[k + 1] = 0;
        }
    for (k = 0; L - 1 > k; k++)
        if (!(Math.abs(m[k]) < 1e-5 || Math.abs(m[k + 1]) < 1e-5)) {
            var ak = m[k] / d[k]
              , bk = m[k + 1] / d[k]
              , s = ak * ak + bk * bk;
            if (s > 9) {
                var tk = 3 / Math.sqrt(s);
                m[k] = tk * ak * d[k];
                m[k + 1] = tk * bk * d[k];
            }
        }
    for (var len, i = 0; L > i; i++) {
        len = 1 + m[i] * m[i];
        tangents.push({
            x: dx[i] / 3 / len,
            y: m[i] * dx[i] / 3 / len
        });
    }
    return tangents;
}
;

pv.SvgScene.curveMonotone = function(points, from, to) {
    var L;
    if (null == from) {
        L = points.length;
        from = 0;
        to = L - 1;
    } else
        L = to - from + 1;
    return 2 >= L ? "" : this.curveHermite(points, this.monotoneTangents(points, from, to), from, to);
}
;

pv.SvgScene.curveMonotoneSegments = function(points, from, to) {
    var L;
    if (null == from) {
        L = points.length;
        from = 0;
        to = L - 1;
    } else
        L = to - from + 1;
    return 2 >= L ? "" : this.curveHermiteSegments(points, this.monotoneTangents(points, from, to), from, to);
}
;

pv.SvgScene.area = function(scenes) {
    var e = scenes.$g.firstChild
      , count = scenes.length;
    if (!count)
        return e;
    var s = scenes[0];
    return "smart" === s.segmented ? this.areaSegmentedSmart(e, scenes) : s.segmented ? this.areaSegmentedFull(e, scenes) : this.areaFixed(e, scenes, 0, count - 1, !0);
}
;

pv.SvgScene.areaFixed = function(elm, scenes, from, to, addEvents) {
    var count = to - from + 1;
    if (1 === count)
        return this.lineAreaDotAlone(elm, scenes, from);
    var s = scenes[from];
    if (!s.visible)
        return elm;
    var fill = s.fillStyle
      , stroke = s.strokeStyle;
    if (!fill.opacity && !stroke.opacity)
        return elm;
    this.addFillStyleDefinition(scenes, fill);
    this.addFillStyleDefinition(scenes, stroke);
    var isInterpBasis = !1
      , isInterpCardinal = !1
      , isInterpMonotone = !1
      , isInterpStepAfter = !1
      , isInterpStepBefore = !1;
    switch (s.interpolate) {
    case "basis":
        isInterpBasis = !0;
        break;

    case "cardinal":
        isInterpCardinal = !0;
        break;

    case "monotone":
        isInterpMonotone = !0;
        break;

    case "step-after":
        isInterpStepAfter = !0;
        break;

    case "step-before":
        isInterpStepBefore = !0;
    }
    for (var si, sj, isInterpBasisCardinalOrMonotone = isInterpBasis || isInterpCardinal || isInterpMonotone, d = [], i = from; to >= i; i++) {
        si = scenes[i];
        if (si.width || si.height) {
            for (var j = i + 1; to >= j; j++) {
                sj = scenes[j];
                if (!sj.width && !sj.height)
                    break;
            }
            i > from && !isInterpStepAfter && i--;
            to >= j && !isInterpStepBefore && j++;
            var fun = isInterpBasisCardinalOrMonotone && j - i > 2 ? this.areaPathCurve : this.areaPathStraight;
            d.push(fun.call(this, scenes, i, j - 1, s));
            i = j - 1;
        }
    }
    if (!d.length)
        return elm;
    var sop = stroke.opacity;
    elm = this.expect(elm, "path", scenes, from, {
        "shape-rendering": s.antialias ? null : "crispEdges",
        "pointer-events": addEvents ? s.events : "none",
        cursor: s.cursor,
        d: "M" + d.join("ZM") + "Z",
        fill: fill.color,
        "fill-opacity": fill.opacity || null,
        stroke: stroke.color,
        "stroke-opacity": sop || null,
        "stroke-width": sop ? s.lineWidth / this.scale : null,
        "stroke-linecap": s.lineCap,
        "stroke-linejoin": s.lineJoin,
        "stroke-miterlimit": s.strokeMiterLimit,
        "stroke-dasharray": sop ? this.parseDasharray(s) : null
    });
    s.svg && this.setAttributes(elm, s.svg);
    s.css && this.setStyle(elm, s.css);
    return this.append(elm, scenes, from);
}
;

pv.SvgScene.areaSegmentedSmart = function(elm, scenes) {
    return this.eachLineAreaSegment(elm, scenes, function(elm, scenes, from, to) {
        var segment = this.areaSegmentPaths(scenes, from, to)
          , pathsT = segment.top
          , pathsB = segment.bottom
          , fromp = from
          , options = {
            breakOnKeyChange: !0,
            from: from,
            to: to
        };
        return this.eachLineAreaSegment(elm, scenes, options, function(elm, scenes, from, to, ka, eventsMax) {
            var s1 = scenes[from]
              , fill = s1.fillStyle
              , stroke = s1.strokeStyle;
            this.addFillStyleDefinition(scenes, fill);
            this.addFillStyleDefinition(scenes, stroke);
            if (from === to)
                return this.lineAreaDotAlone(elm, scenes, from);
            var d = this.areaJoinPaths(pathsT, pathsB, from - fromp, to - fromp - 1)
              , sop = stroke.opacity
              , attrs = {
                "shape-rendering": s1.antialias ? null : "crispEdges",
                "pointer-events": eventsMax,
                cursor: s1.cursor,
                d: d,
                fill: fill.color,
                "fill-opacity": fill.opacity || null,
                stroke: stroke.color,
                "stroke-opacity": sop || null,
                "stroke-width": sop ? s1.lineWidth / this.scale : null,
                "stroke-linecap": s1.lineCap,
                "stroke-linejoin": s1.lineJoin,
                "stroke-miterlimit": s1.strokeMiterLimit,
                "stroke-dasharray": sop ? this.parseDasharray(s1) : null
            };
            elm = this.expect(elm, "path", scenes, from, attrs, s1.css);
            return this.append(elm, scenes, from);
        });
    });
}
;

pv.SvgScene.areaSegmentPaths = function(scenes, from, to) {
    return this.areaSegmentCurvePaths(scenes, from, to) || this.areaSegmentStraightPaths(scenes, from, to);
}
;

pv.SvgScene.areaSegmentCurvePaths = function(scenes, from, to) {
    var count = to - from + 1
      , s = scenes[from]
      , isBasis = "basis" === s.interpolate
      , isCardinal = !isBasis && "cardinal" === s.interpolate;
    if (isBasis || isCardinal || "monotone" == s.interpolate) {
        for (var pointsT = [], pointsB = [], i = 0; count > i; i++) {
            var si = scenes[from + i]
              , sj = scenes[to - i];
            pointsT.push(si);
            pointsB.push({
                left: sj.left + sj.width,
                top: sj.top + sj.height
            });
        }
        var pathsT, pathsB;
        if (isBasis) {
            pathsT = this.curveBasisSegments(pointsT);
            pathsB = this.curveBasisSegments(pointsB);
        } else if (isCardinal) {
            pathsT = this.curveCardinalSegments(pointsT, s.tension);
            pathsB = this.curveCardinalSegments(pointsB, s.tension);
        } else {
            pathsT = this.curveMonotoneSegments(pointsT);
            pathsB = this.curveMonotoneSegments(pointsB);
        }
        if (pathsT || pathsT.length)
            return {
                from: from,
                top: pathsT,
                bottom: pathsB
            };
    }
}
;

pv.SvgScene.areaSegmentStraightPaths = function(scenes, i, j) {
    for (var pathsT = [], pathsB = [], k = j, m = i; k > i; i++,
    j--) {
        var si = scenes[i]
          , sj = scenes[j]
          , pi = ["M" + si.left + "," + si.top]
          , pj = ["M" + (sj.left + sj.width) + "," + (sj.top + sj.height)]
          , sk = scenes[i + 1]
          , sl = scenes[j - 1];
        switch (si.interpolate) {
        case "step-before":
            pi.push("V" + sk.top + "H" + sk.left);
            break;

        case "step-after":
            pi.push("H" + sk.left + "V" + sk.top);
            break;

        default:
            pi.push("L" + sk.left + "," + sk.top);
        }
        pj.push("L" + (sl.left + sl.width) + "," + (sl.top + sl.height));
        pathsT.push(pi);
        pathsB.push(pj);
    }
    return {
        from: m,
        top: pathsT,
        bottom: pathsB
    };
}
;

pv.SvgScene.areaJoinPaths = function(pathsT, pathsB, i, j) {
    for (var fullPathT = "", fullPathB = "", N = pathsT.length, k = i, l = N - 1 - j; j >= k; k++,
    l++) {
        var dT, dB, pathT = pathsT[k], pathB = pathsB[l];
        if (k === i) {
            dT = pathT.join("");
            dB = "L" + pathB[0].substr(1) + pathB[1];
        } else {
            dT = pathT[1];
            dB = pathB[1];
        }
        fullPathT += dT;
        fullPathB += dB;
    }
    return fullPathT + fullPathB + "Z";
}
;

pv.SvgScene.areaSegmentedFull = function(e, scenes) {
    var pathsT, pathsB, count = scenes.length, result = this.areaSegmentCurvePaths(scenes, 0, count - 1);
    if (result) {
        pathsT = result.top;
        pathsB = result.bottom;
    }
    for (var i = (scenes[0],
    0); count - 1 > i; i++) {
        var s1 = scenes[i]
          , s2 = scenes[i + 1];
        if (s1.visible && s2.visible) {
            var fill = s1.fillStyle
              , stroke = s1.strokeStyle;
            if (fill.opacity || stroke.opacity) {
                var d;
                if (pathsT) {
                    var pathT = pathsT[i].join("")
                      , pathB = "L" + pathsB[count - i - 2].join("").substr(1);
                    d = pathT + pathB + "Z";
                } else {
                    var si = s1
                      , sj = s2;
                    switch (s1.interpolate) {
                    case "step-before":
                        si = s2;
                        break;

                    case "step-after":
                        sj = s1;
                    }
                    d = "M" + s1.left + "," + si.top + "L" + s2.left + "," + sj.top + "L" + (s2.left + s2.width) + "," + (sj.top + sj.height) + "L" + (s1.left + s1.width) + "," + (si.top + si.height) + "Z";
                }
                var attrs = {
                    "shape-rendering": s1.antialias ? null : "crispEdges",
                    "pointer-events": s1.events,
                    cursor: s1.cursor,
                    d: d,
                    fill: fill.color,
                    "fill-opacity": fill.opacity || null,
                    stroke: stroke.color,
                    "stroke-opacity": stroke.opacity || null,
                    "stroke-width": stroke.opacity ? s1.lineWidth / this.scale : null
                };
                e = this.expect(e, "path", scenes, i, attrs);
                s1.svg && this.setAttributes(e, s1.svg);
                s1.css && this.setStyle(e, s1.css);
                e = this.append(e, scenes, i);
            }
        }
    }
    return e;
}
;

pv.SvgScene.areaPathStraight = function(scenes, i, j, s) {
    for (var pointsT = [], pointsB = [], k = j; k >= i; i++,
    j--) {
        var si = scenes[i]
          , sj = scenes[j]
          , pi = si.left + "," + si.top
          , pj = sj.left + sj.width + "," + (sj.top + sj.height);
        if (k > i) {
            var sk = scenes[i + 1]
              , sl = scenes[j - 1];
            switch (s.interpolate) {
            case "step-before":
                pi += "V" + sk.top;
                pj += "H" + (sl.left + sl.width);
                break;

            case "step-after":
                pi += "H" + sk.left;
                pj += "V" + (sl.top + sl.height);
            }
        }
        pointsT.push(pi);
        pointsB.push(pj);
    }
    return pointsT.concat(pointsB).join("L");
}
;

pv.SvgScene.areaPathCurve = function(scenes, i, j, s) {
    for (var pathT, pathB, pointsT = [], pointsB = [], k = j; k >= i; i++,
    j--) {
        var sj = scenes[j];
        pointsT.push(scenes[i]);
        pointsB.push({
            left: sj.left + sj.width,
            top: sj.top + sj.height
        });
    }
    switch (s.interpolate) {
    case "basis":
        pathT = this.curveBasis(pointsT);
        pathB = this.curveBasis(pointsB);
        break;

    case "cardinal":
        pathT = this.curveCardinal(pointsT, s.tension);
        pathB = this.curveCardinal(pointsB, s.tension);
        break;

    default:
        pathT = this.curveMonotone(pointsT);
        pathB = this.curveMonotone(pointsB);
    }
    return pointsT[0].left + "," + pointsT[0].top + pathT + "L" + pointsB[0].left + "," + pointsB[0].top + pathB;
}
;

pv.SvgScene.minBarWidth = 1;

pv.SvgScene.minBarHeight = 1;

pv.SvgScene.minBarLineWidth = .2;

pv.SvgScene.bar = function(scenes) {
    for (var e = scenes.$g.firstChild, i = 0; i < scenes.length; i++) {
        var s = scenes[i];
        if (!(!s.visible || Math.abs(s.width) <= 1e-10 || Math.abs(s.height) <= 1e-10)) {
            s.width < this.minBarWidth && (s.width = this.minBarWidth);
            s.height < this.minBarHeight && (s.height = this.minBarHeight);
            var fill = s.fillStyle
              , stroke = s.strokeStyle;
            if (fill.opacity || stroke.opacity) {
                this.addFillStyleDefinition(scenes, fill);
                this.addFillStyleDefinition(scenes, stroke);
                var lineWidth;
                if (stroke.opacity) {
                    lineWidth = s.lineWidth;
                    lineWidth = 1e-10 > lineWidth ? 0 : Math.max(this.minBarLineWidth, lineWidth / this.scale);
                } else
                    lineWidth = null;
                e = this.expect(e, "rect", scenes, i, {
                    "shape-rendering": s.antialias ? null : "crispEdges",
                    "pointer-events": s.events,
                    cursor: s.cursor,
                    x: s.left,
                    y: s.top,
                    width: Math.max(1e-10, s.width),
                    height: Math.max(1e-10, s.height),
                    fill: fill.color,
                    "fill-opacity": fill.opacity || null,
                    stroke: stroke.color,
                    "stroke-opacity": stroke.opacity || null,
                    "stroke-width": lineWidth,
                    "stroke-linecap": s.lineCap,
                    "stroke-dasharray": stroke.opacity ? this.parseDasharray(s) : null
                });
                s.svg && this.setAttributes(e, s.svg);
                s.css && this.setStyle(e, s.css);
                e = this.append(e, scenes, i);
            }
        }
    }
    return e;
}
;

pv.SvgScene.dot = function(scenes) {
    for (var e = scenes.$g.firstChild, i = 0, L = scenes.length; L > i; i++) {
        var s = scenes[i];
        if (s.visible) {
            var fill = s.fillStyle
              , fillOp = fill.opacity
              , stroke = s.strokeStyle
              , strokeOp = stroke.opacity;
            if (fillOp || strokeOp) {
                this.addFillStyleDefinition(scenes, fill);
                this.addFillStyleDefinition(scenes, stroke);
                var svg = {
                    "shape-rendering": s.antialias ? null : "crispEdges",
                    "pointer-events": s.events,
                    cursor: s.cursor,
                    fill: fill.color,
                    "fill-opacity": fillOp || null,
                    stroke: stroke.color,
                    "stroke-opacity": strokeOp || null,
                    "stroke-width": strokeOp ? s.lineWidth / this.scale : null,
                    "stroke-linecap": s.lineCap,
                    "stroke-dasharray": strokeOp ? this.parseDasharray(s) : null
                }
                  , shape = s.shape || "circle"
                  , ar = s.aspectRatio
                  , sa = s.shapeAngle
                  , t = null;
                if ("circle" !== shape && this.hasSymbol(shape)) {
                    var r = s.shapeRadius
                      , rx = r
                      , ry = r;
                    if (ar > 0 && 1 !== ar) {
                        var sy = 1 / Math.sqrt(ar)
                          , sx = ar * sy;
                        rx *= sx;
                        ry *= sy;
                    }
                    svg.d = this.renderSymbol(shape, s, rx, ry);
                    shape = "path";
                    t = "translate(" + s.left + "," + s.top + ") ";
                    sa && (t += "rotate(" + pv.degrees(sa) + ") ");
                } else if (1 === ar) {
                    shape = "circle";
                    svg.cx = s.left;
                    svg.cy = s.top;
                    svg.r = s.shapeRadius;
                } else {
                    shape = "ellipse";
                    svg.cx = svg.cy = 0;
                    t = "translate(" + s.left + "," + s.top + ") ";
                    sa && (t += "rotate(" + pv.degrees(sa) + ") ");
                    svg.rx = s._width / 2;
                    svg.ry = s._height / 2;
                }
                t && (svg.transform = t);
                e = this.expect(e, shape, scenes, i, svg);
                s.svg && this.setAttributes(e, s.svg);
                s.css && this.setStyle(e, s.css);
                e = this.append(e, scenes, i);
            }
        }
    }
    return e;
}
;

!function(S) {
    var _renderersBySymName = {};
    S.registerSymbol = function(symName, funRenderer) {
        _renderersBySymName[symName.toLowerCase()] = funRenderer;
        return S;
    }
    ;
    S.renderSymbol = function(symName, instance, rx, ry) {
        return _renderersBySymName[symName].call(S, instance, symName, rx, ry);
    }
    ;
    S.hasSymbol = function(symName) {
        return _renderersBySymName.hasOwnProperty(symName);
    }
    ;
    S.symbols = function() {
        return pv.keys(_renderersBySymName);
    }
    ;
    var C1 = 2 / Math.sqrt(3);
    S.registerSymbol("circle", function(s) {
        throw new Error("Not implemented as a symbol");
    }).registerSymbol("cross", function(s, name, rx, ry) {
        var rxn = (s.shapeRadius,
        -rx)
          , ryn = -ry;
        return "M" + rxn + "," + ryn + "L" + rx + "," + ry + "M" + rx + "," + ryn + "L" + rxn + "," + ry;
    }).registerSymbol("triangle", function(s, name, rx, ry) {
        var hp = ry
          , wp = rx * C1
          , hn = -ry
          , wn = -wp;
        return "M0," + hp + "L" + wp + "," + hn + " " + wn + "," + hn + "Z";
    }).registerSymbol("diamond", function(s, name, rx, ry) {
        var rxp = rx * Math.SQRT2
          , ryp = ry * Math.SQRT2
          , rxn = -rxp
          , ryn = -ryp;
        return "M0," + ryn + "L" + rxp + ",0 0," + ryp + " " + rxn + ",0Z";
    }).registerSymbol("square", function(s, name, rx, ry) {
        var rxn = -rx
          , ryn = -ry;
        return "M" + rxn + "," + ryn + "L" + rx + "," + ryn + " " + rx + "," + ry + " " + rxn + "," + ry + "Z";
    }).registerSymbol("tick", function(s, name, rx, ry) {
        var ry2 = -ry * ry;
        return "M0,0L0," + ry2;
    }).registerSymbol("bar", function(s, name, rx, ry) {
        var z2 = ry * ry / 2;
        return "M0," + z2 + "L0," + -z2;
    });
}(pv.SvgScene);

pv.SvgScene.image = function(scenes) {
    for (var e = scenes.$g.firstChild, i = 0; i < scenes.length; i++) {
        var s = scenes[i];
        if (s.visible) {
            e = this.fill(e, scenes, i);
            if (s.image) {
                e = this.expect(e, "foreignObject", scenes, i, {
                    cursor: s.cursor,
                    x: s.left,
                    y: s.top,
                    width: s.width,
                    height: s.height
                });
                s.svg && this.setAttributes(e, s.svg);
                s.css && this.setStyle(e, s.css);
                var c = e.firstChild || e.appendChild(document.createElementNS(this.xhtml, "canvas"));
                c.$scene = {
                    scenes: scenes,
                    index: i
                };
                c.style.width = s.width;
                c.style.height = s.height;
                c.width = s.imageWidth;
                c.height = s.imageHeight;
                c.getContext("2d").putImageData(s.image, 0, 0);
            } else {
                e = this.expect(e, "image", scenes, i, {
                    preserveAspectRatio: "none",
                    cursor: s.cursor,
                    x: s.left,
                    y: s.top,
                    width: s.width,
                    height: s.height
                });
                s.svg && this.setAttributes(e, s.svg);
                s.css && this.setStyle(e, s.css);
                e.setAttributeNS(this.xlink, "xlink:href", s.url);
            }
            e = this.append(e, scenes, i);
            e = this.stroke(e, scenes, i);
        }
    }
    return e;
}
;

pv.SvgScene.label = function(scenes) {
    for (var e = scenes.$g.firstChild, i = 0; i < scenes.length; i++) {
        var s = scenes[i];
        if (s.visible) {
            var fill = s.textStyle;
            if (fill.opacity && s.text) {
                var x = 0
                  , y = 0
                  , dy = 0
                  , anchor = "start";
                switch (s.textBaseline) {
                case "middle":
                    dy = ".35em";
                    break;

                case "top":
                    dy = ".71em";
                    y = s.textMargin;
                    break;

                case "bottom":
                    y = "-" + s.textMargin;
                }
                switch (s.textAlign) {
                case "right":
                    anchor = "end";
                    x = "-" + s.textMargin;
                    break;

                case "center":
                    anchor = "middle";
                    break;

                case "left":
                    x = s.textMargin;
                }
                e = this.expect(e, "text", scenes, i, {
                    "pointer-events": s.events,
                    cursor: s.cursor,
                    x: x,
                    y: y,
                    dy: dy,
                    transform: "translate(" + s.left + "," + s.top + ")" + (s.textAngle ? " rotate(" + 180 * s.textAngle / Math.PI + ")" : "") + (1 != this.scale ? " scale(" + 1 / this.scale + ")" : ""),
                    fill: fill.color,
                    "fill-opacity": fill.opacity || null,
                    "text-anchor": anchor
                }, {
                    font: s.font,
                    "text-shadow": s.textShadow,
                    "text-decoration": s.textDecoration
                });
                s.svg && this.setAttributes(e, s.svg);
                s.css && this.setStyle(e, s.css);
                e.firstChild ? e.firstChild.nodeValue = s.text : e.appendChild(document.createTextNode(s.text));
                e = this.append(e, scenes, i);
            }
        }
    }
    return e;
}
;

pv.SvgScene.line = function(scenes) {
    var e = scenes.$g.firstChild
      , count = scenes.length;
    if (!count)
        return e;
    var s = scenes[0];
    return "smart" === s.segmented ? this.lineSegmentedSmart(e, scenes) : 2 > count ? e : s.segmented ? this.lineSegmentedFull(e, scenes) : this.lineFixed(e, scenes);
}
;

pv.SvgScene.lineFixed = function(elm, scenes) {
    var count = scenes.length;
    if (1 === count)
        return this.lineAreaDotAlone(elm, scenes, 0);
    var s = scenes[0];
    if (!s.visible)
        return elm;
    var fill = s.fillStyle
      , stroke = s.strokeStyle;
    if (!fill.opacity && !stroke.opacity)
        return elm;
    this.addFillStyleDefinition(scenes, fill);
    this.addFillStyleDefinition(scenes, stroke);
    var d = "M" + s.left + "," + s.top
      , curveInterpolated = count > 2;
    if (curveInterpolated)
        switch (s.interpolate) {
        case "basis":
            d += this.curveBasis(scenes);
            break;

        case "cardinal":
            d += this.curveCardinal(scenes, s.tension);
            break;

        case "monotone":
            d += this.curveMonotone(scenes);
            break;

        default:
            curveInterpolated = !1;
        }
    if (!curveInterpolated)
        for (var i = 1; count > i; i++)
            d += this.lineSegmentPath(scenes[i - 1], scenes[i]);
    var sop = stroke.opacity
      , attrs = {
        "shape-rendering": s.antialias ? null : "crispEdges",
        "pointer-events": s.events,
        cursor: s.cursor,
        d: d,
        fill: fill.color,
        "fill-opacity": fill.opacity || null,
        stroke: stroke.color,
        "stroke-opacity": sop || null,
        "stroke-width": sop ? s.lineWidth / this.scale : null,
        "stroke-linecap": s.lineCap,
        "stroke-linejoin": s.lineJoin,
        "stroke-miterlimit": s.strokeMiterLimit,
        "stroke-dasharray": sop ? this.parseDasharray(s) : null
    };
    elm = this.expect(elm, "path", scenes, 0, attrs, s.css);
    s.svg && this.setAttributes(elm, s.svg);
    return this.append(elm, scenes, 0);
}
;

pv.SvgScene.lineSegmentedSmart = function(elm, scenes) {
    return this.eachLineAreaSegment(elm, scenes, function(elm, scenes, from, to) {
        var paths = this.lineSegmentPaths(scenes, from, to)
          , fromp = from
          , options = {
            breakOnKeyChange: !0,
            from: from,
            to: to
        };
        return this.eachLineAreaSegment(elm, scenes, options, function(elm, scenes, from, to, ka, eventsMax) {
            var s1 = scenes[from]
              , fill = s1.fillStyle;
            this.addFillStyleDefinition(scenes, fill);
            var stroke = s1.strokeStyle;
            this.addFillStyleDefinition(scenes, stroke);
            if (from === to)
                return this.lineAreaDotAlone(elm, scenes, from);
            var d = this.lineJoinPaths(paths, from - fromp, to - fromp - 1)
              , sop = stroke.opacity
              , attrs = {
                "shape-rendering": s1.antialias ? null : "crispEdges",
                "pointer-events": eventsMax,
                cursor: s1.cursor,
                d: d,
                fill: fill.color,
                "fill-opacity": fill.opacity || null,
                stroke: stroke.color,
                "stroke-opacity": sop || null,
                "stroke-width": sop ? s1.lineWidth / this.scale : null,
                "stroke-linecap": s1.lineCap,
                "stroke-linejoin": s1.lineJoin,
                "stroke-miterlimit": s1.strokeMiterLimit,
                "stroke-dasharray": sop ? this.parseDasharray(s1) : null
            };
            elm = this.expect(elm, "path", scenes, from, attrs, s1.css);
            return this.append(elm, scenes, from);
        });
    });
}
;

pv.SvgScene.lineSegmentedFull = function(e, scenes) {
    var paths, s = scenes[0];
    switch (s.interpolate) {
    case "basis":
        paths = this.curveBasisSegments(scenes);
        break;

    case "cardinal":
        paths = this.curveCardinalSegments(scenes, s.tension);
        break;

    case "monotone":
        paths = this.curveMonotoneSegments(scenes);
    }
    for (var i = 0, n = scenes.length - 1; n > i; i++) {
        var s1 = scenes[i]
          , s2 = scenes[i + 1];
        if (s1.visible && s2.visible) {
            var stroke = s1.strokeStyle
              , fill = pv.FillStyle.transparent;
            if (stroke.opacity) {
                var d;
                if ("linear" == s1.interpolate && "miter" == s1.lineJoin) {
                    fill = stroke;
                    stroke = pv.FillStyle.transparent;
                    d = this.pathJoin(scenes[i - 1], s1, s2, scenes[i + 2]);
                } else
                    d = paths ? paths[i].join("") : "M" + s1.left + "," + s1.top + this.lineSegmentPath(s1, s2);
                e = this.expect(e, "path", scenes, i, {
                    "shape-rendering": s1.antialias ? null : "crispEdges",
                    "pointer-events": s1.events,
                    cursor: s1.cursor,
                    d: d,
                    fill: fill.color,
                    "fill-opacity": fill.opacity || null,
                    stroke: stroke.color,
                    "stroke-opacity": stroke.opacity || null,
                    "stroke-width": stroke.opacity ? s1.lineWidth / this.scale : null,
                    "stroke-linejoin": s1.lineJoin
                });
                s1.svg && this.setAttributes(e, s1.svg);
                s1.css && this.setStyle(e, s1.css);
                e = this.append(e, scenes, i);
            }
        }
    }
    return e;
}
;

pv.SvgScene.lineSegmentPath = function(s1, s2) {
    var l = 1;
    switch (s1.interpolate) {
    case "polar-reverse":
        l = 0;

    case "polar":
        var dx = s2.left - s1.left
          , dy = s2.top - s1.top
          , e = 1 - s1.eccentricity
          , r = Math.sqrt(dx * dx + dy * dy) / (2 * e);
        if (0 >= e || e > 1)
            break;
        return "A" + r + "," + r + " 0 0," + l + " " + s2.left + "," + s2.top;

    case "step-before":
        return "V" + s2.top + "H" + s2.left;

    case "step-after":
        return "H" + s2.left + "V" + s2.top;
    }
    return "L" + s2.left + "," + s2.top;
}
;

pv.SvgScene.lineSegmentPaths = function(scenes, from, to) {
    var paths, s = scenes[from];
    switch (s.interpolate) {
    case "basis":
        paths = this.curveBasisSegments(scenes, from, to);
        break;

    case "cardinal":
        paths = this.curveCardinalSegments(scenes, s.tension, from, to);
        break;

    case "monotone":
        paths = this.curveMonotoneSegments(scenes, from, to);
    }
    if (!paths || !paths.length) {
        paths = [];
        for (var i = from + 1; to >= i; i++) {
            var s1 = scenes[i - 1]
              , s2 = scenes[i];
            paths.push(["M" + s1.left + "," + s1.top, this.lineSegmentPath(s1, s2)]);
        }
    }
    return paths;
}
;

pv.strokeMiterLimit = 4;

pv.SvgScene.pathJoin = function(s0, s1, s2, s3) {
    var miterLimit, miterRatio, miterLength, pts = [], w1 = s1.lineWidth / this.scale, p1 = pv.vector(s1.left, s1.top), p2 = pv.vector(s2.left, s2.top), p21 = p2.minus(p1), v21 = p21.perp().norm(), w21 = v21.times(w1 / 2), a = p1.plus(w21), d = p1.minus(w21), b = p2.plus(w21), c = p2.minus(w21);
    if (s0 && s0.visible) {
        var p0 = pv.vector(s0.left, s0.top)
          , p10 = p1.minus(p0)
          , v10 = p10.perp().norm()
          , v1 = v10.plus(v21).norm()
          , am = this.lineIntersect(p1, v1, a, p21)
          , dm = this.lineIntersect(p1, v1, d, p21);
        miterLength = am.minus(dm).length();
        var w0 = s0.lineWidth / this.scale
          , w10avg = (w1 + w0) / 2;
        miterRatio = miterLength / w10avg;
        miterLimit = s1.strokeMiterLimit || pv.strokeMiterLimit;
        if (miterLimit >= miterRatio)
            pts.push(dm, am);
        else {
            var p12 = p21.times(-1)
              , v1Outer = p10.norm().plus(p12.norm()).norm()
              , bevel10 = p1.plus(v1Outer.times(w10avg / 2));
            v1Outer.dot(v21) >= 0 ? pts.push(dm, bevel10, a) : pts.push(d, bevel10, am);
        }
    } else
        pts.push(d, a);
    if (s3 && s3.visible) {
        var p3 = pv.vector(s3.left, s3.top)
          , p32 = p3.minus(p2)
          , v32 = p32.perp().norm()
          , v2 = v32.plus(v21).norm()
          , bm = this.lineIntersect(p2, v2, b, p21)
          , cm = this.lineIntersect(p2, v2, c, p21);
        miterLength = bm.minus(cm).length();
        var w3 = s3.lineWidth / this.scale
          , w31avg = (w3 + w1) / 2;
        miterRatio = miterLength / w31avg;
        miterLimit = s2.strokeMiterLimit || pv.strokeMiterLimit;
        if (miterLimit >= miterRatio)
            pts.push(bm, cm);
        else {
            var p23 = p32.times(-1)
              , v2Outer = p21.norm().plus(p23.norm()).norm()
              , bevel31 = p2.plus(v2Outer.times(w31avg / 2));
            v2Outer.dot(v21) >= 0 ? pts.push(b, bevel31, cm) : pts.push(bm, bevel31, c);
        }
    } else
        pts.push(b, c);
    var pt = pts.shift();
    return "M" + pt.x + "," + pt.y + "L" + pts.map(function(pt2) {
        return pt2.x + "," + pt2.y;
    }).join(" ");
}
;

pv.SvgScene.lineIntersect = function(o1, d1, o2, d2) {
    return o1.plus(d1.times(o2.minus(o1).dot(d2.perp()) / d1.dot(d2.perp())));
}
;

pv.SvgScene.lineJoinPaths = function(paths, from, to) {
    for (var d = paths[from].join(""), i = from + 1; to >= i; i++)
        d += paths[i][1];
    return d;
}
;

pv.SvgScene.lineAreaDotAlone = function(elm, scenes, i) {
    return elm;
}
;

pv.Scene.eventsToNumber = {
    "": 0,
    none: 0,
    painted: 1,
    all: 2
};

pv.Scene.numberToEvents = ["none", "painted", "all"];

pv.SvgScene.eachLineAreaSegment = function(elm, scenes, keyArgs, lineAreaSegment) {
    if ("function" == typeof keyArgs) {
        lineAreaSegment = keyArgs;
        keyArgs = null;
    }
    var eventsNumber, ki, kf, breakOnKeyChange = pv.get(keyArgs, "breakOnKeyChange", !1), from = pv.get(keyArgs, "from") || 0, to = pv.get(keyArgs, "to", scenes.length - 1);
    if (breakOnKeyChange) {
        ki = [];
        kf = [];
    }
    for (var i = from; to >= i; ) {
        var si = scenes[i];
        if (this.isSceneVisible(si)) {
            eventsNumber = this.eventsToNumber[si.events] || 0;
            breakOnKeyChange && this.lineAreaSceneKey(si, ki);
            for (var i2, f = i; ; ) {
                var f2 = f + 1;
                if (f2 > to) {
                    i2 = f2;
                    break;
                }
                var sf = scenes[f2];
                if (!this.isSceneVisible(sf)) {
                    i2 = f2 + 1;
                    break;
                }
                eventsNumber = Math.max(eventsNumber, this.eventsToNumber[sf.events] || 0);
                f = f2;
                if (breakOnKeyChange) {
                    this.lineAreaSceneKey(sf, kf);
                    if (!this.equalSceneKeys(ki, kf)) {
                        i2 = f;
                        break;
                    }
                }
            }
            elm = lineAreaSegment.call(this, elm, scenes, i, f, keyArgs, this.numberToEvents[eventsNumber]);
            i = i2;
        } else
            i++;
    }
    return elm;
}
;

pv.SvgScene.lineAreaSceneKey = function(s, k) {
    k[0] = s.fillStyle.key;
    k[1] = s.strokeStyle.key;
    k[2] = s.lineWidth;
    k[3] = s.strokeDasharray || "none";
    k[4] = s.interpolate;
    return k;
}
;

pv.SvgScene.isSceneVisible = function(s) {
    return s.visible && (s.fillStyle.opacity > 0 || s.strokeStyle.opacity > 0);
}
;

pv.SvgScene.equalSceneKeys = function(ka, kb) {
    for (var i = 0, K = ka.length; K > i; i++)
        if (ka[i] !== kb[i])
            return !1;
    return !0;
}
;

pv.SvgScene.panel = function(scene) {
    for (var g = scene.$g, e = g && g.firstChild, i = 0, L = scene.length; L > i; i++) {
        var s = scene[i];
        if (s.visible) {
            if (!scene.parent) {
                var canvas = s.canvas;
                this.applyCanvasStyle(canvas);
                if (g && g.parentNode !== canvas) {
                    g = canvas.firstChild;
                    e = g && g.firstChild;
                }
                if (g)
                    e && "defs" === e.tagName && (e = e.nextSibling);
                else {
                    g = this.createRootPanelElement();
                    e = null;
                    this.initRootPanelElement(g, scene.mark);
                    canvas.appendChild(g);
                    scene.$defs = g.appendChild(this.create("defs"));
                    scene.$g = g;
                }
                g.setAttribute("width", s.width + s.left + s.right);
                g.setAttribute("height", s.height + s.top + s.bottom);
            }
            var clip_g = null;
            if ("hidden" === s.overflow) {
                var clipResult = this.addPanelClipPath(g, e, scene, i, s);
                clip_g = clipResult.g;
                scene.$g = g = clip_g;
                e = clipResult.next;
            }
            e = this.fill(e, scene, i);
            var k = this.scale
              , t = s.transform
              , x = s.left + t.x
              , y = s.top + t.y;
            this.scale *= t.k;
            if (s.children.length)
                for (var attrs = {
                    transform: "translate(" + x + "," + y + ")" + (1 != t.k ? " scale(" + t.k + ")" : "")
                }, childScenes = this.getSortedChildScenes(scene, i), j = 0, C = childScenes.length; C > j; j++) {
                    var childScene = childScenes[j];
                    childScene.$g = e = this.expect(e, "g", scene, i, attrs);
                    this.updateAll(childScene);
                    e.parentNode || g.appendChild(e);
                    e = e.nextSibling;
                }
            this.scale = k;
            e = this.stroke(e, scene, i);
            if (clip_g) {
                scene.$g = g = clip_g.parentNode;
                e = clip_g.nextSibling;
            }
        }
    }
    return e;
}
;

pv.SvgScene.applyCanvasStyle = function(canvas) {
    canvas.style.display = "inline-block";
}
;

pv.SvgScene.createRootPanelElement = function() {
    return this.create("svg");
}
;

pv.SvgScene.initRootPanelElement = function(g, panel) {
    g.setAttribute("font-size", "10px");
    g.setAttribute("font-family", "sans-serif");
    g.setAttribute("fill", "none");
    g.setAttribute("stroke", "none");
    g.setAttribute("stroke-width", 1.5);
    this.disableElementSelection(g);
    this.listenRootPanelElement(g, panel);
}
;

pv.SvgScene.listenRootPanelElement = function(g, panel) {
    for (var j = 0, evs = this.events, J = evs.length; J > j; j++) {
        g.addEventListener(evs[j], this.dispatch, !1);
        panel._registerBoundEvent(g, evs[j], this.dispatch, !1);
    }
}
;

pv.SvgScene.disableElementSelection = function(g) {
    g.setAttribute("style", "-webkit-touch-callout: none; -webkit-user-select: none; -khtml-user-select: none; -moz-user-select: none; -ms-user-select: none; user-select: none;");
    if ("undefined" != typeof g.onselectstart) {
        g.setAttribute("unselectable", "on");
        g.onselectstart = function() {
            return !1;
        }
        ;
    }
}
;

pv.SvgScene.addPanelClipPath = function(g, e, scene, i, s) {
    var id = pv.id().toString(36)
      , clip_g = this.expect(e, "g", scene, i, {
        "clip-path": "url(#" + id + ")"
    })
      , clip_p = this.expect(clip_g.firstChild, "clipPath", scene, i, {
        id: id
    })
      , r = clip_p.firstChild || clip_p.appendChild(this.create("rect"));
    r.setAttribute("x", s.left);
    r.setAttribute("y", s.top);
    r.setAttribute("width", s.width);
    r.setAttribute("height", s.height);
    clip_p.parentNode || clip_g.appendChild(clip_p);
    clip_g.parentNode || g.appendChild(clip_g);
    return {
        g: clip_g,
        next: clip_p.nextSibling
    };
}
;

pv.SvgScene.getSortedChildScenes = function(scene, i) {
    var children = scene[i].children;
    if (scene.mark._zOrderChildCount) {
        children = children.slice(0);
        children.sort(function(scenes1, scenes2) {
            var compare = scenes1.mark._zOrder - scenes2.mark._zOrder;
            0 === compare && (compare = scenes1.childIndex - scenes2.childIndex);
            return compare;
        });
    }
    return children;
}
;

pv.SvgScene.fill = function(e, scene, i) {
    var s = scene[i]
      , fill = s.fillStyle;
    if (fill.opacity || "all" == s.events) {
        this.addFillStyleDefinition(scene, fill);
        e = this.expect(e, "rect", scene, i, {
            "shape-rendering": s.antialias ? null : "crispEdges",
            "pointer-events": s.events,
            cursor: s.cursor,
            x: s.left,
            y: s.top,
            width: s.width,
            height: s.height,
            fill: fill.color,
            "fill-opacity": fill.opacity,
            stroke: null
        });
        e = this.append(e, scene, i);
    }
    return e;
}
;

pv.SvgScene.stroke = function(e, scene, i) {
    var s = scene[i]
      , stroke = s.strokeStyle;
    if (stroke.opacity || "all" == s.events) {
        e = this.expect(e, "rect", scene, i, {
            "shape-rendering": s.antialias ? null : "crispEdges",
            "pointer-events": "all" == s.events ? "stroke" : s.events,
            cursor: s.cursor,
            x: s.left,
            y: s.top,
            width: Math.max(1e-10, s.width),
            height: Math.max(1e-10, s.height),
            fill: null,
            stroke: stroke.color,
            "stroke-opacity": stroke.opacity,
            "stroke-width": s.lineWidth / this.scale,
            "stroke-linecap": s.lineCap,
            "stroke-dasharray": stroke.opacity ? this.parseDasharray(s) : null
        });
        e = this.append(e, scene, i);
    }
    return e;
}
;

pv.SvgScene.minRuleLineWidth = 1;

pv.SvgScene.rule = function(scenes) {
    for (var e = scenes.$g.firstChild, i = 0; i < scenes.length; i++) {
        var s = scenes[i];
        if (s.visible) {
            var stroke = s.strokeStyle;
            if (stroke.opacity) {
                var lineWidth = s.lineWidth;
                lineWidth = 1e-10 > lineWidth ? 0 : Math.max(this.minRuleLineWidth, lineWidth / this.scale);
                e = this.expect(e, "line", scenes, i, {
                    "shape-rendering": s.antialias ? null : "crispEdges",
                    "pointer-events": s.events,
                    cursor: s.cursor,
                    x1: s.left,
                    y1: s.top,
                    x2: s.left + s.width,
                    y2: s.top + s.height,
                    stroke: stroke.color,
                    "stroke-opacity": stroke.opacity,
                    "stroke-width": lineWidth,
                    "stroke-linecap": s.lineCap,
                    "stroke-dasharray": stroke.opacity ? this.parseDasharray(s) : null
                });
                s.svg && this.setAttributes(e, s.svg);
                s.css && this.setStyle(e, s.css);
                e = this.append(e, scenes, i);
            }
        }
    }
    return e;
}
;

pv.SvgScene.wedge = function(scenes) {
    for (var e = scenes.$g.firstChild, i = 0; i < scenes.length; i++) {
        var s = scenes[i];
        if (s.visible) {
            var fill = s.fillStyle
              , stroke = s.strokeStyle;
            if (fill.opacity || stroke.opacity) {
                var p, r1 = s.innerRadius, r2 = s.outerRadius, a = Math.abs(s.angle);
                if (a >= 2 * Math.PI)
                    p = r1 ? "M0," + r2 + "A" + r2 + "," + r2 + " 0 1,1 0," + -r2 + "A" + r2 + "," + r2 + " 0 1,1 0," + r2 + "M0," + r1 + "A" + r1 + "," + r1 + " 0 1,1 0," + -r1 + "A" + r1 + "," + r1 + " 0 1,1 0," + r1 + "Z" : "M0," + r2 + "A" + r2 + "," + r2 + " 0 1,1 0," + -r2 + "A" + r2 + "," + r2 + " 0 1,1 0," + r2 + "Z";
                else {
                    var sa = Math.min(s.startAngle, s.endAngle)
                      , ea = Math.max(s.startAngle, s.endAngle)
                      , c1 = Math.cos(sa)
                      , c2 = Math.cos(ea)
                      , s1 = Math.sin(sa)
                      , s2 = Math.sin(ea);
                    p = r1 ? "M" + r2 * c1 + "," + r2 * s1 + "A" + r2 + "," + r2 + " 0 " + (a < Math.PI ? "0" : "1") + ",1 " + r2 * c2 + "," + r2 * s2 + "L" + r1 * c2 + "," + r1 * s2 + "A" + r1 + "," + r1 + " 0 " + (a < Math.PI ? "0" : "1") + ",0 " + r1 * c1 + "," + r1 * s1 + "Z" : "M" + r2 * c1 + "," + r2 * s1 + "A" + r2 + "," + r2 + " 0 " + (a < Math.PI ? "0" : "1") + ",1 " + r2 * c2 + "," + r2 * s2 + "L0,0Z";
                }
                this.addFillStyleDefinition(scenes, fill);
                this.addFillStyleDefinition(scenes, stroke);
                e = this.expect(e, "path", scenes, i, {
                    "shape-rendering": s.antialias ? null : "crispEdges",
                    "pointer-events": s.events,
                    cursor: s.cursor,
                    transform: "translate(" + s.left + "," + s.top + ")",
                    d: p,
                    fill: fill.color,
                    "fill-rule": "evenodd",
                    "fill-opacity": fill.opacity || null,
                    stroke: stroke.color,
                    "stroke-opacity": stroke.opacity || null,
                    "stroke-width": stroke.opacity ? s.lineWidth / this.scale : null,
                    "stroke-linejoin": s.lineJoin,
                    "stroke-miterlimit": s.strokeMiterLimit,
                    "stroke-linecap": s.lineCap,
                    "stroke-dasharray": stroke.opacity ? this.parseDasharray(s) : null
                });
                s.svg && this.setAttributes(e, s.svg);
                s.css && this.setStyle(e, s.css);
                e = this.append(e, scenes, i);
            }
        }
    }
    return e;
}
;

pv.Mark = function() {
    this.$properties = [];
    this.$propertiesMap = {};
    this.$handlers = {};
}
;

pv.Mark.prototype.properties = {};

pv.Mark.cast = {};

pv.Mark.prototype.property = function(name, cast) {
    this.hasOwnProperty("properties") || (this.properties = pv.extend(this.properties));
    this.properties[name] = !0;
    pv.Mark.prototype.propertyMethod(name, !1, pv.Mark.cast[name] = cast);
    return this;
}
;

pv.Mark.prototype.localProperty = function(name, cast) {
    this.hasOwnProperty("properties") || (this.properties = pv.extend(this.properties));
    this.properties[name] = !0;
    var currCast = pv.Mark.cast[name];
    cast && (pv.Mark.cast[name] = currCast = cast);
    this.propertyMethod(name, !1, currCast);
    return this;
}
;

pv.Mark.prototype.def = function(name, v) {
    this.propertyMethod(name, !0);
    return this[name](arguments.length > 1 ? v : null);
}
;

pv.Mark.prototype.propertyMethod = function(name, isDef, cast) {
    cast || (cast = pv.Mark.cast[name]);
    this[name] = function(v, tag) {
        if (isDef && this.scene) {
            var defs = this.scene.defs;
            if (arguments.length) {
                defs[name] = {
                    id: null == v ? 0 : pv.id(),
                    value: null != v && cast ? cast(v) : v
                };
                return this;
            }
            var def = defs[name];
            return def ? def.value : null;
        }
        if (arguments.length) {
            this.setPropertyValue(name, v, isDef, cast, !1, tag);
            return this;
        }
        var s = this.instance();
        if (pv.propBuildMark === this && 1 !== pv.propBuilt[name]) {
            pv.propBuilt[name] = 1;
            return s[name] = this.evalProperty(this.binds.properties[name]);
        }
        return s[name];
    }
    ;
}
;

pv.Mark.funPropertyCaller = function(fun, cast) {
    function mark_callFunProperty() {
        var value = fun.apply(this, stack);
        return null != value ? cast(value) : value;
    }
    var stack = pv.Mark.stack;
    return mark_callFunProperty;
}
;

pv.Mark.prototype.setPropertyValue = function(name, v, isDef, cast, chain, tag) {
    var type = !isDef << 1 | "function" == typeof v;
    1 & type && cast ? v = pv.Mark.funPropertyCaller(v, cast) : null != v && cast && (v = cast(v));
    var propertiesMap = this.$propertiesMap
      , properties = this.$properties
      , p = {
        name: name,
        id: pv.id(),
        value: v,
        type: type,
        tag: tag,
        proto: null,
        root: null,
        _proto: null
    };
    p.root = p;
    var existing = propertiesMap[name];
    propertiesMap[name] = p;
    if (existing)
        for (var i = 0, P = properties.length; P > i; i++)
            if (properties[i] === existing) {
                properties.splice(i, 1);
                break;
            }
    properties.push(p);
    if (chain && existing && 3 === type) {
        p.proto = existing;
        p.root = existing.root;
    }
    return p;
}
;

pv.Mark.prototype.intercept = function(name, v, keyArgs) {
    this.setPropertyValue(name, v, !1, pv.get(keyArgs, "noCast") ? null : pv.Mark.cast[name], !0, pv.get(keyArgs, "tag"));
    return this;
}
;

pv.Mark.prototype.propertyValue = function(name, inherit) {
    var p = this.$propertiesMap[name];
    if (p)
        return p.value;
    if (inherit) {
        if (this.proto) {
            var value = this.proto._propertyValueRecursive(name);
            if (void 0 !== value)
                return value;
        }
        return this.defaults._propertyValueRecursive(name);
    }
}
;

pv.Mark.prototype._propertyValueRecursive = function(name) {
    var p = this.$propertiesMap[name];
    return p ? p.value : this.proto ? this.proto._propertyValueRecursive(name) : void 0;
}
;

pv.Mark.stack = [];

pv.Mark.prototype.property("data").property("visible", Boolean).property("css", Object).property("svg", Object).property("left", Number).property("right", Number).property("top", Number).property("bottom", Number).property("cursor", String).property("title", String).property("reverse", Boolean).property("antialias", Boolean).property("events", pv.stringLowerCase).property("id", String);

pv.Mark.prototype.childIndex = -1;

pv.Mark.prototype.index = -1;

pv.Mark.prototype.scale = 1;

pv.Mark.prototype._zOrder = 0;

pv.Mark.prototype.defaults = new pv.Mark().data(function(d) {
    return [d];
}).visible(!0).antialias(!0).events("painted");

pv.Mark.prototype.extend = function(proto) {
    this.proto = proto;
    this.target = proto.target;
    return this;
}
;

pv.Mark.prototype.add = function(type) {
    return this.parent.add(type).extend(this);
}
;

pv.Mark.prototype.zOrder = function(zOrder) {
    if (!arguments.length)
        return this._zOrder;
    zOrder = +zOrder || 0;
    if (this._zOrder !== zOrder) {
        var p = this.parent;
        p && 0 !== this._zOrder && p._zOrderChildCount--;
        this._zOrder = zOrder;
        p && 0 !== this._zOrder && p._zOrderChildCount++;
    }
    return this;
}
;

pv.Mark.prototype.anchor = function(name) {
    return new pv.Anchor(this).name(name || "center").data(function() {
        return this.scene.target.map(function(s) {
            return s.data;
        });
    }).visible(function() {
        return this.scene.target[this.index].visible;
    }).id(function() {
        return this.scene.target[this.index].id;
    }).left(function() {
        var s = this.scene.target[this.index]
          , w = s.width || 0;
        switch (this.name()) {
        case "bottom":
        case "top":
        case "center":
            return s.left + w / 2;

        case "left":
            return null;
        }
        return s.left + w;
    }).top(function() {
        var s = this.scene.target[this.index]
          , h = s.height || 0;
        switch (this.name()) {
        case "left":
        case "right":
        case "center":
            return s.top + h / 2;

        case "top":
            return null;
        }
        return s.top + h;
    }).right(function() {
        var s = this.scene.target[this.index];
        return "left" == this.name() ? s.right + (s.width || 0) : null;
    }).bottom(function() {
        var s = this.scene.target[this.index];
        return "top" == this.name() ? s.bottom + (s.height || 0) : null;
    }).textAlign(function() {
        switch (this.name()) {
        case "bottom":
        case "top":
        case "center":
            return "center";

        case "right":
            return "right";
        }
        return "left";
    }).textBaseline(function() {
        switch (this.name()) {
        case "right":
        case "left":
        case "center":
            return "middle";

        case "top":
            return "top";
        }
        return "bottom";
    });
}
;

pv.Mark.prototype.anchorTarget = function() {
    return this.target;
}
;

pv.Mark.prototype.margin = function(n) {
    return this.left(n).right(n).top(n).bottom(n);
}
;

pv.Mark.prototype.instance = function(defaultIndex) {
    var scene = this.scene || this.parent.instance(-1).children[this.childIndex]
      , index = null == defaultIndex || this.hasOwnProperty("index") ? this.index : defaultIndex;
    return scene[0 > index ? scene.length - 1 : index];
}
;

pv.Mark.prototype.instances = function(source) {
    for (var scene, mark = this, index = []; !(scene = mark.scene); ) {
        index.push({
            index: source.parentIndex,
            childIndex: mark.childIndex
        });
        source = source.parent;
        mark = mark.parent;
    }
    for (var j = index.length; j--; ) {
        var info = index[j];
        scene = scene[info.index].children[info.childIndex];
    }
    if (this.hasOwnProperty("index")) {
        var s = pv.extend(scene[this.index]);
        s.right = s.top = s.left = s.bottom = 0;
        return [s];
    }
    return scene;
}
;

pv.Mark.prototype.first = function() {
    return this.scene[0];
}
;

pv.Mark.prototype.last = function() {
    return this.scene[this.scene.length - 1];
}
;

pv.Mark.prototype.sibling = function() {
    return 0 == this.index ? null : this.scene[this.index - 1];
}
;

pv.Mark.prototype.cousin = function() {
    var p = this.parent
      , s = p && p.sibling();
    return s && s.children ? s.children[this.childIndex][this.index] : null;
}
;

pv.Mark.prototype._renderId = 0;

pv.Mark.prototype.renderId = function() {
    return this.root._renderId;
}
;

pv.Mark.prototype.render = function() {
    var root = this.root;
    if (!this.parent || root.scene) {
        root._renderId++;
        this.renderCore();
    } else
        root.render();
}
;

pv.Mark.prototype.renderCore = function() {
    function render(mark, depth, scale) {
        mark.scale = scale;
        if (L > depth) {
            var addStack = depth >= stack.length;
            addStack && stack.unshift(null);
            if (mark.hasOwnProperty("index"))
                renderCurrentInstance(mark, depth, scale, addStack);
            else {
                for (var i = 0, n = mark.scene.length; n > i; i++) {
                    mark.index = i;
                    renderCurrentInstance(mark, depth, scale, addStack);
                }
                delete mark.index;
            }
            addStack && stack.shift();
        } else {
            mark.build();
            pv.Scene.scale = scale;
            pv.Scene.updateAll(mark.scene);
        }
        delete mark.scale;
    }
    function renderCurrentInstance(mark, depth, scale, fillStack) {
        var i, s = mark.scene[mark.index];
        if (s.visible) {
            var childMarks = mark.children
              , childScenez = s.children
              , childIndex = indexes[depth]
              , childMark = childMarks[childIndex];
            childMark.scene || childIndex++;
            for (i = 0; childIndex > i; i++)
                childMarks[i].scene = childScenez[i];
            fillStack && (stack[0] = s.data);
            render(childMark, depth + 1, scale * s.transform.k);
            for (i = 0; childIndex > i; i++)
                childMarks[i].scene = void 0;
        }
    }
    for (var parent = this.parent, stack = pv.Mark.stack, S = stack.length, indexes = [], mark = this; mark.parent; mark = mark.parent)
        indexes.unshift(mark.childIndex);
    var L = indexes.length;
    this.bind();
    for (; parent && !parent.hasOwnProperty("index"); )
        parent = parent.parent;
    try {
        this.context(parent ? parent.scene : void 0, parent ? parent.index : -1, function() {
            render(this.root, 0, 1);
        });
    } catch (e) {
        stack.length > S && (stack.length = S);
        throw e;
    }
}
;

pv.Mark.prototype.bind = function() {
    function bind(mark) {
        do
            for (var properties = mark.$properties, i = properties.length; i--; ) {
                var p = properties[i]
                  , name = p.name
                  , pLeaf = seen[name];
                if (pLeaf) {
                    var pRoot = root[name];
                    if (3 === pRoot.type) {
                        pRoot._proto = p;
                        pRoot = root[name] = p.root;
                        pRoot._proto = null;
                    }
                } else {
                    seen[name] = p;
                    root[name] = p.root;
                    p.root._proto = null;
                    switch (name) {
                    case "data":
                        data = p;
                        break;

                    case "visible":
                    case "id":
                        required.push(p);
                        break;

                    default:
                        types[p.type].push(p);
                    }
                }
            }
        while (mark = mark.proto);
    }
    var data, seen = {}, root = {}, required = [], types = [[], [], [], []];
    bind(this);
    bind(this.defaults);
    var types0 = types[0]
      , types1 = types[1].reverse()
      , types2 = types[2];
    types[3].reverse();
    var mark = this;
    do
        for (var name in mark.properties)
            name in seen || types2.push(seen[name] = {
                name: name,
                type: 2,
                value: null
            });
    while (mark = mark.proto);var defs;
    if (types0.length || types1.length) {
        defs = types0.concat(types1);
        for (var i = 0, D = defs.length; D > i; i++)
            this.propertyMethod(defs[i].name, !0);
    } else
        defs = [];
    this.binds = {
        properties: seen,
        data: data,
        defs: defs,
        required: required,
        optional: pv.blend(types)
    };
}
;

pv.Mark.prototype.build = function() {
    var stack = pv.Mark.stack
      , scene = this.scene;
    if (!scene) {
        scene = this.scene = [];
        scene.mark = this;
        scene.type = this.type;
        scene.childIndex = this.childIndex;
        var parent = this.parent;
        if (parent) {
            scene.parent = parent.scene;
            scene.parentIndex = parent.index;
        }
    }
    this.target && (scene.target = this.target.instances(scene));
    var bdefs = this.binds.defs;
    if (bdefs.length)
        for (var defs = scene.defs || (scene.defs = {}), i = 0, B = bdefs.length; B > i; i++) {
            var p = bdefs[i]
              , d = defs[p.name];
            (!d || p.id > d.id) && (defs[p.name] = {
                id: 0,
                value: 1 & p.type ? p.value.apply(this, stack) : p.value
            });
        }
    var datas = this.evalProperty(this.binds.data)
      , L = datas.length;
    scene.length = L;
    if (L) {
        var markProto = pv.Mark.prototype;
        stack.unshift(null);
        var propBuildMarkBefore = pv.propBuildMark
          , propBuiltBefore = pv.propBuilt;
        pv.propBuildMark = this;
        try {
            for (var i = 0; L > i; i++) {
                markProto.index = this.index = i;
                pv.propBuilt = {};
                var instance = scene[i];
                instance ? instance._state && delete instance._state : instance = scene[i] = {};
                instance.data = stack[0] = datas[i];
                this.preBuildInstance(instance);
                this.buildInstance(instance);
            }
        } finally {
            markProto.index = -1;
            delete this.index;
            stack.shift();
            pv.propBuildMark = propBuildMarkBefore;
            pv.propBuilt = propBuiltBefore;
        }
    }
    return this;
}
;

pv.Mark.prototype.instanceState = function(s) {
    s || (s = this.instance());
    return s ? s._state || (s._state = {}) : null;
}
;

pv.Mark.prototype.preBuildInstance = function(s) {}
;

pv.Mark.prototype.buildInstance = function(s) {
    this.buildProperties(s, this.binds.required);
    if (s.visible) {
        this.buildProperties(s, this.binds.optional);
        this.buildImplied(s);
    }
}
;

!function() {
    var _protoProp, _stack = pv.Mark.stack, _evalPropByType = [function(p) {
        return this.scene.defs[p.name].value;
    }
    , null, function(p) {
        return p.value;
    }
    , function(p) {
        _protoProp = p.proto || p._proto;
        return p.value.apply(this, _stack);
    }
    ];
    _evalPropByType[1] = _evalPropByType[0];
    pv.Mark.prototype.buildProperties = function(s, properties) {
        var built = pv.propBuilt
          , localBuilt = !built;
        if (localBuilt) {
            pv.propBuildMark = this;
            pv.propBuilt = built = {};
        }
        for (var protoPropBefore = _protoProp, i = 0, P = properties.length; P > i; i++) {
            var p = properties[i]
              , pname = p.name;
            if (!(pname in built)) {
                built[pname] = 1;
                s[pname] = _evalPropByType[p.type].call(this, p);
            }
        }
        _protoProp = protoPropBefore;
        localBuilt && (pv.propBuildMark = pv.propBuilt = null);
    }
    ;
    pv.Mark.prototype.evalProperty = function(p) {
        var protoPropBefore = _protoProp
          , v = _evalPropByType[p.type].call(this, p);
        _protoProp = protoPropBefore;
        return v;
    }
    ;
    pv.Mark.prototype.evalInPropertyContext = function(f, protoProp) {
        var protoPropBefore = _protoProp;
        _protoProp = protoProp;
        var v = f.apply(this, _stack);
        _protoProp = protoPropBefore;
        return v;
    }
    ;
    pv.Mark.prototype.delegate = function(dv, tag) {
        if (_protoProp && (!tag || _protoProp.tag === tag)) {
            var value = this.evalProperty(_protoProp);
            if (void 0 !== value)
                return value;
        }
        return dv;
    }
    ;
    pv.Mark.prototype.delegateExcept = function(dv, notTag) {
        if (_protoProp && (!notTag || _protoProp.tag !== notTag)) {
            var value = this.evalProperty(_protoProp);
            if (void 0 !== value)
                return value;
        }
        return dv;
    }
    ;
    pv.Mark.prototype.hasDelegate = function(tag) {
        return !(!_protoProp || tag && _protoProp.tag !== tag);
    }
    ;
}();

pv.Mark.prototype.buildImplied = function(s) {
    var parent_s, checked, l = s.left, r = s.right, t = s.top, b = s.bottom, p = this.properties, w = p.width ? s.width : 0, h = p.height ? s.height : 0;
    if (null == w || null == r || null == l) {
        parent_s = this.parent && this.parent.instance();
        checked = !0;
        var width = parent_s ? parent_s.width : w + l + r;
        null == w ? w = width - (r = r || 0) - (l = l || 0) : null == r ? null == l ? l = r = (width - w) / 2 : r = width - w - l : l = width - w - r;
    }
    if (null == h || null == b || null == t) {
        checked || (parent_s = this.parent && this.parent.instance());
        var height = parent_s ? parent_s.height : h + t + b;
        null == h ? h = height - (t = t || 0) - (b = b || 0) : null == b ? b = null == t ? t = (height - h) / 2 : height - h - t : t = height - h - b;
    }
    s.left = l;
    s.right = r;
    s.top = t;
    s.bottom = b;
    p.width && (s.width = w);
    p.height && (s.height = h);
    p.textStyle && !s.textStyle && (s.textStyle = pv.FillStyle.transparent);
    p.fillStyle && !s.fillStyle && (s.fillStyle = pv.FillStyle.transparent);
    p.strokeStyle && !s.strokeStyle && (s.strokeStyle = pv.FillStyle.transparent);
}
;

pv.Mark.prototype.mouse = function() {
    var n = this.root.canvas()
      , ev = pv.event
      , x = ev && ev.pageX || 0
      , y = ev && ev.pageY || 0
      , offset = pv.elementOffset(n);
    if (offset) {
        var getStyle = pv.cssStyle(n);
        x -= offset.left + parseFloat(getStyle("paddingLeft") || 0);
        y -= offset.top + parseFloat(getStyle("paddingTop") || 0);
    }
    var t = pv.Transform.identity
      , p = this.properties.transform ? this : this.parent
      , pz = [];
    do
        pz.push(p);
    while (p = p.parent);for (; p = pz.pop(); ) {
        var pinst = p.instance();
        t = t.translate(pinst.left, pinst.top).times(pinst.transform);
    }
    t = t.invert();
    return pv.vector(x * t.k + t.x, y * t.k + t.y);
}
;

pv.Mark.prototype.event = function(type, handler) {
    handler = pv.functor(handler);
    var hs = this.$handlers[type];
    hs ? hs instanceof Array ? hs.push(handler) : hs = [hs, handler] : hs = handler;
    this.$hasHandlers = !0;
    this.$handlers[type] = hs;
    return this;
}
;

pv.Mark.prototype.context = function(scene, index, f) {
    function apply(scene, index) {
        pv.Mark.scene = scene;
        proto.index = index;
        if (scene) {
            var i, that = scene.mark, mark = that, ancestors = [];
            do {
                ancestors.push(mark);
                stack.push(scene[index].data);
                mark.index = index;
                mark.scene = scene;
                if (mark = mark.parent) {
                    index = scene.parentIndex;
                    scene = scene.parent;
                }
            } while (mark);var k = 1;
            i = ancestors.length - 1;
            if (i > 0)
                do {
                    mark = ancestors[i--];
                    mark.scale = k;
                    k *= mark.scene[mark.index].transform.k;
                } while (i);that.scale = k;
            var n, children = that.children;
            if (children && (n = children.length) > 0) {
                var thatInst = that.scene[that.index];
                k *= thatInst.transform.k;
                var childScenes = thatInst.children;
                i = n;
                for (; i--; ) {
                    mark = children[i];
                    mark.scene = childScenes[i];
                    mark.scale = k;
                }
            }
        }
    }
    function clear(scene) {
        if (scene) {
            var mark, that = scene.mark, children = that.children;
            if (children)
                for (var i = children.length; i--; ) {
                    mark = children[i];
                    mark.scene = void 0;
                    mark.scale = 1;
                }
            mark = that;
            var parent, count = 0;
            do {
                count++;
                delete mark.index;
                if (parent = mark.parent) {
                    mark.scene = void 0;
                    mark.scale = 1;
                }
            } while (mark = parent);count && (stack.length -= count);
        }
    }
    var proto = pv.Mark.prototype
      , stack = pv.Mark.stack
      , oscene = pv.Mark.scene
      , oindex = proto.index;
    if (scene && scene === oscene && index === oindex)
        try {
            f.apply(this, stack);
        } catch (ex) {
            pv.error(ex);
            throw ex;
        } finally {
            pv.Mark.scene = oscene;
            proto.index = oindex;
        }
    else {
        clear(oscene, oindex);
        apply(scene, index);
        try {
            f.apply(this, stack);
        } catch (ex) {
            pv.error(ex);
            throw ex;
        } finally {
            clear(scene, index);
            apply(oscene, oindex);
        }
    }
}
;

pv.Mark.prototype.getEventHandler = function(type, scenes, index, ev) {
    var handler = this.$handlers[type];
    return handler ? [handler, scenes, index, ev] : this.getParentEventHandler(type, scenes, index, ev);
}
;

pv.Mark.prototype.getParentEventHandler = function(type, scenes, index, ev) {
    var parentScenes = scenes.parent;
    return parentScenes ? parentScenes.mark.getEventHandler(type, parentScenes, scenes.parentIndex, ev) : void 0;
}
;

pv.Mark.dispatch = function(type, scenes, index, event) {
    var root = scenes.mark.root;
    if (root.$transition)
        return !0;
    var handlerInfo, interceptors = root.$interceptors && root.$interceptors[type];
    if (interceptors)
        for (var i = 0, L = interceptors.length; L > i; i++) {
            handlerInfo = interceptors[i](type, event);
            if (handlerInfo)
                break;
            if (handlerInfo === !1)
                return !0;
        }
    if (!handlerInfo) {
        handlerInfo = scenes.mark.getEventHandler(type, scenes, index, event);
        if (!handlerInfo)
            return !1;
    }
    return this.handle.apply(this, handlerInfo);
}
;

pv.Mark.handle = function(handler, scenes, index, event) {
    var m = scenes.mark;
    m.context(scenes, index, function() {
        var i, L, mi, stack = pv.Mark.stack.concat(event);
        if (handler instanceof Array) {
            var ms;
            for (i = 0,
            L = handler.length; L > i; i++) {
                mi = handler[i].apply(m, stack);
                mi && mi.render && (ms || (ms = [])).push(mi);
            }
            if (ms)
                for (i = 0,
                L = ms.length; L > i; i++)
                    ms[i].render();
        } else {
            mi = handler.apply(m, stack);
            mi && mi.render && mi.render();
        }
    });
    return !0;
}
;

pv.Mark.prototype.addEventInterceptor = function(type, handler, before) {
    var root = this.root;
    if (root) {
        var ints = root.$interceptors || (root.$interceptors = {})
          , list = ints[type] || (ints[type] = []);
        before ? list.unshift(handler) : list.push(handler);
    }
}
;

pv.Mark.prototype.eachInstance = function(fun, ctx) {
    function mapRecursive(scene, level, toScreen) {
        var D = scene.length;
        if (D > 0) {
            var childIndex, isLastLevel = level === L;
            isLastLevel || (childIndex = indexes[level]);
            for (var index = 0; D > index; index++) {
                var instance = scene[index];
                if (instance.visible)
                    if (level === L)
                        fun.call(ctx, scene, index, toScreen);
                    else {
                        var childScene = instance.children[childIndex];
                        if (childScene) {
                            var childToScreen = toScreen.times(instance.transform).translate(instance.left, instance.top);
                            mapRecursive(childScene, level + 1, childToScreen);
                        }
                    }
            }
        }
    }
    for (var mark = this, indexes = []; mark.parent; ) {
        indexes.unshift(mark.childIndex);
        mark = mark.parent;
    }
    var rootScene = mark.scene;
    if (rootScene) {
        var L = indexes.length;
        mapRecursive(rootScene, 0, pv.Transform.identity);
    }
}
;

pv.Mark.prototype.toScreenTransform = function() {
    var t = pv.Transform.identity;
    this instanceof pv.Panel && (t = t.translate(this.left(), this.top()).times(this.transform()));
    var parent = this.parent;
    if (parent)
        do
            t = t.translate(parent.left(), parent.top()).times(parent.transform());
        while (parent = parent.parent);return t;
}
;

pv.Mark.prototype.transition = function() {
    return new pv.Transition(this);
}
;

pv.Mark.prototype.on = function(state) {
    return this["$" + state] = new pv.Transient(this);
}
;

pv.Mark.prototype.getShape = function(scenes, index, inset) {
    var s = scenes[index];
    if (!s.visible)
        return null;
    null == inset && (inset = 0);
    var key = "_shape_inset_" + inset;
    return s[key] || (s[key] = this.getShapeCore(scenes, index, inset));
}
;

pv.Mark.prototype.getShapeCore = function(scenes, index, inset) {
    var s = scenes[index]
      , l = s.left
      , t = s.top
      , w = s.width
      , h = s.height;
    if (inset > 0 && 1 >= inset) {
        var dw = inset * w
          , dh = inset * h;
        l += dw;
        t += dh;
        w -= 2 * dw;
        h -= 2 * dh;
    }
    return new pv.Shape.Rect(l,t,w,h);
}
;

pv.Mark.prototype.pointingRadiusMax = function(value) {
    if (arguments.length) {
        value = +value;
        this._pointingRadiusMax = isNaN(value) || 0 > value ? 0 : value;
        return this;
    }
    return this._pointingRadiusMax;
}
;

pv.Mark.prototype._pointingRadiusMax = 1 / 0;

pv.Anchor = function(target) {
    pv.Mark.call(this);
    this.target = target;
    this.parent = target.parent;
}
;

pv.Anchor.prototype = pv.extend(pv.Mark).property("name", String);

pv.Anchor.prototype.extend = function(proto) {
    this.proto = proto;
    return this;
}
;

pv.Area = function() {
    pv.Mark.call(this);
}
;

pv.Area.castSegmented = function(v) {
    if (!v)
        return "";
    v = String(v).toLowerCase();
    switch (v) {
    case "smart":
    case "full":
        break;

    default:
        v = "full";
    }
    return v;
}
;

pv.Area.prototype = pv.extend(pv.Mark).property("width", Number).property("height", Number).property("lineWidth", Number).property("lineJoin", pv.stringLowerCase).property("strokeMiterLimit", Number).property("lineCap", pv.stringLowerCase).property("strokeDasharray", pv.stringLowerCase).property("strokeStyle", pv.fillStyle).property("fillStyle", pv.fillStyle).property("segmented", pv.Area.castSegmented).property("interpolate", pv.stringLowerCase).property("tension", Number);

pv.Area.prototype.type = "area";

pv.Area.prototype.defaults = new pv.Area().extend(pv.Mark.prototype.defaults).lineWidth(1.5).fillStyle(pv.Colors.category20().by(pv.parent)).interpolate("linear").tension(.7).lineJoin("miter").strokeMiterLimit(8).lineCap("butt").strokeDasharray("none");

pv.Area.prototype.buildImplied = function(s) {
    null == s.height && (s.height = 0);
    null == s.width && (s.width = 0);
    pv.Mark.prototype.buildImplied.call(this, s);
}
;

pv.Area.fixed = {
    lineWidth: 1,
    lineJoin: 1,
    strokeMiterLimit: 1,
    lineCap: 1,
    strokeStyle: 1,
    strokeDasharray: 1,
    fillStyle: 1,
    segmented: 1,
    interpolate: 1,
    tension: 1
};

pv.Area.prototype.bind = function() {
    pv.Mark.prototype.bind.call(this);
    for (var binds = this.binds, required = binds.required, optional = binds.optional, i = 0, n = optional.length; n > i; i++) {
        var p = optional[i];
        p.fixed = p.name in pv.Area.fixed;
        if ("segmented" == p.name) {
            required.push(p);
            optional.splice(i, 1);
            i--;
            n--;
        }
    }
    this.binds.$required = required;
    this.binds.$optional = optional;
}
;

pv.Area.prototype.buildInstance = function(s) {
    function f(p) {
        return !p.fixed || (fixed.push(p),
        !1);
    }
    var binds = this.binds;
    if (this.index) {
        var fixed = binds.fixed;
        if (!fixed) {
            fixed = binds.fixed = [];
            binds.required = binds.required.filter(f);
            this.scene[0].segmented || (binds.optional = binds.optional.filter(f));
        }
        var n = fixed.length;
        if (n)
            for (var firstScene = this.scene[0], i = 0; n > i; i++) {
                var p = fixed[i].name;
                s[p] = firstScene[p];
            }
    } else {
        binds.required = binds.$required;
        binds.optional = binds.$optional;
        binds.fixed = null;
    }
    pv.Mark.prototype.buildInstance.call(this, s);
}
;

pv.Area.prototype.anchor = function(name) {
    return pv.Mark.prototype.anchor.call(this, name).interpolate(function() {
        return this.scene.target[this.index].interpolate;
    }).eccentricity(function() {
        return this.scene.target[this.index].eccentricity;
    }).tension(function() {
        return this.scene.target[this.index].tension;
    });
}
;

pv.Area.prototype.getEventHandler = function(type, scene, index, ev) {
    var s = scene[index]
      , needEventSimulation = 1 === pv.Scene.mousePositionEventSet[type] && (!s.segmented || "smart" === s.segmented);
    if (!needEventSimulation)
        return pv.Mark.prototype.getEventHandler.call(this, type, scene, index, ev);
    var mouseIndex, handlerMouseOver = "mousemove" === type ? this.$handlers.mouseover : null, handler = this.$handlers[type], handlers = handler || handlerMouseOver;
    if (handlers) {
        mouseIndex = this.getNearestInstanceToMouse(scene, index);
        if (handlerMouseOver && !this.filterMouseMove(scene, mouseIndex)) {
            handlerMouseOver = null;
            handlers = handler;
        }
    }
    if (!handlers)
        return this.getParentEventHandler(type, scene, index, ev);
    handler && handlerMouseOver && (handlers = [].concat(handler, handlerMouseOver));
    return [handlers, scene, mouseIndex, ev];
}
;

pv.Area.prototype.filterMouseMove = function(scene, mouseIndex) {
    var prevMouseOverScene = this._mouseOverScene;
    if (!prevMouseOverScene || prevMouseOverScene !== scene || this._mouseOverIndex !== mouseIndex) {
        this._mouseOverScene = scene;
        this._mouseOverIndex = mouseIndex;
        return !0;
    }
}
;

pv.Area.prototype.getNearestInstanceToMouse = function(scene, eventIndex) {
    for (var p = this.mouse(), minDist2 = 1 / 0, minIndex = null, index = eventIndex, L = scene.length; L > index; index++) {
        var shape = this.getShape(scene, index);
        if (shape) {
            if (shape.containsPoint(p))
                return index;
            var dist2 = shape.distance2(p).dist2;
            if (minDist2 > dist2) {
                minDist2 = dist2;
                minIndex = index;
            }
        }
    }
    return null != minIndex ? minIndex : eventIndex;
}
;

pv.Area.prototype.getShapeCore = function(scenes, index) {
    var s = scenes[index]
      , w = s.width || 0
      , h = s.height || 0
      , x = s.left
      , y = s.top
      , s2 = index + 1 < scenes.length ? scenes[index + 1] : null;
    if (!s2 || !s2.visible)
        return new pv.Shape.Line(x,y,x + w,y + h);
    var x2 = s2.left
      , y2 = s2.top
      , h2 = s2.height || 0
      , w2 = s2.width || 0;
    return new pv.Shape.Polygon([new pv.Vector(x,y), new pv.Vector(x2,y2), new pv.Vector(x2 + w2,y2 + h2), new pv.Vector(x + w,y + h)]);
}
;

pv.Bar = function() {
    pv.Mark.call(this);
}
;

pv.Bar.prototype = pv.extend(pv.Mark).property("width", Number).property("height", Number).property("lineWidth", Number).property("strokeStyle", pv.fillStyle).property("fillStyle", pv.fillStyle).property("lineCap", pv.stringLowerCase).property("strokeDasharray", pv.stringLowerCase);

pv.Bar.prototype.type = "bar";

pv.Bar.prototype.defaults = new pv.Bar().extend(pv.Mark.prototype.defaults).lineWidth(1.5).fillStyle(pv.Colors.category20().by(pv.parent)).lineCap("butt").strokeDasharray("none");

pv.Dot = function() {
    pv.Mark.call(this);
}
;

pv.Dot.prototype = pv.extend(pv.Mark).property("shape", pv.stringLowerCase).property("shapeAngle", Number).property("shapeRadius", Number).property("shapeSize", Number).property("aspectRatio", Number).property("lineWidth", Number).property("strokeStyle", pv.fillStyle).property("lineCap", pv.stringLowerCase).property("strokeDasharray", pv.stringLowerCase).property("fillStyle", pv.fillStyle);

pv.Dot.prototype.type = "dot";

pv.Dot.prototype.defaults = new pv.Dot().extend(pv.Mark.prototype.defaults).shape("circle").aspectRatio(1).lineWidth(1.5).strokeStyle(pv.Colors.category10().by(pv.parent)).lineCap("butt").strokeDasharray("none");

pv.Dot.prototype.anchor = function(name) {
    return pv.Mark.prototype.anchor.call(this, name).left(function() {
        var s = this.scene.target[this.index];
        switch (this.name()) {
        case "bottom":
        case "top":
        case "center":
            return s.left;

        case "left":
            return null;
        }
        return s.left + s._width / 2;
    }).right(function() {
        var s = this.scene.target[this.index];
        return "left" == this.name() ? s.right + s._width / 2 : null;
    }).top(function() {
        var s = this.scene.target[this.index];
        switch (this.name()) {
        case "left":
        case "right":
        case "center":
            return s.top;

        case "top":
            return null;
        }
        return s.top + s._height / 2;
    }).bottom(function() {
        var s = this.scene.target[this.index];
        return "top" == this.name() ? s.bottom + s._height / 2 : null;
    }).textAlign(function() {
        switch (this.name()) {
        case "left":
            return "right";

        case "bottom":
        case "top":
        case "center":
            return "center";
        }
        return "left";
    }).textBaseline(function() {
        switch (this.name()) {
        case "right":
        case "left":
        case "center":
            return "middle";

        case "bottom":
            return "top";
        }
        return "bottom";
    });
}
;

pv.Dot.prototype.buildImplied = function(s) {
    var r = s.shapeRadius
      , z = s.shapeSize
      , a = s.aspectRatio || 1;
    if (null == r)
        if (null == z) {
            z = s.shapeSize = 20.25;
            r = s.shapeRadius = 4.5;
        } else
            r = s.shapeRadius = Math.sqrt(z);
    else
        null == z && (z = s.shapeSize = r * r);
    var h, w;
    if (1 === a || 0 > a)
        h = w = 2 * r;
    else {
        h = 2 * r / Math.sqrt(a);
        w = a * h;
    }
    s._height = h;
    s._width = w;
    pv.Mark.prototype.buildImplied.call(this, s);
}
;

pv.Dot.prototype.width = function() {
    return this.instance()._width;
}
;

pv.Dot.prototype.height = function() {
    return this.instance()._height;
}
;

pv.Dot.prototype.getShapeCore = function(scenes, index) {
    var s = scenes[index]
      , h = s._width
      , w = s._height
      , cx = s.left
      , cy = s.top;
    switch (s.shape) {
    case "diamond":
        h *= Math.SQRT2;
        w *= Math.SQRT2;

    case "square":
    case "cross":
        return new pv.Shape.Rect(cx - w / 2,cy - h / 2,w,h);
    }
    return new pv.Shape.Circle(cx,cy,s.shapeRadius);
}
;

pv.Label = function() {
    pv.Mark.call(this);
}
;

pv.Label.prototype = pv.extend(pv.Mark).property("text", String).property("font", String).property("textAngle", Number).property("textStyle", pv.color).property("textAlign", pv.stringLowerCase).property("textBaseline", pv.stringLowerCase).property("textMargin", Number).property("textDecoration", String).property("textShadow", String);

pv.Label.prototype.type = "label";

pv.Label.prototype.defaults = new pv.Label().extend(pv.Mark.prototype.defaults).events("none").text(pv.identity).font("10px sans-serif").textAngle(0).textStyle("black").textAlign("left").textBaseline("bottom").textMargin(3);

pv.Label.prototype.getShapeCore = function(scenes, index, inset) {
    var s = scenes[index]
      , size = pv.Text.measure(s.text, s.font)
      , l = s.left
      , t = s.top
      , w = size.width
      , h = size.height;
    if (inset > 0 && 1 >= inset) {
        var dw = inset * w
          , dh = inset * h;
        l += dw;
        t += dh;
        w -= 2 * dw;
        h -= 2 * dh;
    }
    return pv.Label.getPolygon(w, h, s.textAlign, s.textBaseline, s.textAngle, s.textMargin).apply(pv.Transform.identity.translate(l, t));
}
;

pv.Label.getPolygon = function(textWidth, textHeight, align, baseline, angle, margin) {
    var x, y;
    switch (baseline) {
    case "middle":
        y = textHeight / 2;
        break;

    case "top":
        y = margin + textHeight;
        break;

    case "bottom":
        y = -margin;
    }
    switch (align) {
    case "right":
        x = -margin - textWidth;
        break;

    case "center":
        x = -textWidth / 2;
        break;

    case "left":
        x = margin;
    }
    var bl = new pv.Vector(x,y)
      , br = bl.plus(textWidth, 0)
      , tr = br.plus(0, -textHeight)
      , tl = bl.plus(0, -textHeight);
    if (0 !== angle) {
        bl = bl.rotate(angle);
        br = br.rotate(angle);
        tl = tl.rotate(angle);
        tr = tr.rotate(angle);
    }
    return new pv.Shape.Polygon([bl, br, tr, tl]);
}
;

pv.Line = function() {
    pv.Mark.call(this);
}
;

pv.Line.prototype = pv.extend(pv.Mark).property("lineWidth", Number).property("lineJoin", pv.stringLowerCase).property("strokeMiterLimit", Number).property("lineCap", pv.stringLowerCase).property("strokeStyle", pv.fillStyle).property("strokeDasharray", pv.stringLowerCase).property("fillStyle", pv.fillStyle).property("segmented", pv.Area.castSegmented).property("interpolate", pv.stringLowerCase).property("eccentricity", Number).property("tension", Number);

pv.Line.prototype.type = "line";

pv.Line.prototype.defaults = new pv.Line().extend(pv.Mark.prototype.defaults).lineWidth(1.5).strokeStyle(pv.Colors.category10().by(pv.parent)).interpolate("linear").eccentricity(0).tension(.7).lineJoin("miter").strokeMiterLimit(8).lineCap("butt").strokeDasharray("none");

pv.Line.prototype.bind = pv.Area.prototype.bind;

pv.Line.prototype.buildInstance = pv.Area.prototype.buildInstance;

pv.Line.prototype.getEventHandler = pv.Area.prototype.getEventHandler;

pv.Line.prototype.getNearestInstanceToMouse = pv.Area.prototype.getNearestInstanceToMouse;

pv.Line.prototype.filterMouseMove = pv.Area.prototype.filterMouseMove;

pv.Line.prototype.anchor = function(name) {
    return pv.Area.prototype.anchor.call(this, name).textAlign(function(d) {
        switch (this.name()) {
        case "left":
            return "right";

        case "bottom":
        case "top":
        case "center":
            return "center";

        case "right":
            return "left";
        }
    }).textBaseline(function(d) {
        switch (this.name()) {
        case "right":
        case "left":
        case "center":
            return "middle";

        case "top":
            return "bottom";

        case "bottom":
            return "top";
        }
    });
}
;

pv.Line.prototype.getShapeCore = function(scenes, index) {
    var s = scenes[index]
      , s2 = index + 1 < scenes.length ? scenes[index + 1] : null;
    return null != s2 && s2.visible ? new pv.Shape.Line(s.left,s.top,s2.left,s2.top) : new pv.Shape.Point(s.left,s.top);
}
;

pv.Rule = function() {
    pv.Mark.call(this);
}
;

pv.Rule.prototype = pv.extend(pv.Mark).property("width", Number).property("height", Number).property("lineWidth", Number).property("strokeStyle", pv.fillStyle).property("lineCap", pv.stringLowerCase).property("strokeDasharray", pv.stringLowerCase);

pv.Rule.prototype.type = "rule";

pv.Rule.prototype.defaults = new pv.Rule().extend(pv.Mark.prototype.defaults).lineWidth(1).strokeStyle("black").antialias(!1).lineCap("butt").strokeDasharray("none");

pv.Rule.prototype.anchor = pv.Line.prototype.anchor;

pv.Rule.prototype.buildImplied = function(s) {
    var l = s.left
      , r = s.right;
    s.top,
    s.bottom;
    null != s.width || null == l && null == r || null != r && null != l ? s.height = 0 : s.width = 0;
    pv.Mark.prototype.buildImplied.call(this, s);
}
;

pv.Rule.prototype.getShapeCore = function(scenes, index) {
    var s = scenes[index];
    return new pv.Shape.Line(s.left,s.top,s.left + s.width,s.top + s.height);
}
;

pv.Panel = function() {
    pv.Bar.call(this);
    this.children = [];
    this.root = this;
    this.$dom = pv.$ && pv.$.s;
}
;

pv.Panel.prototype = pv.extend(pv.Bar).property("transform").property("overflow", pv.stringLowerCase).property("canvas", function(c) {
    return "string" == typeof c ? document.getElementById(c) : c;
});

pv.Panel.prototype.type = "panel";

pv.Panel.prototype.isPointingBarrier = !1;

pv.Panel.prototype._zOrderChildCount = 0;

pv.Panel.prototype.defaults = new pv.Panel().extend(pv.Bar.prototype.defaults).fillStyle(null).overflow("visible");

pv.Panel.prototype.anchor = function(name) {
    var anchor = pv.Bar.prototype.anchor.call(this, name);
    anchor.parent = this;
    return anchor;
}
;

pv.Panel.prototype.add = function(Type) {
    var child = new Type();
    child.parent = this;
    child.root = this.root;
    child.childIndex = this.children.length;
    this.children.push(child);
    var zOrder = +child._zOrder || 0;
    0 !== zOrder && this._zOrderChildCount++;
    return child;
}
;

pv.Panel.prototype.bind = function() {
    pv.Mark.prototype.bind.call(this);
    for (var children = this.children, i = 0, n = children.length; n > i; i++)
        children[i].bind();
}
;

pv.Panel.prototype.buildInstance = function(s) {
    pv.Bar.prototype.buildInstance.call(this, s);
    if (s.visible) {
        var scale = this.scale * s.transform.k;
        pv.Mark.prototype.index = -1;
        for (var child, children = this.children, childScenes = s.children || (s.children = []), i = 0, n = children.length; n > i; i++) {
            child = children[i];
            child.scene = childScenes[i];
            child.scale = scale;
            child.build();
        }
        i = n;
        for (; i--; ) {
            child = children[i];
            childScenes[i] = child.scene;
            delete child.scene;
            delete child.scale;
        }
        childScenes.length = n;
    }
}
;

pv.Panel.prototype.buildImplied = function(s) {
    if (this.parent || this._buildRootInstanceImplied(s)) {
        s.transform || (s.transform = pv.Transform.identity);
        pv.Mark.prototype.buildImplied.call(this, s);
    } else
        s.visible = !1;
}
;

pv.Panel.prototype._buildRootInstanceImplied = function(s) {
    var c = s.canvas;
    if (c) {
        if (!this._rootInstanceStealCanvas(s, c))
            return !1;
        this._rootInstanceInitCanvas(s, c);
    } else
        s.canvas = this._rootInstanceGetInlineCanvas(s);
    return !0;
}
;

pv.Panel.prototype._rootInstanceStealCanvas = function(s, c) {
    var cPanel = c.$panel;
    if (cPanel !== this) {
        if (cPanel) {
            if (this.$lastCreateId)
                return !1;
            cPanel._disposeRootPanel();
            this._updateCreateId(c);
        }
        c.$panel = this;
        pv.removeChildren(c);
    } else
        this._updateCreateId(c);
    return !0;
}
;

pv.Panel.prototype._registerBoundEvent = function(source, name, listener, capturePhase) {
    if (source.removeEventListener) {
        var boundEvents = this._boundEvents || (this._boundEvents = []);
        boundEvents.push([source, name, listener, capturePhase]);
    }
}
;

pv.Panel.prototype.dispose = function() {
    var root = this.root;
    root._disposeRootPanel();
    var canvas = root.canvas();
    root.canvas(null);
    canvas.$panel = null;
    root.binds = null;
    var scene = root.scene;
    if (scene) {
        scene.$defs = null;
        scene.$g = null;
        root.scene = null;
    }
}
;

pv.Panel.prototype._disposeRootPanel = function() {
    var t = this.$transition;
    t && t.stop();
    var boundEvents = this._boundEvents;
    if (boundEvents) {
        this._boundEvents = null;
        for (var i = 0, L = boundEvents.length; L > i; i++) {
            var be = boundEvents[i];
            be[0].removeEventListener(be[1], be[2], be[3]);
        }
    }
}
;

pv.Panel.prototype._rootInstanceInitCanvas = function(s, c) {
    var w, h, cssStyle;
    if (null == s.width) {
        cssStyle = pv.cssStyle(c);
        w = parseFloat(cssStyle("width") || 0);
        s.width = w - s.left - s.right;
    }
    if (null == s.height) {
        cssStyle || (cssStyle = pv.cssStyle(c));
        h = parseFloat(cssStyle("height") || 0);
        s.height = h - s.top - s.bottom;
    }
    cssStyle = null;
}
;

pv.Panel.prototype._rootInstanceGetInlineCanvas = function(s) {
    var c, cache = this.$canvas || (this.$canvas = []);
    if (!(c = cache[this.index])) {
        c = cache[this.index] = document.createElement("span");
        if (this.$dom)
            this.$dom.parentNode.insertBefore(c, this.$dom);
        else {
            for (var n = document.body; n.lastChild && n.lastChild.tagName; )
                n = n.lastChild;
            n != document.body && (n = n.parentNode);
            n.appendChild(c);
        }
    }
    return c;
}
;

pv.Panel.prototype._updateCreateId = function(c) {
    this.$lastCreateId = c.$pvCreateId = (c.$pvCreateId || 0) + 1;
}
;

pv.Image = function() {
    pv.Bar.call(this);
}
;

pv.Image.prototype = pv.extend(pv.Bar).property("url", String).property("imageWidth", Number).property("imageHeight", Number);

pv.Image.prototype.type = "image";

pv.Image.prototype.defaults = new pv.Image().extend(pv.Bar.prototype.defaults).fillStyle(null);

pv.Image.prototype.image = function(f) {
    this.$image = function() {
        var c = f.apply(this, arguments);
        return null == c ? pv.Color.transparent : "string" == typeof c ? pv.color(c) : c;
    }
    ;
    return this;
}
;

pv.Image.prototype.bind = function() {
    pv.Bar.prototype.bind.call(this);
    var binds = this.binds
      , mark = this;
    do
        binds.image = mark.$image;
    while (!binds.image && (mark = mark.proto));
}
;

pv.Image.prototype.buildImplied = function(s) {
    pv.Bar.prototype.buildImplied.call(this, s);
    if (s.visible) {
        null == s.imageWidth && (s.imageWidth = s.width);
        null == s.imageHeight && (s.imageHeight = s.height);
        if (null == s.url && this.binds.image) {
            var data, canvas = this.$canvas || (this.$canvas = document.createElement("canvas")), context = canvas.getContext("2d"), w = s.imageWidth, h = s.imageHeight, stack = pv.Mark.stack;
            canvas.width = w;
            canvas.height = h;
            data = (s.image = context.createImageData(w, h)).data;
            stack.unshift(null, null);
            for (var y = 0, p = 0; h > y; y++) {
                stack[1] = y;
                for (var x = 0; w > x; x++) {
                    stack[0] = x;
                    var color = this.binds.image.apply(this, stack);
                    data[p++] = color.r;
                    data[p++] = color.g;
                    data[p++] = color.b;
                    data[p++] = 255 * color.a;
                }
            }
            stack.splice(0, 2);
        }
    }
}
;

pv.Wedge = function() {
    pv.Mark.call(this);
}
;

pv.Wedge.prototype = pv.extend(pv.Mark).property("startAngle", Number).property("endAngle", Number).property("angle", Number).property("innerRadius", Number).property("outerRadius", Number).property("lineWidth", Number).property("strokeStyle", pv.fillStyle).property("lineJoin", pv.stringLowerCase).property("strokeMiterLimit", Number).property("lineCap", pv.stringLowerCase).property("strokeDasharray", pv.stringLowerCase).property("fillStyle", pv.fillStyle);

pv.Wedge.prototype.type = "wedge";

pv.Wedge.prototype.defaults = new pv.Wedge().extend(pv.Mark.prototype.defaults).startAngle(function() {
    var s = this.sibling();
    return s ? s.endAngle : -Math.PI / 2;
}).innerRadius(0).lineWidth(1.5).strokeStyle(null).fillStyle(pv.Colors.category20().by(pv.index)).lineJoin("miter").strokeMiterLimit(8).lineCap("butt").strokeDasharray("none");

pv.Wedge.prototype.midRadius = function() {
    return (this.innerRadius() + this.outerRadius()) / 2;
}
;

pv.Wedge.prototype.midAngle = function() {
    return (this.startAngle() + this.endAngle()) / 2;
}
;

pv.Wedge.prototype.anchor = function(name) {
    function partial(s) {
        return s.innerRadius || s.angle < 2 * Math.PI;
    }
    function midRadius(s) {
        return (s.innerRadius + s.outerRadius) / 2;
    }
    function midAngle(s) {
        return (s.startAngle + s.endAngle) / 2;
    }
    return pv.Mark.prototype.anchor.call(this, name).left(function() {
        var s = this.scene.target[this.index];
        if (partial(s))
            switch (this.name()) {
            case "outer":
                return s.left + s.outerRadius * Math.cos(midAngle(s));

            case "inner":
                return s.left + s.innerRadius * Math.cos(midAngle(s));

            case "start":
                return s.left + midRadius(s) * Math.cos(s.startAngle);

            case "center":
                return s.left + midRadius(s) * Math.cos(midAngle(s));

            case "end":
                return s.left + midRadius(s) * Math.cos(s.endAngle);
            }
        return s.left;
    }).top(function() {
        var s = this.scene.target[this.index];
        if (partial(s))
            switch (this.name()) {
            case "outer":
                return s.top + s.outerRadius * Math.sin(midAngle(s));

            case "inner":
                return s.top + s.innerRadius * Math.sin(midAngle(s));

            case "start":
                return s.top + midRadius(s) * Math.sin(s.startAngle);

            case "center":
                return s.top + midRadius(s) * Math.sin(midAngle(s));

            case "end":
                return s.top + midRadius(s) * Math.sin(s.endAngle);
            }
        return s.top;
    }).textAlign(function() {
        var s = this.scene.target[this.index];
        if (partial(s))
            switch (this.name()) {
            case "outer":
                return pv.Wedge.upright(midAngle(s)) ? "right" : "left";

            case "inner":
                return pv.Wedge.upright(midAngle(s)) ? "left" : "right";
            }
        return "center";
    }).textBaseline(function() {
        var s = this.scene.target[this.index];
        if (partial(s))
            switch (this.name()) {
            case "start":
                return pv.Wedge.upright(s.startAngle) ? "top" : "bottom";

            case "end":
                return pv.Wedge.upright(s.endAngle) ? "bottom" : "top";
            }
        return "middle";
    }).textAngle(function() {
        var s = this.scene.target[this.index]
          , a = 0;
        if (partial(s))
            switch (this.name()) {
            case "center":
            case "inner":
            case "outer":
                a = midAngle(s);
                break;

            case "start":
                a = s.startAngle;
                break;

            case "end":
                a = s.endAngle;
            }
        return pv.Wedge.upright(a) ? a : a + Math.PI;
    });
}
;

pv.Wedge.upright = function(angle) {
    angle %= 2 * Math.PI;
    angle = 0 > angle ? 2 * Math.PI + angle : angle;
    return angle < Math.PI / 2 || angle >= 3 * Math.PI / 2;
}
;

pv.Wedge.prototype.buildImplied = function(s) {
    null == s.angle ? s.angle = s.endAngle - s.startAngle : null == s.endAngle && (s.endAngle = s.startAngle + s.angle);
    pv.Mark.prototype.buildImplied.call(this, s);
}
;

pv.Wedge.prototype.getShapeCore = function(scenes, index) {
    var s = scenes[index];
    return new pv.Shape.Wedge(s.left,s.top,s.innerRadius,s.outerRadius,s.startAngle,s.angle);
}
;

pv.Ease = function() {
    function reverse(f) {
        return function(t) {
            return 1 - f(1 - t);
        }
        ;
    }
    function reflect(f) {
        return function(t) {
            return .5 * (.5 > t ? f(2 * t) : 2 - f(2 - 2 * t));
        }
        ;
    }
    function poly(e) {
        return function(t) {
            return 0 > t ? 0 : t > 1 ? 1 : Math.pow(t, e);
        }
        ;
    }
    function sin(t) {
        return 1 - Math.cos(t * Math.PI / 2);
    }
    function exp(t) {
        return t ? Math.pow(2, 10 * (t - 1)) - .001 : 0;
    }
    function circle(t) {
        return -(Math.sqrt(1 - t * t) - 1);
    }
    function elastic(a, p) {
        var s;
        p || (p = .45);
        if (!a || 1 > a) {
            a = 1;
            s = p / 4;
        } else
            s = p / (2 * Math.PI) * Math.asin(1 / a);
        return function(t) {
            return 0 >= t || t >= 1 ? t : -(a * Math.pow(2, 10 * --t) * Math.sin(2 * (t - s) * Math.PI / p));
        }
        ;
    }
    function back(s) {
        s || (s = 1.70158);
        return function(t) {
            return t * t * ((s + 1) * t - s);
        }
        ;
    }
    function bounce(t) {
        return 1 / 2.75 > t ? 7.5625 * t * t : 2 / 2.75 > t ? 7.5625 * (t -= 1.5 / 2.75) * t + .75 : 2.5 / 2.75 > t ? 7.5625 * (t -= 2.25 / 2.75) * t + .9375 : 7.5625 * (t -= 2.625 / 2.75) * t + .984375;
    }
    var quad = poly(2)
      , cubic = poly(3)
      , elasticDefault = elastic()
      , backDefault = back()
      , eases = {
        linear: pv.identity,
        "quad-in": quad,
        "quad-out": reverse(quad),
        "quad-in-out": reflect(quad),
        "quad-out-in": reflect(reverse(quad)),
        "cubic-in": cubic,
        "cubic-out": reverse(cubic),
        "cubic-in-out": reflect(cubic),
        "cubic-out-in": reflect(reverse(cubic)),
        "sin-in": sin,
        "sin-out": reverse(sin),
        "sin-in-out": reflect(sin),
        "sin-out-in": reflect(reverse(sin)),
        "exp-in": exp,
        "exp-out": reverse(exp),
        "exp-in-out": reflect(exp),
        "exp-out-in": reflect(reverse(exp)),
        "circle-in": circle,
        "circle-out": reverse(circle),
        "circle-in-out": reflect(circle),
        "circle-out-in": reflect(reverse(circle)),
        "elastic-in": elasticDefault,
        "elastic-out": reverse(elasticDefault),
        "elastic-in-out": reflect(elasticDefault),
        "elastic-out-in": reflect(reverse(elasticDefault)),
        "back-in": backDefault,
        "back-out": reverse(backDefault),
        "back-in-out": reflect(backDefault),
        "back-out-in": reflect(reverse(backDefault)),
        "bounce-in": bounce,
        "bounce-out": reverse(bounce),
        "bounce-in-out": reflect(bounce),
        "bounce-out-in": reflect(reverse(bounce))
    };
    pv.ease = function(f) {
        return eases[f];
    }
    ;
    return {
        reverse: reverse,
        reflect: reflect,
        linear: function() {
            return pv.identity;
        },
        sin: function() {
            return sin;
        },
        exp: function() {
            return exp;
        },
        circle: function() {
            return circle;
        },
        elastic: elastic,
        back: back,
        bounce: bounce,
        poly: poly
    };
}();

pv.Transient = function(mark) {
    pv.Mark.call(this);
    this.fillStyle(null).strokeStyle(null).textStyle(null);
    this.on = function(state) {
        return mark.on(state);
    }
    ;
}
;

pv.Transient.prototype = pv.extend(pv.Mark);

!function() {
    function ids(scene) {
        for (var map = {}, i = scene.length; i--; ) {
            var s = scene[i]
              , id = s.id;
            id && (map[id] = s);
        }
        return map;
    }
    function interpolateProperty(list, name, before, after) {
        var step;
        if (name in _interpolated) {
            var interp = pv.Scale.interpolator(before[name], after[name]);
            step = function(t) {
                before[name] = interp(t);
            }
            ;
        } else
            step = function(t) {
                t > .5 && (before[name] = after[name]);
            }
            ;
        step.next = list.head;
        list.head = step;
    }
    function interpolateInstance(list, beforeInst, afterInst) {
        for (var name in beforeInst)
            "children" !== name && beforeInst[name] != afterInst[name] && interpolateProperty(list, name, beforeInst, afterInst);
        var beforeChildScenes = beforeInst.children;
        if (beforeChildScenes)
            for (var afterChildScenes = afterInst.children, j = 0, L = beforeChildScenes.length; L > j; j++)
                interpolate(list, beforeChildScenes[j], afterChildScenes[j]);
    }
    function overrideInstance(scene, index, proto, other) {
        var t, otherInst = Object.create(scene[index]), m = scene.mark, rs = m.root.scene;
        if (other.target && (t = other.target[other.length])) {
            scene = Object.create(scene);
            scene.target = Object.create(other.target);
            scene.target[index] = t;
        }
        proto || (proto = _defaults);
        var ps = proto.$properties
          , overriden = proto.$propertiesMap;
        ps = m.binds.optional.filter(function(p) {
            return !(p.name in overriden);
        }).concat(ps);
        m.context(scene, index, function() {
            this.buildProperties(otherInst, ps);
            this.buildImplied(otherInst);
        });
        m.root.scene = rs;
        return otherInst;
    }
    function interpolate(list, before, after) {
        for (var beforeInst, afterInst, mark = before.mark, beforeById = ids(before), afterById = ids(after), i = 0, L = before.length; L > i; i++) {
            beforeInst = before[i];
            afterInst = beforeInst.id ? afterById[beforeInst.id] : after[i];
            beforeInst.index = i;
            if (beforeInst.visible) {
                if (!afterInst || !afterInst.visible) {
                    var overridenAfterInst = overrideInstance(before, i, mark.$exit, after);
                    beforeInst.transition = afterInst ? 2 : (after.push(overridenAfterInst),
                    1);
                    afterInst = overridenAfterInst;
                }
                interpolateInstance(list, beforeInst, afterInst);
            }
        }
        i = 0;
        L = after.length;
        for (; L > i; i++) {
            afterInst = after[i];
            beforeInst = afterInst.id ? beforeById[afterInst.id] : before[i];
            if ((!beforeInst || !beforeInst.visible) && afterInst.visible) {
                var overridenBeforeInst = overrideInstance(after, i, mark.$enter, before);
                beforeInst ? before[beforeInst.index] = overridenBeforeInst : before.push(overridenBeforeInst);
                interpolateInstance(list, overridenBeforeInst, afterInst);
            }
        }
    }
    function cleanup(scene) {
        for (var i = 0, j = 0; i < scene.length; i++) {
            var s = scene[i];
            if (1 != s.transition) {
                scene[j++] = s;
                2 == s.transition && (s.visible = !1);
                s.children && s.children.forEach(cleanup);
            }
        }
        scene.length = j;
    }
    var _interpolated = {
        top: 1,
        left: 1,
        right: 1,
        bottom: 1,
        width: 1,
        height: 1,
        innerRadius: 1,
        outerRadius: 1,
        radius: 1,
        shapeRadius: 1,
        shapeSize: 1,
        startAngle: 1,
        endAngle: 1,
        angle: 1,
        fillStyle: 1,
        strokeStyle: 1,
        lineWidth: 1,
        eccentricity: 1,
        tension: 1,
        textAngle: 1,
        textStyle: 1,
        textMargin: 1
    }
      , _defaults = new pv.Transient();
    pv.Transition = function(mark) {
        function doEnd(success) {
            var started = mark.root.$transition === that;
            started && (mark.root.$transition = null);
            if (null != timer) {
                clearInterval(timer);
                timer = null;
            }
            started && cleanupOnce(mark.scene);
            if (onEndCallback) {
                var cb = onEndCallback;
                onEndCallback = null;
                cb(success);
            }
            return success;
        }
        var timer, onEndCallback, cleanedup, that = this, ease = pv.ease("cubic-in-out"), duration = 250, cleanupOnce = function(scene) {
            if (!cleanedup) {
                cleanedup = !0;
                cleanup(scene);
            }
        };
        that.ease = function(x) {
            return arguments.length ? (ease = "function" == typeof x ? x : pv.ease(x),
            that) : ease;
        }
        ;
        that.duration = function(x) {
            return arguments.length ? (duration = Number(x),
            that) : duration;
        }
        ;
        that.start = function(onEnd) {
            if (mark.parent)
                throw new Error("Animated partial rendering is not supported.");
            onEndCallback = onEnd;
            var root = mark.root;
            if (root.$transition)
                try {
                    root.$transition.stop();
                } catch (ex) {
                    return doEnd(!1);
                }
            var list, start;
            root.$transition = that;
            root._renderId++;
            var before = mark.scene;
            mark.scene = null;
            var i0 = pv.Mark.prototype.index;
            try {
                mark.bind();
                mark.build();
                var after = mark.scene;
                mark.scene = before;
                pv.Mark.prototype.index = i0;
                start = Date.now();
                list = {};
                interpolate(list, before, after);
            } catch (ex) {
                pv.Mark.prototype.index = i0;
                return doEnd(!1);
            }
            if (!list.head)
                return doEnd(!0);
            var advance = function() {
                var t = Math.max(0, Math.min(1, (Date.now() - start) / duration))
                  , te = ease(t)
                  , step = list.head;
                do
                    step(te);
                while (step = step.next);if (1 === t) {
                    cleanupOnce(mark.scene);
                    pv.Scene.updateAll(before);
                    doEnd(!0);
                } else
                    pv.Scene.updateAll(before);
            };
            timer = setInterval(function() {
                try {
                    advance();
                } catch (ex) {
                    doEnd(!1);
                }
            }, 24);
        }
        ;
        that.stop = function() {
            doEnd(!0);
        }
        ;
    }
    ;
}();

pv.simulation = function(particles) {
    return new pv.Simulation(particles);
}
;

pv.Simulation = function(particles) {
    for (var i = 0; i < particles.length; i++)
        this.particle(particles[i]);
}
;

pv.Simulation.prototype.particle = function(p) {
    p.next = this.particles;
    isNaN(p.px) && (p.px = p.x);
    isNaN(p.py) && (p.py = p.y);
    isNaN(p.fx) && (p.fx = 0);
    isNaN(p.fy) && (p.fy = 0);
    this.particles = p;
    return this;
}
;

pv.Simulation.prototype.force = function(f) {
    f.next = this.forces;
    this.forces = f;
    return this;
}
;

pv.Simulation.prototype.constraint = function(c) {
    c.next = this.constraints;
    this.constraints = c;
    return this;
}
;

pv.Simulation.prototype.stabilize = function(n) {
    var c;
    arguments.length || (n = 3);
    for (var i = 0; n > i; i++) {
        var q = new pv.Quadtree(this.particles);
        for (c = this.constraints; c; c = c.next)
            c.apply(this.particles, q);
    }
    for (var p = this.particles; p; p = p.next) {
        p.px = p.x;
        p.py = p.y;
    }
    return this;
}
;

pv.Simulation.prototype.step = function() {
    var p, f, c;
    for (p = this.particles; p; p = p.next) {
        var px = p.px
          , py = p.py;
        p.px = p.x;
        p.py = p.y;
        p.x += p.vx = p.x - px + p.fx;
        p.y += p.vy = p.y - py + p.fy;
    }
    var q = new pv.Quadtree(this.particles);
    for (c = this.constraints; c; c = c.next)
        c.apply(this.particles, q);
    for (p = this.particles; p; p = p.next)
        p.fx = p.fy = 0;
    for (f = this.forces; f; f = f.next)
        f.apply(this.particles, q);
}
;

pv.Quadtree = function(particles) {
    function insert(n, p, x1, y1, x2, y2) {
        if (!isNaN(p.x) && !isNaN(p.y))
            if (n.leaf)
                if (n.p)
                    if (Math.abs(n.p.x - p.x) + Math.abs(n.p.y - p.y) < .01)
                        insertChild(n, p, x1, y1, x2, y2);
                    else {
                        var v = n.p;
                        n.p = null;
                        insertChild(n, v, x1, y1, x2, y2);
                        insertChild(n, p, x1, y1, x2, y2);
                    }
                else
                    n.p = p;
            else
                insertChild(n, p, x1, y1, x2, y2);
    }
    function insertChild(n, p, x1, y1, x2, y2) {
        var sx = .5 * (x1 + x2)
          , sy = .5 * (y1 + y2)
          , right = p.x >= sx
          , bottom = p.y >= sy;
        n.leaf = !1;
        switch ((bottom << 1) + right) {
        case 0:
            n = n.c1 || (n.c1 = new pv.Quadtree.Node());
            break;

        case 1:
            n = n.c2 || (n.c2 = new pv.Quadtree.Node());
            break;

        case 2:
            n = n.c3 || (n.c3 = new pv.Quadtree.Node());
            break;

        case 3:
            n = n.c4 || (n.c4 = new pv.Quadtree.Node());
        }
        right ? x1 = sx : x2 = sx;
        bottom ? y1 = sy : y2 = sy;
        insert(n, p, x1, y1, x2, y2);
    }
    var p, x1 = Number.POSITIVE_INFINITY, y1 = x1, x2 = Number.NEGATIVE_INFINITY, y2 = x2;
    for (p = particles; p; p = p.next) {
        p.x < x1 && (x1 = p.x);
        p.y < y1 && (y1 = p.y);
        p.x > x2 && (x2 = p.x);
        p.y > y2 && (y2 = p.y);
    }
    var dx = x2 - x1
      , dy = y2 - y1;
    dx > dy ? y2 = y1 + dx : x2 = x1 + dy;
    this.xMin = x1;
    this.yMin = y1;
    this.xMax = x2;
    this.yMax = y2;
    this.root = new pv.Quadtree.Node();
    for (p = particles; p; p = p.next)
        insert(this.root, p, x1, y1, x2, y2);
}
;

pv.Quadtree.Node = function() {
    this.leaf = !0;
    this.c1 = null;
    this.c2 = null;
    this.c3 = null;
    this.c4 = null;
    this.p = null;
}
;

pv.Force = {};

pv.Force.charge = function(k) {
    function accumulate(n) {
        function accumulateChild(c) {
            accumulate(c);
            n.cn += c.cn;
            cx += c.cn * c.cx;
            cy += c.cn * c.cy;
        }
        var cx = 0
          , cy = 0;
        n.cn = 0;
        if (!n.leaf) {
            n.c1 && accumulateChild(n.c1);
            n.c2 && accumulateChild(n.c2);
            n.c3 && accumulateChild(n.c3);
            n.c4 && accumulateChild(n.c4);
        }
        if (n.p) {
            n.cn += k;
            cx += k * n.p.x;
            cy += k * n.p.y;
        }
        n.cx = cx / n.cn;
        n.cy = cy / n.cn;
    }
    function forces(n, p, x1, y1, x2, y2) {
        var dx = n.cx - p.x
          , dy = n.cy - p.y
          , dn = 1 / Math.sqrt(dx * dx + dy * dy);
        if (n.leaf && n.p != p || theta > (x2 - x1) * dn) {
            if (max1 > dn)
                return;
            dn > min1 && (dn = min1);
            var kc = n.cn * dn * dn * dn
              , fx = dx * kc
              , fy = dy * kc;
            p.fx += fx;
            p.fy += fy;
        } else if (!n.leaf) {
            var sx = .5 * (x1 + x2)
              , sy = .5 * (y1 + y2);
            n.c1 && forces(n.c1, p, x1, y1, sx, sy);
            n.c2 && forces(n.c2, p, sx, y1, x2, sy);
            n.c3 && forces(n.c3, p, x1, sy, sx, y2);
            n.c4 && forces(n.c4, p, sx, sy, x2, y2);
            if (max1 > dn)
                return;
            dn > min1 && (dn = min1);
            if (n.p && n.p != p) {
                var kc = k * dn * dn * dn
                  , fx = dx * kc
                  , fy = dy * kc;
                p.fx += fx;
                p.fy += fy;
            }
        }
    }
    var min = 2
      , min1 = 1 / min
      , max = 500
      , max1 = 1 / max
      , theta = .9
      , force = {};
    arguments.length || (k = -40);
    force.constant = function(x) {
        if (arguments.length) {
            k = Number(x);
            return force;
        }
        return k;
    }
    ;
    force.domain = function(a, b) {
        if (arguments.length) {
            min = Number(a);
            min1 = 1 / min;
            max = Number(b);
            max1 = 1 / max;
            return force;
        }
        return [min, max];
    }
    ;
    force.theta = function(x) {
        if (arguments.length) {
            theta = Number(x);
            return force;
        }
        return theta;
    }
    ;
    force.apply = function(particles, q) {
        accumulate(q.root);
        for (var p = particles; p; p = p.next)
            forces(q.root, p, q.xMin, q.yMin, q.xMax, q.yMax);
    }
    ;
    return force;
}
;

pv.Force.drag = function(k) {
    var force = {};
    arguments.length || (k = .1);
    force.constant = function(x) {
        if (arguments.length) {
            k = x;
            return force;
        }
        return k;
    }
    ;
    force.apply = function(particles) {
        if (k)
            for (var p = particles; p; p = p.next) {
                p.fx -= k * p.vx;
                p.fy -= k * p.vy;
            }
    }
    ;
    return force;
}
;

pv.Force.spring = function(k) {
    var links, kl, d = .1, l = 20, force = {};
    arguments.length || (k = .1);
    force.links = function(x) {
        if (arguments.length) {
            links = x;
            kl = x.map(function(l) {
                return 1 / Math.sqrt(Math.max(l.sourceNode.linkDegree, l.targetNode.linkDegree));
            });
            return force;
        }
        return links;
    }
    ;
    force.constant = function(x) {
        if (arguments.length) {
            k = Number(x);
            return force;
        }
        return k;
    }
    ;
    force.damping = function(x) {
        if (arguments.length) {
            d = Number(x);
            return force;
        }
        return d;
    }
    ;
    force.length = function(x) {
        if (arguments.length) {
            l = Number(x);
            return force;
        }
        return l;
    }
    ;
    force.apply = function(particles) {
        for (var i = 0; i < links.length; i++) {
            var a = links[i].sourceNode
              , b = links[i].targetNode
              , dx = a.x - b.x
              , dy = a.y - b.y
              , dn = Math.sqrt(dx * dx + dy * dy)
              , dd = dn ? 1 / dn : 1
              , ks = k * kl[i]
              , kd = d * kl[i]
              , kk = (ks * (dn - l) + kd * (dx * (a.vx - b.vx) + dy * (a.vy - b.vy)) * dd) * dd
              , fx = -kk * (dn ? dx : .01 * (.5 - Math.random()))
              , fy = -kk * (dn ? dy : .01 * (.5 - Math.random()));
            a.fx += fx;
            a.fy += fy;
            b.fx -= fx;
            b.fy -= fy;
        }
    }
    ;
    return force;
}
;

pv.Constraint = {};

pv.Constraint.collision = function(radius) {
    function constrain(n, p, x1, y1, x2, y2) {
        if (!n.leaf) {
            var sx = .5 * (x1 + x2)
              , sy = .5 * (y1 + y2)
              , top = sy > py1
              , bottom = py2 > sy
              , left = sx > px1
              , right = px2 > sx;
            if (top) {
                n.c1 && left && constrain(n.c1, p, x1, y1, sx, sy);
                n.c2 && right && constrain(n.c2, p, sx, y1, x2, sy);
            }
            if (bottom) {
                n.c3 && left && constrain(n.c3, p, x1, sy, sx, y2);
                n.c4 && right && constrain(n.c4, p, sx, sy, x2, y2);
            }
        }
        if (n.p && n.p != p) {
            var dx = p.x - n.p.x
              , dy = p.y - n.p.y
              , l = Math.sqrt(dx * dx + dy * dy)
              , d = r1 + radius(n.p);
            if (d > l) {
                var k = (l - d) / l * .5;
                dx *= k;
                dy *= k;
                p.x -= dx;
                p.y -= dy;
                n.p.x += dx;
                n.p.y += dy;
            }
        }
    }
    var r1, px1, py1, px2, py2, n = 1, constraint = {};
    arguments.length || (r1 = 10);
    constraint.repeat = function(x) {
        if (arguments.length) {
            n = Number(x);
            return constraint;
        }
        return n;
    }
    ;
    constraint.apply = function(particles, q) {
        var p, r, max = -(1 / 0);
        for (p = particles; p; p = p.next) {
            r = radius(p);
            r > max && (max = r);
        }
        for (var i = 0; n > i; i++)
            for (p = particles; p; p = p.next) {
                r = (r1 = radius(p)) + max;
                px1 = p.x - r;
                px2 = p.x + r;
                py1 = p.y - r;
                py2 = p.y + r;
                constrain(q.root, p, q.xMin, q.yMin, q.xMax, q.yMax);
            }
    }
    ;
    return constraint;
}
;

pv.Constraint.position = function(f) {
    var a = 1
      , constraint = {};
    arguments.length || (f = function(p) {
        return p.fix;
    }
    );
    constraint.alpha = function(x) {
        if (arguments.length) {
            a = Number(x);
            return constraint;
        }
        return a;
    }
    ;
    constraint.apply = function(particles) {
        for (var p = particles; p; p = p.next) {
            var v = f(p);
            if (v) {
                p.x += (v.x - p.x) * a;
                p.y += (v.y - p.y) * a;
                p.fx = p.fy = p.vx = p.vy = 0;
            }
        }
    }
    ;
    return constraint;
}
;

pv.Constraint.bound = function() {
    var x, y, constraint = {};
    constraint.x = function(min, max) {
        if (arguments.length) {
            x = {
                min: Math.min(min, max),
                max: Math.max(min, max)
            };
            return this;
        }
        return x;
    }
    ;
    constraint.y = function(min, max) {
        if (arguments.length) {
            y = {
                min: Math.min(min, max),
                max: Math.max(min, max)
            };
            return this;
        }
        return y;
    }
    ;
    constraint.apply = function(particles) {
        if (x)
            for (var p = particles; p; p = p.next)
                p.x = p.x < x.min ? x.min : p.x > x.max ? x.max : p.x;
        if (y)
            for (var p = particles; p; p = p.next)
                p.y = p.y < y.min ? y.min : p.y > y.max ? y.max : p.y;
    }
    ;
    return constraint;
}
;

pv.Layout = function() {
    pv.Panel.call(this);
}
;

pv.Layout.prototype = pv.extend(pv.Panel);

pv.Layout.prototype.property = pv.Mark.prototype.localProperty;

pv.Layout.Network = function() {
    pv.Layout.call(this);
    var that = this;
    this.$id = pv.id();
    (this.node = new pv.Mark().data(function() {
        return that.nodes();
    }).strokeStyle("#1f77b4").fillStyle("#fff").left(function(n) {
        return n.x;
    }).top(function(n) {
        return n.y;
    })).parent = this;
    this.link = new pv.Mark().extend(this.node).data(function(p) {
        return [p.sourceNode, p.targetNode];
    }).fillStyle(null).lineWidth(function(d, p) {
        return 1.5 * p.linkValue;
    }).strokeStyle("rgba(0,0,0,.2)");
    this.link.add = function(type) {
        return that.add(pv.Panel).data(function() {
            return that.links();
        }).add(type).extend(this);
    }
    ;
    (this.label = new pv.Mark().extend(this.node).textMargin(7).textBaseline("middle").text(function(n) {
        return n.nodeName || n.nodeValue;
    }).textAngle(function(n) {
        var a = n.midAngle;
        return pv.Wedge.upright(a) ? a : a + Math.PI;
    }).textAlign(function(n) {
        return pv.Wedge.upright(n.midAngle) ? "left" : "right";
    })).parent = this;
}
;

pv.Layout.Network.prototype = pv.extend(pv.Layout).property("nodes", function(v) {
    return v.map(function(d, i) {
        "object" != typeof d && (d = {
            nodeValue: d
        });
        d.index = i;
        return d;
    });
}).property("links", function(v) {
    return v.map(function(d) {
        isNaN(d.linkValue) && (d.linkValue = isNaN(d.value) ? 1 : d.value);
        return d;
    });
});

pv.Layout.Network.prototype.reset = function() {
    this.$id = pv.id();
    return this;
}
;

pv.Layout.Network.prototype.buildProperties = function(s, properties) {
    (s.$id || 0) < this.$id && pv.Layout.prototype.buildProperties.call(this, s, properties);
}
;

pv.Layout.Network.prototype.buildImplied = function(s) {
    pv.Layout.prototype.buildImplied.call(this, s);
    if (s.$id >= this.$id)
        return !0;
    s.$id = this.$id;
    s.nodes.forEach(function(d) {
        d.linkDegree = 0;
    });
    s.links.forEach(function(d) {
        var v = d.linkValue;
        (d.sourceNode || (d.sourceNode = s.nodes[d.source])).linkDegree += v;
        (d.targetNode || (d.targetNode = s.nodes[d.target])).linkDegree += v;
    });
}
;

pv.Layout.Hierarchy = function() {
    pv.Layout.Network.call(this);
    this.link.strokeStyle("#ccc");
}
;

pv.Layout.Hierarchy.prototype = pv.extend(pv.Layout.Network);

pv.Layout.Hierarchy.prototype.buildImplied = function(s) {
    s.links || (s.links = pv.Layout.Hierarchy.links.call(this));
    pv.Layout.Network.prototype.buildImplied.call(this, s);
}
;

pv.Layout.Hierarchy.links = function() {
    return this.nodes().filter(function(n) {
        return n.parentNode;
    }).map(function(n) {
        return {
            sourceNode: n,
            targetNode: n.parentNode,
            linkValue: 1
        };
    });
}
;

pv.Layout.Hierarchy.NodeLink = {
    buildImplied: function(s) {
        function radius(n) {
            return n.parentNode ? n.depth * (or - ir) + ir : 0;
        }
        function midAngle(n) {
            return n.parentNode ? 2 * (n.breadth - .25) * Math.PI : 0;
        }
        function x(n) {
            switch (orient) {
            case "left":
                return n.depth * w;

            case "right":
                return w - n.depth * w;

            case "top":
                return n.breadth * w;

            case "bottom":
                return w - n.breadth * w;

            case "radial":
                return w / 2 + radius(n) * Math.cos(n.midAngle);
            }
        }
        function y(n) {
            switch (orient) {
            case "left":
                return n.breadth * h;

            case "right":
                return h - n.breadth * h;

            case "top":
                return n.depth * h;

            case "bottom":
                return h - n.depth * h;

            case "radial":
                return h / 2 + radius(n) * Math.sin(n.midAngle);
            }
        }
        var nodes = s.nodes
          , orient = s.orient
          , horizontal = /^(top|bottom)$/.test(orient)
          , w = s.width
          , h = s.height;
        if ("radial" == orient) {
            var ir = s.innerRadius
              , or = s.outerRadius;
            null == ir && (ir = 0);
            null == or && (or = Math.min(w, h) / 2);
        }
        for (var i = 0; i < nodes.length; i++) {
            var n = nodes[i];
            n.midAngle = "radial" == orient ? midAngle(n) : horizontal ? Math.PI / 2 : 0;
            n.x = x(n);
            n.y = y(n);
            n.firstChild && (n.midAngle += Math.PI);
        }
    }
};

pv.Layout.Hierarchy.Fill = {
    constructor: function() {
        this.node.strokeStyle("#fff").fillStyle("#ccc").width(function(n) {
            return n.dx;
        }).height(function(n) {
            return n.dy;
        }).innerRadius(function(n) {
            return n.innerRadius;
        }).outerRadius(function(n) {
            return n.outerRadius;
        }).startAngle(function(n) {
            return n.startAngle;
        }).angle(function(n) {
            return n.angle;
        });
        this.label.textAlign("center").left(function(n) {
            return n.x + n.dx / 2;
        }).top(function(n) {
            return n.y + n.dy / 2;
        });
        delete this.link;
    },
    buildImplied: function(s) {
        function scale(d, depth) {
            return (d + depth) / (1 + depth);
        }
        function x(n) {
            switch (orient) {
            case "left":
                return scale(n.minDepth, depth) * w;

            case "right":
                return (1 - scale(n.maxDepth, depth)) * w;

            case "top":
                return n.minBreadth * w;

            case "bottom":
                return (1 - n.maxBreadth) * w;

            case "radial":
                return w / 2;
            }
        }
        function y(n) {
            switch (orient) {
            case "left":
                return n.minBreadth * h;

            case "right":
                return (1 - n.maxBreadth) * h;

            case "top":
                return scale(n.minDepth, depth) * h;

            case "bottom":
                return (1 - scale(n.maxDepth, depth)) * h;

            case "radial":
                return h / 2;
            }
        }
        function dx(n) {
            switch (orient) {
            case "left":
            case "right":
                return (n.maxDepth - n.minDepth) / (1 + depth) * w;

            case "top":
            case "bottom":
                return (n.maxBreadth - n.minBreadth) * w;

            case "radial":
                return n.parentNode ? (n.innerRadius + n.outerRadius) * Math.cos(n.midAngle) : 0;
            }
        }
        function dy(n) {
            switch (orient) {
            case "left":
            case "right":
                return (n.maxBreadth - n.minBreadth) * h;

            case "top":
            case "bottom":
                return (n.maxDepth - n.minDepth) / (1 + depth) * h;

            case "radial":
                return n.parentNode ? (n.innerRadius + n.outerRadius) * Math.sin(n.midAngle) : 0;
            }
        }
        function innerRadius(n) {
            return Math.max(0, scale(n.minDepth, depth / 2)) * (or - ir) + ir;
        }
        function outerRadius(n) {
            return scale(n.maxDepth, depth / 2) * (or - ir) + ir;
        }
        function startAngle(n) {
            return 2 * (n.parentNode ? n.minBreadth - .25 : 0) * Math.PI;
        }
        function angle(n) {
            return 2 * (n.parentNode ? n.maxBreadth - n.minBreadth : 1) * Math.PI;
        }
        var nodes = s.nodes
          , orient = s.orient
          , horizontal = /^(top|bottom)$/.test(orient)
          , w = s.width
          , h = s.height
          , depth = -nodes[0].minDepth;
        if ("radial" == orient) {
            var ir = s.innerRadius
              , or = s.outerRadius;
            null == ir && (ir = 0);
            ir && (depth *= 2);
            null == or && (or = Math.min(w, h) / 2);
        }
        for (var i = 0; i < nodes.length; i++) {
            var n = nodes[i];
            n.x = x(n);
            n.y = y(n);
            if ("radial" == orient) {
                n.innerRadius = innerRadius(n);
                n.outerRadius = outerRadius(n);
                n.startAngle = startAngle(n);
                n.angle = angle(n);
                n.midAngle = n.startAngle + n.angle / 2;
            } else
                n.midAngle = horizontal ? -Math.PI / 2 : 0;
            n.dx = dx(n);
            n.dy = dy(n);
        }
    }
};

pv.Layout.Grid = function() {
    pv.Layout.call(this);
    var that = this;
    (this.cell = new pv.Mark().data(function() {
        return that.scene[that.index].$grid;
    }).width(function() {
        return that.width() / that.cols();
    }).height(function() {
        return that.height() / that.rows();
    }).left(function() {
        return this.width() * (this.index % that.cols());
    }).top(function() {
        return this.height() * Math.floor(this.index / that.cols());
    })).parent = this;
}
;

pv.Layout.Grid.prototype = pv.extend(pv.Layout).property("rows").property("cols");

pv.Layout.Grid.prototype.defaults = new pv.Layout.Grid().extend(pv.Layout.prototype.defaults).rows(1).cols(1);

pv.Layout.Grid.prototype.buildImplied = function(s) {
    pv.Layout.prototype.buildImplied.call(this, s);
    var r = s.rows
      , c = s.cols;
    "object" == typeof c && (r = pv.transpose(c));
    if ("object" == typeof r) {
        s.$grid = pv.blend(r);
        s.rows = r.length;
        s.cols = r[0] ? r[0].length : 0;
    } else
        s.$grid = pv.repeat([s.data], r * c);
}
;

pv.Layout.Stack = function() {
    function proxy(name) {
        return function() {
            return prop[name](this.parent.index, this.index);
        }
        ;
    }
    pv.Layout.call(this);
    var values, that = this, none = function() {
        return null;
    }, prop = {
        t: none,
        l: none,
        r: none,
        b: none,
        w: none,
        h: none
    }, buildImplied = that.buildImplied;
    this.buildImplied = function(s) {
        buildImplied.call(this, s);
        var m, data = s.layers, n = data.length, orient = s.orient, horizontal = /^(top|bottom)\b/.test(orient), h = this.parent[horizontal ? "height" : "width"](), x = [], y = [], dy = [], stack = pv.Mark.stack, o = {
            parent: {
                parent: this
            }
        };
        stack.unshift(null);
        values = [];
        for (var i = 0; n > i; i++) {
            dy[i] = [];
            y[i] = [];
            o.parent.index = i;
            stack[0] = data[i];
            values[i] = this.$values.apply(o.parent, stack);
            i || (m = values[i].length);
            stack.unshift(null);
            for (var j = 0; m > j; j++) {
                stack[0] = values[i][j];
                o.index = j;
                i || (x[j] = this.$x.apply(o, stack));
                dy[i][j] = this.$y.apply(o, stack);
            }
            stack.shift();
        }
        stack.shift();
        var index;
        switch (s.order) {
        case "inside-out":
            for (var max = dy.map(function(v) {
                return pv.max.index(v);
            }), map = pv.range(n).sort(function(a, b) {
                return max[a] - max[b];
            }), sums = dy.map(function(v) {
                return pv.sum(v);
            }), top = 0, bottom = 0, tops = [], bottoms = [], i = 0; n > i; i++) {
                var j = map[i];
                if (bottom > top) {
                    top += sums[j];
                    tops.push(j);
                } else {
                    bottom += sums[j];
                    bottoms.push(j);
                }
            }
            index = bottoms.reverse().concat(tops);
            break;

        case "reverse":
            index = pv.range(n - 1, -1, -1);
            break;

        default:
            index = pv.range(n);
        }
        switch (s.offset) {
        case "silohouette":
            for (var j = 0; m > j; j++) {
                for (var o = 0, i = 0; n > i; i++)
                    o += dy[i][j];
                y[index[0]][j] = (h - o) / 2;
            }
            break;

        case "wiggle":
            for (var o = 0, i = 0; n > i; i++)
                o += dy[i][0];
            y[index[0]][0] = o = (h - o) / 2;
            for (var j = 1; m > j; j++) {
                for (var s1 = 0, s2 = 0, dx = x[j] - x[j - 1], i = 0; n > i; i++)
                    s1 += dy[i][j];
                for (var i = 0; n > i; i++) {
                    for (var s3 = (dy[index[i]][j] - dy[index[i]][j - 1]) / (2 * dx), k = 0; i > k; k++)
                        s3 += (dy[index[k]][j] - dy[index[k]][j - 1]) / dx;
                    s2 += s3 * dy[index[i]][j];
                }
                y[index[0]][j] = o -= s1 ? s2 / s1 * dx : 0;
            }
            break;

        case "expand":
            for (var j = 0; m > j; j++) {
                y[index[0]][j] = 0;
                for (var k = 0, i = 0; n > i; i++)
                    k += dy[i][j];
                if (k) {
                    k = h / k;
                    for (var i = 0; n > i; i++)
                        dy[i][j] *= k;
                } else {
                    k = h / n;
                    for (var i = 0; n > i; i++)
                        dy[i][j] = k;
                }
            }
            break;

        default:
            for (var j = 0; m > j; j++)
                y[index[0]][j] = 0;
        }
        for (var j = 0; m > j; j++)
            for (var o = y[index[0]][j], i = 1; n > i; i++) {
                o += dy[index[i - 1]][j];
                y[index[i]][j] = o;
            }
        var i = orient.indexOf("-")
          , pdy = horizontal ? "h" : "w"
          , px = 0 > i ? horizontal ? "l" : "b" : orient.charAt(i + 1)
          , py = orient.charAt(0);
        for (var p in prop)
            prop[p] = none;
        prop[px] = function(i, j) {
            return x[j];
        }
        ;
        prop[py] = function(i, j) {
            return y[i][j];
        }
        ;
        prop[pdy] = function(i, j) {
            return dy[i][j];
        }
        ;
    }
    ;
    this.layer = new pv.Mark().data(function() {
        return values[this.parent.index];
    }).top(proxy("t")).left(proxy("l")).right(proxy("r")).bottom(proxy("b")).width(proxy("w")).height(proxy("h"));
    this.layer.add = function(type) {
        return that.add(pv.Panel).data(function() {
            return that.layers();
        }).add(type).extend(this);
    }
    ;
}
;

pv.Layout.Stack.prototype = pv.extend(pv.Layout).property("orient", String).property("offset", String).property("order", String).property("layers");

pv.Layout.Stack.prototype.defaults = new pv.Layout.Stack().extend(pv.Layout.prototype.defaults).orient("bottom-left").offset("zero").layers([[]]);

pv.Layout.Stack.prototype.$x = pv.Layout.Stack.prototype.$y = function() {
    return 0;
}
;

pv.Layout.Stack.prototype.x = function(f) {
    this.$x = pv.functor(f);
    return this;
}
;

pv.Layout.Stack.prototype.y = function(f) {
    this.$y = pv.functor(f);
    return this;
}
;

pv.Layout.Stack.prototype.$values = pv.identity;

pv.Layout.Stack.prototype.values = function(f) {
    this.$values = pv.functor(f);
    return this;
}
;

pv.Layout.Band = function() {
    function proxy(name) {
        return function() {
            return itemProps[name](this.index, this.parent.index);
        }
        ;
    }
    pv.Layout.call(this);
    var itemProps, values, that = this, buildImplied = that.buildImplied, itemProto = new pv.Mark().data(function() {
        return values[this.parent.index];
    }).top(proxy("t")).left(proxy("l")).right(proxy("r")).bottom(proxy("b")).width(proxy("w")).height(proxy("h")).antialias(proxy("antialias"));
    this.buildImplied = function(s) {
        buildImplied.call(this, s);
        itemProps = Object.create(pv.Layout.Band.$baseItemProps);
        values = [];
        var data = s.layers
          , L = data.length;
        if (L > 0) {
            var orient = s.orient
              , horizontal = /^(top|bottom)\b/.test(orient)
              , bh = this.parent[horizontal ? "height" : "width"]()
              , bands = this._readData(data, values, s)
              , B = bands.length;
            "reverse" === s.bandOrder && bands.reverse();
            if ("reverse" === s.order) {
                values.reverse();
                for (var b = 0; B > b; b++)
                    bands[b].items.reverse();
            }
            switch (s.layout) {
            case "grouped":
                this._calcGrouped(bands, L, bh, s);
                break;

            case "stacked":
                this._calcStacked(bands, L, bh, s);
            }
            for (var hZero = s.hZero || 0, isStacked = "stacked" === s.layout, i = 0; B > i; i++)
                for (var band = bands[i], hMargin2 = isStacked ? Math.max(0, band.vertiMargin) / 2 : 0, j = 0; L > j; j++) {
                    var item = band.items[j];
                    if (item.zero) {
                        item.h = hZero;
                        item.y -= hMargin2 + hZero / 2;
                    }
                }
            this._bindItemProps(bands, itemProps, orient, horizontal);
        }
    }
    ;
    var itemAccessor = this.item = {
        end: this,
        add: function(type) {
            return that.add(pv.Panel).data(function() {
                return that.layers();
            }).add(type).extend(itemProto);
        },
        order: function(value) {
            that.order(value);
            return this;
        },
        w: function(f) {
            that.$iw = pv.functor(f);
            return this;
        },
        h: function(f) {
            that.$ih = pv.functor(f);
            return this;
        },
        horizontalRatio: function(f) {
            that.$ihorizRatio = pv.functor(f);
            return this;
        },
        verticalMargin: function(f) {
            that.$ivertiMargin = pv.functor(f);
            return this;
        }
    }
      , bandAccessor = this.band = {
        end: this,
        w: function(f) {
            that.$bw = pv.functor(f);
            return this;
        },
        x: function(f) {
            that.$bx = pv.functor(f);
            return this;
        },
        order: function(value) {
            that.bandOrder(value);
            return this;
        },
        differentialControl: function(f) {
            that.$bDiffControl = pv.functor(f);
            return this;
        }
    };
    this.band.item = itemAccessor;
    this.item.band = bandAccessor;
}
;

pv.Layout.Band.$baseItemProps = function() {
    var none = function() {
        return null;
    };
    return {
        t: none,
        l: none,
        r: none,
        b: none,
        w: none,
        h: none
    };
}();

pv.Layout.Band.prototype = pv.extend(pv.Layout).property("orient", String).property("layout", String).property("layers").property("yZero", Number).property("hZero", Number).property("verticalMode", String).property("horizontalMode", String).property("order", String).property("bandOrder", String);

pv.Layout.Band.prototype.defaults = new pv.Layout.Band().extend(pv.Layout.prototype.defaults).orient("bottom-left").layout("grouped").yZero(0).hZero(1.5).layers([[]]);

pv.Layout.Band.prototype.$bx = pv.Layout.Band.prototype.$bw = pv.Layout.Band.prototype.$bDiffControl = pv.Layout.Band.prototype.$iw = pv.Layout.Band.prototype.$ih = pv.Layout.Band.prototype.$ivertiMargin = pv.functor(0);

pv.Layout.Band.prototype.$ihorizRatio = pv.functor(.9);

pv.Layout.Band.prototype.$values = pv.identity;

pv.Layout.Band.prototype.values = function(f) {
    this.$values = pv.functor(f);
    return this;
}
;

pv.Layout.prototype._readData = function(data, layersValues, scene) {
    var B, L = data.length, bands = [], stack = pv.Mark.stack, hZero = scene.hZero, o = {
        parent: {
            parent: this
        }
    };
    stack.unshift(null);
    for (var l = 0; L > l; l++) {
        o.parent.index = l;
        stack[0] = data[l];
        var layerValues = layersValues[l] = this.$values.apply(o.parent, stack);
        l || (B = layerValues.length);
        stack.unshift(null);
        for (var b = 0; B > b; b++) {
            stack[0] = layerValues[b];
            o.index = b;
            var band = bands[b];
            band || (band = bands[b] = {
                horizRatio: this.$ihorizRatio.apply(o, stack),
                vertiMargin: this.$ivertiMargin.apply(o, stack),
                w: this.$bw.apply(o, stack),
                x: this.$bx.apply(o, stack),
                diffControl: this.$bDiffControl ? this.$bDiffControl.apply(o, stack) : 0,
                items: []
            });
            var ih = this.$ih.apply(o, stack)
              , h = null != ih ? Math.abs(ih) : ih;
            band.items[l] = {
                y: scene.yZero || 0,
                x: 0,
                w: this.$iw.apply(o, stack),
                h: h,
                zero: null != h && hZero >= h,
                dir: 0 > ih ? -1 : 1
            };
        }
        stack.shift();
    }
    stack.shift();
    return bands;
}
;

pv.Layout.Band.prototype._normalizeBands = function(bands, L, bh, scene) {
    var items, B = bands.length;
    if ("expand" === scene.verticalMode)
        for (var b = 0; B > b; b++) {
            items = bands[b].items;
            for (var hSum = null, nonNullCount = 0, l = 0; L > l; l++) {
                var item = items[l];
                item.dir = 1;
                var h = item.h;
                if (null != h) {
                    nonNullCount++;
                    hSum += h;
                }
            }
            if (nonNullCount)
                if (hSum)
                    for (var hScale = bh / hSum, l = 0; L > l; l++) {
                        var h = items[l].h;
                        null != h && (items[l].h = h * hScale);
                    }
                else if (0 == hSum)
                    for (var l = 0; L > l; l++)
                        items[l].h = 0;
                else
                    for (var hAvg = bh / nonNullCount, l = 0; L > l; l++) {
                        var h = items[l].h;
                        null != h && (items[l].h = hAvg);
                    }
        }
    return items;
}
;

pv.Layout.Band.prototype._calcGrouped = function(bands, L, bh, scene) {
    for (var items = this._normalizeBands(bands, L, bh, scene), b = 0, B = bands.length; B > b; b++) {
        for (var band = bands[b], items = band.items, w = band.w, horizRatio = band.horizRatio, wItems = 0, l = 0; L > l; l++)
            wItems += items[l].w;
        1 === L ? horizRatio = 1 : horizRatio > 0 && 1 >= horizRatio || (horizRatio = 1);
        if (null == w)
            w = band.w = wItems / horizRatio;
        else if ("expand" === scene.horizontalMode) {
            var wItems2 = horizRatio * w;
            if (wItems)
                for (var wScale = wItems2 / wItems, l = 0; L > l; l++)
                    items[l].w *= wScale;
            else
                for (var wiavg = wItems2 / L, l = 0; L > l; l++)
                    items[l].w = wiavg;
            wItems = wItems2;
        }
        for (var wItemsWithMargin = wItems / horizRatio, ix = band.x - wItemsWithMargin / 2, margin = L > 1 ? (wItemsWithMargin - wItems) / (L - 1) : 0, l = 0; L > l; l++) {
            var item = items[l];
            item.x = ix;
            ix += item.w + margin;
            item.dir < 0 && (item.y -= item.h);
        }
    }
}
;

pv.Layout.Band.prototype._calcStacked = function(bands, L, bh, scene) {
    for (var items = this._normalizeBands(bands, L, bh, scene), yZero = scene.yZero, yOffset = yZero, b = 0, B = bands.length; B > b; b++) {
        var band = bands[b]
          , bx = band.x
          , bDiffControl = band.diffControl
          , positiveGoesDown = 0 > bDiffControl
          , vertiMargin = Math.max(0, band.vertiMargin);
        items = band.items;
        var resultPos = this._layoutItemsOfDir(1, positiveGoesDown, items, vertiMargin, bx, yOffset)
          , resultNeg = null;
        resultPos.existsOtherDir && (resultNeg = this._layoutItemsOfDir(-1, positiveGoesDown, items, vertiMargin, bx, yOffset));
        if (bDiffControl) {
            if (1 === Math.abs(bDiffControl)) {
                var yOffset0 = yOffset;
                yOffset = resultPos.yOffset;
                resultNeg && (yOffset -= yOffset0 - resultNeg.yOffset);
            }
        } else
            yOffset = yZero;
    }
}
;

pv.Layout.Band.prototype._layoutItemsOfDir = function(stackDir, positiveGoesDown, items, vertiMargin, bx, yOffset) {
    for (var existsOtherDir = !1, vertiMargin2 = vertiMargin / 2, efDir = positiveGoesDown ? -stackDir : stackDir, reverseLayers = positiveGoesDown, l = 0, L = items.length; L > l; l += 1) {
        var item = items[reverseLayers ? L - l - 1 : l];
        if (item.dir === stackDir) {
            var h = item.h || 0;
            if (efDir > 0) {
                item.y = yOffset + vertiMargin2;
                yOffset += h;
            } else {
                item.y = yOffset - (h - vertiMargin2);
                yOffset -= h;
            }
            var h2 = h - vertiMargin;
            item.h = h2 > 0 ? h2 : 0;
            item.x = bx - item.w / 2;
        } else
            existsOtherDir = !0;
    }
    return {
        existsOtherDir: existsOtherDir,
        yOffset: yOffset
    };
}
;

pv.Layout.Band.prototype._bindItemProps = function(bands, itemProps, orient, horizontal) {
    var index = orient.indexOf("-")
      , ph = horizontal ? "h" : "w"
      , pw = horizontal ? "w" : "h"
      , px = 0 > index ? horizontal ? "l" : "b" : orient.charAt(index + 1)
      , py = orient.charAt(0);
    itemProps[px] = function(b, l) {
        return bands[b].items[l].x;
    }
    ;
    itemProps[py] = function(b, l) {
        return bands[b].items[l].y;
    }
    ;
    itemProps[pw] = function(b, l) {
        return bands[b].items[l].w;
    }
    ;
    itemProps[ph] = function(b, l) {
        return bands[b].items[l].h || 0;
    }
    ;
    itemProps.antialias = function(b, l) {
        return bands[b].items[l].zero;
    }
    ;
}
;

pv.Layout.Treemap = function() {
    pv.Layout.Hierarchy.call(this);
    this.node.strokeStyle("#fff").fillStyle("rgba(31, 119, 180, .25)").width(function(n) {
        return n.dx;
    }).height(function(n) {
        return n.dy;
    });
    this.label.visible(function(n) {
        return !n.firstChild;
    }).left(function(n) {
        return n.x + n.dx / 2;
    }).top(function(n) {
        return n.y + n.dy / 2;
    }).textAlign("center").textAngle(function(n) {
        return n.dx > n.dy ? 0 : -Math.PI / 2;
    });
    (this.leaf = new pv.Mark().extend(this.node).fillStyle(null).strokeStyle(null).visible(function(n) {
        return !n.firstChild;
    })).parent = this;
    delete this.link;
}
;

pv.Layout.Treemap.prototype = pv.extend(pv.Layout.Hierarchy).property("round", Boolean).property("mode", String).property("order", String);

pv.Layout.Treemap.prototype.defaults = new pv.Layout.Treemap().extend(pv.Layout.Hierarchy.prototype.defaults).mode("squarify").order("ascending");

pv.Layout.Treemap.prototype.$size = function(d) {
    return Number(d.nodeValue);
}
;

pv.Layout.Treemap.prototype.$padLeft = pv.Layout.Treemap.prototype.$padRight = pv.Layout.Treemap.prototype.$padBottom = pv.Layout.Treemap.prototype.$padTop = function() {
    return 0;
}
;

pv.Layout.Treemap.prototype.size = function(f) {
    this.$size = pv.functor(f);
    return this;
}
;

pv.Layout.Treemap.prototype.padding = function(n) {
    n = pv.functor(n);
    return this.paddingLeft(n).paddingRight(n).paddingTop(n).paddingBottom(n);
}
;

pv.Layout.Treemap.prototype.paddingLeft = function(f) {
    if (arguments.length) {
        this.$padLeft = pv.functor(f);
        return this;
    }
    return this.$padLeft;
}
;

pv.Layout.Treemap.prototype.paddingRight = function(f) {
    if (arguments.length) {
        this.$padRight = pv.functor(f);
        return this;
    }
    return this.$padRight;
}
;

pv.Layout.Treemap.prototype.paddingBottom = function(f) {
    if (arguments.length) {
        this.$padBottom = pv.functor(f);
        return this;
    }
    return this.$padBottom;
}
;

pv.Layout.Treemap.prototype.paddingTop = function(f) {
    if (arguments.length) {
        this.$padTop = pv.functor(f);
        return this;
    }
    return this.$padTop;
}
;

pv.Layout.Treemap.prototype.buildImplied = function(s) {
    function slice(row, sum, horizontal, x, y, w, h) {
        for (var i = 0, d = 0; i < row.length; i++) {
            var n = row[i];
            if (horizontal) {
                n.x = x + d;
                n.y = y;
                d += n.dx = round(w * n.size / sum);
                n.dy = h;
            } else {
                n.x = x;
                n.y = y + d;
                n.dx = w;
                d += n.dy = round(h * n.size / sum);
            }
        }
        n && (horizontal ? n.dx += w - d : n.dy += h - d);
    }
    function ratio(row, l) {
        for (var rmax = -(1 / 0), rmin = 1 / 0, s = 0, i = 0; i < row.length; i++) {
            var r = row[i].size;
            rmin > r && (rmin = r);
            r > rmax && (rmax = r);
            s += r;
        }
        s *= s;
        l *= l;
        return Math.max(l * rmax / s, s / (l * rmin));
    }
    function layout(n, i) {
        function position(row) {
            var horizontal = w == l
              , sum = pv.sum(row, size)
              , r = l ? round(sum / l) : 0;
            slice(row, sum, horizontal, x, y, horizontal ? w : r, horizontal ? r : h);
            if (horizontal) {
                y += r;
                h -= r;
            } else {
                x += r;
                w -= r;
            }
            l = Math.min(w, h);
            return horizontal;
        }
        var p = n.parentNode
          , x = n.x
          , y = n.y
          , w = n.dx
          , h = n.dy;
        if (p) {
            x += p.paddingLeft;
            y += p.paddingTop;
            w += -p.paddingLeft - p.paddingRight,
            h += -p.paddingTop - p.paddingBottom;
        }
        if ("squarify" == mode) {
            var row = []
              , mink = 1 / 0
              , l = Math.min(w, h)
              , k = w * h / n.size;
            if (!(n.size <= 0)) {
                n.visitBefore(function(n) {
                    n.size *= k;
                });
                for (var children = n.childNodes.slice(); children.length; ) {
                    var child = children[children.length - 1];
                    if (child.size) {
                        row.push(child);
                        var k = ratio(row, l);
                        if (mink >= k) {
                            children.pop();
                            mink = k;
                        } else {
                            row.pop();
                            position(row);
                            row.length = 0;
                            mink = 1 / 0;
                        }
                    } else
                        children.pop();
                }
                if (position(row))
                    for (var i = 0; i < row.length; i++)
                        row[i].dy += h;
                else
                    for (var i = 0; i < row.length; i++)
                        row[i].dx += w;
            }
        } else
            slice(n.childNodes, n.size, "slice" == mode ? !0 : "dice" == mode ? !1 : 1 & i, x, y, w, h);
    }
    if (!pv.Layout.Hierarchy.prototype.buildImplied.call(this, s)) {
        var that = this
          , nodes = s.nodes
          , root = nodes[0]
          , stack = pv.Mark.stack
          , size = function(n) {
            return n.size;
        }
          , round = s.round ? Math.round : Number
          , mode = s.mode;
        stack.unshift(null);
        try {
            root.visitAfter(function(n, i) {
                n.depth = i;
                n.x = n.y = n.dx = n.dy = 0;
                stack[0] = n;
                if (n.firstChild) {
                    n.size = pv.sum(n.childNodes, size);
                    n.paddingRight = +that.$padRight.apply(that, stack) || 0;
                    n.paddingLeft = +that.$padLeft.apply(that, stack) || 0;
                    n.paddingBottom = +that.$padBottom.apply(that, stack) || 0;
                    n.paddingTop = +that.$padTop.apply(that, stack) || 0;
                } else
                    n.size = that.$size.apply(that, stack);
            });
        } finally {
            stack.shift();
        }
        switch (s.order) {
        case "ascending":
            root.sort(function(a, b) {
                return a.size - b.size;
            });
            break;

        case "descending":
            root.sort(function(a, b) {
                return b.size - a.size;
            });
            break;

        case "reverse":
            root.reverse();
        }
        root.x = 0;
        root.y = 0;
        root.dx = s.width;
        root.dy = s.height;
        root.visitBefore(layout);
    }
}
;

pv.Layout.Tree = function() {
    pv.Layout.Hierarchy.call(this);
}
;

pv.Layout.Tree.prototype = pv.extend(pv.Layout.Hierarchy).property("group", Number).property("breadth", Number).property("depth", Number).property("orient", String);

pv.Layout.Tree.prototype.defaults = new pv.Layout.Tree().extend(pv.Layout.Hierarchy.prototype.defaults).group(1).breadth(15).depth(60).orient("top");

pv.Layout.Tree.prototype.buildImplied = function(s) {
    function firstWalk(v) {
        var l, r, a;
        if (v.firstChild) {
            l = v.firstChild;
            r = v.lastChild;
            a = l;
            for (var c = l; c; c = c.nextSibling) {
                firstWalk(c);
                a = apportion(c, a);
            }
            executeShifts(v);
            var midpoint = .5 * (l.prelim + r.prelim);
            if (l = v.previousSibling) {
                v.prelim = l.prelim + distance(v.depth, !0);
                v.mod = v.prelim - midpoint;
            } else
                v.prelim = midpoint;
        } else
            (l = v.previousSibling) && (v.prelim = l.prelim + distance(v.depth, !0));
    }
    function secondWalk(v, m, depth) {
        v.breadth = v.prelim + m;
        m += v.mod;
        for (var c = v.firstChild; c; c = c.nextSibling)
            secondWalk(c, m, depth);
    }
    function apportion(v, a) {
        var w = v.previousSibling;
        if (w) {
            for (var vip = v, vop = v, vim = w, vom = v.parentNode.firstChild, sip = vip.mod, sop = vop.mod, sim = vim.mod, som = vom.mod, nr = nextRight(vim), nl = nextLeft(vip); nr && nl; ) {
                vim = nr;
                vip = nl;
                vom = nextLeft(vom);
                vop = nextRight(vop);
                vop.ancestor = v;
                var shift = vim.prelim + sim - (vip.prelim + sip) + distance(vim.depth, !1);
                if (shift > 0) {
                    moveSubtree(ancestor(vim, v, a), v, shift);
                    sip += shift;
                    sop += shift;
                }
                sim += vim.mod;
                sip += vip.mod;
                som += vom.mod;
                sop += vop.mod;
                nr = nextRight(vim);
                nl = nextLeft(vip);
            }
            if (nr && !nextRight(vop)) {
                vop.thread = nr;
                vop.mod += sim - sop;
            }
            if (nl && !nextLeft(vom)) {
                vom.thread = nl;
                vom.mod += sip - som;
                a = v;
            }
        }
        return a;
    }
    function nextLeft(v) {
        return v.firstChild || v.thread;
    }
    function nextRight(v) {
        return v.lastChild || v.thread;
    }
    function moveSubtree(wm, wp, shift) {
        var subtrees = wp.number - wm.number;
        wp.change -= shift / subtrees;
        wp.shift += shift;
        wm.change += shift / subtrees;
        wp.prelim += shift;
        wp.mod += shift;
    }
    function executeShifts(v) {
        for (var shift = 0, change = 0, c = v.lastChild; c; c = c.previousSibling) {
            c.prelim += shift;
            c.mod += shift;
            change += c.change;
            shift += c.shift + change;
        }
    }
    function ancestor(vim, v, a) {
        return vim.ancestor.parentNode == v.parentNode ? vim.ancestor : a;
    }
    function distance(depth, siblings) {
        return (siblings ? 1 : group + 1) / ("radial" == orient ? depth : 1);
    }
    function midAngle(n) {
        return "radial" == orient ? n.breadth / depth : 0;
    }
    function x(n) {
        switch (orient) {
        case "left":
            return n.depth;

        case "right":
            return w - n.depth;

        case "top":
        case "bottom":
            return n.breadth + w / 2;

        case "radial":
            return w / 2 + n.depth * Math.cos(midAngle(n));
        }
    }
    function y(n) {
        switch (orient) {
        case "left":
        case "right":
            return n.breadth + h / 2;

        case "top":
            return n.depth;

        case "bottom":
            return h - n.depth;

        case "radial":
            return h / 2 + n.depth * Math.sin(midAngle(n));
        }
    }
    if (!pv.Layout.Hierarchy.prototype.buildImplied.call(this, s)) {
        var nodes = s.nodes
          , orient = s.orient
          , depth = s.depth
          , breadth = s.breadth
          , group = s.group
          , w = s.width
          , h = s.height
          , root = nodes[0];
        root.visitAfter(function(v, i) {
            v.ancestor = v;
            v.prelim = 0;
            v.mod = 0;
            v.change = 0;
            v.shift = 0;
            v.number = v.previousSibling ? v.previousSibling.number + 1 : 0;
            v.depth = i;
        });
        firstWalk(root);
        secondWalk(root, -root.prelim, 0);
        root.visitAfter(function(v) {
            v.breadth *= breadth;
            v.depth *= depth;
            v.midAngle = midAngle(v);
            v.x = x(v);
            v.y = y(v);
            v.firstChild && (v.midAngle += Math.PI);
            delete v.breadth;
            delete v.depth;
            delete v.ancestor;
            delete v.prelim;
            delete v.mod;
            delete v.change;
            delete v.shift;
            delete v.number;
            delete v.thread;
        });
    }
}
;

pv.Layout.Indent = function() {
    pv.Layout.Hierarchy.call(this);
    this.link.interpolate("step-after");
}
;

pv.Layout.Indent.prototype = pv.extend(pv.Layout.Hierarchy).property("depth", Number).property("breadth", Number);

pv.Layout.Indent.prototype.defaults = new pv.Layout.Indent().extend(pv.Layout.Hierarchy.prototype.defaults).depth(15).breadth(15);

pv.Layout.Indent.prototype.buildImplied = function(s) {
    function position(n, breadth, depth) {
        n.x = ax + depth++ * dspace;
        n.y = ay + breadth++ * bspace;
        n.midAngle = 0;
        for (var c = n.firstChild; c; c = c.nextSibling)
            breadth = position(c, breadth, depth);
        return breadth;
    }
    if (!pv.Layout.Hierarchy.prototype.buildImplied.call(this, s)) {
        var nodes = s.nodes
          , bspace = s.breadth
          , dspace = s.depth
          , ax = 0
          , ay = 0;
        position(nodes[0], 1, 1);
    }
}
;

pv.Layout.Pack = function() {
    pv.Layout.Hierarchy.call(this);
    this.node.shapeRadius(function(n) {
        return n.radius;
    }).strokeStyle("rgb(31, 119, 180)").fillStyle("rgba(31, 119, 180, .25)");
    this.label.textAlign("center");
    delete this.link;
}
;

pv.Layout.Pack.prototype = pv.extend(pv.Layout.Hierarchy).property("spacing", Number).property("order", String);

pv.Layout.Pack.prototype.defaults = new pv.Layout.Pack().extend(pv.Layout.Hierarchy.prototype.defaults).spacing(1).order("ascending");

pv.Layout.Pack.prototype.$radius = function() {
    return 1;
}
;

pv.Layout.Pack.prototype.size = function(f) {
    this.$radius = "function" == typeof f ? function() {
        return Math.sqrt(f.apply(this, arguments));
    }
    : (f = Math.sqrt(f),
    function() {
        return f;
    }
    );
    return this;
}
;

pv.Layout.Pack.prototype.buildImplied = function(s) {
    function radii(nodes) {
        var stack = pv.Mark.stack;
        stack.unshift(null);
        for (var i = 0, n = nodes.length; n > i; i++) {
            var c = nodes[i];
            c.firstChild || (c.radius = that.$radius.apply(that, (stack[0] = c,
            stack)));
        }
        stack.shift();
    }
    function packTree(n) {
        for (var nodes = [], c = n.firstChild; c; c = c.nextSibling) {
            c.firstChild && (c.radius = packTree(c));
            c.n = c.p = c;
            nodes.push(c);
        }
        switch (s.order) {
        case "ascending":
            nodes.sort(function(a, b) {
                return a.radius - b.radius;
            });
            break;

        case "descending":
            nodes.sort(function(a, b) {
                return b.radius - a.radius;
            });
            break;

        case "reverse":
            nodes.reverse();
        }
        return packCircle(nodes);
    }
    function packCircle(nodes) {
        function bound(n) {
            xMin = Math.min(n.x - n.radius, xMin);
            xMax = Math.max(n.x + n.radius, xMax);
            yMin = Math.min(n.y - n.radius, yMin);
            yMax = Math.max(n.y + n.radius, yMax);
        }
        function insert(a, b) {
            var c = a.n;
            a.n = b;
            b.p = a;
            b.n = c;
            c.p = b;
        }
        function splice(a, b) {
            a.n = b;
            b.p = a;
        }
        function intersects(a, b) {
            var dx = b.x - a.x
              , dy = b.y - a.y
              , dr = a.radius + b.radius;
            return dr * dr - dx * dx - dy * dy > .001;
        }
        var a, b, c, j, k, xMin = 1 / 0, xMax = -(1 / 0), yMin = 1 / 0, yMax = -(1 / 0);
        a = nodes[0];
        a.x = -a.radius;
        a.y = 0;
        bound(a);
        if (nodes.length > 1) {
            b = nodes[1];
            b.x = b.radius;
            b.y = 0;
            bound(b);
            if (nodes.length > 2) {
                c = nodes[2];
                place(a, b, c);
                bound(c);
                insert(a, c);
                a.p = c;
                insert(c, b);
                b = a.n;
                for (var i = 3; i < nodes.length; i++) {
                    place(a, b, c = nodes[i]);
                    var isect = 0
                      , s1 = 1
                      , s2 = 1;
                    for (j = b.n; j != b; j = j.n,
                    s1++)
                        if (intersects(j, c)) {
                            isect = 1;
                            break;
                        }
                    if (1 == isect)
                        for (k = a.p; k != j.p; k = k.p,
                        s2++)
                            if (intersects(k, c)) {
                                if (s1 > s2) {
                                    isect = -1;
                                    j = k;
                                }
                                break;
                            }
                    if (0 == isect) {
                        insert(a, c);
                        b = c;
                        bound(c);
                    } else if (isect > 0) {
                        splice(a, j);
                        b = j;
                        i--;
                    } else if (0 > isect) {
                        splice(j, b);
                        a = j;
                        i--;
                    }
                }
            }
        }
        for (var cx = (xMin + xMax) / 2, cy = (yMin + yMax) / 2, cr = 0, i = 0; i < nodes.length; i++) {
            var n = nodes[i];
            n.x -= cx;
            n.y -= cy;
            cr = Math.max(cr, n.radius + Math.sqrt(n.x * n.x + n.y * n.y));
        }
        return cr + s.spacing;
    }
    function place(a, b, c) {
        var da = b.radius + c.radius
          , db = a.radius + c.radius
          , dx = b.x - a.x
          , dy = b.y - a.y
          , dc = Math.sqrt(dx * dx + dy * dy)
          , cos = (db * db + dc * dc - da * da) / (2 * db * dc)
          , theta = Math.acos(cos)
          , x = cos * db
          , h = Math.sin(theta) * db;
        dx /= dc;
        dy /= dc;
        c.x = a.x + x * dx + h * dy;
        c.y = a.y + x * dy - h * dx;
    }
    function transform(n, x, y, k) {
        for (var c = n.firstChild; c; c = c.nextSibling) {
            c.x += n.x;
            c.y += n.y;
            transform(c, x, y, k);
        }
        n.x = x + k * n.x;
        n.y = y + k * n.y;
        n.radius *= k;
    }
    if (!pv.Layout.Hierarchy.prototype.buildImplied.call(this, s)) {
        var that = this
          , nodes = s.nodes
          , root = nodes[0];
        radii(nodes);
        root.x = 0;
        root.y = 0;
        root.radius = packTree(root);
        var w = this.width()
          , h = this.height()
          , k = 1 / Math.max(2 * root.radius / w, 2 * root.radius / h);
        transform(root, w / 2, h / 2, k);
    }
}
;

pv.Layout.Force = function() {
    pv.Layout.Network.call(this);
    this.link.lineWidth(function(d, p) {
        return 1.5 * Math.sqrt(p.linkValue);
    });
    this.label.textAlign("center");
}
;

pv.Layout.Force.prototype = pv.extend(pv.Layout.Network).property("bound", Boolean).property("iterations", Number).property("dragConstant", Number).property("chargeConstant", Number).property("chargeMinDistance", Number).property("chargeMaxDistance", Number).property("chargeTheta", Number).property("springConstant", Number).property("springDamping", Number).property("springLength", Number);

pv.Layout.Force.prototype.defaults = new pv.Layout.Force().extend(pv.Layout.Network.prototype.defaults).dragConstant(.1).chargeConstant(-40).chargeMinDistance(2).chargeMaxDistance(500).chargeTheta(.9).springConstant(.1).springDamping(.3).springLength(20);

pv.Layout.Force.prototype.buildImplied = function(s) {
    function speed(n) {
        return n.fix ? 1 : n.vx * n.vx + n.vy * n.vy;
    }
    if (pv.Layout.Network.prototype.buildImplied.call(this, s)) {
        var f = s.$force;
        if (f) {
            f.next = this.binds.$force;
            this.binds.$force = f;
        }
    } else {
        for (var n, that = this, nodes = s.nodes, links = s.links, k = s.iterations, w = s.width, h = s.height, i = 0; i < nodes.length; i++) {
            n = nodes[i];
            isNaN(n.x) && (n.x = w / 2 + 40 * Math.random() - 20);
            isNaN(n.y) && (n.y = h / 2 + 40 * Math.random() - 20);
        }
        var sim = pv.simulation(nodes);
        sim.force(pv.Force.drag(s.dragConstant));
        sim.force(pv.Force.charge(s.chargeConstant).domain(s.chargeMinDistance, s.chargeMaxDistance).theta(s.chargeTheta));
        sim.force(pv.Force.spring(s.springConstant).damping(s.springDamping).length(s.springLength).links(links));
        sim.constraint(pv.Constraint.position());
        s.bound && sim.constraint(pv.Constraint.bound().x(6, w - 6).y(6, h - 6));
        if (null == k) {
            sim.step();
            sim.step();
            s.$force = this.binds.$force = {
                next: this.binds.$force,
                nodes: nodes,
                min: 1e-4 * (links.length + 1),
                sim: sim
            };
            this.$timer || (this.$timer = setInterval(function() {
                for (var render = !1, f = that.binds.$force; f; f = f.next)
                    if (pv.max(f.nodes, speed) > f.min) {
                        f.sim.step();
                        render = !0;
                    }
                render && that.render();
            }, 42));
        } else
            for (var i = 0; k > i; i++)
                sim.step();
    }
}
;

pv.Layout.Cluster = function() {
    pv.Layout.Hierarchy.call(this);
    var interpolate, buildImplied = this.buildImplied;
    this.buildImplied = function(s) {
        buildImplied.call(this, s);
        interpolate = /^(top|bottom)$/.test(s.orient) ? "step-before" : /^(left|right)$/.test(s.orient) ? "step-after" : "linear";
    }
    ;
    this.link.interpolate(function() {
        return interpolate;
    });
}
;

pv.Layout.Cluster.prototype = pv.extend(pv.Layout.Hierarchy).property("group", Number).property("orient", String).property("innerRadius", Number).property("outerRadius", Number);

pv.Layout.Cluster.prototype.defaults = new pv.Layout.Cluster().extend(pv.Layout.Hierarchy.prototype.defaults).group(0).orient("top");

pv.Layout.Cluster.prototype.buildImplied = function(s) {
    if (!pv.Layout.Hierarchy.prototype.buildImplied.call(this, s)) {
        var breadth, depth, root = s.nodes[0], group = s.group, leafCount = 0, leafIndex = .5 - group / 2, p = void 0;
        root.visitAfter(function(n) {
            if (n.firstChild)
                n.depth = 1 + pv.max(n.childNodes, function(n) {
                    return n.depth;
                });
            else {
                if (group && p != n.parentNode) {
                    p = n.parentNode;
                    leafCount += group;
                }
                leafCount++;
                n.depth = 0;
            }
        });
        breadth = 1 / leafCount;
        depth = 1 / root.depth;
        var p = void 0;
        root.visitAfter(function(n) {
            if (n.firstChild)
                n.breadth = pv.mean(n.childNodes, function(n) {
                    return n.breadth;
                });
            else {
                if (group && p != n.parentNode) {
                    p = n.parentNode;
                    leafIndex += group;
                }
                n.breadth = breadth * leafIndex++;
            }
            n.depth = 1 - n.depth * depth;
        });
        root.visitAfter(function(n) {
            n.minBreadth = n.firstChild ? n.firstChild.minBreadth : n.breadth - breadth / 2;
            n.maxBreadth = n.firstChild ? n.lastChild.maxBreadth : n.breadth + breadth / 2;
        });
        root.visitBefore(function(n) {
            n.minDepth = n.parentNode ? n.parentNode.maxDepth : 0;
            n.maxDepth = n.parentNode ? n.depth + root.depth : n.minDepth + 2 * root.depth;
        });
        root.minDepth = -depth;
        pv.Layout.Hierarchy.NodeLink.buildImplied.call(this, s);
    }
}
;

pv.Layout.Cluster.Fill = function() {
    pv.Layout.Cluster.call(this);
    pv.Layout.Hierarchy.Fill.constructor.call(this);
}
;

pv.Layout.Cluster.Fill.prototype = pv.extend(pv.Layout.Cluster);

pv.Layout.Cluster.Fill.prototype.buildImplied = function(s) {
    pv.Layout.Cluster.prototype.buildImplied.call(this, s) || pv.Layout.Hierarchy.Fill.buildImplied.call(this, s);
}
;

pv.Layout.Partition = function() {
    pv.Layout.Hierarchy.call(this);
}
;

pv.Layout.Partition.prototype = pv.extend(pv.Layout.Hierarchy).property("order", String).property("orient", String).property("innerRadius", Number).property("outerRadius", Number);

pv.Layout.Partition.prototype.defaults = new pv.Layout.Partition().extend(pv.Layout.Hierarchy.prototype.defaults).orient("top");

pv.Layout.Partition.prototype.$size = function() {
    return 1;
}
;

pv.Layout.Partition.prototype.size = function(f) {
    this.$size = f;
    return this;
}
;

pv.Layout.Partition.prototype.buildImplied = function(s) {
    if (!pv.Layout.Hierarchy.prototype.buildImplied.call(this, s)) {
        var that = this
          , root = s.nodes[0]
          , stack = pv.Mark.stack
          , maxDepth = 0;
        stack.unshift(null);
        root.visitAfter(function(n, depth) {
            depth > maxDepth && (maxDepth = depth);
            n.size = n.firstChild ? pv.sum(n.childNodes, function(n) {
                return n.size;
            }) : that.$size.apply(that, (stack[0] = n,
            stack));
        });
        stack.shift();
        switch (s.order) {
        case "ascending":
            root.sort(function(a, b) {
                return a.size - b.size;
            });
            break;

        case "descending":
            root.sort(function(b, a) {
                return a.size - b.size;
            });
        }
        root.minBreadth = 0;
        root.breadth = .5;
        root.maxBreadth = 1;
        root.visitBefore(function(n) {
            for (var b = n.minBreadth, s = n.maxBreadth - b, c = n.firstChild; c; c = c.nextSibling) {
                c.minBreadth = b;
                b += c.size / n.size * s;
                c.maxBreadth = b;
                c.breadth = (b + c.minBreadth) / 2;
            }
        });
        root.visitAfter(function(n, depth) {
            n.minDepth = (depth - 1) / maxDepth;
            n.maxDepth = n.depth = depth / maxDepth;
        });
        pv.Layout.Hierarchy.NodeLink.buildImplied.call(this, s);
    }
}
;

pv.Layout.Partition.Fill = function() {
    pv.Layout.Partition.call(this);
    pv.Layout.Hierarchy.Fill.constructor.call(this);
}
;

pv.Layout.Partition.Fill.prototype = pv.extend(pv.Layout.Partition);

pv.Layout.Partition.Fill.prototype.buildImplied = function(s) {
    pv.Layout.Partition.prototype.buildImplied.call(this, s) || pv.Layout.Hierarchy.Fill.buildImplied.call(this, s);
}
;

pv.Layout.Arc = function() {
    pv.Layout.Network.call(this);
    var interpolate, directed, reverse, buildImplied = this.buildImplied;
    this.buildImplied = function(s) {
        buildImplied.call(this, s);
        directed = s.directed;
        interpolate = "radial" == s.orient ? "linear" : "polar";
        reverse = "right" == s.orient || "top" == s.orient;
    }
    ;
    this.link.data(function(p) {
        var s = p.sourceNode
          , t = p.targetNode;
        return reverse != (directed || s.breadth < t.breadth) ? [s, t] : [t, s];
    }).interpolate(function() {
        return interpolate;
    });
}
;

pv.Layout.Arc.prototype = pv.extend(pv.Layout.Network).property("orient", String).property("directed", Boolean);

pv.Layout.Arc.prototype.defaults = new pv.Layout.Arc().extend(pv.Layout.Network.prototype.defaults).orient("bottom");

pv.Layout.Arc.prototype.sort = function(f) {
    this.$sort = f;
    return this;
}
;

pv.Layout.Arc.prototype.buildImplied = function(s) {
    function midAngle(b) {
        switch (orient) {
        case "top":
            return -Math.PI / 2;

        case "bottom":
            return Math.PI / 2;

        case "left":
            return Math.PI;

        case "right":
            return 0;

        case "radial":
            return 2 * (b - .25) * Math.PI;
        }
    }
    function x(b) {
        switch (orient) {
        case "top":
        case "bottom":
            return b * w;

        case "left":
            return 0;

        case "right":
            return w;

        case "radial":
            return w / 2 + r * Math.cos(midAngle(b));
        }
    }
    function y(b) {
        switch (orient) {
        case "top":
            return 0;

        case "bottom":
            return h;

        case "left":
        case "right":
            return b * h;

        case "radial":
            return h / 2 + r * Math.sin(midAngle(b));
        }
    }
    if (!pv.Layout.Network.prototype.buildImplied.call(this, s)) {
        var nodes = s.nodes
          , orient = s.orient
          , sort = this.$sort
          , index = pv.range(nodes.length)
          , w = s.width
          , h = s.height
          , r = Math.min(w, h) / 2;
        sort && index.sort(function(a, b) {
            return sort(nodes[a], nodes[b]);
        });
        for (var i = 0; i < nodes.length; i++) {
            var n = nodes[index[i]]
              , b = n.breadth = (i + .5) / nodes.length;
            n.x = x(b);
            n.y = y(b);
            n.midAngle = midAngle(b);
        }
    }
}
;

pv.Layout.Horizon = function() {
    pv.Layout.call(this);
    var bands, mode, size, fill, red, blue, that = this, buildImplied = this.buildImplied;
    this.buildImplied = function(s) {
        buildImplied.call(this, s);
        bands = s.bands;
        mode = s.mode;
        size = Math.round(("color" == mode ? .5 : 1) * s.height);
        fill = s.backgroundStyle;
        red = pv.ramp(fill, s.negativeStyle).domain(0, bands);
        blue = pv.ramp(fill, s.positiveStyle).domain(0, bands);
    }
    ;
    var bands = new pv.Panel().data(function() {
        return pv.range(2 * bands);
    }).overflow("hidden").height(function() {
        return size;
    }).top(function(i) {
        return "color" == mode ? (1 & i) * size : 0;
    }).fillStyle(function(i) {
        return i ? null : fill;
    });
    this.band = new pv.Mark().top(function(d, i) {
        return "mirror" == mode && 1 & i ? (i + 1 >> 1) * size : null;
    }).bottom(function(d, i) {
        return "mirror" == mode ? 1 & i ? null : (i + 1 >> 1) * -size : (1 & i || -1) * (i + 1 >> 1) * size;
    }).fillStyle(function(d, i) {
        return (1 & i ? red : blue)((i >> 1) + 1);
    });
    this.band.add = function(type) {
        return that.add(pv.Panel).extend(bands).add(type).extend(this);
    }
    ;
}
;

pv.Layout.Horizon.prototype = pv.extend(pv.Layout).property("bands", Number).property("mode", String).property("backgroundStyle", pv.fillStyle).property("positiveStyle", pv.fillStyle).property("negativeStyle", pv.fillStyle);

pv.Layout.Horizon.prototype.defaults = new pv.Layout.Horizon().extend(pv.Layout.prototype.defaults).bands(2).mode("offset").backgroundStyle("white").positiveStyle("#1f77b4").negativeStyle("#d62728");

pv.Layout.Rollup = function() {
    pv.Layout.Network.call(this);
    var nodes, links, that = this, buildImplied = that.buildImplied;
    this.buildImplied = function(s) {
        buildImplied.call(this, s);
        nodes = s.$rollup.nodes;
        links = s.$rollup.links;
    }
    ;
    this.node.data(function() {
        return nodes;
    }).shapeSize(function(d) {
        return 20 * d.nodes.length;
    });
    this.link.interpolate("polar").eccentricity(.8);
    this.link.add = function(type) {
        return that.add(pv.Panel).data(function() {
            return links;
        }).add(type).extend(this);
    }
    ;
}
;

pv.Layout.Rollup.prototype = pv.extend(pv.Layout.Network).property("directed", Boolean);

pv.Layout.Rollup.prototype.x = function(f) {
    this.$x = pv.functor(f);
    return this;
}
;

pv.Layout.Rollup.prototype.y = function(f) {
    this.$y = pv.functor(f);
    return this;
}
;

pv.Layout.Rollup.prototype.buildImplied = function(s) {
    function id(i) {
        return x[i] + "," + y[i];
    }
    if (!pv.Layout.Network.prototype.buildImplied.call(this, s)) {
        var nodes = s.nodes
          , links = s.links
          , directed = s.directed
          , n = nodes.length
          , x = []
          , y = []
          , rnindex = 0
          , rnodes = {}
          , rlinks = {}
          , stack = pv.Mark.stack
          , o = {
            parent: this
        };
        stack.unshift(null);
        for (var i = 0; n > i; i++) {
            o.index = i;
            stack[0] = nodes[i];
            x[i] = this.$x.apply(o, stack);
            y[i] = this.$y.apply(o, stack);
        }
        stack.shift();
        for (var i = 0; i < nodes.length; i++) {
            var nodeId = id(i)
              , rn = rnodes[nodeId];
            if (!rn) {
                rn = rnodes[nodeId] = Object.create(nodes[i]);
                rn.index = rnindex++;
                rn.x = x[i];
                rn.y = y[i];
                rn.nodes = [];
            }
            rn.nodes.push(nodes[i]);
        }
        for (var i = 0; i < links.length; i++) {
            var source = links[i].sourceNode
              , target = links[i].targetNode
              , rsource = rnodes[id(source.index)]
              , rtarget = rnodes[id(target.index)]
              , reverse = !directed && rsource.index > rtarget.index
              , linkId = reverse ? rtarget.index + "," + rsource.index : rsource.index + "," + rtarget.index
              , rl = rlinks[linkId];
            rl || (rl = rlinks[linkId] = {
                sourceNode: rsource,
                targetNode: rtarget,
                linkValue: 0,
                links: []
            });
            rl.links.push(links[i]);
            rl.linkValue += links[i].linkValue;
        }
        s.$rollup = {
            nodes: pv.values(rnodes),
            links: pv.values(rlinks)
        };
    }
}
;

pv.Layout.Matrix = function() {
    pv.Layout.Network.call(this);
    var n, dx, dy, labels, pairs, that = this, buildImplied = that.buildImplied;
    this.buildImplied = function(s) {
        buildImplied.call(this, s);
        n = s.nodes.length;
        dx = s.width / n;
        dy = s.height / n;
        labels = s.$matrix.labels;
        pairs = s.$matrix.pairs;
    }
    ;
    this.link.data(function() {
        return pairs;
    }).left(function() {
        return dx * (this.index % n);
    }).top(function() {
        return dy * Math.floor(this.index / n);
    }).width(function() {
        return dx;
    }).height(function() {
        return dy;
    }).lineWidth(1.5).strokeStyle("#fff").fillStyle(function(l) {
        return l.linkValue ? "#555" : "#eee";
    }).parent = this;
    delete this.link.add;
    this.label.data(function() {
        return labels;
    }).left(function() {
        return 1 & this.index ? dx * ((this.index >> 1) + .5) : 0;
    }).top(function() {
        return 1 & this.index ? 0 : dy * ((this.index >> 1) + .5);
    }).textMargin(4).textAlign(function() {
        return 1 & this.index ? "left" : "right";
    }).textAngle(function() {
        return 1 & this.index ? -Math.PI / 2 : 0;
    });
    delete this.node;
}
;

pv.Layout.Matrix.prototype = pv.extend(pv.Layout.Network).property("directed", Boolean);

pv.Layout.Matrix.prototype.sort = function(f) {
    this.$sort = f;
    return this;
}
;

pv.Layout.Matrix.prototype.buildImplied = function(s) {
    if (!pv.Layout.Network.prototype.buildImplied.call(this, s)) {
        var nodes = s.nodes
          , links = s.links
          , sort = this.$sort
          , n = nodes.length
          , index = pv.range(n)
          , labels = []
          , pairs = []
          , map = {};
        s.$matrix = {
            labels: labels,
            pairs: pairs
        };
        sort && index.sort(function(a, b) {
            return sort(nodes[a], nodes[b]);
        });
        for (var i = 0; n > i; i++)
            for (var j = 0; n > j; j++) {
                var a = index[i]
                  , b = index[j]
                  , p = {
                    row: i,
                    col: j,
                    sourceNode: nodes[a],
                    targetNode: nodes[b],
                    linkValue: 0
                };
                pairs.push(map[a + "." + b] = p);
            }
        for (var i = 0; n > i; i++) {
            var a = index[i];
            labels.push(nodes[a], nodes[a]);
        }
        for (var i = 0; i < links.length; i++) {
            var l = links[i]
              , source = l.sourceNode.index
              , target = l.targetNode.index
              , value = l.linkValue;
            map[source + "." + target].linkValue += value;
            s.directed || (map[target + "." + source].linkValue += value);
        }
    }
}
;

pv.Layout.Bullet = function() {
    pv.Layout.call(this);
    var orient, horizontal, rangeColor, measureColor, x, that = this, buildImplied = that.buildImplied, scale = that.x = pv.Scale.linear();
    this.buildImplied = function(s) {
        buildImplied.call(this, x = s);
        orient = s.orient;
        horizontal = /^left|right$/.test(orient);
        rangeColor = pv.ramp("#bbb", "#eee").domain(0, Math.max(1, x.ranges.length - 1));
        measureColor = pv.ramp("steelblue", "lightsteelblue").domain(0, Math.max(1, x.measures.length - 1));
    }
    ;
    (this.range = new pv.Mark()).data(function() {
        return x.ranges;
    }).reverse(!0).left(function() {
        return "left" == orient ? 0 : null;
    }).top(function() {
        return "top" == orient ? 0 : null;
    }).right(function() {
        return "right" == orient ? 0 : null;
    }).bottom(function() {
        return "bottom" == orient ? 0 : null;
    }).width(function(d) {
        return horizontal ? scale(d) : null;
    }).height(function(d) {
        return horizontal ? null : scale(d);
    }).fillStyle(function() {
        return rangeColor(this.index);
    }).antialias(!1).parent = that;
    (this.measure = new pv.Mark()).extend(this.range).data(function() {
        return x.measures;
    }).left(function() {
        return "left" == orient ? 0 : horizontal ? null : this.parent.width() / 3.25;
    }).top(function() {
        return "top" == orient ? 0 : horizontal ? this.parent.height() / 3.25 : null;
    }).right(function() {
        return "right" == orient ? 0 : horizontal ? null : this.parent.width() / 3.25;
    }).bottom(function() {
        return "bottom" == orient ? 0 : horizontal ? this.parent.height() / 3.25 : null;
    }).fillStyle(function() {
        return measureColor(this.index);
    }).parent = that;
    (this.marker = new pv.Mark()).data(function() {
        return x.markers;
    }).left(function(d) {
        return "left" == orient ? scale(d) : horizontal ? null : this.parent.width() / 2;
    }).top(function(d) {
        return "top" == orient ? scale(d) : horizontal ? this.parent.height() / 2 : null;
    }).right(function(d) {
        return "right" == orient ? scale(d) : null;
    }).bottom(function(d) {
        return "bottom" == orient ? scale(d) : null;
    }).strokeStyle("black").shape("bar").shapeAngle(function() {
        return horizontal ? 0 : Math.PI / 2;
    }).parent = that;
    (this.tick = new pv.Mark()).data(function() {
        return scale.ticks(7);
    }).left(function(d) {
        return "left" == orient ? scale(d) : null;
    }).top(function(d) {
        return "top" == orient ? scale(d) : null;
    }).right(function(d) {
        return "right" == orient ? scale(d) : horizontal ? null : -6;
    }).bottom(function(d) {
        return "bottom" == orient ? scale(d) : horizontal ? -8 : null;
    }).height(function() {
        return horizontal ? 6 : null;
    }).width(function() {
        return horizontal ? null : 6;
    }).parent = that;
}
;

pv.Layout.Bullet.prototype = pv.extend(pv.Layout).property("orient", String).property("ranges").property("markers").property("measures").property("minimum").property("maximum");

pv.Layout.Bullet.prototype.defaults = new pv.Layout.Bullet().extend(pv.Layout.prototype.defaults).orient("left").ranges([]).markers([]).measures([]);

pv.Layout.Bullet.prototype._originIsZero = !0;

pv.Layout.Bullet.prototype.originIsZero = function(value) {
    return arguments.length ? this._originIsZero = !!value : this._originIsZero;
}
;

pv.Layout.Bullet.prototype.buildImplied = function(s) {
    pv.Layout.prototype.buildImplied.call(this, s);
    var allValues, size = this.parent[/^left|right$/.test(s.orient) ? "width" : "height"](), max = s.maximum, min = s.minimum, delta = 1e-10;
    if (null == max) {
        allValues = [].concat(s.ranges, s.markers, s.measures);
        max = pv.max(allValues);
    } else
        max = +max;
    if (null == min) {
        allValues || (allValues = [].concat(s.ranges, s.markers, s.measures));
        min = pv.min(allValues);
        min = .95 * min;
    } else
        min = +min;
    (min > max || delta > max - min) && (min = Math.abs(max) < delta ? -.1 : .99 * max);
    this._originIsZero && min * max > 0 && (min > 0 ? min = 0 : max = 0);
    s.minimum = min;
    s.maximum = max;
    this.x.domain(min, max).range(0, size);
}
;

pv.Behavior = {};

pv.Behavior.dragBase = function(shared) {
    function mousedown(d) {
        if (!inited) {
            inited = !0;
            this.addEventInterceptor("click", eventInterceptor, !0);
        }
        if (!events) {
            var root = this.root.scene.$g;
            events = [[root, "mousemove", pv.listen(root, "mousemove", mousemove)], [root, "mouseup", pv.listen(root, "mouseup", mouseup)], [document, "mousemove", pv.listen(document, "mousemove", mousemove)], [document, "mouseup", pv.listen(document, "mouseup", mouseup)]];
        }
        var ev = arguments[arguments.length - 1];
        downElem = ev.target;
        cancelClick = !1;
        ev.stopPropagation();
        var m1 = this.mouse()
          , scene = this.scene
          , index = this.index;
        drag = scene[index].drag = {
            phase: "start",
            m: m1,
            m1: m1,
            m2: null,
            d: d,
            scene: scene,
            index: index
        };
        ev = wrapEvent(ev, drag);
        shared.dragstart.call(this, ev);
        var m = drag.m;
        if (m !== m1) {
            m1.x = m.x;
            m1.y = m.y;
        }
    }
    function mousemove(ev) {
        if (drag) {
            drag.phase = "move";
            ev.stopPropagation();
            ev = wrapEvent(ev, drag);
            var scene = drag.scene;
            scene.mark.context(scene, drag.index, function() {
                var mprev = drag.m2 || drag.m1
                  , m2 = this.mouse();
                if (!(mprev && m2.distance2(mprev).dist2 <= 2)) {
                    drag.m = drag.m2 = m2;
                    shared.drag.call(this, ev);
                    var m = drag.m;
                    if (m !== m2) {
                        m2.x = m.x;
                        m2.y = m.y;
                    }
                }
            });
        }
    }
    function mouseup(ev) {
        if (drag) {
            drag.phase = "end";
            var m2 = drag.m2
              , isDrag = m2 && drag.m1.distance2(m2).dist2 > .1;
            drag.canceled = !isDrag;
            cancelClick = isDrag && downElem === ev.target;
            cancelClick || (downElem = null);
            ev.stopPropagation();
            ev = wrapEvent(ev, drag);
            if (events) {
                events.forEach(function(registration) {
                    pv.unlisten.apply(pv, registration);
                });
                events = null;
            }
            var scene = drag.scene
              , index = drag.index;
            try {
                scene.mark.context(scene, index, function() {
                    shared.dragend.call(this, ev);
                });
            } finally {
                drag = null;
                delete scene[index].drag;
            }
        }
    }
    function wrapEvent(ev, drag) {
        try {
            ev.drag = drag;
            return ev;
        } catch (ex) {}
        var ev2 = {};
        for (var p in ev) {
            var v = ev[p];
            ev2[p] = "function" != typeof v ? v : bindEventFun(v, ev);
        }
        ev2._sourceEvent = ev;
        return ev2;
    }
    function bindEventFun(f, ctx) {
        return function() {
            return f.apply(ctx, arguments);
        }
        ;
    }
    function eventInterceptor(type, ev) {
        if (cancelClick && downElem === ev.target) {
            cancelClick = !1;
            downElem = null;
            return !1;
        }
    }
    var events, downElem, cancelClick, inited, drag;
    shared.autoRender = !0;
    shared.positionConstraint = null;
    shared.bound = function(v, a_p) {
        return Math.max(drag.min[a_p], Math.min(drag.max[a_p], v));
    }
    ;
    mousedown.autoRender = function(_) {
        if (arguments.length) {
            shared.autoRender = !!_;
            return mousedown;
        }
        return shared.autoRender;
    }
    ;
    mousedown.positionConstraint = function(_) {
        if (arguments.length) {
            shared.positionConstraint = _;
            return mousedown;
        }
        return shared.positionConstraint;
    }
    ;
    return mousedown;
}
;

pv.Behavior.drag = function() {
    var v1, collapse = null, kx = 1, ky = 1, shared = {
        dragstart: function(ev) {
            var drag = ev.drag;
            drag.type = "drag";
            var p = drag.d
              , fix = pv.vector(p.x, p.y);
            p.fix = fix;
            p.drag = drag;
            v1 = fix.minus(drag.m1);
            var parent = this.parent;
            drag.max = {
                x: parent.width() - (p.dx || 0),
                y: parent.height() - (p.dy || 0)
            };
            drag.min = {
                x: 0,
                y: 0
            };
            shared.autoRender && this.render();
            pv.Mark.dispatch("dragstart", drag.scene, drag.index, ev);
        },
        drag: function(ev) {
            var drag = ev.drag
              , m2 = drag.m2
              , p = drag.d;
            drag.m = v1.plus(m2);
            var constraint = shared.positionConstraint;
            constraint && constraint(drag);
            var m = drag.m;
            kx && (p.x = p.fix.x = shared.bound(m.x, "x"));
            ky && (p.y = p.fix.y = shared.bound(m.y, "y"));
            shared.autoRender && this.render();
            pv.Mark.dispatch("drag", drag.scene, drag.index, ev);
        },
        dragend: function(ev) {
            var drag = ev.drag
              , p = drag.d;
            p.fix = null;
            v1 = null;
            shared.autoRender && this.render();
            try {
                pv.Mark.dispatch("dragend", drag.scene, drag.index, ev);
            } finally {
                delete p.drag;
            }
        }
    }, mousedown = pv.Behavior.dragBase(shared);
    mousedown.collapse = function(x) {
        if (arguments.length) {
            collapse = String(x);
            switch (collapse) {
            case "y":
                kx = 1;
                ky = 0;
                break;

            case "x":
                kx = 0;
                ky = 1;
                break;

            default:
                kx = 1;
                ky = 1;
            }
            return mousedown;
        }
        return collapse;
    }
    ;
    return mousedown;
}
;

pv.Behavior.point = function(keyArgs) {
    function searchSceneChildren(scene, curr) {
        if (scene.visible)
            for (var i = scene.children.length - 1; i >= 0; i--)
                if (searchScenes(scene.children[i], curr))
                    return !0;
    }
    function searchScenes(scenes, curr) {
        var result, j, isPointingBarrier, mark = scenes.mark, isPanel = "panel" === mark.type;
        if (mark.$handlers.point) {
            var visibility, mouse = (isPanel && mark.parent || mark).mouse(), markRMax = mark._pointingRadiusMax, markCostMax = markRMax * markRMax;
            j = scenes.length;
            for (; j--; )
                if ((visibility = sceneVisibility(scenes, j)) && evalScene(scenes, j, mouse, curr, visibility, markCostMax)) {
                    result = !0;
                    break;
                }
        }
        if (isPanel) {
            mark.scene = scenes;
            isPointingBarrier = !(!mark.isPointingBarrier || !mark.parent);
            try {
                j = scenes.length;
                for (; j--; ) {
                    mark.index = j;
                    if ((!isPointingBarrier || mark.getShape(scenes, j).containsPoint(mark.parent.mouse())) && searchSceneChildren(scenes[j], curr))
                        return !0;
                }
            } finally {
                delete mark.scene;
                delete mark.index;
            }
        }
        return result;
    }
    function sceneVisibility(scenes, index) {
        var s = scenes[index];
        if (!s.visible)
            return 0;
        if (!painted)
            return 1;
        var ps = scenes.mark.properties;
        if (!ps.fillStyle && !ps.strokeStyle)
            return 1;
        var o1 = s.fillStyle ? s.fillStyle.opacity : 0
          , o2 = s.strokeStyle ? s.strokeStyle.opacity : 0
          , o = Math.max(o1, o2);
        return .02 > o ? 0 : o > .98 ? 1 : .5;
    }
    function evalScene(scenes, index, mouse, curr, visibility, markCostMax) {
        function makeChoice() {
            if (applyMarkCostMax && 0 >= markCostMax)
                return -1;
            cand = shape.distance2(mouse, k);
            if (applyMarkCostMax && pv.floatLess(markCostMax, cand.cost))
                return -2;
            if (finiteDist2Max && !inside && pv.floatLess(dist2Max, cand.dist2))
                return -3;
            if (hasArea === curr.hasArea) {
                if (inside < curr.inside)
                    return -4;
                if (inside > curr.inside)
                    return 1;
            } else {
                if (collapse) {
                    if (!inside && curr.inside)
                        return -5;
                    if (inside && !curr.inside)
                        return 2;
                }
                if (hasArea || 2 !== curr.inside) {
                    if (hasArea && 2 === inside) {
                        if (2 === curr.inside)
                            return -7;
                        if (0 === curr.inside && pv.floatLess(3, curr.cost))
                            return 4;
                    }
                } else {
                    if (2 === inside)
                        return 3;
                    if (0 === inside && pv.floatLess(3, cand.cost))
                        return -6;
                }
            }
            if (!collapse || !inside) {
                if (pv.floatLess(curr.dist2, cand.dist2))
                    return -8;
                if (pv.floatLess(cand.dist2, curr.dist2))
                    return 5;
            }
            return collapse && pv.floatLess(cand.cost, curr.cost) ? 6 : -9;
        }
        var cand, shape = scenes.mark.getShape(scenes, index), hasArea = shape.hasArea(), inside = shape.containsPoint(mouse, k) ? !collapse || shape.containsPoint(mouse) ? 2 : 1 : 0, applyMarkCostMax = isFinite(markCostMax) && 2 > inside, choice = makeChoice();
        DEBUG && function() {
            if (-3 > choice || choice > 0) {
                var pointMark = scenes && scenes.mark;
                console.log("POINT " + (choice > 0 ? "choose" : "skip") + " (" + choice + ") " + (pointMark ? pointMark.type + " " + index : "none") + " in=" + inside + " d2=" + (cand && cand.dist2) + " cost=" + (cand && cand.cost) + " opaq=" + (1 === visibility));
            }
        }();
        if (choice > 0) {
            curr.hasArea = hasArea;
            curr.inside = inside;
            curr.dist2 = cand.dist2;
            curr.cost = cand.cost;
            curr.scenes = scenes;
            curr.index = index;
            curr.shape = shape;
            if (hasArea && 2 === inside && 1 === visibility)
                return !0;
        }
    }
    function mousemove() {
        var e = pv.event;
        DEBUG && console.log("POINT MOUSE MOVE BEG");
        try {
            var point = {
                cost: 1 / 0,
                dist2: 1 / 0,
                inside: 0,
                hasArea: !1,
                x: e.pageX || 0,
                y: e.pageY || 0
            };
            if (unpoint && radiusHyst2 && pv.Shape.dist2(point, unpoint).cost < radiusHyst2)
                return;
            searchSceneChildren(this.scene[this.index], point);
            point.inside || isFinite(point.cost) || (point = null);
            e.pointFrom = unpoint;
            e.pointTo = point;
            if (unpoint) {
                if (point && unpoint.scenes == point.scenes && unpoint.index == point.index)
                    return;
                e.isPointSwitch = !!point;
                pv.Mark.dispatch("unpoint", unpoint.scenes, unpoint.index, e);
            }
            unpoint = point;
            if (point) {
                pv.Mark.dispatch("point", point.scenes, point.index, e);
                if (pointingPanel)
                    ;
                else if ("panel" === this.type) {
                    pointingPanel = this;
                    this.event("mouseout", function() {
                        mouseout.call(this.scene.$g);
                    });
                    stealClick && pointingPanel.addEventInterceptor("click", eventInterceptor);
                } else
                    pv.listen(this.root.canvas(), "mouseout", mouseout);
            }
        } finally {
            DEBUG && console.log("POINT MOUSE MOVE END");
        }
    }
    function mouseout() {
        var e = pv.event;
        if (unpoint && !pv.ancestor(this, e.relatedTarget)) {
            pv.Mark.dispatch("unpoint", unpoint.scenes, unpoint.index, e);
            unpoint = null;
        }
    }
    function eventInterceptor(type, ev) {
        if (unpoint) {
            var scenes = unpoint.scenes
              , handler = scenes.mark.$handlers[type];
            if (handler)
                return [handler, scenes, unpoint.index, ev];
        }
    }
    "object" != typeof keyArgs && (keyArgs = {
        radius: keyArgs
    });
    var unpoint, DEBUG = 0, collapse = null, painted = !!pv.get(keyArgs, "painted", !1), stealClick = !!pv.get(keyArgs, "stealClick", !1), k = {
        x: 1,
        y: 1
    }, pointingPanel = null, dist2Max = function() {
        var r = pv.parseNumNonNeg(pv.get(keyArgs, "radius"), 30);
        return r * r;
    }(), finiteDist2Max = isFinite(dist2Max), radiusHyst2 = function() {
        var r = pv.parseNumNonNeg(pv.get(keyArgs, "radiusHyst"), 0);
        isFinite(r) || (r = 4);
        return r * r;
    }();
    mousemove.collapse = function(x) {
        if (arguments.length) {
            collapse = String(x);
            switch (collapse) {
            case "y":
                k.x = 1;
                k.y = 0;
                break;

            case "x":
                k.x = 0;
                k.y = 1;
                break;

            default:
                k.x = 1;
                k.y = 1;
                collapse = null;
            }
            return mousemove;
        }
        return collapse;
    }
    ;
    keyArgs && null != keyArgs.collapse && mousemove.collapse(keyArgs.collapse);
    keyArgs = null;
    return mousemove;
}
;

pv.Behavior.select = function() {
    var collapse = null
      , kx = 1
      , ky = 1
      , preserveLength = !1
      , shared = {
        dragstart: function(ev) {
            var drag = ev.drag;
            drag.type = "select";
            drag.dxmin = 0;
            drag.dymin = 0;
            var r = drag.d;
            r.drag = drag;
            drag.max = {
                x: this.width(),
                y: this.height()
            };
            drag.min = {
                x: 0,
                y: 0
            };
            var constraint = shared.positionConstraint;
            if (constraint) {
                drag.m = drag.m.clone();
                constraint(drag);
            }
            var m = drag.m;
            if (kx) {
                r.x = shared.bound(m.x, "x");
                preserveLength || (r.dx = Math.max(0, drag.dxmin));
            }
            if (ky) {
                r.y = shared.bound(m.y, "y");
                preserveLength || (r.dy = Math.max(0, drag.dymin));
            }
            pv.Mark.dispatch("selectstart", drag.scene, drag.index, ev);
        },
        drag: function(ev) {
            var drag = ev.drag
              , m1 = drag.m1
              , r = drag.d;
            drag.max.x = this.width();
            drag.max.y = this.height();
            var constraint = shared.positionConstraint;
            if (constraint) {
                drag.m = drag.m.clone();
                constraint(drag);
            }
            var m = drag.m;
            if (kx) {
                var bx = Math.min(m1.x, m.x);
                bx = shared.bound(bx, "x");
                r.x = bx;
                if (!preserveLength) {
                    var ex = Math.max(m.x, m1.x);
                    ex = shared.bound(ex, "x");
                    r.dx = Math.max(0, drag.dxmin, ex - bx);
                }
            }
            if (ky) {
                var by = Math.min(m1.y, m.y);
                by = shared.bound(by, "y");
                r.y = by;
                if (!preserveLength) {
                    var ey = Math.max(m.y, m1.y);
                    ey = shared.bound(ey, "y");
                    r.dy = Math.max(0, drag.dymin, ey - by);
                }
            }
            shared.autoRender && this.render();
            pv.Mark.dispatch("select", drag.scene, drag.index, ev);
        },
        dragend: function(ev) {
            var drag = ev.drag;
            try {
                pv.Mark.dispatch("selectend", drag.scene, drag.index, ev);
            } finally {
                var r = drag.d;
                delete r.drag;
            }
        }
    }
      , mousedown = pv.Behavior.dragBase(shared);
    mousedown.collapse = function(x) {
        if (arguments.length) {
            collapse = String(x);
            switch (collapse) {
            case "y":
                kx = 1;
                ky = 0;
                break;

            case "x":
                kx = 0;
                ky = 1;
                break;

            default:
                kx = 1;
                ky = 1;
            }
            return mousedown;
        }
        return collapse;
    }
    ;
    mousedown.preserveLength = function(_) {
        if (arguments.length) {
            preserveLength = !!_;
            return mousedown;
        }
        return preserveLength;
    }
    ;
    return mousedown;
}
;

pv.Behavior.resize = function(side) {
    var preserveOrtho = !1
      , isLeftRight = "left" === side || "right" === side
      , shared = {
        dragstart: function(ev) {
            var drag = ev.drag;
            drag.type = "resize";
            var m1 = drag.m1
              , r = drag.d;
            r.drag = drag;
            switch (side) {
            case "left":
                m1.x = r.x + r.dx;
                break;

            case "right":
                m1.x = r.x;
                break;

            case "top":
                m1.y = r.y + r.dy;
                break;

            case "bottom":
                m1.y = r.y;
            }
            var parent = this.parent;
            drag.max = {
                x: parent.width(),
                y: parent.height()
            };
            drag.min = {
                x: 0,
                y: 0
            };
            pv.Mark.dispatch("resizestart", drag.scene, drag.index, ev);
        },
        drag: function(ev) {
            var drag = ev.drag
              , m1 = drag.m1
              , constraint = shared.positionConstraint;
            if (constraint) {
                drag.m = drag.m.clone();
                constraint(drag);
            }
            var m = drag.m
              , r = drag.d;
            if (!preserveOrtho || isLeftRight) {
                var bx = Math.min(m1.x, m.x)
                  , ex = Math.max(m.x, m1.x);
                bx = shared.bound(bx, "x");
                ex = shared.bound(ex, "x");
                r.x = bx;
                r.dx = ex - bx;
            }
            if (!preserveOrtho || !isLeftRight) {
                var by = Math.min(m1.y, m.y)
                  , ey = Math.max(m.y, m1.y);
                by = shared.bound(by, "y");
                ey = shared.bound(ey, "y");
                r.y = by;
                r.dy = ey - by;
            }
            shared.autoRender && this.render();
            pv.Mark.dispatch("resize", drag.scene, drag.index, ev);
        },
        dragend: function(ev) {
            var drag = ev.drag;
            drag.max = null;
            try {
                pv.Mark.dispatch("resizeend", drag.scene, drag.index, ev);
            } finally {
                var r = drag.d;
                delete r.drag;
            }
        }
    }
      , mousedown = pv.Behavior.dragBase(shared);
    mousedown.preserveOrtho = function(_) {
        if (arguments.length) {
            preserveOrtho = !!_;
            return mousedown;
        }
        return preserveOrtho;
    }
    ;
    return mousedown;
}
;

pv.Behavior.pan = function() {
    function mousedown() {
        index = this.index;
        scene = this.scene;
        v1 = pv.vector(pv.event.pageX, pv.event.pageY);
        m1 = this.transform();
        k = 1 / (m1.k * this.scale);
        bound && (bound = {
            x: (1 - m1.k) * this.width(),
            y: (1 - m1.k) * this.height()
        });
    }
    function mousemove(e) {
        if (scene) {
            scene.mark.context(scene, index, function() {
                var x = (pv.event.pageX - v1.x) * k
                  , y = (pv.event.pageY - v1.y) * k
                  , m = m1.translate(x, y);
                if (bound) {
                    m.x = Math.max(bound.x, Math.min(0, m.x));
                    m.y = Math.max(bound.y, Math.min(0, m.y));
                }
                this.transform(m).render();
            });
            pv.Mark.dispatch("pan", scene, index, e);
        }
    }
    function mouseup() {
        scene = null;
    }
    var scene, index, m1, v1, k, bound;
    mousedown.bound = function(x) {
        if (arguments.length) {
            bound = Boolean(x);
            return this;
        }
        return Boolean(bound);
    }
    ;
    pv.listen(window, "mousemove", mousemove);
    pv.listen(window, "mouseup", mouseup);
    return mousedown;
}
;

pv.Behavior.zoom = function(speed) {
    function mousewheel(e) {
        var v = this.mouse()
          , k = pv.event.wheel * speed
          , m = this.transform().translate(v.x, v.y).scale(0 > k ? 1e3 / (1e3 - k) : (1e3 + k) / 1e3).translate(-v.x, -v.y);
        if (bound) {
            m.k = Math.max(1, m.k);
            m.x = Math.max((1 - m.k) * this.width(), Math.min(0, m.x));
            m.y = Math.max((1 - m.k) * this.height(), Math.min(0, m.y));
        }
        this.transform(m).render();
        pv.Mark.dispatch("zoom", this.scene, this.index, e);
    }
    var bound;
    arguments.length || (speed = 1 / 48);
    mousewheel.bound = function(x) {
        if (arguments.length) {
            bound = Boolean(x);
            return this;
        }
        return Boolean(bound);
    }
    ;
    return mousewheel;
}
;

pv.Geo = function() {}
;

pv.Geo.projections = {
    mercator: {
        project: function(latlng) {
            return {
                x: latlng.lng / 180,
                y: latlng.lat > 85 ? 1 : latlng.lat < -85 ? -1 : Math.log(Math.tan(Math.PI / 4 + pv.radians(latlng.lat) / 2)) / Math.PI
            };
        },
        invert: function(xy) {
            return {
                lng: 180 * xy.x,
                lat: pv.degrees(2 * Math.atan(Math.exp(xy.y * Math.PI)) - Math.PI / 2)
            };
        }
    },
    "gall-peters": {
        project: function(latlng) {
            return {
                x: latlng.lng / 180,
                y: Math.sin(pv.radians(latlng.lat))
            };
        },
        invert: function(xy) {
            return {
                lng: 180 * xy.x,
                lat: pv.degrees(Math.asin(xy.y))
            };
        }
    },
    sinusoidal: {
        project: function(latlng) {
            return {
                x: pv.radians(latlng.lng) * Math.cos(pv.radians(latlng.lat)) / Math.PI,
                y: latlng.lat / 90
            };
        },
        invert: function(xy) {
            return {
                lng: pv.degrees(xy.x * Math.PI / Math.cos(xy.y * Math.PI / 2)),
                lat: 90 * xy.y
            };
        }
    },
    aitoff: {
        project: function(latlng) {
            var l = pv.radians(latlng.lng)
              , f = pv.radians(latlng.lat)
              , a = Math.acos(Math.cos(f) * Math.cos(l / 2));
            return {
                x: 2 * (a ? Math.cos(f) * Math.sin(l / 2) * a / Math.sin(a) : 0) / Math.PI,
                y: 2 * (a ? Math.sin(f) * a / Math.sin(a) : 0) / Math.PI
            };
        },
        invert: function(xy) {
            var x = xy.x * Math.PI / 2
              , y = xy.y * Math.PI / 2;
            return {
                lng: pv.degrees(x / Math.cos(y)),
                lat: pv.degrees(y)
            };
        }
    },
    hammer: {
        project: function(latlng) {
            var l = pv.radians(latlng.lng)
              , f = pv.radians(latlng.lat)
              , c = Math.sqrt(1 + Math.cos(f) * Math.cos(l / 2));
            return {
                x: 2 * Math.SQRT2 * Math.cos(f) * Math.sin(l / 2) / c / 3,
                y: Math.SQRT2 * Math.sin(f) / c / 1.5
            };
        },
        invert: function(xy) {
            var x = 3 * xy.x
              , y = 1.5 * xy.y
              , z = Math.sqrt(1 - x * x / 16 - y * y / 4);
            return {
                lng: pv.degrees(2 * Math.atan2(z * x, 2 * (2 * z * z - 1))),
                lat: pv.degrees(Math.asin(z * y))
            };
        }
    },
    identity: {
        project: function(latlng) {
            return {
                x: latlng.lng / 180,
                y: latlng.lat / 90
            };
        },
        invert: function(xy) {
            return {
                lng: 180 * xy.x,
                lat: 90 * xy.y
            };
        }
    }
};

pv.Geo.scale = function(p) {
    function scale(latlng) {
        if (!lastLatLng || latlng.lng != lastLatLng.lng || latlng.lat != lastLatLng.lat) {
            lastLatLng = latlng;
            var p = project(latlng);
            lastPoint = {
                x: x(p.x),
                y: y(p.y)
            };
        }
        return lastPoint;
    }
    function project(latlng) {
        var offset = {
            lng: latlng.lng - c.lng,
            lat: latlng.lat
        };
        return j.project(offset);
    }
    function invert(xy) {
        var latlng = j.invert(xy);
        latlng.lng += c.lng;
        return latlng;
    }
    var lastLatLng, lastPoint, rmin = {
        x: 0,
        y: 0
    }, rmax = {
        x: 1,
        y: 1
    }, d = [], j = pv.Geo.projections.identity, x = pv.Scale.linear(-1, 1).range(0, 1), y = pv.Scale.linear(-1, 1).range(1, 0), c = {
        lng: 0,
        lat: 0
    };
    scale.x = function(latlng) {
        return scale(latlng).x;
    }
    ;
    scale.y = function(latlng) {
        return scale(latlng).y;
    }
    ;
    scale.ticks = {
        lng: function(m) {
            var lat, lng;
            if (d.length > 1) {
                var s = pv.Scale.linear();
                void 0 == m && (m = 10);
                lat = s.domain(d, function(d) {
                    return d.lat;
                }).ticks(m);
                lng = s.domain(d, function(d) {
                    return d.lng;
                }).ticks(m);
            } else {
                lat = pv.range(-80, 81, 10);
                lng = pv.range(-180, 181, 10);
            }
            return lng.map(function(lng) {
                return lat.map(function(lat) {
                    return {
                        lat: lat,
                        lng: lng
                    };
                });
            });
        },
        lat: function(m) {
            return pv.transpose(scale.ticks.lng(m));
        }
    };
    scale.invert = function(p) {
        return invert({
            x: x.invert(p.x),
            y: y.invert(p.y)
        });
    }
    ;
    scale.domain = function(array, f) {
        if (arguments.length) {
            d = array instanceof Array ? arguments.length > 1 ? pv.map(array, f) : array : Array.prototype.slice.call(arguments);
            if (d.length > 1) {
                var lngs = d.map(function(c) {
                    return c.lng;
                })
                  , lats = d.map(function(c) {
                    return c.lat;
                });
                c = {
                    lng: (pv.max(lngs) + pv.min(lngs)) / 2,
                    lat: (pv.max(lats) + pv.min(lats)) / 2
                };
                var n = d.map(project);
                x.domain(n, function(p) {
                    return p.x;
                });
                y.domain(n, function(p) {
                    return p.y;
                });
            } else {
                c = {
                    lng: 0,
                    lat: 0
                };
                x.domain(-1, 1);
                y.domain(-1, 1);
            }
            lastLatLng = null;
            return this;
        }
        return d;
    }
    ;
    scale.range = function(min, max) {
        if (arguments.length) {
            if ("object" == typeof min) {
                rmin = {
                    x: Number(min.x),
                    y: Number(min.y)
                };
                rmax = {
                    x: Number(max.x),
                    y: Number(max.y)
                };
            } else {
                rmin = {
                    x: 0,
                    y: 0
                };
                rmax = {
                    x: Number(min),
                    y: Number(max)
                };
            }
            x.range(rmin.x, rmax.x);
            y.range(rmax.y, rmin.y);
            lastLatLng = null;
            return this;
        }
        return [rmin, rmax];
    }
    ;
    scale.projection = function(p) {
        if (arguments.length) {
            j = "string" == typeof p ? pv.Geo.projections[p] || pv.Geo.projections.identity : p;
            return this.domain(d);
        }
        return p;
    }
    ;
    pv.copyOwn(scale, pv.Scale.common);
    arguments.length && scale.projection(p);
    return scale;
}
;
/*!
 * Copyright 2002 - 2013 Webdetails, a Pentaho company.  All rights reserved.
 *
 * This software was developed by Webdetails and is provided under the terms
 * of the Mozilla Public License, Version 2.0, or any later version. You may not use
 * this file except in compliance with the license. If you need a copy of the license,
 * please go to  http://mozilla.org/MPL/2.0/. The Initial Developer is Webdetails.
 *
 * Software distributed under the Mozilla Public License is distributed on an "AS IS"
 * basis, WITHOUT WARRANTY OF ANY KIND, either express or  implied. Please refer to
 * the license for the specific language governing your rights and limitations.
 */

/*!
 * Protovis MSIE/VML addon
 * Copyright (C) 2011 by DataMarket <http://datamarket.com>
 * Dual licensed under the terms of the MIT or GPL Version 2 software licenses.
 *
 * This software includes code from jQuery, http://jquery.com/
 * jQuery is licensed under the MIT or GPL Version 2 license.
 *
 * This software includes code from the Protovis, http://mbostock.github.com/protovis/
 * Protovis is licensed under the BSD license.
 *
 */

pv.have_SVG = !(!document.createElementNS || !document.createElementNS("http://www.w3.org/2000/svg", "svg").createSVGRect);

pv.have_VML = function(d, a, b) {
    a = d.createElement("div");
    a.innerHTML = '<pvml:shape adj="1" />';
    b = a.firstChild;
    b.style.behavior = "url(#default#VML)";
    return b ? "object" == typeof b.adj : !0;
}(document);

!pv.have_SVG && pv.have_VML && !function() {
    "function" != typeof Date.now && (Date.now = function() {
        return 1 * new Date();
    }
    );
    var vml = {
        is64Bit: "x64" === window.navigator.cpuClass,
        round: function(n) {
            return Math.round(21.6 * (n || 0));
        },
        styles: null,
        pre: "<pvml:",
        post: ' class="msvml">',
        block: {
            group: 1,
            shape: 1,
            shapetype: 1,
            line: 1,
            polyline: 1,
            curve: 1,
            rect: 1,
            roundrect: 1,
            oval: 1,
            arc: 1,
            image: 1
        },
        caps: {
            butt: "flat",
            round: "round",
            square: "square"
        },
        joins: {
            bevel: "bevel",
            round: "round",
            miter: "miter"
        },
        cursorstyles: {
            hand: "pointer",
            crosshair: 1,
            pointer: 1,
            move: 1,
            text: 1,
            wait: 1,
            help: 1,
            progress: 1,
            "n-resize": 1,
            "ne-resize": 1,
            "nw-resize": 1,
            "s-resize": 1,
            "se-resize": 1,
            "sw-resize": 1,
            "e-resize": 1,
            "w-resize": 1
        },
        text_shim: null,
        text_dims: function(text, font) {
            var shim = vml.text_shim || (vml.init(),
            vml.text_shim);
            shim.style.font = vml.processFont(font);
            shim.innerText = text;
            return {
                height: shim.offsetHeight,
                width: shim.offsetWidth
            };
        },
        _fontCache: {},
        _fontSubst: {
            "default": "Arial",
            "sans-serif": "Arial",
            sansserif: "Arial",
            sans: "Arial",
            serif: "Times New Roman",
            dialog: "Arial",
            monospaced: "Courier New",
            dialoginput: "Courier New"
        },
        _fontWhiteListIE64Bit: {
            "agency fb": 1,
            aharoni: 1,
            algerian: 1,
            andalus: 1,
            "angsana new": 1,
            angsanaupc: 1,
            aparajita: 1,
            "arabic typesetting": 1,
            arial: 1,
            "arial black": 1,
            "arial narrow": 1,
            "arial rounded mt bold": 1,
            "arial unicode ms": 1,
            "baskerville old face": 1,
            batang: 1,
            batangche: 1,
            "bauhaus 93": 1,
            "bell mt": 1,
            "berlin sans fb": 1,
            "berlin sans fb demi": 1,
            "bernard mt condensed": 1,
            "blackadder itc": 1,
            "bodoni mt": 1,
            "bodoni mt black": 1,
            "bodoni mt condensed": 1,
            "bodoni mt poster compressed": 1,
            "book antiqua": 1,
            "bookman old style": 1,
            "bookshelf symbol 7": 1,
            "bradley hand itc": 1,
            "britannic bold": 1,
            broadway: 1,
            "browallia new": 1,
            browalliaupc: 1,
            "brush script mt": 1,
            calibri: 1,
            "californian fb": 1,
            "calisto mt": 1,
            cambria: 1,
            "cambria math": 1,
            candara: 1,
            castellar: 1,
            centaur: 1,
            century: 1,
            "century gothic": 1,
            "century schoolbook": 1,
            chiller: 1,
            "colonna mt": 1,
            "comic sans ms": 1,
            consolas: 1,
            constantia: 1,
            "cooper black": 1,
            "copperplate gothic bold": 1,
            "copperplate gothic light": 1,
            corbel: 1,
            "cordia new": 1,
            cordiaupc: 1,
            "courier new": 1,
            "curlz mt": 1,
            daunpenh: 1,
            david: 1,
            "dfkai-sb": 1,
            dilleniaupc: 1,
            dokchampa: 1,
            dotum: 1,
            dotumche: 1,
            ebrima: 1,
            "edwardian script itc": 1,
            elephant: 1,
            "engravers mt": 1,
            "eras bold itc": 1,
            "eras demi itc": 1,
            "eras light itc": 1,
            "eras medium itc": 1,
            "estrangelo edessa": 1,
            eucrosiaupc: 1,
            euphemia: 1,
            fangsong: 1,
            "felix titling": 1,
            "footlight mt light": 1,
            forte: 1,
            "franklin gothic book": 1,
            "franklin gothic demi": 1,
            "franklin gothic demi cond": 1,
            "franklin gothic heavy": 1,
            "franklin gothic medium": 1,
            "franklin gothic medium cond": 1,
            frankruehl: 1,
            freesiaupc: 1,
            "freestyle script": 1,
            "french script mt": 1,
            gabriola: 1,
            garamond: 1,
            gautami: 1,
            georgia: 1,
            gigi: 1,
            "gill sans mt": 1,
            "gill sans mt condensed": 1,
            "gill sans mt ext condensed bold": 1,
            "gill sans ultra bold": 1,
            "gill sans ultra bold condensed": 1,
            gisha: 1,
            "gloucester mt extra condensed": 1,
            "goudy old style": 1,
            "goudy stout": 1,
            gulim: 1,
            gulimche: 1,
            gungsuh: 1,
            gungsuhche: 1,
            "guttman adii": 1,
            "guttman adii-light": 1,
            "guttman aharoni": 1,
            "guttman calligraphic": 1,
            "guttman david": 1,
            "guttman drogolin": 1,
            "guttman frank": 1,
            "guttman frnew": 1,
            "guttman haim": 1,
            "guttman haim-condensed": 1,
            "guttman hatzvi": 1,
            "guttman hodes": 1,
            "guttman kav": 1,
            "guttman kav-light": 1,
            "guttman keren": 1,
            "guttman logo1": 1,
            "guttman mantova": 1,
            "guttman mantova-decor": 1,
            "guttman miryam": 1,
            "guttman myamfix": 1,
            "guttman rashi": 1,
            "guttman stam": 1,
            "guttman stam1": 1,
            "guttman vilna": 1,
            "guttman yad": 1,
            "guttman yad-brush": 1,
            "guttman yad-light": 1,
            "guttman-aharoni": 1,
            "guttman-aram": 1,
            "guttman-courmir": 1,
            "guttman-soncino": 1,
            "guttman-toledo": 1,
            haettenschweiler: 1,
            "harlow solid italic": 1,
            harrington: 1,
            "high tower text": 1,
            impact: 1,
            "imprint mt shadow": 1,
            "informal roman": 1,
            irisupc: 1,
            "iskoola pota": 1,
            jasmineupc: 1,
            jokerman: 1,
            "juice itc": 1,
            kaiti: 1,
            kalinga: 1,
            kartika: 1,
            "khmer ui": 1,
            kodchiangupc: 1,
            kokila: 1,
            "kristen itc": 1,
            "kunstler script": 1,
            "lao ui": 1,
            latha: 1,
            leelawadee: 1,
            "levenim mt": 1,
            lilyupc: 1,
            "lucida bright": 1,
            "lucida calligraphy": 1,
            "lucida console": 1,
            "lucida fax": 1,
            "lucida handwriting": 1,
            "lucida sans": 1,
            "lucida sans typewriter": 1,
            "lucida sans unicode": 1,
            magneto: 1,
            "maiandra gd": 1,
            "malgun gothic": 1,
            mangal: 1,
            marlett: 1,
            "matura mt script capitals": 1,
            meiryo: 1,
            "meiryo ui": 1,
            "microsoft himalaya": 1,
            "microsoft jhenghei": 1,
            "microsoft new tai lue": 1,
            "microsoft phagspa": 1,
            "microsoft sans serif": 1,
            "microsoft tai le": 1,
            "microsoft uighur": 1,
            "microsoft yahei": 1,
            "microsoft yi baiti": 1,
            mingliu: 1,
            "mingliu-extb": 1,
            mingliu_hkscs: 1,
            "mingliu_hkscs-extb": 1,
            miriam: 1,
            "miriam fixed": 1,
            mistral: 1,
            "modern no. 20": 1,
            "mongolian baiti": 1,
            "monotype corsiva": 1,
            "monotype hadassah": 1,
            moolboran: 1,
            "ms gothic": 1,
            "ms mincho": 1,
            "ms outlook": 1,
            "ms pgothic": 1,
            "ms pmincho": 1,
            "ms reference sans serif": 1,
            "ms reference specialty": 1,
            "ms ui gothic": 1,
            "mt extra": 1,
            "mv boli": 1,
            narkisim: 1,
            "niagara engraved": 1,
            "niagara solid": 1,
            nsimsun: 1,
            nyala: 1,
            "ocr a extended": 1,
            "old english text mt": 1,
            onyx: 1,
            "palace script mt": 1,
            "palatino linotype": 1,
            papyrus: 1,
            parchment: 1,
            perpetua: 1,
            "perpetua titling mt": 1,
            "plantagenet cherokee": 1,
            playbill: 1,
            pmingliu: 1,
            "pmingliu-extb": 1,
            "poor richard": 1,
            pristina: 1,
            raavi: 1,
            "rage italic": 1,
            ravie: 1,
            rockwell: 1,
            "rockwell condensed": 1,
            "rockwell extra bold": 1,
            rod: 1,
            "sakkal majalla": 1,
            "script mt bold": 1,
            "segoe print": 1,
            "segoe script": 1,
            "segoe ui": 1,
            "segoe ui light": 1,
            "segoe ui semibold": 1,
            "segoe ui symbol": 1,
            "shonar bangla": 1,
            "showcard gothic": 1,
            shruti: 1,
            simhei: 1,
            "simplified arabic": 1,
            "simplified arabic fixed": 1,
            simsun: 1,
            "simsun-extb": 1,
            "snap itc": 1,
            stencil: 1,
            sylfaen: 1,
            symbol: 1,
            tahoma: 1,
            "tempus sans itc": 1,
            "times new roman": 1,
            "toptype soncino": 1,
            "traditional arabic": 1,
            "trebuchet ms": 1,
            tunga: 1,
            "tw cen mt": 1,
            "tw cen mt condensed": 1,
            "tw cen mt condensed extra bold": 1,
            utsaah: 1,
            vani: 1,
            verdana: 1,
            vijaya: 1,
            "viner hand itc": 1,
            vivaldi: 1,
            "vladimir script": 1,
            vrinda: 1,
            webdings: 1,
            "wide latin": 1,
            wingdings: 1,
            "wingdings 2": 1,
            "wingdings 3": 1
        },
        _defaultFontIE64Bit: "Arial",
        processFont: function(font) {
            var processedFont = vml._fontCache[font];
            if (!processedFont) {
                var shim = vml.text_shim || (vml.init(),
                vml.text_shim)
                  , style = shim.style;
                style.font = font;
                var fontFamily = style.fontFamily;
                '"' === fontFamily.charAt(0) && (fontFamily = fontFamily.substr(1, fontFamily.length - 1));
                var ffKey = fontFamily.toLowerCase()
                  , substFF = vml._fontSubst[ffKey];
                substFF ? fontFamily = substFF : vml.is64Bit && !vml._fontWhiteListIE64Bit[ffKey] && (fontFamily = vml._defaultFontIE64Bit);
                style.fontFamily = '"' + fontFamily + '"';
                vml._fontCache[font] = processedFont = style.font;
            }
            return processedFont;
        },
        get_dim: function(attr, target) {
            var o = target || {};
            o.rotation = o.tx = o.ty = 0;
            o.sx = o.sy = 1;
            var transf = attr.transform;
            if (transf) {
                var t = /translate\((-?\d+(?:\.\d+)?(?:e-?\d+)?)(?:,(-?\d+(?:\.\d+)?(?:e-?\d+)?))?\)/.exec(transf);
                if (t) {
                    t[1] && (o.tx = +t[1]);
                    t[2] && (o.ty = +t[2]);
                }
                var r = /rotate\((-?\d+(?:\.\d+)?(?:e-?\d+)?)\)/.exec(transf);
                if (r) {
                    var r = +r[1] % 360;
                    0 > r && (r += 360);
                    r = pv.radians(r);
                }
                var s = /scale\((-?\d+(?:\.\d+)?(?:e-?\d+)?)(?:,(-?\d+(?:\.\d+)?(?:e-?\d+)?))?\)/.exec(transf);
                if (s) {
                    s[1] && (o.sx = +s[1]);
                    s[2] && (o.sy = +s[2]);
                }
                o.rotation = r || 0;
            }
            o.x = parseFloat(attr.x || 0);
            o.y = parseFloat(attr.y || 0);
            "width"in attr && (o.width = parseFloat(attr.width));
            "height"in attr && (o.height = parseFloat(attr.height));
            return o;
        },
        solidFillStyle: {
            type: "solid"
        },
        elm_defaults: {
            g: {
                rewrite: "span",
                attr: function(attr, style, elm) {
                    var d = vml.get_dim(attr);
                    elm.style.cssText = "position:absolute;zoom:1;left:" + (d.tx + d.x) + "px;top:" + (d.ty + d.y) + "px;";
                }
            },
            line: {
                rewrite: "shape",
                attr: function(attr, style, elm, scene, i) {
                    var x1 = parseFloat(attr.x1 || 0)
                      , y1 = parseFloat(attr.y1 || 0)
                      , x2 = parseFloat(attr.x2 || 0)
                      , y2 = parseFloat(attr.y2 || 0)
                      , r = vml.round;
                    elm.coordorigin = "0,0";
                    elm.coordsize = "21600,21600";
                    vml.path(elm).v = "M " + r(x1) + " " + r(y1) + " L " + r(x2) + " " + r(y2) + " E";
                    vml.stroke(elm, attr, scene, i);
                },
                css: "top:0px;left:0px;width:1000px;height:1000px"
            },
            rect: {
                rewrite: "shape",
                attr: function(attr, style, elm, scene, i) {
                    var d = vml.get_dim(attr)
                      , p = vml.path(elm)
                      , r = vml.round;
                    elm.coordorigin = "0,0";
                    elm.coordsize = "21600,21600";
                    var x = r(d.tx + d.x)
                      , y = r(d.ty + d.y)
                      , w = r(d.width)
                      , h = r(d.height);
                    p.v = "M " + x + " " + y + " L " + (x + w) + " " + y + " L " + (x + w) + " " + (y + h) + " L " + x + " " + (y + h) + " x";
                    vml.stroke(elm, attr, scene, i);
                    vml.fill(elm, attr, scene, i);
                },
                css: "top:0px;left:0px;width:1000px;height:1000px"
            },
            path: {
                rewrite: "shape",
                attr: function(attr, style, elm, scene, i) {
                    var d = vml.get_dim(attr)
                      , es = elm.style;
                    es.visibility = "hidden";
                    es.left = d.tx + d.x + "px";
                    es.top = d.ty + d.y + "px";
                    elm.coordorigin = "0,0";
                    elm.coordsize = "21600,21600";
                    elm._events = attr["pointer-events"] || "none";
                    vml.path(elm, attr.d);
                    var skew = vml.rotateAndScale(elm, d.rotation && -d.rotation, d.sx, d.sy);
                    skew && (skew.origin = "-0.5,-0.5");
                    vml.fill(elm, attr, scene, i);
                    vml.stroke(elm, attr, scene, i);
                    es.visibility = "visible";
                },
                css: "top:0px;left:0px;width:1000px;height:1000px;"
            },
            ellipse: {
                rewrite: "oval",
                attr: function(attr, style, elm, scene, i) {
                    var d = vml.get_dim(attr)
                      , rx = attr.rx
                      , ry = attr.ry
                      , es = elm.style;
                    es.left = d.tx - rx + "px";
                    es.top = d.ty - ry + "px";
                    es.width = 2 * rx + "px";
                    es.height = 2 * ry + "px";
                    var skew = vml.rotateAndScale(elm, d.rotation && -d.rotation);
                    skew && (skew.origin = "0,0");
                    vml.fill(elm, attr, scene, i);
                    vml.stroke(elm, attr, scene, i);
                }
            },
            circle: {
                rewrite: "oval",
                attr: function(attr, style, elm, scene, i) {
                    var d = vml.get_dim(attr)
                      , r = parseFloat(attr.r || 0) + .5
                      , cx = parseFloat(attr.cx || 0) + .7
                      , cy = parseFloat(attr.cy || 0) + .7
                      , es = elm.style;
                    es.left = d.tx + cx - r + "px";
                    es.top = d.ty + cy - r + "px";
                    es.width = es.height = 2 * r + "px";
                    vml.fill(elm, attr, scene, i);
                    vml.stroke(elm, attr, scene, i);
                }
            },
            text: {
                rewrite: "shape",
                attr: function(attr, style, elm, scene, i) {
                    elm.style;
                    elm.stroked = "False";
                    elm.path = "m0,0 l1,0 e";
                    var tp = vml.textpath(elm);
                    tp.string = attr.string;
                    var tpStyle = tp.style;
                    tpStyle["v-text-align"] = attr.textAlign;
                    tpStyle.font = attr.font;
                    attr.textDecoration && (tpStyle.textDecoration = attr.textDecoration);
                    vml.path(elm).textpathok = "True";
                    vml.rotateAndScale(elm, attr.rotation && -attr.rotation);
                    var s = scene[i];
                    s.fillStyle = vml.solidFillStyle;
                    vml.fill(elm, attr, scene, i);
                    s.fillStyle = null;
                },
                css: "position:absolute;top:0px;left:0px;width:1px;height:1px;"
            },
            svg: {
                rewrite: "span",
                css: "position:relative;overflow:hidden;display:inline-block;"
            },
            "vml:path": {
                rewrite: "path"
            },
            "vml:stroke": {
                rewrite: "stroke"
            },
            "vml:fill": {
                rewrite: "fill"
            },
            "vml:textpath": {
                rewrite: "textpath"
            },
            "vml:skew": {
                rewrite: "skew"
            }
        },
        _elmcache: {
            span: document.createElement("span"),
            div: document.createElement("div")
        },
        createElement: function(type) {
            var elm, cache = vml._elmcache, helper = vml.elm_defaults[type] || {}, tagName = helper.rewrite || type;
            if (tagName in cache)
                elm = cache[tagName].cloneNode(!1);
            else {
                cache[tagName] = document.createElement(vml.pre + tagName + vml.post);
                tagName in vml.block && (cache[tagName].className += " msvml_block");
                elm = cache[tagName].cloneNode(!1);
            }
            helper.css && (elm.style.cssText = helper.css);
            return elm;
        },
        _hex: pv.range(0, 256).map(function(i) {
            return pv.Format.pad("0", 2, i.toString(16));
        }),
        _colorcache: {},
        color: function(value) {
            var rgb, result = vml._colorcache[value];
            !result && (rgb = /^rgb\((\d+),(\d+),(\d+)\)$/i.exec(value)) && (vml._colorcache[value] = result = "#" + vml._hex[rgb[1]] + vml._hex[rgb[2]] + vml._hex[rgb[3]]);
            return result || value;
        },
        fill: function(elm, attr, scene, i) {
            var fill = elm.getElementsByTagName("fill")[0] || (fill = elm.appendChild(vml.createElement("vml:fill")))
              , fillStyle = scene[i].fillStyle
              , fillType = fillStyle && fillStyle.type;
            fillType || (fillType = "solid");
            if (!attr.fill || !fillStyle || "solid" === fillType && "none" === attr.fill)
                fill.on = "false";
            else {
                fill.on = "true";
                if ("solid" === fillType) {
                    fill.type = "solid";
                    fill.color = vml.color(attr.fill);
                } else {
                    var isLinear = "lineargradient" === fillType;
                    fill.method = "none";
                    var stops = fillStyle.stops
                      , S = stops.length;
                    if (S > 0) {
                        for (var stopsText = [], i = 0; S > i; i++) {
                            var stop = stops[i];
                            stopsText.push(stop.offset + "% " + vml.color(stop.color.color));
                        }
                        fill.colors && "object" == typeof fill.colors ? fill.colors.value = stopsText.join(",") : fill.colors = stopsText.join(",");
                    }
                    if (isLinear) {
                        fill.type = "gradient";
                        var angle = -pv.degrees(fillStyle.angle) % 360;
                        fill.angle = 0 > angle ? angle + 360 : angle;
                    } else {
                        fill.type = "gradientTitle";
                        fill.focus = "100%";
                        fill.focussize = "0 0";
                        fill.focusposition = "0 0";
                        fill.angle = 0;
                    }
                }
                fill.opacity = Math.min(parseFloat(attr["fill-opacity"] || "1"), 1) || "1";
            }
        },
        stroke: function(elm, attr) {
            var stroke = elm.getElementsByTagName("stroke")[0] || (stroke = elm.appendChild(vml.createElement("vml:stroke")));
            if (attr.stroke && "none" !== attr.stroke) {
                var strokeWidth = attr["stroke-width"];
                strokeWidth = null == strokeWidth || "" === strokeWidth ? 1 : +strokeWidth;
                1e-10 > strokeWidth ? strokeWidth = 0 : 1 > strokeWidth && (strokeWidth = 1);
                if (strokeWidth) {
                    stroke.on = "true";
                    stroke.weight = strokeWidth;
                    stroke.color = vml.color(attr.stroke) || "red";
                    stroke.opacity = Math.min(parseFloat(attr["stroke-opacity"] || "1"), 1) || "1";
                    stroke.joinstyle = vml.joins[attr["stroke-linejoin"]] || "miter";
                    stroke.miterlimit = attr["stroke-miterlimit"] || 8;
                    stroke.endcap = vml.caps[attr["stroke-linecap"]] || "flat";
                    var dashArray = attr["stroke-dasharray"];
                    dashArray && "none" !== dashArray || (dashArray = "Solid");
                    stroke.dashstyle = dashArray;
                } else {
                    stroke.on = "false";
                    stroke.weight = 0;
                }
            } else {
                stroke.on = "false";
                stroke.weight = 0;
            }
        },
        path: function(elm, svgpath) {
            var p = elm.getElementsByTagName("path")[0] || (p = elm.appendChild(vml.createElement("vml:path")));
            arguments.length > 1 && (p.v = vml.rewritePath(svgpath));
            return p;
        },
        skew: function(elm) {
            var sk = elm.getElementsByTagName("skew")[0] || (sk = elm.appendChild(vml.createElement("vml:skew")));
            sk.on = "false";
            return sk;
        },
        rotateAndScale: function(elm, r, sx, sy) {
            r && (r = pv.radians(Math.round(pv.degrees(r)) % 360));
            var hasScale = sx && 1 !== sx || sy && 1 !== sy;
            if (r || hasScale) {
                var skew = vml.skew(elm);
                skew.on = "true";
                skew.offset = "0,0";
                sx || (sx = 1);
                sy || (sy = 1);
                var m;
                if (r) {
                    var ct = Math.cos(r)
                      , st = Math.sin(r);
                    m = (sx * ct).toFixed(8) + "," + (sy * st).toFixed(8) + "," + (sx * -st).toFixed(8) + "," + (sy * ct).toFixed(8) + ",0,0";
                } else
                    m = sx.toFixed(8) + ",0,0," + sy.toFixed(8) + ",0,0";
                skew.matrix = m;
                return skew;
            }
        },
        textpath: function(elm) {
            var tp = elm.getElementsByTagName("textpath")[0] || (tp = elm.appendChild(vml.createElement("vml:textpath")));
            tp.style["v-text-align"] = "center";
            tp.style["v-text-kern"] = "true";
            tp.on = "true";
            return tp;
        },
        init: function() {
            if (!vml.text_shim) {
                vml.text_shim = document.getElementById("pv_vml_text_shim") || document.createElement("span");
                vml.text_shim.id = "protovisvml_text_shim";
                vml.text_shim.style.cssText = "position:absolute;left:-9999em;top:-9999em;padding:0;margin:0;line-height:1;display:inline-block;white-space:nowrap;";
                document.body.appendChild(vml.text_shim);
            }
            if (!vml.styles) {
                vml.styles = document.getElementById("protovisvml_styles") || document.createElement("style");
                vml.styles.id = "protovisvml_styles";
                document.documentElement.firstChild.appendChild(vml.styles);
                vml.styles.styleSheet.addRule(".msvml", "behavior:url(#default#VML);");
                vml.styles.styleSheet.addRule(".msvml_block", "position:absolute;top:0;left:0;");
                try {
                    document.namespaces.pvml || document.namespaces.add("pvml", "urn:schemas-microsoft-com:vml");
                } catch (e) {
                    vml.pre = "<";
                    vml.post = ' class="msvml" xmlns="urn:schemas-microsoft.com:vml">';
                }
            }
        },
        _pathcache: {},
        rewritePath: function(p) {
            var x = 0
              , y = 0
              , round = vml.round;
            if (!p)
                return p;
            if (p in vml._pathcache)
                return vml._pathcache[p];
            p = p.replace(/(\d*)((\.*\d*)(e ?-?\d*))/g, "$1");
            for (var bits = p.match(/([MLHVCSQTAZ ][^MLHVCSQTAZ ]*)/gi), np = [], lastcurve = [], oldOp = "", i = 0, bl = bits.length; bl > i; i++) {
                var itm = bits[i]
                  , op = itm.charAt(0)
                  , args = itm.substring(1).split(/[,]/);
                " " == op && (op = oldOp);
                oldOp = op;
                switch (op) {
                case "M":
                    op = "m";
                    x = round(args[0]);
                    y = round(args[1]);
                    args = [x, y];
                    break;

                case "m":
                    op = "m";
                    x += round(args[0]);
                    y += round(args[1]);
                    args = [x, y];
                    break;

                case "A":
                    op = "l";
                    args = [x = round(args[5]), y = round(args[6])];
                    break;

                case "L":
                    op = "l";
                    args = [x = round(args[0]), y = round(args[1])];
                    break;

                case "l":
                    op = "l";
                    args = [x += round(args[0]), y += round(args[1])];
                    break;

                case "H":
                    op = "l";
                    args = [x = round(args[0]), y];
                    break;

                case "h":
                    op = "l";
                    args = [x += round(args[0]), y];
                    break;

                case "V":
                    op = "l";
                    args = [x, y = round(args[0])];
                    break;

                case "v":
                    op = "l";
                    args = [x, y += round(args[0])];
                    break;

                case "C":
                    op = "c";
                    lastcurve = args = [round(args[0]), round(args[1]), round(args[2]), round(args[3]), x = round(args[4]), y = round(args[5])];
                    break;

                case "c":
                    op = "c";
                    lastcurve = args = [x + round(args[0]), y + round(args[1]), x + round(args[2]), y + round(args[3]), x += round(args[4]), y += round(args[5])];
                    break;

                case "S":
                    op = "c";
                    lastcurve = args = [lastcurve[4] + (lastcurve[4] - lastcurve[2]), lastcurve[5] + (lastcurve[5] - lastcurve[3]), round(args[0]), round(args[1]), x = round(args[2]), y = round(args[3])];
                    break;

                case "s":
                    op = "c";
                    lastcurve = args = [lastcurve[4] + (lastcurve[4] - lastcurve[2]), lastcurve[5] + (lastcurve[5] - lastcurve[3]), x + round(args[0]), y + round(args[1]), x += round(args[2]), y += round(args[3])];
                    break;

                case "Q":
                    op = "c";
                    var x1 = round(args[0])
                      , y1 = round(args[1])
                      , x2 = round(args[2])
                      , y2 = round(args[3]);
                    args = [~~(x + 2 * (x1 - x) / 3), ~~(y + 2 * (y1 - y) / 3), ~~(x1 + (x2 - x1) / 3), ~~(y1 + (y2 - y1) / 3), x = x2, y = y2];
                    break;

                case "q":
                    op = "l";
                    x += round(args[2]);
                    y += round(args[3]);
                    args = [x, y];
                    break;

                case "Z":
                case "z":
                    op = "xe";
                    args = [];
                    break;

                default:
                    op = "";
                    args = [];
                }
                np.push(op, args.join(","));
            }
            return vml._pathcache[p] = np.join("") + "e";
        }
    };
    pv.Text.measure = vml.text_dims;
    pv.Vml = vml;
    pv.VmlScene = {
        scale: 1,
        events: ["mousewheel", "mousedown", "mouseup", "mouseover", "mouseout", "mousemove", "click", "dblclick", "contextmenu"],
        mousePositionEventSet: pv.Scene.mousePositionEventSet,
        eventsToNumber: pv.Scene.eventsToNumber,
        numberToEvents: pv.Scene.numberToEvents,
        implicit: {
            css: {}
        },
        copy_functions: function(obj) {
            for (var name in obj)
                "function" != typeof obj[name] || name in pv.VmlScene || (pv.VmlScene[name] = obj[name]);
        }
    };
    pv.VmlScene.copy_functions(pv.SvgScene);
    pv.Scene = pv.VmlScene;
    pv.renderer = function() {
        return "vml";
    }
    ;
    !function(is64bit) {
        pv.VmlScene.minRuleLineWidth = is64bit ? 1.2 : 1.1;
        pv.VmlScene.minBarWidth = is64bit ? 2.2 : 1.8;
        pv.VmlScene.minBarHeight = is64bit ? 2.2 : 1.8;
        pv.VmlScene.minBarLineWidth = is64bit ? 1.2 : 1;
    }(vml.is64Bit);
    pv.VmlScene.expect = function(e, type, scene, i, attr, style) {
        style = style || {};
        var helper = vml.elm_defaults[type] || {}
          , _type = helper.rewrite || type;
        if (e) {
            if (e.tagName.toUpperCase() !== _type.toUpperCase()) {
                var n = vml.createElement(type);
                e.parentNode.replaceChild(n, e);
                e = n;
            }
        } else
            e = vml.createElement(type);
        if (attr) {
            "attr"in helper && helper.attr(attr, style, e, scene, i);
            if (attr.cursor in vml.cursorstyles) {
                var curs = vml.cursorstyles[attr.cursor];
                style.cursor = 1 === curs ? attr.cursor : curs;
            }
        }
        style && this.setStyle(e, style);
        return e;
    }
    ;
    pv.VmlScene.removeSiblings = function(e) {
        for (; e; ) {
            var n = e.nextSibling;
            e.parentNode.removeChild(e);
            e = n;
        }
    }
    ;
    pv.VmlScene.addFillStyleDefinition = function() {}
    ;
    pv.VmlScene.setAttributes = function() {}
    ;
    pv.VmlScene.setStyle = function(e, style) {
        var prevStyle = e.__style__;
        prevStyle === style && (prevStyle = null);
        var eStyle = e.style;
        for (var name in style) {
            var value = style[name];
            prevStyle && value === prevStyle[name] || (null == value ? eStyle.removeAttribute(name) : eStyle[name] = value);
        }
        e.__style__ = style;
    }
    ;
    pv.VmlScene.append = function(e, scene, index) {
        e.$scene = {
            scenes: scene,
            index: index
        };
        e = this.title(e, scene[index]);
        e.parentNode && 11 !== e.parentNode.nodeType || scene.$g.appendChild(e);
        return e.nextSibling;
    }
    ;
    pv.VmlScene.title = function(e, s) {
        e.title = s.title || "";
        return e;
    }
    ;
    pv.VmlScene.panel = function(scene) {
        for (var style, g = scene.$g, e = g && g.firstChild, inited = !1, i = 0, L = scene.length; L > i; i++) {
            var s = scene[i];
            if (s.visible) {
                if (!scene.parent) {
                    var canvas = s.canvas;
                    style = canvas.style;
                    style.display = "inline-block";
                    style.zoom = 1;
                    if (g && g.parentNode !== canvas) {
                        g = canvas.firstChild;
                        e = g && g.firstChild;
                    }
                    if (!g) {
                        inited = !0;
                        vml.init();
                        g = canvas.appendChild(vml.createElement("svg"));
                        g.unselectable = "on";
                        g.onselectstart = function() {
                            return !1;
                        }
                        ;
                        for (var events = this.events, dispatch = this.dispatch, j = 0, E = events.length; E > j; j++)
                            g.addEventListener ? g.addEventListener(events[j], dispatch, !1) : g.attachEvent("on" + events[j], dispatch);
                        e = g.firstChild;
                    }
                    scene.$g = g;
                    var w = s.width + s.left + s.right
                      , h = s.height + s.top + s.bottom;
                    style = g.style;
                    style.width = w + "px";
                    style.height = h + "px";
                    style.clip = "rect(0px " + w + "px " + h + "px 0px)";
                }
                var c;
                if ("hidden" === s.overflow) {
                    c = this.expect(e, "g", scene, i);
                    c.style.position = "absolute";
                    c.style.clip = "rect(" + s.top.toFixed(2) + "px " + (s.left + s.width).toFixed(2) + "px " + (s.top + s.height).toFixed(2) + "px " + s.left.toFixed(2) + "px)";
                    c.parentNode || g.appendChild(c);
                    scene.$g = g = c;
                    e = c.firstChild;
                }
                e = this.fill(e, scene, i);
                var k = this.scale
                  , t = s.transform
                  , x = s.left + t.x
                  , y = s.top + t.y;
                this.scale *= t.k;
                if (s.children.length)
                    for (var attrs = {
                        transform: "translate(" + x + "," + y + ")" + (1 != t.k ? " scale(" + t.k + ")" : "")
                    }, childScenes = this.getSortedChildScenes(scene, i), j = 0, C = childScenes.length; C > j; j++) {
                        var childScene = childScenes[j];
                        childScene.$g = e = this.expect(e, "g", scene, i, attrs);
                        this.updateAll(childScene);
                        var parentNode = e.parentNode;
                        if (!parentNode || 11 === parentNode.nodeType) {
                            g.appendChild(e);
                            var helper = vml.elm_defaults[e.svgtype];
                            helper && "function" == typeof helper.onappend && helper.onappend(e, scene[i]);
                        }
                        e = e.nextSibling;
                    }
                this.scale = k;
                e = this.stroke(e, scene, i);
                if (c) {
                    scene.$g = g = c.parentNode;
                    e = c.nextSibling;
                }
            }
        }
        if (inited) {
            this.removeSiblings(e);
            e = g.appendChild(vml.createElement("oval"));
        }
        return e;
    }
    ;
    pv.VmlScene.parseDasharray = function(s) {
        var dashArray = s.strokeDasharray;
        if (dashArray && "none" !== dashArray) {
            var standardDashArray = this.translateDashStyleAlias(dashArray);
            if (this.isStandardDashStyle(standardDashArray))
                dashArray = standardDashArray;
            else {
                dashArray = dashArray.split(/[\s,]+/).map(function(num) {
                    return +num / this.scale;
                }, this);
                dashArray.length % 2 && (dashArray = dashArray.concat(dashArray));
                dashArray = dashArray.join(" ");
            }
        } else
            dashArray = null;
        return dashArray;
    }
    ;
    pv.VmlScene.create = function(type) {
        return vml.createElement(type);
    }
    ;
    !function() {
        function IEvent(src) {
            if (src && src.type) {
                this.originalEvent = src;
                this.type = src.type;
                this.isDefaultPrevented = returnFalse;
                (src.defaultPrevented || src.returnValue === !1 || src.getPreventDefault && src.getPreventDefault()) && (this.isDefaultPrevented = returnTrue);
                this.timeStamp = src.timeStamp || Date.now();
            } else {
                this.type = src;
                this.timeStamp = Date.now();
            }
        }
        var returnTrue = function() {
            return !0;
        }
          , returnFalse = function() {
            return !1;
        }
          , _event_props = ["altKey", "attrChange", "attrName", "bubbles", "button", "cancelable", "charCode", "clientX", "clientY", "ctrlKey", "currentTarget", "data", "detail", "eventPhase", "fromElement", "handler", "keyCode", "layerX", "layerY", "metaKey", "newValue", "offsetX", "offsetY", "pageX", "pageY", "prevValue", "relatedNode", "relatedTarget", "screenX", "screenY", "shiftKey", "srcElement", "target", "toElement", "view", "wheelDelta", "which"]
          , _evPropCount = _event_props.length;
        IEvent.prototype = {
            preventDefault: function() {
                this.isDefaultPrevented = returnTrue;
                var e = this.originalEvent;
                e && (e.preventDefault ? e.preventDefault() : e.returnValue = !1);
            },
            stopPropagation: function() {
                this.isPropagationStopped = returnTrue;
                var e = this.originalEvent;
                if (e) {
                    e.stopPropagation && e.stopPropagation();
                    e.cancelBubble = !0;
                }
            },
            stopImmediatePropagation: function() {
                this.isImmediatePropagationStopped = returnTrue;
                this.stopPropagation();
            },
            isDefaultPrevented: returnFalse,
            isPropagationStopped: returnFalse,
            isImmediatePropagationStopped: returnFalse
        };
        var SCROLL_NODE = document.compatMode && "BackCompat" != document.compatMode ? "documentElement" : "body";
        vml.fixEvent = function(ev) {
            var originalEvent = ev;
            ev = new IEvent(originalEvent);
            for (var type = ev.type, isKey = "keypress" === type, i = _evPropCount; i; ) {
                var prop = _event_props[--i];
                ev[prop] = originalEvent[prop];
            }
            var target = ev.target;
            if (!target) {
                target = ev.srcElement || document;
                3 === target.nodeType && (target = target.parentNode);
                ev.target = target;
            }
            var fromElem;
            !ev.relatedTarget && (fromElem = ev.fromElement) && (ev.relatedTarget = fromElem === target ? ev.toElement : fromElem);
            if (!isKey) {
                var clientX;
                if (null == ev.pageX && null != (clientX = ev.clientX)) {
                    var scrollNode = document[SCROLL_NODE];
                    ev.pageX = clientX + (scrollNode.scrollLeft || 0) - (scrollNode.clientLeft || 0);
                    ev.pageY = ev.clientY + (scrollNode.scrollTop || 0) - (scrollNode.clientTop || 0);
                }
            }
            if (null == ev.which) {
                var charCode, keyCode, btn;
                isKey ? null != (charCode = ev.charCode) ? ev.which = charCode : null != (keyCode = ev.keyCode) && (ev.which = keyCode) : null !== (btn = ev.button) && (ev.which = 1 & btn ? 1 : 2 & btn ? 3 : 4 & btn ? 2 : 0);
            }
            ev.metaKey = !!ev.metaKey;
            "mousewheel" === type && (ev.wheel = ev.wheelDelta);
            return ev;
        }
        ;
    }();
    pv.fixEvent = function(ev) {
        return vml.fixEvent(ev || window.event);
    }
    ;
    pv.VmlScene.dispatch = pv.listener(function(e) {
        var t = e.target.$scene;
        if (t) {
            var events = e.target._events;
            if ("none" === events || pv.Mark.dispatch(e.type, t.scenes, t.index, e)) {
                e.preventDefault();
                e.stopPropagation();
            }
        }
    });
    pv.VmlScene.image = function(scene) {
        for (var e = scene.$g.firstChild, i = 0; i < scene.length; i++) {
            var s = scene[i];
            if (s.visible) {
                e = this.fill(e, scene, i);
                if (s.image)
                    ;
                else {
                    e = new Image();
                    e.src = s.url;
                    var st = e.style;
                    st.position = "absolute";
                    st.top = s.top;
                    st.left = s.left;
                    st.width = s.width;
                    st.height = s.height;
                    st.cursor = s.cursor;
                    st.msInterpolationMode = "bicubic";
                }
                e = this.append(e, scene, i);
                e = this.stroke(e, scene, i);
            }
        }
        return e;
    }
    ;
    pv.VmlScene.label = function(scene) {
        for (var e = scene.$g.firstChild, i = 0, L = scene.length; L > i; i++) {
            var s = scene[i];
            if (s.visible) {
                var fill = s.textStyle;
                if (fill.opacity && s.text) {
                    var txt = s.text.replace(/\s+/g, " ")
                      , font = vml.processFont(s.font)
                      , label = vml.text_dims(txt, font)
                      , dx = 0
                      , dy = 0;
                    switch (s.textBaseline) {
                    case "middle":
                        dy = .1 * label.height;
                        break;

                    case "top":
                        dy = s.textMargin + .5 * label.height;
                        break;

                    case "bottom":
                        dy = -(s.textMargin + .5 * label.height);
                    }
                    switch (s.textAlign) {
                    case "left":
                        dx = s.textMargin;
                        break;

                    case "right":
                        dx = -s.textMargin;
                    }
                    var a = s.textAngle;
                    if (a) {
                        var ct = Math.cos(a)
                          , st = Math.sin(a)
                          , dx2 = dx * ct - dy * st
                          , dy2 = dx * st + dy * ct;
                        dx = dx2;
                        dy = dy2;
                    }
                    var left = s.left + dx
                      , top = s.top + dy
                      , attr = {};
                    s.cursor && (attr.cursor = s.cursor);
                    attr.fill = vml.color(fill.color) || "red";
                    vml.is64Bit && (attr["fill-opacity"] = .7);
                    attr.x = left;
                    attr.y = top;
                    attr.rotation = s.textAngle;
                    attr.string = txt;
                    attr.textAlign = s.textAlign;
                    attr.font = font;
                    attr.textDecoration = s.textDecoration;
                    e = this.expect(e, "text", scene, i, attr, {
                        display: "block",
                        lineHeight: 1,
                        whiteSpace: "nowrap",
                        zoom: 1,
                        position: "absolute",
                        cursor: "default",
                        top: top + "px",
                        left: left + "px"
                    });
                    e = this.append(e, scene, i);
                }
            }
        }
        return e;
    }
    ;
    pv.VmlScene.wedge = function(scene) {
        for (var e = scene.$g.firstChild, round = vml.round, i = 0, L = scene.length; L > i; i++) {
            var s = scene[i];
            if (s.visible) {
                var fill = s.fillStyle
                  , stroke = s.strokeStyle;
                if (fill.opacity || stroke.opacity) {
                    e = this.expect(e, "path", scene, i, {
                        "pointer-events": s.events,
                        cursor: s.cursor,
                        transform: "translate(" + s.left + "," + s.top + ")",
                        d: "",
                        fill: fill.color,
                        "fill-rule": "evenodd",
                        "fill-opacity": fill.opacity || null,
                        stroke: stroke.color,
                        "stroke-opacity": stroke.opacity || null,
                        "stroke-width": stroke.opacity ? s.lineWidth / this.scale : null,
                        "stroke-linecap": s.lineCap,
                        "stroke-linejoin": s.lineJoin,
                        "stroke-miterlimit": s.strokeMiterLimit,
                        "stroke-dasharray": stroke.opacity ? this.parseDasharray(s) : null
                    });
                    var p = e.getElementsByTagName("path")[0];
                    if (!p) {
                        p = vml.make("path");
                        e.appendChild(p);
                    }
                    var d, r1 = round(s.innerRadius), r2 = round(s.outerRadius);
                    if (s.angle >= 2 * Math.PI)
                        d = r1 ? "AE0,0 " + r2 + "," + r2 + " 0 23592960AL0,0 " + r1 + "," + r1 + " 0 23592960" : "AE0,0 " + r2 + "," + r2 + " 0 23592960";
                    else {
                        var sa = Math.round(s.startAngle / Math.PI * 11796480)
                          , a = Math.round(s.angle / Math.PI * 11796480);
                        d = r1 ? "AE 0,0 " + r2 + "," + r2 + " " + -sa + " " + -a + " 0,0 " + r1 + "," + r1 + " " + -(sa + a) + " " + a + "X" : "M0,0AE0,0 " + r2 + "," + r2 + " " + -sa + " " + -a + "X";
                    }
                    p.v = d;
                    e = this.append(e, scene, i);
                }
            }
        }
        return e;
    }
    ;
}();

/*!
 * Copyright 2002 - 2013 Webdetails, a Pentaho company.  All rights reserved.
 *
 * This software was developed by Webdetails and is provided under the terms
 * of the Mozilla Public License, Version 2.0, or any later version. You may not use
 * this file except in compliance with the license. If you need a copy of the license,
 * please go to  http://mozilla.org/MPL/2.0/. The Initial Developer is Webdetails.
 *
 * Software distributed under the Mozilla Public License is distributed on an "AS IS"
 * basis, WITHOUT WARRANTY OF ANY KIND, either express or  implied. Please refer to
 * the license for the specific language governing your rights and limitations.
 */

var def = function() {
    function globalSpace(name, space) {
        return globalNamespaces[name] = space;
    }
    function getNamespace(name, base) {
        var current = base || currentNamespace;
        if (name) {
            var parts = name.split(".")
              , L = parts.length;
            if (L) {
                var part, i = 0;
                if (current === def.global) {
                    part = parts[0];
                    var globalNamespace = def.getOwn(globalNamespaces, part);
                    if (globalNamespace) {
                        current = globalNamespace;
                        i++;
                    }
                }
                for (; L > i; ) {
                    part = parts[i++];
                    current = current[part] || (current[part] = {});
                }
            }
        }
        return current;
    }
    function createSpace(name, base, definition) {
        if (def.fun.is(base)) {
            definition = base;
            base = null;
        }
        var namespace = getNamespace(name, base);
        if (definition) {
            namespaceStack.push(currentNamespace);
            try {
                definition(namespace);
            } finally {
                currentNamespace = namespaceStack.pop();
            }
        }
        return namespace;
    }
    function defineName(namespace, name, value) {
        !def.hasOwn(namespace, name) || def.fail.operationInvalid("Name '{0}' is already defined in namespace.", [name]);
        return namespace[name] = value;
    }
    function createMixin(protectNativeObject) {
        return function(instance) {
            return mixinMany(instance, arraySlice.call(arguments, 1), protectNativeObject);
        }
        ;
    }
    function mixinMany(instance, mixins, protectNativeObject) {
        for (var i = 0, L = mixins.length; L > i; i++) {
            var mixin = mixins[i];
            if (mixin) {
                mixin = def.object.as(mixin.prototype || mixin);
                mixin && mixinRecursive(instance, mixin, protectNativeObject);
            }
        }
        return instance;
    }
    function mixinRecursive(instance, mixin, protectNativeObject) {
        for (var p in mixin)
            mixinProp(instance, p, mixin[p], protectNativeObject);
    }
    function mixinProp(instance, p, vMixin, protectNativeObject) {
        if (void 0 !== vMixin) {
            var oMixin, oTo = def.object.asNative(instance[p]);
            if (oTo) {
                oMixin = def.object.as(vMixin);
                if (oMixin) {
                    objectHasOwn.call(instance, p) || (instance[p] = oTo = Object.create(oTo));
                    mixinRecursive(oTo, oMixin, protectNativeObject);
                } else
                    instance[p] = vMixin;
            } else {
                oMixin = def.object.asNative(vMixin);
                oMixin && (vMixin = (protectNativeObject || Object.create)(oMixin));
                instance[p] = vMixin;
            }
        }
    }
    function createRecursive(instance) {
        for (var p in instance) {
            var vObj = def.object.asNative(instance[p]);
            vObj && createRecursive(instance[p] = Object.create(vObj));
        }
    }
    function query_nextMany() {
        for (; this._source.next(); ) {
            var manySource = this._selectMany ? this._selectMany.call(this._ctx, this._source.item, this._source.index) : this._source.item;
            if (null != manySource) {
                this._manySource = def.query(manySource);
                return !0;
            }
        }
    }
    var arraySlice = Array.prototype.slice;
    Object.keys || (Object.keys = function(o) {
        if (o !== Object(o))
            throw new TypeError("Object.keys called on non-object");
        var ret = [];
        for (var p in o)
            Object.prototype.hasOwnProperty.call(o, p) && ret.push(p);
        return ret;
    }
    );
    Object.create || (Object.create = function() {
        function create(baseProto) {
            Klass.prototype = baseProto || {};
            var instance = new Klass();
            Klass.prototype = proto;
            return instance;
        }
        var Klass = function() {}
          , proto = Klass.prototype;
        return create;
    }());
    Function.prototype.bind || (Function.prototype.bind = function(ctx) {
        var staticArgs = arraySlice.call(arguments, 1)
          , fToBind = this;
        return function() {
            return fToBind.apply(ctx, staticArgs.concat(arraySlice.call(arguments)));
        }
        ;
    }
    );
    this.JSON || (this.JSON = {});
    this.JSON.stringify || (this.JSON.stringify = function(t) {
        return "" + t;
    }
    );
    var objectHasOwn = Object.prototype.hasOwnProperty
      , def = {
        global: this,
        get: function(o, p, dv) {
            var v;
            return o && null != (v = o[p]) ? v : dv;
        },
        gets: function(o, props) {
            return props.map(function(p) {
                return o[p];
            });
        },
        getPath: function(o, path, dv, create) {
            if (!o)
                return dv;
            if (null != path) {
                var parts = def.array.is(path) ? path : path.split(".")
                  , L = parts.length;
                if (L)
                    for (var i = 0; L > i; ) {
                        var part = parts[i++]
                          , value = o[part];
                        if (null == value) {
                            if (!create)
                                return dv;
                            value = o[part] = null == dv || isNaN(+dv) ? {} : [];
                        }
                        o = value;
                    }
            }
            return o;
        },
        setPath: function(o, path, v) {
            if (o && null != path) {
                var parts = def.array.is(path) ? path : path.split(".");
                if (parts.length) {
                    var pLast = parts.pop();
                    o = def.getPath(o, parts, pLast, !0);
                    null != o && (o[pLast] = v);
                }
            }
            return o;
        },
        propGet: function(p, dv) {
            p = "" + p;
            return function(o) {
                return o ? o[p] : dv;
            }
            ;
        },
        getOwn: function(o, p, dv) {
            var v;
            return o && objectHasOwn.call(o, p) && null != (v = o[p]) ? v : dv;
        },
        hasOwn: function(o, p) {
            return !!o && objectHasOwn.call(o, p);
        },
        hasOwnProp: objectHasOwn,
        set: function(o) {
            for (var oo = o || {}, a = arguments, i = 1, A = a.length - 1; A > i; i += 2)
                oo[a[i]] = a[i + 1];
            return oo;
        },
        setDefaults: function(o, o2) {
            var p, oo = o || {}, a = arguments, A = a.length;
            if (2 === A && def.object.is(o2))
                for (p in o2)
                    null == oo[p] && (oo[p] = o2[p]);
            else {
                A--;
                for (var i = 1; A > i; i += 2) {
                    p = a[i];
                    null == oo[p] && (oo[p] = a[i + 1]);
                }
            }
            return oo;
        },
        setUDefaults: function(o, o2) {
            var p, oo = o || {}, a = arguments, A = a.length;
            if (2 === A && def.object.is(o2))
                for (p in o2)
                    void 0 === oo[p] && (oo[p] = o2[p]);
            else {
                A--;
                for (var i = 1; A > i; i += 2) {
                    p = a[i];
                    void 0 === oo[p] && (oo[p] = a[i + 1]);
                }
            }
            return oo;
        },
        eachOwn: function(o, fun, ctx) {
            if (o)
                for (var p in o)
                    objectHasOwn.call(o, p) && fun.call(ctx, o[p], p, o);
        },
        each: function(o, fun, ctx) {
            if (o)
                for (var p in o)
                    fun.call(ctx, o[p], p, o);
        },
        copyOwn: function(a, b) {
            var to, from;
            if (arguments.length >= 2) {
                to = a || {};
                from = b;
            } else {
                to = {};
                from = a;
            }
            if (from)
                for (var p in from)
                    objectHasOwn.call(from, p) && (to[p] = from[p]);
            return to;
        },
        copy: function(a, b) {
            var to, from;
            if (arguments.length >= 2) {
                to = a || {};
                from = b;
            } else {
                to = {};
                from = a;
            }
            if (from)
                for (var p in from)
                    to[p] = from[p];
            return to;
        },
        copyProps: function(a, b, props) {
            var to, from;
            if (arguments.length >= 3) {
                to = a || {};
                from = b;
            } else {
                to = {};
                from = a;
                props = b;
            }
            props && props.forEach(from ? function(p) {
                to[p] = from[p];
            }
            : function(p) {
                to[p] = void 0;
            }
            );
            return to;
        },
        keys: function(o) {
            var keys = [];
            for (var p in o)
                keys.push(p);
            return keys;
        },
        values: function(o) {
            var values = [];
            for (var p in o)
                values.push(o[p]);
            return values;
        },
        uniqueIndex: function(o, key, ctx) {
            var index = {};
            for (var p in o) {
                var v = key ? key.call(ctx, o[p]) : o[p];
                null == v || objectHasOwn.call(index, v) || (index[v] = p);
            }
            return index;
        },
        ownKeys: Object.keys,
        own: function(o, f, ctx) {
            var keys = Object.keys(o);
            return keys.map(f ? function(key) {
                return f.call(ctx, o[key], key);
            }
            : function(key) {
                return o[key];
            }
            );
        },
        scope: function(scopeFun, ctx) {
            return scopeFun.call(ctx);
        },
        bit: {
            set: function(bits, set, on) {
                return on || null == on ? bits | set : bits & ~set;
            }
        },
        compare: function(a, b) {
            return a === b ? 0 : a > b ? 1 : -1;
        },
        compareReverse: function(a, b) {
            return a === b ? 0 : a > b ? -1 : 1;
        },
        methodCaller: function(p, x) {
            return x ? function() {
                return x[p].apply(x, arguments);
            }
            : function() {
                return this[p].apply(this, arguments);
            }
            ;
        },
        identity: function(x) {
            return x;
        },
        add: function(a, b) {
            return a + b;
        },
        negate: function(f) {
            return function() {
                return !f.apply(this, arguments);
            }
            ;
        },
        sqr: function(v) {
            return v * v;
        },
        noop: function() {},
        retTrue: function() {
            return !0;
        },
        retFalse: function() {
            return !1;
        },
        number: {
            is: function(v) {
                return "number" == typeof v;
            },
            as: function(d, dv) {
                var v = parseFloat(d);
                return isNaN(v) ? dv || 0 : v;
            },
            to: function(d, dv) {
                var v = parseFloat(d);
                return isNaN(v) ? dv || 0 : v;
            }
        },
        array: {
            is: function(v) {
                return v instanceof Array;
            },
            isLike: function(v) {
                return v && null != v.length && "string" != typeof v;
            },
            as: function(thing) {
                return thing instanceof Array ? thing : null != thing ? [thing] : null;
            },
            to: function(thing) {
                return thing instanceof Array ? thing : null != thing ? [thing] : null;
            },
            lazy: function(scope, p, f, ctx) {
                return scope[p] || (scope[p] = f ? f.call(ctx, p) : []);
            },
            copy: function(al) {
                return arraySlice.apply(al, arraySlice.call(arguments, 1));
            }
        },
        object: {
            is: function(v) {
                return v && "object" == typeof v;
            },
            isNative: function(v) {
                return !!v && v.constructor === Object;
            },
            as: function(v) {
                return v && "object" == typeof v ? v : null;
            },
            asNative: function(v) {
                return v && v.constructor === Object ? v : null;
            },
            lazy: function(scope, p, f, ctx) {
                return scope[p] || (scope[p] = f ? f.call(ctx, p) : {});
            }
        },
        string: {
            is: function(v) {
                return "string" == typeof v;
            },
            to: function(v, ds) {
                return null != v ? "" + v : ds || "";
            },
            join: function(sep) {
                var v, v2, a = arguments, L = a.length;
                switch (L) {
                case 3:
                    v = a[1];
                    v2 = a[2];
                    return null != v && "" !== v ? null != v2 && "" !== v2 ? "" + v + sep + ("" + v2) : "" + v : null != v2 && "" !== v2 ? "" + v2 : "";

                case 2:
                    v = a[1];
                    return null != v ? "" + v : "";

                case 1:
                case 0:
                    return "";
                }
                for (var args = [], i = 1; L > i; i++) {
                    v = a[i];
                    null != v && "" !== v && args.push("" + v);
                }
                return args.join(sep);
            },
            padRight: function(s, n, p) {
                s || (s = "");
                null == p && (p = " ");
                var k = ~~((n - s.length) / p.length);
                return k > 0 ? s + new Array(k + 1).join(p) : s;
            }
        },
        fun: {
            is: function(v) {
                return "function" == typeof v;
            },
            as: function(v) {
                return "function" == typeof v ? v : null;
            },
            to: function(v) {
                return "function" == typeof v ? v : def.fun.constant(v);
            },
            constant: function(v) {
                return function() {
                    return v;
                }
                ;
            }
        },
        nullyTo: function(v, dv) {
            return null != v ? v : dv;
        },
        between: function(v, min, max) {
            return Math.max(min, Math.min(v, max));
        },
        nully: function(v) {
            return null == v;
        },
        notNully: function(v) {
            return null != v;
        },
        notUndef: function(v) {
            return void 0 !== v;
        },
        empty: function(v) {
            return null == v || "" === v;
        },
        notEmpty: function(v) {
            return null != v && "" !== v;
        },
        truthy: function(x) {
            return !!x;
        },
        falsy: function(x) {
            return !x;
        },
        firstUpperCase: function(s) {
            if (s) {
                var c = s.charAt(0)
                  , cU = c.toUpperCase();
                c !== cU && (s = cU + s.substr(1));
            }
            return s;
        },
        firstLowerCase: function(s) {
            if (s) {
                var c = s.charAt(0)
                  , cL = c.toLowerCase();
                c !== cL && (s = cL + s.substr(1));
            }
            return s;
        },
        format: function(mask, scope, ctx) {
            if (null == mask || "" === mask)
                return "";
            var isScopeFun = scope && def.fun.is(scope);
            return mask.replace(/(^|[^{])\{([^{}]+)\}/g, function($0, before, prop) {
                var value = scope ? isScopeFun ? scope.call(ctx, prop) : scope[prop] : null;
                return before + (null == value ? "" : String(value));
            });
        },
        destructuringTypeBind: function(types, values) {
            var T = types.length
              , result = new Array(T);
            if (T && values) {
                var V = values.length;
                if (V) {
                    var v = 0
                      , t = 0;
                    do {
                        var value = values[v];
                        if (null == value || typeof value === types[t]) {
                            result[t] = value;
                            v++;
                        }
                        t++;
                    } while (T > t && V > v);
                }
            }
            return result;
        },
        error: function(error) {
            return error instanceof Error ? error : new Error(error);
        },
        fail: function(error) {
            throw def.error(error);
        },
        assert: function(msg, scope) {
            throw def.error.assertionFailed(msg, scope);
        }
    };
    def.ascending = def.compare;
    def.descending = def.compareReverse;
    var AL = def.array.like = def.copyOwn(function(v) {
        return AL.is(v) ? v : [v];
    }, {
        is: function(v) {
            return v && null != v.length && "string" != typeof v;
        },
        as: function(v) {
            return AL.is(v) ? v : null;
        }
    });
    AL.to = AL;
    def.lazy = def.object.lazy;
    def.shared = function() {
        function create(value) {
            function safe() {
                _channel = value;
            }
            return safe;
        }
        function opener(safe) {
            if (null != _channel)
                throw new Error("Access denied.");
            safe();
            var value;
            value = _channel;
            _channel = null;
            return value;
        }
        var _channel = null;
        opener.safe = create;
        return opener;
    }
    ;
    var errors = {
        operationInvalid: function(msg, scope) {
            return def.error(def.string.join(" ", "Invalid operation.", def.format(msg, scope)));
        },
        notImplemented: function() {
            return def.error("Not implemented.");
        },
        argumentRequired: function(name) {
            return def.error(def.format("Required argument '{0}'.", [name]));
        },
        argumentInvalid: function(name, msg, scope) {
            return def.error(def.string.join(" ", def.format("Invalid argument '{0}'.", [name]), def.format(msg, scope)));
        },
        assertionFailed: function(msg, scope) {
            return def.error(def.string.join(" ", "Assertion failed.", def.format(msg, scope)));
        }
    };
    def.copyOwn(def.error, errors);
    def.eachOwn(errors, function(errorFun, name) {
        def.fail[name] = function() {
            throw errorFun.apply(null, arguments);
        }
        ;
    });
    var currentNamespace = def
      , globalNamespaces = {}
      , namespaceStack = [];
    def.space = createSpace;
    def.globalSpace = globalSpace;
    def.mixin = createMixin(Object.create);
    def.copyOwn(def.mixin, {
        custom: createMixin,
        inherit: def.mixin,
        copy: createMixin(def.copy),
        share: createMixin(def.identity)
    });
    def.create = function() {
        var mixins = arraySlice.call(arguments)
          , deep = !0
          , baseProto = mixins.shift();
        if ("boolean" == typeof baseProto) {
            deep = baseProto;
            baseProto = mixins.shift();
        }
        var instance = baseProto ? Object.create(baseProto) : {};
        deep && createRecursive(instance);
        if (mixins.length > 0) {
            mixins.unshift(instance);
            def.mixin.apply(def, mixins);
        }
        return instance;
    }
    ;
    def.scope(function() {
        function typeLocked() {
            return def.error.operationInvalid("Type is locked.");
        }
        function getStatic(state, p) {
            if (state)
                do {
                    var v = def.getOwn(state.constructor, p);
                    if (void 0 !== v)
                        return v;
                } while (state = state.base);
        }
        function TypeName(full) {
            var parts;
            if (full)
                if (full instanceof Array) {
                    parts = full;
                    full = parts.join(".");
                } else
                    parts = full.split(".");
            if (parts && parts.length > 1) {
                this.name = parts.pop();
                this.namespace = parts.join(".");
                this.namespaceParts = parts;
            } else {
                this.name = full || null;
                this.namespace = null;
                this.namespaceParts = [];
            }
        }
        function Method(spec) {
            this.fun = spec.as;
            this.isAbstract = !!spec.isAbstract;
        }
        function asMethod(fun) {
            if (fun) {
                if (def.fun.is(fun))
                    return new Method({
                        as: fun
                    });
                if (fun instanceof Method)
                    return fun;
                if (def.fun.is(fun.as))
                    return new Method(fun);
                if (fun.isAbstract)
                    return new Method({
                        isAbstract: !0,
                        as: def.fail.notImplemented
                    });
            }
            return null;
        }
        function method(fun) {
            return asMethod(fun) || def.fail.argumentInvalid("fun");
        }
        function rootType() {}
        function override(method, base) {
            return function() {
                var prevBase = rootProto.base;
                rootProto.base = base;
                try {
                    return method.apply(this, arguments);
                } finally {
                    rootProto.base = prevBase;
                }
            }
            ;
        }
        function overrideMethod(mname, method) {
            this[mname] = override(method, this[mname]);
            return this;
        }
        function toStringMethod() {
            return "" + this.constructor;
        }
        function inherits(type, base) {
            var proto = type.prototype = Object.create(base.prototype);
            proto.constructor = type;
            return proto;
        }
        function createConstructor(state) {
            function constructor() {
                if (S)
                    for (var i = 0; steps[i].apply(this, arguments) !== !1 && ++i < S; )
                        ;
            }
            var S = 1
              , steps = [function() {
                S = 0;
                if (state.initOrPost) {
                    steps.length = 0;
                    if (state.init) {
                        steps.push(state.init);
                        S++;
                    }
                    if (state.post) {
                        steps.push(state.post);
                        S++;
                    }
                    constructor.apply(this, arguments);
                    return !1;
                }
                steps = null;
            }
            ];
            return constructor;
        }
        function type() {
            var args = def.destructuringTypeBind(_typeFunArgTypes, arguments);
            return typeCore.apply(this, args);
        }
        function typeCore(name, baseType, space) {
            var baseState, typeName = new TypeName(name);
            if (baseType) {
                baseState = baseType.safe && shared(baseType.safe) || def.fail.operationInvalid('Invalid "foreign" base type.');
                baseState.locked = !0;
            } else {
                baseType = rootType;
                baseState = rootState;
            }
            var state = Object.create(baseState);
            state.locked = !1;
            state.base = baseState;
            state.methods = Object.create(baseState.methods);
            var constructor = createConstructor(state);
            def.copyOwn(constructor, typeProto);
            constructor.name = typeName.name;
            constructor.typeName = typeName;
            constructor.safe = shared.safe(state);
            constructor.toString = function() {
                return "" + this.typeName || "Anonymous type";
            }
            ;
            var proto = inherits(constructor, baseType);
            state.constructor = constructor;
            proto.override = overrideMethod;
            proto.toString = toStringMethod;
            typeName.name && defineName(def.space(typeName.namespace, space), typeName.name, constructor);
            return constructor;
        }
        var shared = def.shared()
          , typeProto = {
            init: function(init) {
                init || def.fail.argumentRequired("init");
                var state = shared(this.safe);
                !state.locked || def.fail(typeLocked());
                var baseInit = state.init;
                baseInit && (init = override(init, baseInit));
                state.init = init;
                state.initOrPost = !0;
                return this;
            },
            postInit: function(postInit) {
                postInit || def.fail.argumentRequired("postInit");
                var state = shared(this.safe);
                !state.locked || def.fail(typeLocked());
                var basePostInit = state.post;
                basePostInit && (postInit = override(postInit, basePostInit));
                state.post = postInit;
                state.initOrPost = !0;
                return this;
            },
            add: function(mixin) {
                var state = shared(this.safe);
                !state.locked || def.fail(typeLocked());
                var proto = this.prototype
                  , baseState = state.base;
                def.each(mixin.prototype || mixin, function(value, p) {
                    switch (p) {
                    case "base":
                    case "constructor":
                        return;

                    case "toString":
                        if (value === toStringMethod)
                            return;
                        break;

                    case "override":
                        if (value === overrideMethod)
                            return;
                    }
                    if (value) {
                        var method = asMethod(value);
                        if (method) {
                            var baseMethod, bm = state.methods[p];
                            if (bm && bm instanceof Method)
                                baseMethod = bm;
                            else if (baseState) {
                                bm = baseState.methods[p];
                                bm && bm instanceof Method && (baseMethod = bm);
                            }
                            state.methods[p] = method;
                            baseMethod && (value = baseMethod.override(method));
                            proto[p] = value;
                            return;
                        }
                    }
                    mixinProp(proto, p, value, def.identity);
                });
                return this;
            },
            getStatic: function(p) {
                return getStatic(shared(this.safe), p);
            },
            addStatic: function(mixin) {
                var state = shared(this.safe);
                !state.locked || def.fail(typeLocked());
                for (var p in mixin)
                    if ("prototype" !== p) {
                        var v2 = mixin[p]
                          , o2 = def.object.as(v2);
                        if (o2) {
                            var v1 = def.getOwn(this, p)
                              , v1Local = void 0 !== v1;
                            v1Local || (v1 = getStatic(state.base, p));
                            var o1 = def.object.asNative(v1);
                            if (o1) {
                                if (v1Local) {
                                    def.mixin(v1, v2);
                                    continue;
                                }
                                v2 = def.create(v1, v2);
                            }
                        }
                        this[p] = v2;
                    }
                return this;
            }
        };
        TypeName.prototype.toString = function() {
            return def.string.join(".", this.namespace + "." + this.name);
        }
        ;
        def.copyOwn(Method.prototype, {
            override: function(method) {
                if (this.isAbstract)
                    return method.fun;
                var fun2 = override(method.fun, this.fun);
                method.fun = fun2;
                return fun2;
            }
        });
        var rootProto = rootType.prototype;
        rootProto.base = void 0;
        var rootState = {
            locked: !0,
            init: void 0,
            postInit: void 0,
            initOrPost: !1,
            methods: {},
            constructor: rootType
        };
        rootType.safe = shared.safe(rootState);
        var _typeFunArgTypes = ["string", "function", "object"];
        def.type = type;
        def.method = method;
    });
    def.makeEnum = function(a) {
        var i = 1
          , e = {};
        a.forEach(function(p) {
            e[p] = i;
            i <<= 1;
        });
        return e;
    }
    ;
    def.copyOwn(def.array, {
        create: function(len, dv) {
            var a = len >= 0 ? new Array(len) : [];
            if (void 0 !== dv)
                for (var i = 0; len > i; i++)
                    a[i] = dv;
            return a;
        },
        append: function(target, source, start) {
            null == start && (start = 0);
            for (var i = 0, L = source.length, T = target.length; L > i; i++)
                target[T + i] = source[start + i];
            return target;
        },
        appendMany: function(target) {
            var a = arguments
              , S = a.length;
            if (S > 1)
                for (var t = target.length, s = 1; S > s; s++) {
                    var source = a[s];
                    if (source)
                        for (var i = 0, L = source.length; L > i; )
                            target[t++] = source[i++];
                }
            return target;
        },
        prepend: function(target, source, start) {
            null == start && (start = 0);
            for (var i = 0, L = source.length; L > i; i++)
                target.unshift(source[start + i]);
            return target;
        },
        removeAt: function(array, index) {
            return array.splice(index, 1)[0];
        },
        insertAt: function(array, index, elem) {
            array.splice(index, 0, elem);
            return array;
        },
        removeIf: function(array, p, x) {
            for (var i = 0, L = array.length; L > i; )
                if (p.call(x, array[i], i)) {
                    L--;
                    array.splice(i, 1);
                } else
                    i++;
            return array;
        },
        binarySearch: function(array, item, comparer, key) {
            comparer || (comparer = def.compare);
            for (var low = 0, high = array.length - 1; high >= low; ) {
                var mid = low + high >> 1
                  , result = comparer(item, key ? key(array[mid]) : array[mid]);
                if (0 > result)
                    high = mid - 1;
                else {
                    if (!(result > 0))
                        return mid;
                    low = mid + 1;
                }
            }
            return ~low;
        },
        insert: function(array, item, comparer) {
            var index = def.array.binarySearch(array, item, comparer);
            0 > index && array.splice(~index, 0, item);
            return index;
        },
        remove: function(array, item, comparer) {
            var index = def.array.binarySearch(array, item, comparer);
            return index >= 0 ? array.splice(index, 1)[0] : void 0;
        }
    });
    var nextGlobalId = 1
      , nextIdByScope = {};
    def.nextId = function(scope) {
        if (scope) {
            var nextId = def.getOwn(nextIdByScope, scope) || 1;
            nextIdByScope[scope] = nextId + 1;
            return nextId;
        }
        return nextGlobalId++;
    }
    ;
    def.type("Set").init(function(source, count) {
        this.source = source || {};
        this.count = source ? null != count ? count : def.ownKeys(source).length : 0;
    }).add({
        has: function(p) {
            return objectHasOwn.call(this.source, p);
        },
        add: function(p) {
            var source = this.source;
            if (!objectHasOwn.call(source, p)) {
                this.count++;
                source[p] = !0;
            }
            return this;
        },
        rem: function(p) {
            if (objectHasOwn.call(this.source, p)) {
                delete this.source[p];
                this.count--;
            }
            return this;
        },
        clear: function() {
            if (this.count) {
                this.source = {};
                this.count = 0;
            }
            return this;
        },
        members: function() {
            return def.ownKeys(this.source);
        }
    });
    def.type("Map").init(function(source, count) {
        this.source = source || {};
        this.count = source ? null != count ? count : def.ownKeys(source).length : 0;
    }).add({
        has: function(p) {
            return objectHasOwn.call(this.source, p);
        },
        get: function(p) {
            return objectHasOwn.call(this.source, p) ? this.source[p] : void 0;
        },
        set: function(p, v) {
            var source = this.source;
            objectHasOwn.call(source, p) || this.count++;
            source[p] = v;
            return this;
        },
        rem: function(p) {
            if (objectHasOwn.call(this.source, p)) {
                delete this.source[p];
                this.count--;
            }
            return this;
        },
        clear: function() {
            if (this.count) {
                this.source = {};
                this.count = 0;
            }
            return this;
        },
        copy: function(other) {
            def.eachOwn(other.source, function(value, p) {
                this.set(p, value);
            }, this);
        },
        values: function() {
            return def.own(this.source);
        },
        keys: function() {
            return def.ownKeys(this.source);
        },
        clone: function() {
            return new def.Map(def.copy(this.source),this.count);
        },
        symmetricDifference: function(other) {
            if (!this.count)
                return other.clone();
            if (!other.count)
                return this.clone();
            var result = {}
              , count = 0
              , as = this.source
              , bs = other.source;
            def.eachOwn(as, function(a, p) {
                if (!objectHasOwn.call(bs, p)) {
                    result[p] = a;
                    count++;
                }
            });
            def.eachOwn(bs, function(b, p) {
                if (!objectHasOwn.call(as, p)) {
                    result[p] = b;
                    count++;
                }
            });
            return new def.Map(result,count);
        },
        intersect: function(other, result) {
            result || (result = new def.Map());
            def.eachOwn(this.source, function(value, p) {
                other.has(p) && result.set(p, value);
            });
            return result;
        }
    });
    def.type("OrderedMap").init(function() {
        this._list = [];
        this._map = {};
    }).add({
        has: function(key) {
            return objectHasOwn.call(this._map, key);
        },
        count: function() {
            return this._list.length;
        },
        get: function(key) {
            var map = this._map;
            return objectHasOwn.call(map, key) ? map[key].value : void 0;
        },
        at: function(index) {
            var bucket = this._list[index];
            return bucket ? bucket.value : void 0;
        },
        add: function(key, v, index) {
            var map = this._map
              , bucket = objectHasOwn.call(map, key) && map[key];
            if (bucket)
                bucket.value !== v && (bucket.value = v);
            else {
                bucket = map[key] = {
                    key: key,
                    value: v
                };
                null == index ? this._list.push(bucket) : def.array.insertAt(this._list, index, bucket);
            }
            return this;
        },
        rem: function(key) {
            var map = this._map
              , bucket = objectHasOwn.call(map, key) && map[key];
            if (bucket) {
                var index = this._list.indexOf(bucket);
                this._list.splice(index, 1);
                delete this._map[key];
            }
            return this;
        },
        clear: function() {
            if (this._list.length) {
                this._map = {};
                this._list.length = 0;
            }
            return this;
        },
        keys: function() {
            return def.ownKeys(this._map);
        },
        forEach: function(fun, ctx) {
            return this._list.forEach(function(bucket) {
                fun.call(ctx, bucket.value, bucket.key);
            });
        }
    });
    def.html = {
        escape: function(str) {
            return def.string.to(str).replace(/&/gm, "&amp;").replace(/</gm, "&lt;").replace(/>/gm, "&gt;").replace(/"/gm, "&quot;");
        }
    };
    def.type("Query").add({
        index: -1,
        item: void 0,
        next: function() {
            var me = this
              , index = me.index;
            if (-2 === index)
                return !1;
            index++;
            if (!me._next(index)) {
                me._finish();
                return !1;
            }
            me.index = index;
            return !0;
        },
        _next: def.method({
            isAbstract: !0
        }),
        _finish: function() {
            var me = this;
            if (me.index > -2) {
                me.next = def.retFalse;
                me.index = -2;
                delete me.item;
            }
        },
        each: function(f, x) {
            for (var me = this; me.next(); )
                if (f.call(x, me.item, me.index) === !1)
                    return !0;
            return !1;
        },
        array: function() {
            for (var array = [], me = this; me.next(); )
                array.push(me.item);
            return array;
        },
        sort: function(compare, by) {
            compare || (compare = def.compare);
            if (by) {
                var keyCompare = compare;
                compare = function(a, b) {
                    return keyCompare(by(a), by(b));
                }
                ;
            }
            var sorted = this.array().sort(compare);
            return new def.ArrayLikeQuery(sorted);
        },
        object: function(keyArgs) {
            for (var target = def.get(keyArgs, "target") || {}, nameFun = def.get(keyArgs, "name"), valueFun = def.get(keyArgs, "value"), ctx = def.get(keyArgs, "context"); this.next(); ) {
                var name = "" + (nameFun ? nameFun.call(ctx, this.item, this.index) : this.item);
                target[name] = valueFun ? valueFun.call(ctx, this.item, this.index) : this.item;
            }
            return target;
        },
        reduce: function(accumulator) {
            var result, i = 0;
            if (arguments.length < 2) {
                if (!this.next())
                    throw new TypeError("Length is 0 and no second argument");
                result = this.item;
            } else
                result = arguments[1];
            for (; this.next(); ) {
                result = accumulator(result, this.item, this.index);
                ++i;
            }
            return result;
        },
        count: function() {
            for (var count = 0; this.next(); )
                count++;
            return count;
        },
        first: function(pred, ctx, dv) {
            for (; this.next(); )
                if (!pred || pred.call(ctx, this.item, this.index)) {
                    var item = this.item;
                    this._finish();
                    return item;
                }
            return dv;
        },
        last: function(pred, ctx, dv) {
            for (var theItem = dv; this.next(); )
                (!pred || pred.call(ctx, this.item, this.index)) && (theItem = this.item);
            return theItem;
        },
        any: function(pred, ctx) {
            for (; this.next(); )
                if (!pred || pred.call(ctx, this.item, this.index)) {
                    this._finish();
                    return !0;
                }
            return !1;
        },
        all: function(pred, ctx) {
            for (; this.next(); )
                if (!pred.call(ctx, this.item, this.index)) {
                    this._finish();
                    return !1;
                }
            return !0;
        },
        min: function() {
            for (var min = null; this.next(); )
                (null === min || this.item < min) && (min = this.item);
            return min;
        },
        max: function() {
            for (var max = null; this.next(); )
                (null === max || this.item > max) && (max = this.item);
            return max;
        },
        range: function() {
            for (var min = null, max = null; this.next(); ) {
                var item = this.item;
                if (null === min)
                    min = max = item;
                else {
                    min > item && (min = item);
                    item > max && (max = item);
                }
            }
            return null != min ? {
                min: min,
                max: max
            } : null;
        },
        multipleIndex: function(keyFun, ctx) {
            var keyIndex = {};
            this.each(function(item) {
                var key = keyFun ? keyFun.call(ctx, item) : item;
                if (null != key) {
                    var sameKeyItems = def.getOwn(keyIndex, key) || (keyIndex[key] = []);
                    sameKeyItems.push(item);
                }
            });
            return keyIndex;
        },
        uniqueIndex: function(keyFun, ctx) {
            var keyIndex = {};
            this.each(function(item) {
                var key = keyFun ? keyFun.call(ctx, item) : item;
                null == key || objectHasOwn.call(keyIndex, key) || (keyIndex[key] = item);
            });
            return keyIndex;
        },
        select: function(fun, ctx) {
            return new def.SelectQuery(this,fun,ctx);
        },
        prop: function(p) {
            return new def.SelectQuery(this,function(item) {
                return item ? item[p] : void 0;
            }
            );
        },
        selectMany: function(fun, ctx) {
            return new def.SelectManyQuery(this,fun,ctx);
        },
        union: function() {
            var queries = def.array.append([this], arguments);
            return new def.SelectManyQuery(new def.ArrayLikeQuery(queries));
        },
        where: function(fun, ctx) {
            return new def.WhereQuery(this,fun,ctx);
        },
        distinct: function(fun, ctx) {
            return new def.DistinctQuery(this,fun,ctx);
        },
        skip: function(n) {
            return new def.SkipQuery(this,n);
        },
        take: function(n) {
            return 0 >= n ? new def.NullQuery() : isFinite(n) ? new def.TakeQuery(this,n) : this;
        },
        whayl: function(pred, ctx) {
            return new def.WhileQuery(this,pred,ctx);
        },
        reverse: function() {
            return new def.ReverseQuery(this);
        }
    });
    def.type("NullQuery", def.Query).add({
        next: def.retFalse
    });
    def.type("AdhocQuery", def.Query).init(function(next) {
        this._next = next;
    });
    def.type("ArrayLikeQuery", def.Query).init(function(list) {
        function arraLike_next() {
            for (; ++i < I; )
                if (objectHasOwn.call(list, i)) {
                    me.index = i;
                    me.item = list[i];
                    return !0;
                }
            me._finish();
            return !1;
        }
        var me = this;
        def.array.isLike(list) || (list = [list]);
        me._list = list;
        me._count = list.length;
        var i = -1
          , I = list.length;
        me.next = arraLike_next;
    }).add({
        count: function() {
            var remaining = this._count;
            this.index >= 0 && (remaining -= this.index + 1);
            this._finish();
            return remaining;
        }
    });
    def.type("RangeQuery", def.Query).init(function(start, count, step) {
        this._index = start;
        this._count = count;
        this._step = null == step ? 1 : step;
    }).add({
        _next: function(nextIndex) {
            if (nextIndex < this._count) {
                this.item = this._index;
                this._index += this._step;
                return !0;
            }
        },
        count: function() {
            var remaining = this._count;
            this.index >= 0 && (remaining -= this.index + 1);
            this._finish();
            return remaining;
        }
    });
    def.type("WhereQuery", def.Query).init(function(source, p, x) {
        function where_next() {
            for (; source.next(); ) {
                var e = source.item;
                if (p.call(x, e, source.index)) {
                    me.item = e;
                    me.index = ++i;
                    return !0;
                }
            }
            me._finish();
            return !1;
        }
        var me = this
          , i = -1;
        me.next = where_next;
    });
    def.type("WhileQuery", def.Query).init(function(s, p, x) {
        function while_next() {
            if (s.next()) {
                var e = s.item;
                if (p.call(x, e, s.index)) {
                    me.item = e;
                    me.index = ++i;
                    return !0;
                }
            }
            me._finish();
            return !1;
        }
        var me = this
          , i = -1;
        me.next = while_next;
    });
    def.type("SelectQuery", def.Query).init(function(s, f, x) {
        function select_next() {
            if (s.next()) {
                me.item = f.call(x, s.item, s.index);
                me.index = ++i;
                return !0;
            }
            me._finish();
            return !1;
        }
        var me = this
          , i = -1;
        me.next = select_next;
    });
    def.type("SelectManyQuery", def.Query).init(function(source, selectMany, ctx) {
        this._selectMany = selectMany;
        this._ctx = ctx;
        this._source = source;
        this._manySource = null;
    }).add({
        _next: function() {
            for (; ; ) {
                if (this._manySource) {
                    if (this._manySource.next()) {
                        this.item = this._manySource.item;
                        return !0;
                    }
                    this._manySource = null;
                }
                if (!query_nextMany.call(this))
                    break;
            }
        }
    });
    def.type("DistinctQuery", def.Query).init(function(s, k, x) {
        function distinct_next() {
            for (; s.next(); ) {
                var e = s.item
                  , v = k ? k.call(x, e, s.index) : e;
                if (null != v && !objectHasOwn.call(ks, v)) {
                    me.item = e;
                    me.index = ++i;
                    return ks[v] = !0;
                }
            }
            me._finish();
            return !1;
        }
        var me = this
          , i = -1
          , ks = {};
        me.next = distinct_next;
    });
    def.type("SkipQuery", def.Query).init(function(source, skip) {
        this._source = source;
        this._skip = skip;
    }).add({
        _next: function() {
            for (; this._source.next(); ) {
                if (!(this._skip > 0)) {
                    this.item = this._source.item;
                    return !0;
                }
                this._skip--;
            }
        }
    });
    def.type("TakeQuery", def.Query).init(function(source, take) {
        this._source = source;
        this._take = take;
    }).add({
        _next: function() {
            if (this._take > 0 && this._source.next()) {
                this._take--;
                this.item = this._source.item;
                return !0;
            }
        }
    });
    def.type("ReverseQuery", def.Query).init(function(source) {
        this._source = source;
    }).add({
        _next: function(nextIndex) {
            if (!nextIndex) {
                this._source instanceof def.Query && (this._source = this._source instanceof def.ArrayLikeQuery ? this._source._list : this._source.array());
                this._count = this._source.length;
            }
            var count = this._count;
            if (count > nextIndex) {
                for (var index = count - nextIndex - 1, source = this._source; !objectHasOwn.call(source, index); ) {
                    if (--index < 0)
                        return !1;
                    this._count--;
                }
                this.item = source[index];
                return !0;
            }
        }
    });
    def.query = function(q) {
        return void 0 === q ? new def.NullQuery() : q instanceof def.Query ? q : def.fun.is(q) ? new def.AdhocQuery(q) : new def.ArrayLikeQuery(q);
    }
    ;
    def.range = function(start, count, step) {
        return new def.RangeQuery(start,count,step);
    }
    ;
    currentNamespace = def.global;
    return def;
}();

var pvc = function(def, pv) {
    function pvc_syncLog() {
        if (pvc.debug > 0 && "undefined" != typeof console)
            ["log", "info", ["trace", "debug"], "error", "warn", ["group", "groupCollapsed"], "groupEnd"].forEach(function(ps) {
                ps = ps instanceof Array ? ps : [ps, ps];
                pvc_installLog(pvc, ps[0], ps[1], "[pvChart]");
            });
        else {
            pvc.debug > 1 && (pvc.debug = 1);
            ["log", "info", "trace", "warn", "group", "groupEnd"].forEach(function(p) {
                pvc[p] = def.noop;
            });
            var _errorPrefix = "[pvChart ERROR]: ";
            pvc.error = function(e) {
                e && "object" == typeof e && e.message && (e = e.message);
                e = "" + def.nullyTo(e, "");
                e.indexOf(_errorPrefix) < 0 && (e = _errorPrefix + e);
                throw new Error(e);
            }
            ;
        }
        pvc.logError = pvc.error;
        pv.error = pvc.error;
    }
    function pvc_syncTipsyLog() {
        var tip = pv.Behavior.tipsy;
        if (tip && tip.setDebug) {
            tip.setDebug(pvc.debug);
            tip.log = pvc.log;
        }
    }
    function pvc_installLog(o, pto, pfrom, prompt) {
        pfrom || (pfrom = pto);
        var fun, c = console, m = c[pfrom] || c.log;
        if (m) {
            var mask = prompt + ": %s";
            if (def.fun.is(m))
                fun = m.bind(c, mask);
            else {
                var apply = Function.prototype.apply;
                fun = function() {
                    apply.call(m, c, def.array.append([mask], arguments));
                }
                ;
            }
        }
        o[pto] = fun;
    }
    function pvc_unwrapExtensionOne(id, prefix) {
        return id ? def.object.is(id) ? id.abs : prefix ? prefix + def.firstUpperCase(id) : id : prefix;
    }
    function pvc_colorIsGray(color) {
        color = pv.color(color);
        var r = color.r
          , g = color.g
          , b = color.b
          , avg = (r + g + b) / 3
          , tol = 2;
        return Math.abs(r - avg) <= tol && Math.abs(g - avg) <= tol && Math.abs(b - avg) <= tol;
    }
    function pvc_colorScales(keyArgs) {
        keyArgs || def.fail.argumentRequired("keyArgs");
        var type = keyArgs.type || def.fail.argumentRequired("keyArgs.type");
        switch (type) {
        case "linear":
            return new pvc.color.LinearScalesBuild(keyArgs).buildMap();

        case "discrete":
            return new pvc.color.DiscreteScalesBuild(keyArgs).buildMap();

        case "normal":
            return new pvc.color.NormalScalesBuild(keyArgs).buildMap();
        }
        throw def.error.argumentInvalid("scaleType", "Unexistent scale type '{0}'.", [type]);
    }
    function pvc_colorScale(keyArgs) {
        keyArgs || def.fail.argumentRequired("keyArgs");
        var type = keyArgs.type || def.fail.argumentRequired("keyArgs.type");
        switch (type) {
        case "linear":
            return new pvc.color.LinearScalesBuild(keyArgs).build();

        case "discrete":
            return new pvc.color.DiscreteScalesBuild(keyArgs).build();

        case "normal":
            return new pvc.color.NormalScalesBuild(keyArgs).build();
        }
        throw def.error.argumentInvalid("scaleType", "Unexistent scale type '{0}'.", [type]);
    }
    function pvc_options(specs, context) {
        function resolve(name) {
            return _infos[name].resolve();
        }
        function option(name, noDefault) {
            var info = resolve(name);
            return noDefault && !info.isSpecified ? void 0 : info.value;
        }
        function isSpecified(name) {
            return resolve(name).isSpecified;
        }
        function specified(name) {
            return option(name, !0);
        }
        function isDefined(name) {
            return def.hasOwn(_infos, name);
        }
        function specify(opts) {
            return set(opts, !1);
        }
        function defaults(opts) {
            return set(opts, !0);
        }
        function getDefaultValue(name) {
            return resolve(name)._dv;
        }
        function set(opts, isDefault) {
            for (var name in opts) {
                var info = def.hasOwnProp.call(_infos, name) && _infos[name];
                if (info) {
                    var value = opts[name];
                    void 0 !== value && info.set(value, isDefault);
                }
            }
            return option;
        }
        specs || def.fail.argumentRequired("specs");
        var _infos = {};
        def.each(specs, function(spec, name) {
            var info = new pvc_OptionInfo(name,option,context,spec);
            _infos[info.name] = info;
        });
        option.option = option;
        option.specified = specified;
        option.defaultValue = getDefaultValue;
        option.isSpecified = isSpecified;
        option.isDefined = isDefined;
        option.specify = specify;
        option.defaults = defaults;
        return option;
    }
    function options_resolvers(list) {
        return function(optionInfo) {
            for (var i = 0, L = list.length; L > i; i++) {
                var m = list[i];
                "string" == typeof m && (m = this[m]);
                if (m.call(this, optionInfo) === !0)
                    return !0;
            }
        }
        ;
    }
    function options_constantResolver(value) {
        return function(optionInfo) {
            optionInfo.specify(value);
            return !0;
        }
        ;
    }
    function options_specifyResolver(fun) {
        return function(optionInfo) {
            var value = fun.call(this, optionInfo);
            if (void 0 !== value) {
                optionInfo.specify(value);
                return !0;
            }
        }
        ;
    }
    function options_defaultResolver(fun) {
        return function(optionInfo) {
            var value = fun.call(this, optionInfo);
            if (void 0 !== value) {
                optionInfo.defaultValue(value);
                return !0;
            }
        }
        ;
    }
    function data_disposeChildList(list, parentProp) {
        var L = list && list.length;
        if (L) {
            for (var i = 0; L > i; i++) {
                var child = list[i];
                parentProp && (child[parentProp] = null);
                child.dispose();
            }
            list.length = 0;
        }
    }
    function data_addColChild(parent, childrenProp, child, parentProp, index) {
        child[parentProp] = parent;
        var col = parent[childrenProp] || (parent[childrenProp] = []);
        null == index || index >= col.length ? col.push(child) : col.splice(index, 0, child);
    }
    function data_removeColChild(parent, childrenProp, child, parentProp) {
        var children = parent[childrenProp];
        if (children) {
            var index = children.indexOf(child);
            index >= 0 && def.array.removeAt(children, index);
        }
        child[parentProp] = null;
    }
    function dimType_addVisualRole(visualRole) {
        this.playedVisualRoles.set(visualRole.name, visualRole);
        compType_dimensionRolesChanged.call(this.complexType, this);
    }
    function dimType_removeVisualRole(visualRole) {
        this.playedVisualRoles.rem(visualRole.name);
        compType_dimensionRolesChanged.call(this.complexType, this);
    }
    function compType_dimensionRolesChanged() {
        this._isPctRoleDimTypeMap = null;
    }
    function relTransl_dataPartGet(plot2DataSeriesIndexes, seriesReader) {
        function calcAxis2SeriesKeySet() {
            var atoms = {}
              , seriesKeys = def.query(me.source).select(function(item) {
                seriesReader(item, atoms);
                var value = atoms.series;
                null != value && null != value.v && (value = value.v);
                return value || null;
            }).distinct().array();
            return me._createPlot2SeriesKeySet(plot2DataSeriesIndexes, seriesKeys);
        }
        var me = this;
        return this._dataPartGet(calcAxis2SeriesKeySet, seriesReader);
    }
    function atom_idComparer(a, b) {
        return a.id - b.id;
    }
    function atom_idComparerReverse(a, b) {
        return b.id - a.id;
    }
    function datum_deselect() {
        delete this.isSelected;
    }
    function datum_isNullOrSelected(d) {
        return d.isNull || d.isSelected;
    }
    function datum_isSelectedT(d) {
        return d.isSelected === !0;
    }
    function datum_isSelectedF(d) {
        return d.isSelected === !1;
    }
    function datum_isVisibleT(d) {
        return d.isVisible === !0;
    }
    function datum_isVisibleF(d) {
        return d.isVisible === !1;
    }
    function datum_isNullT(d) {
        return d.isNull === !0;
    }
    function datum_isNullF(d) {
        return d.isNull === !1;
    }
    function dim_createAtom(type, sourceValue, key, value, label, isVirtual) {
        var atom;
        if (this.owner === this) {
            if (null == label) {
                var formatter = type._formatter;
                label = formatter ? formatter(value, sourceValue) : value;
            }
            label = "" + label;
            !label && pvc.debug >= 2 && pvc.log("Only the null value should have an empty label.");
            atom = new pvc.data.Atom(this,value,label,sourceValue,key);
            isVirtual && (atom.isVirtual = !0);
        } else {
            var source = this.parent || this.linkParent;
            atom = source._atomsByKey[key] || dim_createAtom.call(source, type, sourceValue, key, value, label, isVirtual);
        }
        def.array.insert(this._atoms, atom, this._atomComparer);
        dim_clearVisiblesCache.call(this);
        this._atomsByKey[key] = atom;
        return atom;
    }
    function dim_internAtom(atom) {
        var key = atom.key
          , me = this;
        if (atom.dimension === me) {
            me.owner === me || def.assert("Should be an owner dimension");
            key || atom !== me._virtualNullAtom || (atom = me.intern(null));
            return atom;
        }
        var hasInited = !me._lazyInit;
        if (hasInited) {
            var localAtom = me._atomsByKey[key];
            if (localAtom) {
                if (localAtom !== atom)
                    throw def.error.operationInvalid("Atom is from a different root data.");
                return atom;
            }
            if (me.owner === me)
                throw def.error.operationInvalid("Atom is from a different root data.");
        }
        dim_internAtom.call(me.parent || me.linkParent, atom);
        if (hasInited) {
            me._atomsByKey[key] = atom;
            if (key)
                def.array.insert(me._atoms, atom, me._atomComparer);
            else {
                me._nullAtom = atom;
                me._atoms.unshift(atom);
            }
            dim_clearVisiblesCache.call(me);
        }
        return atom;
    }
    function dim_buildDatumsFilterKey(keyArgs) {
        var visible = def.get(keyArgs, "visible")
          , selected = def.get(keyArgs, "selected");
        return (null == visible ? null : !!visible) + ":" + (null == selected ? null : !!selected);
    }
    function dim_createNullAtom(sourceValue) {
        var nullAtom = this._nullAtom;
        if (!nullAtom) {
            if (this.owner === this) {
                var typeFormatter = this.type._formatter
                  , label = "" + (typeFormatter ? typeFormatter.call(null, null, sourceValue) : "");
                nullAtom = new pvc.data.Atom(this,null,label,null,"");
                this.data._atomsBase[this.name] = nullAtom;
            } else
                nullAtom = dim_createNullAtom.call(this.parent || this.linkParent, sourceValue);
            this._atomsByKey[""] = this._nullAtom = nullAtom;
            this._atoms.unshift(nullAtom);
        }
        return nullAtom;
    }
    function dim_createVirtualNullAtom() {
        this.owner === this || def.assert("Can only create atoms on an owner dimension.");
        if (!this._virtualNullAtom) {
            this._virtualNullAtom = new pvc.data.Atom(this,null,"",null,"");
            this.data._atomsBase[this.name] = this._virtualNullAtom;
        }
        return this._virtualNullAtom;
    }
    function dim_uninternUnvisitedAtoms() {
        this.owner === this || def.assert("Can only unintern atoms of an owner dimension.");
        var atoms = this._atoms;
        if (atoms) {
            for (var atomsByKey = this._atomsByKey, i = 0, L = atoms.length; L > i; ) {
                var atom = atoms[i];
                if (atom.visited) {
                    delete atom.visited;
                    i++;
                } else if (atom !== this._virtualNullAtom) {
                    atoms.splice(i, 1);
                    L--;
                    var key = atom.key;
                    delete atomsByKey[key];
                    if (!key) {
                        delete this._nullAtom;
                        this.data._atomsBase[this.name] = this._virtualNullAtom;
                    }
                }
            }
            dim_clearVisiblesCache.call(this);
        }
    }
    function dim_uninternVirtualAtoms() {
        var atoms = this._atoms;
        if (atoms) {
            for (var removed, atomsByKey = this._atomsByKey, i = 0, L = atoms.length; L > i; ) {
                var atom = atoms[i];
                if (atom.isVirtual) {
                    atoms.splice(i, 1);
                    L--;
                    removed = !0;
                    var key = atom.key || def.assert("Cannot be the null or virtual null atom.");
                    delete atomsByKey[key];
                } else
                    i++;
            }
            removed && dim_clearVisiblesCache.call(this);
        }
    }
    function dim_clearVisiblesCache() {
        this._atomVisibleDatumsCount = this._sumCache = this._visibleAtoms = this._visibleIndexes = null;
    }
    function dim_addChild(child) {
        data_addColChild(this, "childNodes", child, "parent");
        child.owner = this.owner;
    }
    function dim_addLinkChild(linkChild) {
        data_addColChild(this, "_linkChildren", linkChild, "linkParent");
        linkChild.owner = this.owner;
    }
    function dim_onDatumVisibleChanged(datum, visible) {
        var map;
        if (!this._disposed && (map = this._atomVisibleDatumsCount)) {
            var atom = datum.atoms[this.name]
              , key = atom.key;
            def.hasOwn(this._atomsByKey, key) || def.assert("Atom must exist in this dimension.");
            var count = map[key];
            visible || count > 0 || def.assert("Must have had accounted for at least one visible datum.");
            map[key] = (count || 0) + (visible ? 1 : -1);
            this._visibleAtoms = this._sumCache = this._visibleIndexes = null;
        }
    }
    function dim_getVisibleDatumsCountMap() {
        var map = this._atomVisibleDatumsCount;
        if (!map) {
            map = {};
            this.data.datums(null, {
                visible: !0
            }).each(function(datum) {
                var atom = datum.atoms[this.name]
                  , key = atom.key;
                map[key] = (map[key] || 0) + 1;
            }, this);
            this._atomVisibleDatumsCount = map;
        }
        return map;
    }
    function dim_calcVisibleIndexes(visible) {
        var indexes = [];
        this._atoms.forEach(function(atom, index) {
            this.isVisible(atom) === visible && indexes.push(index);
        }, this);
        return indexes;
    }
    function dim_calcVisibleAtoms(visible) {
        return def.query(this._atoms).where(function(atom) {
            return this.isVisible(atom) === visible;
        }, this).array();
    }
    function data_addChild(child, index) {
        this.insertAt(child, index);
        def.lazy(this, "_childrenByKey")[child.key] = child;
    }
    function data_addLinkChild(linkChild, index) {
        data_addColChild(this, "_linkChildren", linkChild, "linkParent", index);
    }
    function data_removeLinkChild(linkChild) {
        data_removeColChild(this, "_linkChildren", linkChild, "linkParent");
    }
    function data_disposeChildLists() {
        data_disposeChildList(this.childNodes, "parent");
        this._childrenByKey = null;
        data_disposeChildList(this._linkChildren, "linkParent");
        this._groupByCache = null;
        this._sumAbsCache = null;
    }
    function data_assertIsOwner() {
        this.isOwner() || def.fail("Can only be called on the owner data.");
    }
    function data_onDatumSelectedChanged(datum, selected) {
        !datum.isNull || def.assert("Null datums do not notify selected changes");
        selected ? this._selectedNotNullDatums.set(datum.id, datum) : this._selectedNotNullDatums.rem(datum.id);
        this._sumAbsCache = null;
    }
    function data_onDatumVisibleChanged(datum, visible) {
        var did = datum.id
          , me = this
          , hasOwn = def.hasOwnProp;
        if (hasOwn.call(me._datumsById, did)) {
            !datum.isNull || def.assert("Null datums do not notify visible changes");
            visible ? me._visibleNotNullDatums.set(did, datum) : me._visibleNotNullDatums.rem(did);
            me._sumAbsCache = null;
            for (var list = me._dimensionsList, i = 0, L = list.length; L > i; )
                dim_onDatumVisibleChanged.call(list[i++], datum, visible);
            list = me.childNodes;
            i = 0;
            L = list.length;
            for (; L > i; )
                data_onDatumVisibleChanged.call(list[i++], datum, visible);
            list = me._linkChildren;
            if (list && (L = list.length)) {
                i = 0;
                for (; L > i; )
                    data_onDatumVisibleChanged.call(list[i++], datum, visible);
            }
        }
    }
    function groupSpec_parseGroupingLevel(groupLevelText, type) {
        def.string.is(groupLevelText) || def.fail.argumentInvalid("groupLevelText", "Invalid grouping specification.");
        return def.query(groupLevelText.split(/\s*\|\s*/)).where(def.truthy).select(function(dimSpecText) {
            var match = groupSpec_matchDimSpec.exec(dimSpecText) || def.fail.argumentInvalid("groupLevelText", "Invalid grouping level syntax '{0}'.", [dimSpecText])
              , name = match[1]
              , order = (match[2] || "").toLowerCase()
              , reverse = "desc" === order;
            return new pvc.data.GroupingDimensionSpec(name,reverse,type);
        });
    }
    function data_setDatums(addDatums, keyArgs) {
        function maybeAddDatum(newDatum) {
            if (newDatum) {
                var key = newDatum.key;
                if (!def.hasOwnProp.call(datumsByKey, key)) {
                    !isAdditive && oldDatumsByKey && def.hasOwnProp.call(oldDatumsByKey, key) && (newDatum = oldDatumsByKey[key]);
                    var id = newDatum.id;
                    datums.push(newDatum);
                    datumsByKey[key] = newDatum;
                    datumsById[id] = newDatum;
                    newDatums && newDatums.push(newDatum);
                    data_processDatumAtoms.call(this, newDatum, internNewAtoms, doAtomGC);
                    if (!newDatum.isNull) {
                        selDatums && newDatum.isSelected && selDatums.set(id, newDatum);
                        newDatum.isVisible && visDatums.set(id, newDatum);
                    }
                }
            }
        }
        addDatums || def.fail.argumentRequired("addDatums");
        var i, L, oldDatumsByKey, oldDatumsById, doAtomGC = def.get(keyArgs, "doAtomGC", !1), isAdditive = def.get(keyArgs, "isAdditive", !1), internNewAtoms = !!this._dimensions, visDatums = this._visibleNotNullDatums, selDatums = this._selectedNotNullDatums, oldDatums = this._datums;
        if (oldDatums) {
            oldDatumsByKey = this._datumsByKey;
            oldDatumsById = this._datumsById;
            isAdditive && doAtomGC && oldDatums.forEach(function(oldDatum) {
                data_processDatumAtoms.call(this, oldDatum, !1, !0);
            }, this);
        } else
            isAdditive = !1;
        var newDatums, datums, datumsByKey, datumsById;
        if (isAdditive) {
            newDatums = [];
            datums = oldDatums;
            datumsById = oldDatumsById;
            datumsByKey = oldDatumsByKey;
            this._sumAbsCache = null;
        } else {
            this._datums = datums = [];
            this._datumsById = datumsById = {};
            this._datumsByKey = datumsByKey = {};
            if (oldDatums) {
                data_disposeChildLists.call(this);
                visDatums.clear();
                selDatums && selDatums.clear();
            }
        }
        if (def.array.is(addDatums)) {
            i = 0;
            L = addDatums.length;
            for (; L > i; )
                maybeAddDatum.call(this, addDatums[i++]);
        } else {
            if (!(addDatums instanceof def.Query))
                throw def.error.argumentInvalid("addDatums", "Argument is of invalid type.");
            addDatums.each(maybeAddDatum, this);
        }
        if (doAtomGC) {
            var dims = this._dimensionsList;
            i = 0;
            L = dims.length;
            for (; L > i; )
                dim_uninternUnvisitedAtoms.call(dims[i++]);
        }
        if (isAdditive) {
            var linkChildren = this._linkChildren;
            if (linkChildren) {
                i = 0;
                L = linkChildren.length;
                for (; L > i; )
                    data_addDatumsSimple.call(linkChildren[i++], newDatums);
            }
        }
    }
    function data_processDatumAtoms(datum, intern, markVisited) {
        var dims = this._dimensionsList;
        dims || (intern = !1);
        if (intern || markVisited) {
            var L, atom, dim, datoms = datum.atoms, i = 0;
            if (dims) {
                L = dims.length;
                for (; L > i; ) {
                    dim = dims[i++];
                    atom = datoms[dim.name];
                    if (atom) {
                        intern && dim_internAtom.call(dim, atom);
                        markVisited && (atom.visited = !0);
                    }
                }
            } else {
                var dimNames = this.type.dimensionsNames();
                L = dimNames.length;
                for (; L > i; ) {
                    atom = datoms[dimNames[i++]];
                    atom && (atom.visited = !0);
                }
            }
        }
    }
    function data_addDatumsSimple(newDatums) {
        newDatums || def.fail.argumentRequired("newDatums");
        var groupOper = this._groupOper;
        if (groupOper)
            newDatums = groupOper.executeAdd(this, newDatums);
        else {
            var wherePred = this._wherePred;
            wherePred && (newDatums = newDatums.filter(wherePred));
            data_addDatumsLocal.call(this, newDatums);
        }
        var list = this._linkChildren
          , L = list && list.length;
        if (L)
            for (var i = 0; L > i; i++)
                data_addDatumsSimple.call(list[i], newDatums);
    }
    function data_addDatumsLocal(newDatums) {
        var me = this;
        me._sumAbsCache = null;
        for (var ds = me._datums, vds = me._visibleNotNullDatums, sds = me._selectedNotNullDatums, dsById = me._datumsById, i = 0, L = newDatums.length; L > i; i++) {
            var newDatum = newDatums[i]
              , id = newDatum.id;
            dsById[id] = newDatum;
            data_processDatumAtoms.call(me, newDatum, !0, !1);
            if (!newDatum.isNull) {
                sds && newDatum.isSelected && sds.set(id, newDatum);
                newDatum.isVisible && vds.set(id, newDatum);
            }
            ds.push(newDatum);
        }
    }
    function data_processWhereSpec(whereSpec) {
        function processDatumFilter(datumFilter) {
            if (null != datumFilter) {
                "object" == typeof datumFilter || def.fail.invalidArgument("datumFilter");
                var datumProcFilter = {}
                  , any = !1;
                for (var dimName in datumFilter) {
                    var atoms = this.dimensions(dimName).getDistinctAtoms(def.array.as(datumFilter[dimName]));
                    if (atoms.length) {
                        any = !0;
                        datumProcFilter[dimName] = atoms;
                    }
                }
                any && whereProcSpec.push(datumProcFilter);
            }
        }
        var whereProcSpec = [];
        whereSpec = def.array.as(whereSpec);
        whereSpec && whereSpec.forEach(processDatumFilter, this);
        return whereProcSpec;
    }
    function data_whereState(q, keyArgs) {
        var visible = def.get(keyArgs, "visible")
          , isNull = def.get(keyArgs, "isNull")
          , selected = def.get(keyArgs, "selected")
          , where = def.get(keyArgs, "where");
        null != visible && (q = q.where(visible ? datum_isVisibleT : datum_isVisibleF));
        null != isNull && (q = q.where(isNull ? datum_isNullT : datum_isNullF));
        null != selected && (q = q.where(selected ? datum_isSelectedT : datum_isSelectedF));
        where && (q = q.where(where));
        return q;
    }
    function data_wherePredicate(whereSpec, keyArgs) {
        var visible = def.get(keyArgs, "visible")
          , isNull = def.get(keyArgs, "isNull")
          , selected = def.get(keyArgs, "selected")
          , where = def.get(keyArgs, "where")
          , ps = [];
        null != visible && ps.unshift(visible ? datum_isVisibleT : datum_isVisibleF);
        null != isNull && ps.unshift(isNull ? datum_isNullT : datum_isNullF);
        null != selected && ps.unshift(selected ? datum_isSelectedT : datum_isSelectedF);
        where && ps.unshift(where);
        whereSpec && ps.unshift(data_whereSpecPredicate(whereSpec));
        var P = ps.length;
        if (P) {
            if (1 === P)
                return ps[0];
            var wherePredicate = function(d) {
                for (var i = P; i; )
                    if (!ps[--i](d))
                        return !1;
                return !0;
            };
            return wherePredicate;
        }
    }
    function data_whereSpecPredicate(whereSpec) {
        function datumWhereSpecPredicate(d) {
            for (var datoms = d.atoms, i = 0; L > i; i++)
                if (datumFilterPredicate(datoms, whereSpec[i]))
                    return !0;
            return !1;
        }
        function datumFilterPredicate(datoms, datumFilter) {
            for (var dimName in datumFilter)
                if (datumFilter[dimName].indexOf(datoms[dimName]) < 0)
                    return !1;
            return !0;
        }
        var L = whereSpec.length;
        return datumWhereSpecPredicate;
    }
    function data_where(whereSpec, keyArgs) {
        var orderBys = def.array.as(def.get(keyArgs, "orderBy"))
          , datumKeyArgs = def.create(keyArgs || {}, {
            orderBy: null
        })
          , query = def.query(whereSpec).selectMany(function(datumFilter, index) {
            orderBys && (datumKeyArgs.orderBy = orderBys[index]);
            return data_whereDatumFilter.call(this, datumFilter, datumKeyArgs);
        }, this);
        return query.distinct(def.propGet("id"));
    }
    function data_whereDatumFilter(datumFilter, keyArgs) {
        var groupingSpecText = keyArgs.orderBy;
        if (groupingSpecText) {
            if (groupingSpecText.indexOf("|") >= 0)
                throw def.error.argumentInvalid("keyArgs.orderBy", "Multi-dimension order by is not supported.");
        } else
            groupingSpecText = Object.keys(datumFilter).sort().join(",");
        var rootData = this.groupBy(groupingSpecText, keyArgs)
          , H = rootData.treeHeight
          , stateStack = [];
        return def.query(function() {
            var state;
            if (this._data) {
                if (this._datumsQuery) {
                    this._data || def.assert("Must have a current data");
                    stateStack.length || def.assert("Must have a parent data");
                    !this._dimAtomsOrQuery || def.assert();
                    if (this._datumsQuery.next()) {
                        this.item = this._datumsQuery.item;
                        return 1;
                    }
                    this._datumsQuery = null;
                    state = stateStack.pop();
                    this._data = state.data;
                    this._dimAtomsOrQuery = state.dimAtomsOrQuery;
                }
            } else {
                this._data = rootData;
                this._dimAtomsOrQuery = def.query(datumFilter[rootData._groupLevelSpec.dimensions[0].name]);
            }
            this._dimAtomsOrQuery || def.assert("Invalid programmer");
            this._data || def.assert("Must have a current data");
            for (var depth = stateStack.length; ; ) {
                for (; this._dimAtomsOrQuery.next(); ) {
                    var dimAtomOr = this._dimAtomsOrQuery.item
                      , childData = this._data.child(dimAtomOr.key);
                    if (childData && (H - 1 > depth || childData._datums.length)) {
                        stateStack.push({
                            data: this._data,
                            dimAtomsOrQuery: this._dimAtomsOrQuery
                        });
                        this._data = childData;
                        if (!(H - 1 > depth)) {
                            this._dimAtomsOrQuery = null;
                            this._datumsQuery = def.query(childData._datums);
                            this._datumsQuery.next();
                            this.item = this._datumsQuery.item;
                            return 1;
                        }
                        this._dimAtomsOrQuery = def.query(datumFilter[childData._groupLevelSpec.dimensions[0].name]);
                        depth++;
                    }
                }
                if (!depth)
                    return 0;
                state = stateStack.pop();
                this._data = state.data;
                this._dimAtomsOrQuery = state.dimAtomsOrQuery;
                depth--;
            }
            return 0;
        });
    }
    function scene_renderId(renderId) {
        if (this._renderId !== renderId) {
            this._renderId = renderId;
            this.renderState = {};
        }
    }
    function rootScene_setActive(scene) {
        var ownerScene;
        scene && (ownerScene = scene.ownerScene) && (scene = ownerScene);
        var active = this._active;
        if (active !== scene) {
            active && scene_setActive.call(active, !1);
            this._active = active = scene || null;
            active && scene_setActive.call(active, !0);
            return !0;
        }
        return !1;
    }
    function scene_setActive(isActive) {
        this.isActive !== isActive && (isActive ? this.isActive = !0 : delete this.isActive);
    }
    function scene_createVarMainMethod(name, nameEval) {
        return function() {
            var vb = this.vars[name];
            if (void 0 === vb) {
                vb = this[nameEval]();
                void 0 === vb && (vb = null);
                this.vars[name] = vb;
            }
            return vb;
        }
        ;
    }
    function visualContext_update(pvMark, scene) {
        this.event = pv.event;
        this.pvMark = pvMark;
        if (pvMark) {
            var sign = this.sign = pvMark.sign || null;
            !scene && sign && (scene = sign.scene());
            if (scene)
                this.index = scene.childIndex();
            else {
                this.index = null;
                scene = new pvc.visual.Scene(null,{
                    panel: this.panel
                });
            }
        } else {
            this.sign = null;
            this.index = null;
            scene = new pvc.visual.Scene(null,{
                panel: this.panel,
                source: this.chart.root.data
            });
        }
        this.scene = scene;
    }
    function sign_createBasic(pvMark) {
        var as = mark_getAncestorSign(pvMark) || def.assert("There must exist an ancestor sign");
        return new pvc.visual.BasicSign(as.panel,pvMark);
    }
    function mark_getAncestorSign(pvMark) {
        var sign;
        do
            pvMark = pvMark.parent;
        while (!(!pvMark || (sign = pvMark.sign) || pvMark.proto && (sign = pvMark.proto.sign)));return sign;
    }
    function axis_groupingScaleType(grouping) {
        return grouping.isDiscrete() ? "discrete" : grouping.firstDimensionValueType() === Date ? "timeSeries" : "numeric";
    }
    function pvc_castDomainScope(scope, axis) {
        return pvc.parseDomainScope(scope, axis.orientation);
    }
    function pvc_castAxisPosition(side) {
        if (side) {
            if (def.hasOwn(pvc_Sides.namesSet, side)) {
                var mapAlign = pvc.BasePanel["y" === this.orientation ? "horizontalAlign" : "verticalAlign2"];
                return mapAlign[side];
            }
            pvc.debug >= 2 && pvc.log(def.format("Invalid axis position value '{0}'.", [side]));
        }
        return "x" === this.orientation ? "bottom" : "left";
    }
    function cartAxis_castSize(value) {
        var position = this.option("Position");
        return pvc_Size.toOrtho(value, position);
    }
    function cartAxis_castTitleSize(value) {
        var position = this.option("Position");
        return pvc_Size.to(value, {
            singleProp: pvc.BasePanel.orthogonalLength[position]
        });
    }
    function colorAxis_castColorMap(colorMap) {
        var resultMap;
        if (colorMap) {
            var any;
            def.eachOwn(colorMap, function(v, k) {
                any = !0;
                colorMap[k] = pv.color(v);
            });
            any && (resultMap = colorMap);
        }
        return resultMap;
    }
    function colorAxis_getDefaultColors() {
        var colors, scaleType = this.scaleType;
        if (scaleType)
            if ("discrete" === scaleType)
                if (0 === this.index)
                    colors = pvc.createColorScheme();
                else {
                    var me = this;
                    colors = function() {
                        return me.chart._getRoleColorScale(me.role.name);
                    }
                    ;
                }
            else {
                colorAxis_defContColors || (colorAxis_defContColors = ["black", "yellow", "green"].map(pv.color));
                colors = colorAxis_defContColors.slice();
            }
        else
            colors = pvc.createColorScheme();
        return colors;
    }
    function legend_castSize(size) {
        if (!def.object.is(size)) {
            var position = this.option("Position");
            size = new pvc_Size().setSize(size, {
                singleProp: pvc.BasePanel.orthogonalLength[position]
            });
        }
        return size;
    }
    function legend_castAlign(align) {
        var position = this.option("Position");
        return pvc.parseAlign(position, align);
    }
    function legendItem_castSize(size) {
        return new pvc_Size().setSize(size, {
            singleProp: "width"
        });
    }
    function dataCell_dataPartValue(dc) {
        return dc.dataPartValue;
    }
    function pvc_castTrend(trend) {
        if ("trend" === this.name)
            return null;
        var type = this.option("TrendType");
        !type && trend && (type = trend.type);
        if (!type || "none" === type)
            return null;
        trend = trend ? Object.create(trend) : {};
        var trendInfo = pvc.trends.get(type);
        trend.info = trendInfo;
        trend.type = type;
        var label = this.option("TrendLabel");
        trend.label = null != label ? String(label) : trendInfo.dataPartAtom.f;
        return trend;
    }
    function pvcPoint_buildVisibleOption(type, dv) {
        return {
            resolveV1: function(optionInfo) {
                if (0 === this.globalIndex) {
                    this._specifyChartOption(optionInfo, "show" + type) || optionInfo.defaultValue(dv);
                    return !0;
                }
            }
        };
    }
    function pvcMetricPoint_buildVisibleOption(type) {
        return {
            resolveV1: function(optionInfo) {
                this._specifyChartOption(optionInfo, "show" + type);
                return !0;
            }
        };
    }
    Array.prototype.every || (Array.prototype.every = function(fun) {
        if (null == this)
            throw new TypeError();
        var t = Object(this)
          , len = t.length >>> 0;
        if ("function" != typeof fun)
            throw new TypeError();
        for (var thisArg = arguments.length >= 2 ? arguments[1] : void 0, i = 0; len > i; i++)
            if (i in t && !fun.call(thisArg, t[i], i, t))
                return !1;
        return !0;
    }
    );
    var pvc = def.globalSpace("pvc", {
        debug: 0
    });
    !function() {
        if ("undefined" != typeof window && window.location) {
            var urlIfHasDebug = function(url) {
                return url && /\bdebug=true\b/.test(url) ? url : null;
            }
              , url = urlIfHasDebug(window.location.href);
            if (!url)
                try {
                    url = urlIfHasDebug(window.top.location.href);
                } catch (e) {}
            if (url) {
                var m = /\bdebugLevel=(\d+)/.exec(url);
                pvc.debug = m ? +m[1] : 3;
            }
        }
    }();
    var pv_Mark = pv.Mark;
    pvc.invisibleFill = "rgba(127,127,127,0.00001)";
    pvc.logSeparator = "------------------------------------------";
    var pvc_arraySlice = Array.prototype.slice;
    pvc.setDebug = function(level) {
        level = +level;
        pvc.debug = isNaN(level) ? 0 : level;
        pvc_syncLog();
        pvc_syncTipsyLog();
        return pvc.debug;
    }
    ;
    pvc.setDebug(pvc.debug);
    pvc.defaultCompatVersion = function(compatVersion) {
        var defaults = pvc.BaseChart.prototype.defaults;
        return null != compatVersion ? defaults.compatVersion = compatVersion : defaults.compatVersion;
    }
    ;
    pvc.cloneMatrix = function(m) {
        return m.map(function(d) {
            return d.slice();
        });
    }
    ;
    pvc.normAngle = pv.Shape.normalizeAngle;
    pvc.stringify = function(t, keyArgs) {
        var maxLevel = def.get(keyArgs, "maxLevel") || 5
          , out = [];
        pvc.stringifyRecursive(out, t, maxLevel, keyArgs);
        return out.join("");
    }
    ;
    pvc.stringifyRecursive = function(out, t, remLevels, keyArgs) {
        if (remLevels > 0) {
            remLevels--;
            switch (typeof t) {
            case "undefined":
                return out.push("undefined");

            case "object":
                if (!t) {
                    out.push("null");
                    return !0;
                }
                if (def.fun.is(t.stringify))
                    return t.stringify(out, remLevels, keyArgs);
                if (t instanceof Array) {
                    out.push("[");
                    t.forEach(function(item, index) {
                        index && out.push(", ");
                        pvc.stringifyRecursive(out, item, remLevels, keyArgs) || out.pop();
                    });
                    out.push("]");
                } else {
                    var ownOnly = def.get(keyArgs, "ownOnly", !0);
                    if (t === def.global) {
                        out.push("<window>");
                        return !0;
                    }
                    if (def.fun.is(t.cloneNode)) {
                        out.push("<dom #" + (t.id || t.name || "?") + ">");
                        return !0;
                    }
                    if (remLevels > 1 && t.constructor !== Object) {
                        remLevels = 1;
                        ownOnly = !0;
                    }
                    out.push("{");
                    var first = !0;
                    for (var p in t)
                        if (!ownOnly || def.hasOwnProp.call(t, p)) {
                            first || out.push(", ");
                            out.push(p + ": ");
                            if (pvc.stringifyRecursive(out, t[p], remLevels, keyArgs))
                                first && (first = !1);
                            else {
                                out.pop();
                                first || out.pop();
                            }
                        }
                    if (first) {
                        var s = "" + t;
                        "[object Object]" !== s && out.push("{" + s + "}");
                    }
                    out.push("}");
                }
                return !0;

            case "number":
                out.push("" + Math.round(1e5 * t) / 1e5);
                return !0;

            case "boolean":
                out.push("" + t);
                return !0;

            case "string":
                out.push(JSON.stringify(t));
                return !0;

            case "function":
                if (def.get(keyArgs, "funs", !1)) {
                    out.push(JSON.stringify(t.toString().substr(0, 13) + "..."));
                    return !0;
                }
                return !1;
            }
            out.push("'new ???'");
            return !0;
        }
    }
    ;
    pvc.orientation = {
        vertical: "vertical",
        horizontal: "horizontal"
    };
    pvc.extensionTag = "extension";
    pvc.extendType = function(type, exts, names) {
        if (exts) {
            var exts2, sceneVars = type.prototype._vars, addExtension = function(ext, n) {
                if (void 0 !== ext) {
                    exts2 || (exts2 = {});
                    sceneVars && sceneVars[n] && (n = "_" + n + "EvalCore");
                    exts2[n] = def.fun.to(ext);
                }
            };
            names ? names.forEach(function(n) {
                addExtension(exts[n], n);
            }) : def.each(addExtension);
            exts2 && type.add(exts2);
        }
    }
    ;
    pv.Color.prototype.stringify = function(out, remLevels, keyArgs) {
        return pvc.stringifyRecursive(out, this.key, remLevels, keyArgs);
    }
    ;
    pv_Mark.prototype.hasDelegateValue = function(name, tag) {
        var p = this.$propertiesMap[name];
        return p ? !tag || p.tag === tag : this.proto ? this.proto.hasDelegateValue(name, tag) : !1;
    }
    ;
    pvc.defaultColorScheme = null;
    pvc.brighterColorTransform = function(color) {
        return (color.rgb ? color : pv.color(color)).brighter(.6);
    }
    ;
    pvc.setDefaultColorScheme = function(colors) {
        return pvc.defaultColorScheme = pvc.colorScheme(colors);
    }
    ;
    pvc.defaultColor = pv.Colors.category10()("?");
    pvc.colorScheme = function(colors) {
        if (null == colors)
            return null;
        if ("function" == typeof colors) {
            if (!colors.hasOwnProperty("range"))
                return colors;
            colors = colors.range();
        } else
            colors = def.array.as(colors);
        return colors.length ? function() {
            var scale = pv.colors(colors);
            scale.domain.apply(scale, arguments);
            return scale;
        }
        : null;
    }
    ,
    pvc.createColorScheme = function(colors) {
        return pvc.colorScheme(colors) || pvc.defaultColorScheme || pv.Colors.category10;
    }
    ;
    pvc.toGrayScale = function(color, alpha, maxGrayLevel, minGrayLevel) {
        color = pv.color(color);
        var avg = .299 * color.r + .587 * color.g + .114 * color.b;
        void 0 === maxGrayLevel ? maxGrayLevel = 200 : null == maxGrayLevel && (maxGrayLevel = 255);
        void 0 === minGrayLevel ? minGrayLevel = 30 : null == minGrayLevel && (minGrayLevel = 0);
        var delta = maxGrayLevel - minGrayLevel;
        avg = 0 >= delta ? maxGrayLevel : minGrayLevel + avg / 255 * delta;
        null == alpha ? alpha = color.opacity : 0 > alpha && (alpha = -alpha * color.opacity);
        avg = Math.round(avg);
        return pv.rgb(avg, avg, avg, alpha);
    }
    ;
    pvc.removeTipsyLegends = function() {
        try {
            $(".tipsy").remove();
        } catch (e) {}
    }
    ;
    pvc.createDateComparer = function(parser, key) {
        key || (key = pv.identity);
        return function(a, b) {
            return parser.parse(key(a)) - parser.parse(key(b));
        }
        ;
    }
    ;
    pvc.time = {
        intervals: {
            y: 31536e6,
            m: 2592e6,
            d30: 2592e6,
            w: 6048e5,
            d7: 6048e5,
            d: 864e5,
            h: 36e5,
            M: 6e4,
            s: 1e3,
            ms: 1
        },
        withoutTime: function(t) {
            return new Date(t.getFullYear(),t.getMonth(),t.getDate());
        },
        weekday: {
            previousOrSelf: function(t, toWd) {
                var wd = t.getDay()
                  , difDays = wd - toWd;
                if (difDays) {
                    var previousOffset = 0 > difDays ? 7 + difDays : difDays;
                    t = new Date(t - previousOffset * pvc.time.intervals.d);
                }
                return t;
            },
            nextOrSelf: function(t, toWd) {
                var wd = t.getDay()
                  , difDays = wd - toWd;
                if (difDays) {
                    var nextOffset = difDays > 0 ? 7 - difDays : -difDays;
                    t = new Date(t + nextOffset * pvc.time.intervals.d);
                }
                return t;
            },
            closestOrSelf: function(t, toWd) {
                var wd = t.getDay()
                  , difDays = wd - toWd;
                if (difDays) {
                    var D = pvc.time.intervals.d
                      , sign = difDays > 0 ? 1 : -1;
                    difDays = Math.abs(difDays);
                    t = new Date(difDays >= 4 ? t.getTime() + sign * (7 - difDays) * D : t.getTime() - sign * difDays * D);
                }
                return t;
            }
        }
    };
    pv.Format.createParser = function(pvFormat) {
        function parse(value) {
            return value instanceof Date ? value : def.number.is(value) ? new Date(value) : pvFormat.parse(value);
        }
        return parse;
    }
    ;
    pv.Format.createFormatter = function(pvFormat) {
        function format(value) {
            return null != value ? pvFormat.format(value) : "";
        }
        return format;
    }
    ;
    pvc.buildTitleFromName = function(name) {
        return def.firstUpperCase(name).replace(/([a-z\d])([A-Z])/, "$1 $2");
    }
    ;
    pvc.buildIndexedId = function(prefix, index) {
        return index > 0 ? prefix + "" + (index + 1) : prefix;
    }
    ;
    pvc.splitIndexedId = function(indexedId) {
        var match = /^(.*?)(\d*)$/.exec(indexedId)
          , index = null;
        if (match[2]) {
            index = Number(match[2]);
            1 >= index ? index = 1 : index--;
        }
        return [match[1], index];
    }
    ;
    var pvc_oneNullArray = [null];
    pvc.makeExtensionAbsId = function(id, prefix) {
        if (!id)
            return prefix;
        var result = [];
        prefix = def.array.to(prefix) || pvc_oneNullArray;
        id = def.array.to(id);
        for (var i = 0, I = prefix.length; I > i; i++)
            for (var j = 0, J = id.length; J > j; j++) {
                var absId = pvc_unwrapExtensionOne(id[j], prefix[i]);
                absId && result.push(absId);
            }
        return result;
    }
    ;
    pvc.makeEnumParser = function(enumName, hasKey, dk) {
        if (def.array.is(hasKey)) {
            var keySet = {};
            hasKey.forEach(function(k) {
                k && (keySet[k.toLowerCase()] = k);
            });
            hasKey = function(k) {
                return def.hasOwn(keySet, k);
            }
            ;
        }
        dk && (dk = dk.toLowerCase());
        return function(k) {
            k && (k = ("" + k).toLowerCase());
            if (!hasKey(k)) {
                k && pvc.debug >= 2 && pvc.warn("Invalid '" + enumName + "' value: '" + k + "'. Assuming '" + dk + "'.");
                k = dk;
            }
            return k;
        }
        ;
    }
    ;
    pvc.parseDistinctIndexArray = function(value, min, max) {
        value = def.array.as(value);
        if (null == value)
            return null;
        null == min && (min = 0);
        null == max && (max = 1 / 0);
        var a = def.query(value).select(function(index) {
            return +index;
        }).where(function(index) {
            return !isNaN(index) && index >= min && max >= index;
        }).distinct().array();
        return a.length ? a : null;
    }
    ;
    pvc.parseValuesOverflow = pvc.makeEnumParser("valuesOverflow", ["show", "trim", "hide"], "hide");
    pvc.parseMultiChartOverflow = pvc.makeEnumParser("multiChartOverflow", ["grow", "fit", "clip"], "grow");
    pvc.parseLegendClickMode = pvc.makeEnumParser("legendClickMode", ["toggleSelected", "toggleVisible", "none"], "toggleVisible");
    pvc.parseTooltipAutoContent = pvc.makeEnumParser("tooltipAutoContent", ["summary", "value"], "value");
    pvc.parseSelectionMode = pvc.makeEnumParser("selectionMode", ["rubberBand", "focusWindow"], "rubberBand");
    pvc.parseClearSelectionMode = pvc.makeEnumParser("clearSelectionMode", ["emptySpaceClick", "manual"], "emptySpaceClick");
    pvc.parseSunburstSliceOrder = pvc.makeEnumParser("sliceOrder", ["bySizeAscending", "bySizeDescending", "none"], "bySizeDescending");
    pvc.parseShape = pvc.makeEnumParser("shape", pv.Scene.hasSymbol, null);
    pvc.parseTreemapColorMode = pvc.makeEnumParser("colorMode", ["byParent", "bySelf"], "byParent");
    pvc.parseTreemapLayoutMode = pvc.makeEnumParser("layoutMode", ["squarify", "slice-and-dice", "slice", "dice"], "squarify");
    pvc.parseContinuousColorScaleType = function(scaleType) {
        if (scaleType) {
            scaleType = ("" + scaleType).toLowerCase();
            switch (scaleType) {
            case "linear":
            case "normal":
            case "discrete":
                break;

            default:
                pvc.debug >= 2 && pvc.log("[Warning] Invalid 'ScaleType' option value: '" + scaleType + "'.");
                scaleType = null;
            }
        }
        return scaleType;
    }
    ;
    pvc.parseDomainScope = function(scope, orientation) {
        if (scope) {
            scope = ("" + scope).toLowerCase();
            switch (scope) {
            case "cell":
            case "global":
                break;

            case "section":
                if (!orientation)
                    throw def.error.argumentRequired("orientation");
                scope = "y" === orientation ? "row" : "column";
                break;

            case "column":
            case "row":
                if (orientation && orientation !== ("row" === scope ? "y" : "x")) {
                    scope = "section";
                    pvc.debug >= 2 && pvc.log("[Warning] Invalid 'DomainScope' option value: '" + scope + "' for the orientation: '" + orientation + "'.");
                }
                break;

            default:
                pvc.debug >= 2 && pvc.log("[Warning] Invalid 'DomainScope' option value: '" + scope + "'.");
                scope = null;
            }
        }
        return scope;
    }
    ;
    pvc.parseDomainRoundingMode = function(mode) {
        if (mode) {
            mode = ("" + mode).toLowerCase();
            switch (mode) {
            case "none":
            case "nice":
            case "tick":
                break;

            default:
                pvc.debug >= 2 && pvc.log("[Warning] Invalid 'DomainRoundMode' value: '" + mode + "'.");
                mode = null;
            }
        }
        return mode;
    }
    ;
    pvc.parseOverlappedLabelsMode = function(mode) {
        if (mode) {
            mode = ("" + mode).toLowerCase();
            switch (mode) {
            case "leave":
            case "hide":
            case "rotatethenhide":
                break;

            default:
                pvc.debug >= 2 && pvc.log("[Warning] Invalid 'OverlappedLabelsMode' option value: '" + mode + "'.");
                mode = null;
            }
        }
        return mode;
    }
    ;
    pvc.castNumber = function(value) {
        if (null != value) {
            value = +value;
            isNaN(value) && (value = null);
        }
        return value;
    }
    ;
    pvc.castPositiveNumber = function(value) {
        value = pvc.castNumber(value);
        null == value || value > 0 || (value = null);
        return value;
    }
    ;
    pvc.castNonNegativeNumber = function(value) {
        value = pvc.castNumber(value);
        null != value && 0 > value && (value = null);
        return value;
    }
    ;
    pvc.parseWaterDirection = function(value) {
        if (value) {
            value = ("" + value).toLowerCase();
            switch (value) {
            case "up":
            case "down":
                return value;
            }
            pvc.debug >= 2 && pvc.log("[Warning] Invalid 'WaterDirection' value: '" + value + "'.");
        }
    }
    ;
    pvc.parseTrendType = function(value) {
        if (value) {
            value = ("" + value).toLowerCase();
            if ("none" === value)
                return value;
            if (pvc.trends.has(value))
                return value;
            pvc.debug >= 2 && pvc.log("[Warning] Invalid 'TrendType' value: '" + value + "'.");
        }
    }
    ;
    pvc.parseNullInterpolationMode = function(value) {
        if (value) {
            value = ("" + value).toLowerCase();
            switch (value) {
            case "none":
            case "linear":
            case "zero":
                return value;
            }
            pvc.debug >= 2 && pvc.log("[Warning] Invalid 'NullInterpolationMode' value: '" + value + "'.");
        }
    }
    ;
    pvc.parseAlign = function(side, align) {
        align && (align = ("" + align).toLowerCase());
        var align2, isInvalid;
        if ("left" === side || "right" === side) {
            align2 = align && pvc.BasePanel.verticalAlign[align];
            if (!align2) {
                align2 = "middle";
                isInvalid = !!align;
            }
        } else {
            align2 = align && pvc.BasePanel.horizontalAlign[align];
            if (!align2) {
                align2 = "center";
                isInvalid = !!align;
            }
        }
        isInvalid && pvc.debug >= 2 && pvc.log(def.format("Invalid alignment value '{0}'. Assuming '{1}'.", [align, align2]));
        return align2;
    }
    ;
    pvc.parseAnchor = function(anchor) {
        if (anchor) {
            anchor = ("" + anchor).toLowerCase();
            switch (anchor) {
            case "top":
            case "left":
            case "center":
            case "bottom":
            case "right":
                return anchor;
            }
            pvc.debug >= 2 && pvc.log(def.format("Invalid anchor value '{0}'.", [anchor]));
        }
    }
    ;
    pvc.parseAnchorWedge = function(anchor) {
        if (anchor) {
            anchor = ("" + anchor).toLowerCase();
            switch (anchor) {
            case "outer":
            case "inner":
            case "center":
            case "start":
            case "end":
                return anchor;
            }
            pvc.debug >= 2 && pvc.log(def.format("Invalid wedge anchor value '{0}'.", [anchor]));
        }
    }
    ;
    pvc.unionExtents = function(result, range) {
        if (result) {
            if (range) {
                range.min < result.min && (result.min = range.min);
                range.max > result.max && (result.max = range.max);
            }
        } else {
            if (!range)
                return null;
            result = {
                min: range.min,
                max: range.max
            };
        }
        return result;
    }
    ;
    var pvc_Sides = pvc.Sides = function(sides) {
        null != sides && this.setSides(sides);
    }
    ;
    pvc_Sides.hnames = "left right".split(" ");
    pvc_Sides.vnames = "top bottom".split(" ");
    pvc_Sides.names = "left right top bottom".split(" ");
    pvc_Sides.namesSet = pv.dict(pvc_Sides.names, def.retTrue);
    pvc.parsePosition = function(side, defaultSide) {
        if (side) {
            side = ("" + side).toLowerCase();
            if (!def.hasOwn(pvc_Sides.namesSet, side)) {
                var newSide = defaultSide || "left";
                pvc.debug >= 2 && pvc.log(def.format("Invalid position value '{0}. Assuming '{1}'.", [side, newSide]));
                side = newSide;
            }
        }
        return side || defaultSide || "left";
    }
    ;
    pvc_Sides.as = function(v) {
        null == v || v instanceof pvc_Sides || (v = new pvc_Sides().setSides(v));
        return v;
    }
    ;
    pvc_Sides.to = function(v) {
        null != v && v instanceof pvc_Sides || (v = new pvc_Sides().setSides(v));
        return v;
    }
    ;
    pvc_Sides.prototype.stringify = function(out, remLevels, keyArgs) {
        return pvc.stringifyRecursive(out, def.copyOwn(this), remLevels, keyArgs);
    }
    ;
    pvc_Sides.prototype.setSides = function(sides) {
        if ("string" == typeof sides) {
            var comps = sides.split(/\s+/).map(function(comp) {
                return pvc_PercentValue.parse(comp);
            });
            switch (comps.length) {
            case 1:
                this.set("all", comps[0]);
                return this;

            case 2:
                this.set("top", comps[0]);
                this.set("left", comps[1]);
                this.set("right", comps[1]);
                this.set("bottom", comps[0]);
                return this;

            case 3:
                this.set("top", comps[0]);
                this.set("left", comps[1]);
                this.set("right", comps[1]);
                this.set("bottom", comps[2]);
                return this;

            case 4:
                this.set("top", comps[0]);
                this.set("right", comps[1]);
                this.set("bottom", comps[2]);
                this.set("left", comps[3]);
                return this;

            case 0:
                return this;
            }
        } else {
            if ("number" == typeof sides) {
                this.set("all", sides);
                return this;
            }
            if ("object" == typeof sides) {
                if (sides instanceof pvc_PercentValue)
                    this.set("all", sides);
                else {
                    this.set("all", sides.all);
                    this.set("width", sides.width);
                    this.set("height", sides.height);
                    for (var p in sides)
                        pvc_Sides.namesSet.hasOwnProperty(p) && this.set(p, sides[p]);
                }
                return this;
            }
        }
        pvc.debug && pvc.log("Invalid 'sides' value: " + pvc.stringify(sides));
        return this;
    }
    ;
    pvc_Sides.prototype.set = function(prop, value) {
        value = pvc_PercentValue.parse(value);
        if (null != value)
            switch (prop) {
            case "all":
                pvc_Sides.names.forEach(function(p) {
                    this[p] = value;
                }, this);
                break;

            case "width":
                this.left = this.right = pvc_PercentValue.divide(value, 2);
                break;

            case "height":
                this.top = this.bottom = pvc_PercentValue.divide(value, 2);
                break;

            default:
                def.hasOwn(pvc_Sides.namesSet, prop) && (this[prop] = value);
            }
    }
    ;
    pvc_Sides.prototype.resolve = function(width, height) {
        if ("object" == typeof width) {
            height = width.height;
            width = width.width;
        }
        var sides = {};
        pvc_Sides.names.forEach(function(side) {
            var value = 0
              , sideValue = this[side];
            null != sideValue && (value = "number" == typeof sideValue ? sideValue : sideValue.resolve("left" === side || "right" === side ? width : height));
            sides[side] = value;
        }, this);
        return pvc_Sides.updateSize(sides);
    }
    ;
    pvc_Sides.updateSize = function(sides) {
        sides.width = (sides.left || 0) + (sides.right || 0);
        sides.height = (sides.bottom || 0) + (sides.top || 0);
        return sides;
    }
    ;
    pvc_Sides.resolvedMax = function(a, b) {
        var sides = {};
        pvc_Sides.names.forEach(function(side) {
            sides[side] = Math.max(a[side] || 0, b[side] || 0);
        });
        return sides;
    }
    ;
    pvc_Sides.inflate = function(sides, by) {
        var sidesOut = {};
        pvc_Sides.names.forEach(function(side) {
            sidesOut[side] = (sides[side] || 0) + by;
        });
        return pvc_Sides.updateSize(sidesOut);
    }
    ;
    var pvc_PercentValue = pvc.PercentValue = function(pct) {
        this.percent = pct;
    }
    ;
    pvc_PercentValue.prototype.resolve = function(total) {
        return this.percent * total;
    }
    ;
    pvc_PercentValue.prototype.divide = function(divisor) {
        return new pvc_PercentValue(this.percent / divisor);
    }
    ;
    pvc_PercentValue.divide = function(value, divisor) {
        return value instanceof pvc_PercentValue ? value.divide(divisor) : value / divisor;
    }
    ;
    pvc_PercentValue.parse = function(value) {
        if (null != value && "" !== value) {
            switch (typeof value) {
            case "number":
                return value;

            case "string":
                var match = value.match(/^(.+?)\s*(%)?$/);
                if (match) {
                    var n = +match[1];
                    if (!isNaN(n)) {
                        if (!match[2])
                            return n;
                        if (n >= 0)
                            return new pvc_PercentValue(n / 100);
                    }
                }
                break;

            case "object":
                if (value instanceof pvc_PercentValue)
                    return value;
            }
            pvc.debug && pvc.log(def.format("Invalid margins component '{0}'", ["" + value]));
        }
    }
    ;
    pvc_PercentValue.resolve = function(value, total) {
        return value instanceof pvc_PercentValue ? value.resolve(total) : value;
    }
    ;
    var pvc_markZOrder = pv_Mark.prototype.zOrder;
    pv_Mark.prototype.zOrder = function(zOrder) {
        var borderPanel = this.borderPanel;
        return borderPanel && borderPanel !== this ? pvc_markZOrder.call(borderPanel, zOrder) : pvc_markZOrder.call(this, zOrder);
    }
    ;
    pv_Mark.prototype.wrapper = function(wrapper) {
        this._wrapper = wrapper;
        return this;
    }
    ;
    pv_Mark.prototype.wrap = function(f, m) {
        if (f && def.fun.is(f) && this._wrapper && !f._cccWrapped) {
            f = this._wrapper(f, m);
            f._cccWrapped = !0;
        }
        return f;
    }
    ;
    pv.Mark.prototype.call = function(f) {
        f.call(this, this);
    }
    ;
    pv_Mark.prototype.lock = function(prop, value) {
        void 0 !== value && this[prop](value);
        (this._locked || (this._locked = {}))[prop] = !0;
        return this;
    }
    ;
    pv_Mark.prototype.isIntercepted = function(prop) {
        return this._intercepted && this._intercepted[prop];
    }
    ;
    pv_Mark.prototype.isLocked = function(prop) {
        return this._locked && this._locked[prop];
    }
    ;
    pv_Mark.prototype.ensureEvents = function(defEvs) {
        var events = this.propertyValue("events", !0);
        events && "none" !== events || this.events(defEvs || "all");
        return this;
    }
    ;
    pv_Mark.prototype.addMargin = function(name, margin) {
        if (0 !== margin) {
            var staticValue = def.nullyTo(this.propertyValue(name), 0)
              , fMeasure = pv.functor(staticValue);
            this[name](function() {
                return margin + fMeasure.apply(this, pvc_arraySlice.call(arguments));
            });
        }
        return this;
    }
    ;
    pv_Mark.prototype.addMargins = function(margins) {
        var all = def.get(margins, "all", 0);
        this.addMargin("left", def.get(margins, "left", all));
        this.addMargin("right", def.get(margins, "right", all));
        this.addMargin("top", def.get(margins, "top", all));
        this.addMargin("bottom", def.get(margins, "bottom", all));
        return this;
    }
    ;
    pv_Mark.prototype.eachInstanceWithData = function(fun, ctx) {
        this.eachInstance(function(scenes, index, t) {
            scenes.mark.sign && scenes[index].data && fun.call(ctx, scenes, index, t);
        });
    }
    ;
    pv_Mark.prototype.eachSceneWithDataOnRect = function(rect, fun, ctx, selectionMode) {
        function processShape(shape, instance) {
            if (shape.intersectsRect(rect)) {
                var cccScene = instance.data;
                cccScene && cccScene.datum && fun.call(ctx, cccScene);
            }
        }
        var me = this
          , sign = me.sign;
        if (!sign || sign.selectable()) {
            null == selectionMode && (selectionMode = me.rubberBandSelectionMode || "partial");
            var useCenter = "center" === selectionMode;
            me.eachInstanceWithData(function(scenes, index, toScreen) {
                var shape = me.getShape(scenes, index, .15);
                shape = (useCenter ? shape.center() : shape).apply(toScreen);
                processShape(shape, scenes[index], index);
            });
        }
    }
    ;
    pv_Mark.prototype.eachDatumOnRect = function(rect, fun, ctx, selectionMode) {
        function processShape(shape, instance) {
            if (shape.intersectsRect(rect)) {
                var cccScene = instance.data;
                cccScene && cccScene.datum && cccScene.datums().each(function(datum) {
                    datum.isNull || fun.call(ctx, datum);
                });
            }
        }
        var me = this
          , sign = me.sign;
        if (!sign || sign.selectable()) {
            null == selectionMode && (selectionMode = me.rubberBandSelectionMode || "partial");
            var useCenter = "center" === selectionMode;
            me.eachInstanceWithData(function(scenes, index, toScreen) {
                var shape = me.getShape(scenes, index, .15);
                shape = (useCenter ? shape.center() : shape).apply(toScreen);
                processShape(shape, scenes[index], index);
            });
        }
    }
    ;
    pv.Transform.prototype.transformHPosition = function(left) {
        return this.x + this.k * left;
    }
    ;
    pv.Transform.prototype.transformVPosition = function(top) {
        return this.y + this.k * top;
    }
    ;
    pv.Transform.prototype.transformLength = function(length) {
        return this.k * length;
    }
    ;
    var pvc_Size = def.type("pvc.Size").init(function(width, height) {
        if (1 === arguments.length)
            null != width && this.setSize(width);
        else {
            null != width && (this.width = width);
            null != height && (this.height = height);
        }
    }).add({
        stringify: function(out, remLevels, keyArgs) {
            return pvc.stringifyRecursive(out, def.copyOwn(this), remLevels, keyArgs);
        },
        setSize: function(size, keyArgs) {
            if ("string" == typeof size) {
                var comps = size.split(/\s+/).map(function(comp) {
                    return pvc_PercentValue.parse(comp);
                });
                switch (comps.length) {
                case 1:
                    this.set(def.get(keyArgs, "singleProp", "all"), comps[0]);
                    return this;

                case 2:
                    this.set("width", comps[0]);
                    this.set("height", comps[1]);
                    return this;
                case 0:
                    return this;
                }
            } else {
                if ("number" == typeof size) {
                    this.set(def.get(keyArgs, "singleProp", "all"), size);
                    return this;
                }
                if ("object" == typeof size) {
                    if (size instanceof pvc_PercentValue)
                        this.set(def.get(keyArgs, "singleProp", "all"), size);
                    else {
                        this.set("all", size.all);
                        for (var p in size)
                            "all" !== p && this.set(p, size[p]);
                    }
                    return this;
                }
            }
            pvc.debug && pvc.log("Invalid 'size' value: " + pvc.stringify(size));
            return this;
        },
        set: function(prop, value) {
            if (null != value && ("all" === prop || def.hasOwn(pvc_Size.namesSet, prop))) {
                value = pvc_PercentValue.parse(value);
                null != value && ("all" === prop ? pvc_Size.names.forEach(function(p) {
                    this[p] = value;
                }, this) : this[prop] = value);
            }
            return this;
        },
        clone: function() {
            return new pvc_Size(this.width,this.height);
        },
        intersect: function(size) {
            return new pvc_Size(Math.min(this.width, size.width),Math.min(this.height, size.height));
        },
        resolve: function(refSize) {
            var size = {};
            pvc_Size.names.forEach(function(length) {
                var lengthValue = this[length];
                if (null != lengthValue)
                    if ("number" == typeof lengthValue)
                        size[length] = lengthValue;
                    else if (refSize) {
                        var refLength = refSize[length];
                        null != refLength && (size[length] = lengthValue.resolve(refLength));
                    }
            }, this);
            return size;
        }
    });
    pvc_Size.names = ["width", "height"];
    pvc_Size.namesSet = pv.dict(pvc_Size.names, def.retTrue);
    pvc_Size.toOrtho = function(value, anchor) {
        if (null != value) {
            var a_ol;
            anchor && (a_ol = pvc.BasePanel.orthogonalLength[anchor]);
            value = pvc_Size.to(value, {
                singleProp: a_ol
            });
            anchor && delete value[pvc.BasePanel.oppositeLength[a_ol]];
        }
        return value;
    }
    ;
    pvc_Size.to = function(v, keyArgs) {
        null == v || v instanceof pvc_Size || (v = new pvc_Size().setSize(v, keyArgs));
        return v;
    }
    ;
    var pvc_Offset = def.type("pvc.Offset").init(function(x, y) {
        if (1 === arguments.length)
            null != x && this.setOffset(x);
        else {
            null != x && (this.x = x);
            null != y && (this.y = y);
        }
    }).add({
        stringify: function(out, remLevels, keyArgs) {
            return pvc.stringifyRecursive(out, def.copyOwn(this), remLevels, keyArgs);
        },
        setOffset: function(offset, keyArgs) {
            if ("string" == typeof offset) {
                var comps = offset.split(/\s+/).map(function(comp) {
                    return pvc_PercentValue.parse(comp);
                });
                switch (comps.length) {
                case 1:
                    this.set(def.get(keyArgs, "singleProp", "all"), comps[0]);
                    return this;

                case 2:
                    this.set("x", comps[0]);
                    this.set("y", comps[1]);
                    return this;

                case 0:
                    return this;
                }
            } else {
                if ("number" == typeof offset) {
                    this.set(def.get(keyArgs, "singleProp", "all"), offset);
                    return this;
                }
                if ("object" == typeof offset) {
                    this.set("all", offset.all);
                    for (var p in offset)
                        "all" !== p && this.set(p, offset[p]);
                    return this;
                }
            }
            pvc.debug && pvc.log("Invalid 'offset' value: " + pvc.stringify(offset));
            return this;
        },
        set: function(prop, value) {
            if (null != value && def.hasOwn(pvc_Offset.namesSet, prop)) {
                value = pvc_PercentValue.parse(value);
                null != value && ("all" === prop ? pvc_Offset.names.forEach(function(p) {
                    this[p] = value;
                }, this) : this[prop] = value);
            }
        },
        resolve: function(refSize) {
            var offset = {};
            pvc_Size.names.forEach(function(length) {
                var offsetProp = pvc_Offset.namesSizeToOffset[length]
                  , offsetValue = this[offsetProp];
                if (null != offsetValue)
                    if ("number" == typeof offsetValue)
                        offset[offsetProp] = offsetValue;
                    else if (refSize) {
                        var refLength = refSize[length];
                        null != refLength && (offset[offsetProp] = offsetValue.resolve(refLength));
                    }
            }, this);
            return offset;
        }
    });
    pvc_Offset.addStatic({
        names: ["x", "y"]
    }).addStatic({
        namesSet: pv.dict(pvc_Offset.names, def.retTrue),
        namesSizeToOffset: {
            width: "x",
            height: "y"
        },
        namesSidesToOffset: {
            left: "x",
            right: "x",
            top: "y",
            bottom: "y"
        },
        as: function(v) {
            null == v || v instanceof pvc_Offset || (v = new pvc_Offset().setOffset(v));
            return v;
        }
    });
    null == $.support.svg && ($.support.svg = document.implementation.hasFeature("http://www.w3.org/TR/SVG11/feature#BasicStructure", "1.1"));
    pvc.text = {
        getFitInfo: function(w, h, text, font, diagMargin) {
            if ("" === text)
                return {
                    h: !0,
                    v: !0,
                    d: !0
                };
            var len = pv.Text.measureWidth(text, font);
            return {
                h: w >= len,
                v: h >= len,
                d: len <= Math.sqrt(w * w + h * h) - diagMargin
            };
        },
        trimToWidthB: function(len, text, font, trimTerminator, before) {
            var terminLen = pv.Text.measureWidth(trimTerminator, font)
              , clipLen = 1.5 * terminLen;
            return pvc.text.trimToWidth(len, text, font, trimTerminator, before, clipLen);
        },
        trimToWidth: function(len, text, font, trimTerminator, before, clipLen) {
            if ("" === text)
                return text;
            var textLen = pv.Text.measureWidth(text, font);
            if (len >= textLen)
                return text;
            if (textLen > 1.5 * len)
                return pvc.text.trimToWidthBin(len, text, font, trimTerminator, before, clipLen);
            len -= pv.Text.measureWidth(trimTerminator, font);
            for (; textLen > len; ) {
                text = before ? text.slice(1) : text.slice(0, text.length - 1);
                textLen = pv.Text.measureWidth(text, font);
            }
            return clipLen && clipLen >= textLen ? "" : before ? trimTerminator + text : text + trimTerminator;
        },
        trimToWidthBin: function(len, text, font, trimTerminator, before, clipLen) {
            len -= pv.Text.measureWidth(trimTerminator, font);
            for (var mid, textLen, ilen = text.length, high = ilen - 2, low = 0; high >= low && high > 0; ) {
                mid = Math.ceil((low + high) / 2);
                var textMid = before ? text.slice(ilen - mid) : text.slice(0, mid);
                textLen = pv.Text.measureWidth(textMid, font);
                if (textLen > len)
                    high = mid - 1;
                else {
                    if (!(pv.Text.measureWidth(before ? text.slice(ilen - mid - 1) : text.slice(0, mid + 1), font) < len))
                        return clipLen && clipLen >= textLen ? "" : before ? trimTerminator + textMid : textMid + trimTerminator;
                    low = mid + 1;
                }
            }
            text = before ? text.slice(ilen - high) : text.slice(0, high);
            textLen = text.length;
            return clipLen && clipLen >= textLen ? "" : before ? trimTerminator + text : text + trimTerminator;
        },
        justify: function(text, lineWidth, font) {
            var lines = [];
            if (lineWidth < pv.Text.measureWidth("a", font))
                return lines;
            for (var words = (text || "").split(/\s+/), line = ""; words.length; ) {
                var word = words.shift();
                if (word) {
                    var nextLine = line ? line + " " + word : word;
                    if (pv.Text.measureWidth(nextLine, font) > lineWidth) {
                        line && lines.push(line);
                        line = word;
                    } else
                        line = nextLine;
                }
            }
            line && lines.push(line);
            return lines;
        },
        getLabelBBox: function(textWidth, textHeight, align, baseline, angle, margin) {
            var polygon = pv.Label.getPolygon(textWidth, textHeight, align, baseline, angle, margin)
              , bbox = polygon.bbox();
            bbox.source = polygon;
            bbox.sourceAngle = angle;
            bbox.sourceAlign = align;
            bbox.sourceTextWidth = textWidth;
            return bbox;
        }
    };
    pvc.color = {
        scale: pvc_colorScale,
        scales: pvc_colorScales,
        toGray: pvc.toGrayScale,
        isGray: pvc_colorIsGray
    };
    def.type("pvc.color.ScalesBuild").init(function(keyArgs) {
        this.keyArgs = keyArgs;
        this.data = keyArgs.data || def.fail.argumentRequired("keyArgs.data");
        this.domainDimName = keyArgs.colorDimension || def.fail.argumentRequired("keyArgs.colorDimension");
        this.domainDim = this.data.dimensions(this.domainDimName);
        var dimType = this.domainDim.type;
        if (dimType.isComparable)
            this.domainComparer = function(a, b) {
                return dimType.compare(a, b);
            }
            ;
        else {
            this.domainComparer = null;
            pvc.log("Color value dimension should be comparable. Generated color scale may be invalid.");
        }
        this.nullRangeValue = keyArgs.colorMissing ? pv.color(keyArgs.colorMissing) : pv.Color.transparent;
        this.domainRangeCountDif = 0;
    }).add({
        build: function() {
            this.range = this._getRange();
            this.desiredDomainCount = this.range.length + this.domainRangeCountDif;
            var domain = this._getDomain();
            return this._createScale(domain);
        },
        buildMap: function() {
            this.range = this._getRange();
            this.desiredDomainCount = this.range.length + this.domainRangeCountDif;
            var createCategoryScale;
            if (this.keyArgs.normPerBaseCategory)
                createCategoryScale = function(leafData) {
                    var domain = this._ensureDomain(null, !1, leafData);
                    return this._createScale(domain);
                }
                ;
            else {
                var domain = this._getDomain()
                  , scale = this._createScale(domain);
                createCategoryScale = def.fun.constant(scale);
            }
            return this._createCategoryScalesMap(createCategoryScale);
        },
        _createScale: def.method({
            isAbstract: !0
        }),
        _createCategoryScalesMap: function(createCategoryScale) {
            return this.data.children().object({
                name: function(leafData) {
                    return leafData.absKey;
                },
                value: createCategoryScale,
                context: this
            });
        },
        _getRange: function() {
            var keyArgs = this.keyArgs
              , range = keyArgs.colors || ["red", "yellow", "green"];
            null != keyArgs.colorMin && null != keyArgs.colorMax ? range = [keyArgs.colorMin, keyArgs.colorMax] : null != keyArgs.colorMin ? range.unshift(keyArgs.colorMin) : null != keyArgs.colorMax && range.push(keyArgs.colorMax);
            return range.map(function(c) {
                return pv.color(c);
            });
        },
        _getDataExtent: function(data) {
            var extent = data.dimensions(this.domainDimName).extent({
                visible: !0
            });
            if (!extent)
                return null;
            var min = extent.min.value
              , max = extent.max.value;
            max == min && (max >= 1 ? min = max - 1 : max = min + 1);
            return {
                min: min,
                max: max
            };
        },
        _getDomain: function() {
            var domain = this.keyArgs.colorDomain;
            if (null != domain) {
                domain = domain.slice();
                this.domainComparer && domain.sort(this.domainComparer);
                domain.length > this.desiredDomainCount && (domain = domain.slice(0, this.desiredDomainCount));
            } else
                domain = [];
            return this._ensureDomain(domain, !0, this.data);
        },
        _ensureDomain: function(domain, doDomainPadding, data) {
            var extent;
            if (domain && doDomainPadding) {
                var domainPointsMissing = this.desiredDomainCount - domain.length;
                if (domainPointsMissing > 0) {
                    extent = this._getDataExtent(data);
                    if (extent)
                        switch (domainPointsMissing) {
                        case 1:
                            this.domainComparer ? def.array.insert(domain, extent.max, this.domainComparer) : domain.push(extent.max);
                            break;

                        case 2:
                            if (this.domainComparer) {
                                def.array.insert(domain, extent.min, this.domainComparer);
                                def.array.insert(domain, extent.max, this.domainComparer);
                            } else {
                                domain.unshift(extent.min);
                                domain.push(extent.max);
                            }
                            break;

                        default:
                            pvc.debug >= 2 && pvc.log("Ignoring option 'colorDomain' due to unsupported length." + def.format(" Should have '{0}', but instead has '{1}'.", [this.desiredDomainCount, domain.length]));
                            domain = null;
                        }
                }
            }
            if (!domain) {
                extent || (extent = this._getDataExtent(data));
                if (extent) {
                    var min = extent.min
                      , max = extent.max
                      , step = (max - min) / (this.desiredDomainCount - 1);
                    domain = pv.range(min, max + step, step);
                }
            }
            return domain;
        }
    });
    def.type("pvc.color.LinearScalesBuild", pvc.color.ScalesBuild).add({
        _createScale: function(domain) {
            var scale = pv.Scale.linear();
            domain && scale.domain.apply(scale, domain);
            scale.range.apply(scale, this.range);
            return scale;
        }
    });
    def.type("pvc.color.DiscreteScalesBuild", pvc.color.ScalesBuild).init(function(keyArgs) {
        this.base(keyArgs);
        this.domainRangeCountDif = 1;
    }).add({
        _createScale: function(domain) {
            function scale(val) {
                if (null == val)
                    return nullRangeValue;
                for (var i = 0; Dl > i; i++)
                    if (val <= domain[i + 1])
                        return range[i];
                return range[Rl];
            }
            var Dl = domain.length - 1
              , range = this.range
              , nullRangeValue = this.nullRangeValue
              , Rl = range.length - 1;
            def.copy(scale, pv.Scale.common);
            scale.domain = function() {
                return domain;
            }
            ;
            scale.range = function() {
                return range;
            }
            ;
            return scale;
        }
    });
    //def.space("pvc.trends", function(trends) {
    //    var _trends = {};
    //    def.set(trends, "define", function(type, trendSpec) {
    //        type || def.fail.argumentRequired("type");
    //        trendSpec || def.fail.argumentRequired("trendSpec");
    //        def.object.is(trendSpec) || def.fail.argumentInvalid("trendSpec", "Must be a trend specification object.");
    //        type = ("" + type).toLowerCase();
    //        pvc.debug >= 2 && def.hasOwn(_trends, type) && pvc.log(def.format("[WARNING] A trend type with the name '{0}' is already defined.", [ type ]));
    //        var label = trendSpec.label || def.fail.argumentRequired("trendSpec.label"), model = trendSpec.model || def.fail.argumentRequired("trendSpec.model");
    //        def.fun.is(model) || def.fail.argumentInvalid("trendSpec.mode", "Must be a function.");
    //        var trendInfo = {
    //            dataPartAtom: {
    //                v: "trend",
    //                f: label
    //            },
    //            type: type,
    //            label: label,
    //            model: model
    //        };
    //        _trends[type] = trendInfo;
    //    }, "get", function(type) {
    //        type || def.fail.argumentRequired("type");
    //        return def.getOwn(_trends, type) || def.fail.operationInvalid("Undefined trend type '{0}'.", [ type ]);
    //    }, "has", function(type) {
    //        return def.hasOwn(_trends, type);
    //    }, "types", function() {
    //        return def.ownKeys(_trends);
    //    });
    //    trends.define("linear", {
    //        label: "Linear trend",
    //        model: function(options) {
    //            for (var rows = def.get(options, "rows"), funX = def.get(options, "x"), funY = def.get(options, "y"), i = 0, N = 0, sumX = 0, sumY = 0, sumXY = 0, sumXX = 0, parseNum = function(value) {
    //                return null != value ? +value : 0/0;
    //            }; rows.next(); ) {
    //                var row = rows.item, x = funX ? parseNum(funX(row)) : i;
    //                if (!isNaN(x)) {
    //                    var y = parseNum(funY(row));
    //                    if (!isNaN(y)) {
    //                        N++;
    //                        sumX += x;
    //                        sumY += y;
    //                        sumXY += x * y;
    //                        sumXX += x * x;
    //                    }
    //                }
    //                i++;
    //            }
    //            var alpha, beta;
    //            if (N >= 2) {
    //                var avgX = sumX / N, avgY = sumY / N, avgXY = sumXY / N, avgXX = sumXX / N, den = avgXX - avgX * avgX;
    //                beta = 0 === den ? 0 : (avgXY - avgX * avgY) / den;
    //                alpha = avgY - beta * avgX;
    //                return {
    //                    alpha: alpha,
    //                    beta: beta,
    //                    reset: def.noop,
    //                    sample: function(x) {
    //                        return alpha + beta * +x;
    //                    }
    //                };
    //            }
    //        }
    //    });
    //    trends.define("moving-average", {
    //        label: "Moving average",
    //        model: function(options) {
    //            var W = Math.max(+(def.get(options, "periods") || 3), 2), sum = 0, avgValues = [];
    //            return {
    //                reset: function() {
    //                    sum = 0;
    //                    avgValues.length = 0;
    //                },
    //                sample: function(x, y) {
    //                    var L = W;
    //                    if (null != y) {
    //                        avgValues.unshift(y);
    //                        sum += y;
    //                        L = avgValues.length;
    //                        if (L > W) {
    //                            sum -= avgValues.pop();
    //                            L = W;
    //                        }
    //                    }
    //                    return sum / L;
    //                }
    //            };
    //        }
    //    });
    //    trends.define("weighted-moving-average", {
    //        label: "Weighted Moving average",
    //        model: function(options) {
    //            var W = Math.max(+(def.get(options, "periods") || 3), 2), sum = 0, numer = 0, avgValues = [], L = 0, denom = 0;
    //            return {
    //                reset: function() {
    //                    sum = numer = denom = L = 0;
    //                    avgValues.length = 0;
    //                },
    //                sample: function(x, y) {
    //                    if (null != y) if (W > L) {
    //                        avgValues.push(y);
    //                        L++;
    //                        denom += L;
    //                        numer += L * y;
    //                        sum += y;
    //                    } else {
    //                        numer += L * y - sum;
    //                        sum += y - avgValues[0];
    //                        for (var j = 1; W > j; j++) avgValues[j - 1] = avgValues[j];
    //                        avgValues[W - 1] = y;
    //                    }
    //                    return numer / denom;
    //                }
    //            };
    //        }
    //    });
    //});
    pvc_options.resolvers = options_resolvers;
    pvc_options.constant = options_constantResolver;
    pvc_options.specify = options_specifyResolver;
    pvc_options.defaultValue = options_defaultResolver;
    pvc.options = pvc_options;
    var pvc_OptionInfo = def.type().init(function(name, option, context, spec) {
        this.name = name;
        this.option = option;
        this._dv = this.value = def.get(spec, "value");
        this._resolve = def.get(spec, "resolve");
        var resolved = !this._resolve;
        this.isResolved = resolved;
        this.isSpecified = !1;
        this._setCalled = !1;
        this._context = context;
        this._cast = def.get(spec, "cast");
        this._getDefault = resolved ? null : def.get(spec, "getDefault");
        this.data = def.get(spec, "data");
    }).add({
        resolve: function() {
            if (!this.isResolved) {
                this.isResolved = !0;
                this._setCalled = !1;
                this._getFunProp("_resolve").call(this._context, this);
                if (!this._setCalled) {
                    this.isSpecified = !1;
                    var value = this._dynDefault();
                    null != value && (this.value = this._dv = value);
                }
            }
            return this;
        },
        specify: function(value) {
            return this.set(value, !1);
        },
        defaultValue: function(defaultValue) {
            arguments.length && this.set(defaultValue, !0);
            return this._dv;
        },
        cast: function(value) {
            if (null != value) {
                var cast = this._getFunProp("_cast");
                cast && (value = cast.call(this._context, value, this));
            }
            return value;
        },
        set: function(value, isDefault) {
            this._setCalled = !0;
            null != value && (value = this.cast(value));
            if (null == value) {
                value = this._dynDefault();
                if (null == value) {
                    if (!this.isSpecified)
                        return this;
                    value = this._dv;
                }
                isDefault = !0;
            }
            if (isDefault) {
                this._dv = value;
                this.isSpecified || (this.value = value);
            } else {
                this.isResolved = this.isSpecified = !0;
                this.value = value;
            }
            return this;
        },
        _dynDefault: function() {
            var get = this._getFunProp("_getDefault");
            return get && this.cast(get.call(this._context, this));
        },
        _getFunProp: function(name) {
            var fun = this[name];
            if (fun) {
                var context = this._context;
                context && "string" == typeof fun && (fun = context[fun]);
            }
            return fun;
        }
    });
    def.global.NoDataException = function() {}
    ;
    def.global.InvalidDataException = function(msg) {
        this.message = msg ? msg : "Invalid Data.";
    }
    ;
    pvc.data = {
        visibleKeyArgs: {
            visible: !0
        }
    };
    def.type("pvc.data.DimensionType").init(function(complexType, name, keyArgs) {
        this.complexType = complexType;
        this.name = name;
        this.label = def.get(keyArgs, "label") || pvc.buildTitleFromName(name);
        var groupAndLevel = pvc.splitIndexedId(name);
        this.group = groupAndLevel[0];
        this.groupLevel = def.nullyTo(groupAndLevel[1], 0);
        this.label.indexOf("{") >= 0 && (this.label = def.format(this.label, [this.groupLevel + 1]));
        this.playedVisualRoles = new def.Map();
        this.isHidden = !!def.get(keyArgs, "isHidden");
        var valueType = def.get(keyArgs, "valueType") || null
          , valueTypeName = pvc.data.DimensionType.valueTypeName(valueType)
          , cast = def.getOwn(pvc.data.DimensionType.cast, valueTypeName, null);
        this.valueType = valueType;
        this.valueTypeName = valueTypeName;
        this.cast = cast;
        this.isDiscreteValueType = this.valueType !== Number && this.valueType !== Date;
        this.isDiscrete = def.get(keyArgs, "isDiscrete");
        if (null == this.isDiscrete)
            this.isDiscrete = this.isDiscreteValueType;
        else {
            this.isDiscrete = !!this.isDiscrete;
            if (!this.isDiscrete && this.isDiscreteValueType)
                throw def.error.argumentInvalid("isDiscrete", "The only supported continuous value types are Number and Date.");
        }
        this._converter = def.get(keyArgs, "converter") || null;
        if (!this._converter) {
            var rawFormat = def.get(keyArgs, "rawFormat");
            if (rawFormat)
                switch (this.valueType) {
                case Date:
                    this._converter = pv.Format.createParser(pv.Format.date(rawFormat));
                }
        }
        this._key = def.get(keyArgs, "key") || null;
        this._comparer = def.get(keyArgs, "comparer");
        if (void 0 === this._comparer)
            switch (this.valueType) {
            case Number:
            case Date:
                this._comparer = def.compare;
                break;

            default:
                this._comparer = null;
            }
        this.isComparable = null != this._comparer;
        this._formatter = def.get(keyArgs, "formatter") || null;
        if (!this._formatter)
            switch (this.valueType) {
            case Number:
                this._formatter = pv.Format.createFormatter(pv.Format.number().fractionDigits(0, 2));
                break;

            case Date:
                var format = def.get(keyArgs, "format");
                if (!format) {
                    format = def.get(keyArgs, "rawFormat");
                    format && (format = format.replace(/-/g, "/"));
                }
                format || (format = "%Y/%m/%d");
                this._formatter = pv.Format.createFormatter(pv.Format.date(format));
            }
    }).add({
        isCalculated: !1,
        compare: function(a, b) {
            return null == a ? null == b ? 0 : -1 : null == b ? 1 : this._comparer.call(null, a, b);
        },
        comparer: function(reverse) {
            if (!this.isComparable)
                return null;
            var me = this;
            return reverse ? this._reverseComparer || (this._reverseComparer = function(a, b) {
                return me.compare(b, a);
            }
            ) : this._directComparer || (this._directComparer = function(a, b) {
                return me.compare(a, b);
            }
            );
        },
        atomComparer: function(reverse) {
            return reverse ? this._reverseAtomComparer || (this._reverseAtomComparer = this._createReverseAtomComparer()) : this._directAtomComparer || (this._directAtomComparer = this._createDirectAtomComparer());
        },
        _toDiscrete: function() {
            this.isDiscrete = !0;
        },
        _toCalculated: function() {
            this.isCalculated = !0;
        },
        _createReverseAtomComparer: function() {
            function reverseAtomComparer(a, b) {
                return a === b ? 0 : me.compare(b.value, a.value);
            }
            if (!this.isComparable)
                return atom_idComparerReverse;
            var me = this;
            return reverseAtomComparer;
        },
        _createDirectAtomComparer: function() {
            function directAtomComparer(a, b) {
                return a === b ? 0 : me.compare(a.value, b.value);
            }
            if (!this.isComparable)
                return atom_idComparer;
            var me = this;
            return directAtomComparer;
        },
        formatter: function() {
            return this._formatter;
        },
        converter: function() {
            return this._converter;
        },
        playingPercentVisualRole: function() {
            return def.query(this.playedVisualRoles.values()).any(function(visualRole) {
                return visualRole.isPercent;
            });
        }
    });
    pvc.data.DimensionType.cast = {
        Date: function(value) {
            return value instanceof Date ? value : new Date(value);
        },
        Number: function(value) {
            value = Number(value);
            return isNaN(value) ? null : value;
        },
        String: String,
        Boolean: Boolean,
        Object: Object,
        Any: null
    };
    pvc.data.DimensionType.dimensionGroupName = function(dimName) {
        return dimName.replace(/^(.*?)(\d*)$/, "$1");
    }
    ;
    pvc.data.DimensionType.valueTypeName = function(valueType) {
        if (null == valueType)
            return "Any";
        switch (valueType) {
        case Boolean:
            return "Boolean";

        case Number:
            return "Number";

        case String:
            return "String";

        case Object:
            return "Object";

        case Date:
            return "Date";

        default:
            throw def.error.argumentInvalid("valueType", "Invalid valueType function: '{0}'.", [valueType]);
        }
    }
    ;
    pvc.data.DimensionType.extendSpec = function(dimName, dimSpec, keyArgs) {
        var dimGroup = pvc.data.DimensionType.dimensionGroupName(dimName)
          , userDimGroupsSpec = def.get(keyArgs, "dimensionGroups");
        if (userDimGroupsSpec) {
            var groupDimSpec = userDimGroupsSpec[dimGroup];
            groupDimSpec && (dimSpec = def.create(groupDimSpec, dimSpec));
        }
        dimSpec || (dimSpec = {});
        switch (dimGroup) {
        case "category":
            var isCategoryTimeSeries = def.get(keyArgs, "isCategoryTimeSeries", !1);
            isCategoryTimeSeries && void 0 === dimSpec.valueType && (dimSpec.valueType = Date);
            break;

        case "value":
            void 0 === dimSpec.valueType && (dimSpec.valueType = Number);
            dimSpec.valueType === Number && (void 0 !== dimSpec.formatter || dimSpec.format || (dimSpec.formatter = def.get(keyArgs, "valueNumberFormatter")));
        }
        void 0 !== dimSpec.converter || dimSpec.valueType !== Date || dimSpec.rawFormat || (dimSpec.rawFormat = def.get(keyArgs, "timeSeriesFormat"));
        return dimSpec;
    }
    ;
    def.type("pvc.data.ComplexType").init(function(dimTypeSpecs) {
        this._dims = {};
        this._dimsList = [];
        this._dimsNames = [];
        this._calculations = [];
        this._calculatedDimNames = {};
        this._dimsIndexByName = null;
        this._dimsByGroup = {};
        this._dimsNamesByGroup = {};
        if (dimTypeSpecs)
            for (var name in dimTypeSpecs)
                this.addDimension(name, dimTypeSpecs[name]);
    }).add({
        describe: function() {
            var out = ["COMPLEX TYPE INFORMATION", pvc.logSeparator];
            this._dimsList.forEach(function(type) {
                var features = [];
                features.push(type.valueTypeName);
                type.isComparable && features.push("comparable");
                type.isDiscrete || features.push("continuous");
                type.isHidden && features.push("hidden");
                out.push("  " + type.name + " (" + features.join(", ") + ")");
            });
            return out.join("\n");
        },
        dimensions: function(name, keyArgs) {
            if (null == name)
                return this._dims;
            var dimType = def.getOwn(this._dims, name, null);
            if (!dimType && def.get(keyArgs, "assertExists", !0))
                throw def.error.argumentInvalid("name", "Undefined dimension '{0}'", [name]);
            return dimType;
        },
        dimensionsList: function() {
            return this._dimsList;
        },
        calculatedDimensionsList: function() {
            return this._calcDimsList;
        },
        dimensionsNames: function() {
            return this._dimsNames;
        },
        groupDimensions: function(group, keyArgs) {
            var dims = def.getOwn(this._dimsByGroup, group);
            if (!dims && def.get(keyArgs, "assertExists", !0))
                throw def.error.operationInvalid("There is no dimension type group with name '{0}'.", [group]);
            return dims;
        },
        groupDimensionsNames: function(group, keyArgs) {
            var dimNames = def.getOwn(this._dimsNamesByGroup, group);
            if (!dimNames && def.get(keyArgs, "assertExists", !0))
                throw def.error.operationInvalid("There is no dimension type group with name '{0}'.", [group]);
            return dimNames;
        },
        addDimension: function(name, dimTypeSpec) {
            name || def.fail.argumentRequired("name");
            !def.hasOwn(this._dims, name) || def.fail.operationInvalid("A dimension type with name '{0}' is already defined.", [name]);
            var dimension = new pvc.data.DimensionType(this,name,dimTypeSpec);
            this._dims[name] = dimension;
            this._dimsIndexByName = null;
            var groupLevel, group = dimension.group;
            if (group) {
                var groupDimsNames, groupDims = def.getOwn(this._dimsByGroup, group);
                if (groupDims)
                    groupDimsNames = this._dimsNamesByGroup[group];
                else {
                    groupDims = this._dimsByGroup[group] = [];
                    groupDimsNames = this._dimsNamesByGroup[group] = [];
                }
                groupLevel = def.array.insert(groupDimsNames, name, def.compare);
                groupLevel = ~groupLevel;
                def.array.insertAt(groupDims, groupLevel, dimension);
            }
            var index, L = this._dimsList.length;
            if (group) {
                groupLevel = dimension.groupLevel;
                for (var i = 0; L > i; i++) {
                    var dim = this._dimsList[i];
                    if (dim.group === group) {
                        if (dim.groupLevel > groupLevel) {
                            index = i;
                            break;
                        }
                        index = i + 1;
                    }
                }
                null == index && (index = L);
            } else
                index = L;
            def.array.insertAt(this._dimsList, index, dimension);
            def.array.insertAt(this._dimsNames, index, name);
            if (dimension._calculate) {
                index = def.array.binarySearch(this._calcDimsList, dimension._calculationOrder, def.compare, function(dimType) {
                    return dimType._calculationOrder;
                });
                index >= 0 ? index++ : index = ~index;
                def.array.insertAt(this._calcDimsList, index, dimension);
            }
            this._isPctRoleDimTypeMap = null;
            return dimension;
        },
        addCalculation: function(calcSpec, dimsOptions) {
            calcSpec || def.fail.argumentRequired("calcSpec");
            var calculation = calcSpec.calculation || def.fail.argumentRequired("calculations[i].calculation")
              , dimNames = calcSpec.names;
            dimNames = "string" == typeof dimNames ? dimNames.split(/\s*\,\s*/) : def.array.as(dimNames);
            if (dimNames && dimNames.length) {
                var calcDimNames = this._calculatedDimNames;
                dimNames.forEach(function(name) {
                    if (name) {
                        name = name.replace(/^\s*(.+?)\s*$/, "$1");
                        !def.hasOwn(calcDimNames, name) || def.fail.argumentInvalid("calculations[i].names", "Dimension name '{0}' is already being calculated.", [name]);
                        var dimType = this._dims[name];
                        if (!dimType) {
                            var dimSpec = pvc.data.DimensionType.extendSpec(name, null, dimsOptions);
                            this.addDimension(name, dimSpec);
                        }
                        calcDimNames[name] = !0;
                        dimType._toCalculated();
                    }
                }, this);
            }
            this._calculations.push(calculation);
        },
        isCalculated: function(dimName) {
            return def.hasOwn(this._calculatedDimNames, dimName);
        },
        _calculate: function(complex) {
            var calcs = this._calculations
              , L = calcs.length;
            if (L) {
                for (var valuesByName = {}, i = 0; L > i; i++) {
                    var calc = calcs[i];
                    calc(complex, valuesByName);
                }
                return valuesByName;
            }
        },
        getPlayingPercentVisualRoleDimensionMap: function() {
            var map = this._isPctRoleDimTypeMap;
            map || (map = this._isPctRoleDimTypeMap = new def.Map(def.query(def.own(this._dims)).where(function(dimType) {
                return dimType.playingPercentVisualRole();
            }).object({
                name: function(dimType) {
                    return dimType.name;
                }
            })));
            return map;
        },
        sortDimensionNames: function(dims, nameKey) {
            var dimsIndexByName = this._dimsIndexByName;
            if (!dimsIndexByName) {
                dimsIndexByName = def.query(this._dimsList).object({
                    name: function(dim) {
                        return dim.name;
                    },
                    value: function(dim, index) {
                        return index;
                    }
                });
                this._dimsIndexByName = dimsIndexByName;
            }
            dims.sort(function(da, db) {
                return def.compare(dimsIndexByName[nameKey ? nameKey(da) : da], dimsIndexByName[nameKey ? nameKey(db) : db]);
            });
            return dims;
        }
    });
    def.type("pvc.data.ComplexTypeProject").init(function(dimGroupSpecs) {
        this._dims = {};
        this._dimList = [];
        this._dimGroupsDims = {};
        this._dimGroupSpecs = dimGroupSpecs || {};
        this._calcList = [];
    }).add({
        _ensureDim: function(name, spec) {
            name || def.fail.argumentInvalid("name", "Invalid dimension name '{0}'.", [name]);
            var info = def.getOwn(this._dims, name);
            if (info)
                spec && def.setUDefaults(info.spec, spec);
            else {
                info = this._dims[name] = this._createDim(name, spec);
                this._dimList.push(info);
                var groupDimsNames = def.array.lazy(this._dimGroupsDims, info.groupName);
                def.array.insert(groupDimsNames, name, def.compare);
            }
            return info;
        },
        hasDim: function(name) {
            return def.hasOwn(this._dims, name);
        },
        setDim: function(name, spec) {
            var _ = this._ensureDim(name).spec;
            spec && def.copy(_, spec);
            return this;
        },
        setDimDefaults: function(name, spec) {
            def.setUDefaults(this._ensureDim(name).spec, spec);
            return this;
        },
        _createDim: function(name, spec) {
            var dimGroupName = pvc.data.DimensionType.dimensionGroupName(name)
              , dimGroupSpec = this._dimGroupSpecs[dimGroupName];
            dimGroupSpec && (spec = def.create(dimGroupSpec, spec));
            return {
                name: name,
                groupName: dimGroupName,
                spec: spec || {}
            };
        },
        readDim: function(name, spec) {
            var info = this._ensureDim(name, spec);
            if (info.isRead)
                throw def.error.operationInvalid("Dimension '{0}' already is the target of a reader.", [name]);
            if (info.isCalc)
                throw def.error.operationInvalid("Dimension '{0}' is being calculated, so it cannot be the target of a reader.", [name]);
            info.isRead = !0;
        },
        calcDim: function(name, spec) {
            var info = this._ensureDim(name, spec);
            if (info.isCalc)
                throw def.error.operationInvalid("Dimension '{0}' already is being calculated.", [name]);
            if (info.isRead)
                throw def.error.operationInvalid("Dimension '{0}' is the target of a reader, so it cannot be calculated.", [name]);
            info.isCalc = !0;
        },
        isReadOrCalc: function(name) {
            if (name) {
                var info = def.getOwn(this._dims, name);
                if (info)
                    return info.isRead || info.isCalc;
            }
            return !1;
        },
        groupDimensionsNames: function(groupDimName) {
            return this._dimGroupsDims[groupDimName];
        },
        setCalc: function(calcSpec) {
            calcSpec || def.fail.argumentRequired("calculations[i]");
            calcSpec.calculation || def.fail.argumentRequired("calculations[i].calculation");
            var dimNames = calcSpec.names;
            dimNames = "string" == typeof dimNames ? dimNames.split(/\s*\,\s*/) : def.array.as(dimNames);
            dimNames && dimNames.length && dimNames.forEach(this.calcDim, this);
            this._calcList.push(calcSpec);
        },
        configureComplexType: function(complexType, translOptions) {
            this._dimList.forEach(function(dimInfo) {
                var dimName = dimInfo.name
                  , spec = dimInfo.spec;
                spec = pvc.data.DimensionType.extendSpec(dimName, spec, translOptions);
                complexType.addDimension(dimName, spec);
            });
            this._calcList.forEach(function(calcSpec) {
                complexType.addCalculation(calcSpec);
            });
        }
    });
    def.type("pvc.data.TranslationOper").init(function(chart, complexTypeProj, source, metadata, options) {
        this.chart = chart;
        this.complexTypeProj = complexTypeProj;
        this.source = source || def.fail.argumentRequired("source");
        this.metadata = metadata || def.fail.argumentRequired("metadata");
        this.options = options || {};
        this._initType();
        if (pvc.debug >= 4) {
            this._logItems = !0;
            this._logItemCount = 0;
        }
    }).add({
        _logItems: !1,
        logSource: def.method({
            isAbstract: !0
        }),
        logVItem: def.method({
            isAbstract: !0
        }),
        _translType: "Unknown",
        logTranslatorType: function() {
            return this._translType + " data source translator";
        },
        virtualItemSize: function() {
            return this.metadata.length;
        },
        freeVirtualItemSize: function() {
            return this.virtualItemSize() - this._userUsedIndexesCount;
        },
        setSource: function(source) {
            if (!source)
                throw def.error.argumentRequired("source");
            this.source = source;
        },
        defReader: function(dimReaderSpec) {
            dimReaderSpec || def.fail.argumentRequired("readerSpec");
            var dimNames;
            dimNames = def.string.is(dimReaderSpec) ? dimReaderSpec : dimReaderSpec.names;
            dimNames = def.string.is(dimNames) ? dimNames.split(/\s*\,\s*/) : def.array.as(dimNames);
            var indexes = def.array.as(dimReaderSpec.indexes);
            indexes && indexes.forEach(this._userUseIndex, this);
            var hasDims = !(!dimNames || !dimNames.length)
              , reader = dimReaderSpec.reader;
            if (reader) {
                hasDims || def.fail.argumentRequired("reader.names", "Required argument when a reader function is specified.");
                this._userRead(reader, dimNames);
            } else {
                if (hasDims)
                    return this._userCreateReaders(dimNames, indexes);
                indexes && indexes.forEach(function(index) {
                    this._userIndexesToSingleDim[index] = null;
                }, this);
            }
            return indexes;
        },
        configureType: function() {
            this._configureTypeCore();
        },
        _configureTypeCore: def.method({
            isAbstract: !0
        }),
        _initType: function() {
            this._userDimsReaders = [];
            this._userDimsReadersByDim = {};
            this._userItem = [];
            this._userUsedIndexes = {};
            this._userUsedIndexesCount = 0;
            this._userIndexesToSingleDim = [];
            var userDimReaders = this.options.readers;
            userDimReaders && userDimReaders.forEach(this.defReader, this);
            var multiChartIndexes = pvc.parseDistinctIndexArray(this.options.multiChartIndexes);
            multiChartIndexes && (this._multiChartIndexes = this.defReader({
                names: "multiChart",
                indexes: multiChartIndexes
            }));
        },
        _userUseIndex: function(index) {
            index = +index;
            if (0 > index)
                throw def.error.argumentInvalid("index", "Invalid reader index: '{0}'.", [index]);
            if (def.hasOwn(this._userUsedIndexes, index))
                throw def.error.argumentInvalid("index", "Virtual item index '{0}' is already assigned.", [index]);
            this._userUsedIndexes[index] = !0;
            this._userUsedIndexesCount++;
            this._userItem[index] = !0;
            return index;
        },
        _userCreateReaders: function(dimNames, indexes) {
            indexes ? indexes.forEach(function(index, j) {
                indexes[j] = +index;
            }) : indexes = [];
            var dimName, I = indexes.length, N = dimNames.length;
            if (N > I) {
                var nextIndex = I > 0 ? indexes[I - 1] + 1 : 0;
                do {
                    nextIndex = this._nextAvailableItemIndex(nextIndex);
                    indexes[I] = nextIndex;
                    this._userUseIndex(nextIndex);
                    I++;
                } while (N > I);
            }
            for (var index, L = I === N ? N : N - 1, n = 0; L > n; n++) {
                dimName = dimNames[n];
                index = indexes[n];
                this._userIndexesToSingleDim[index] = dimName;
                this._userRead(this._propGet(dimName, index), dimName);
            }
            if (N > L)
                for (var splitGroupName = pvc.splitIndexedId(dimNames[N - 1]), groupName = splitGroupName[0], level = def.nullyTo(splitGroupName[1], 0), i = L; I > i; i++,
                level++) {
                    dimName = pvc.buildIndexedId(groupName, level);
                    index = indexes[i];
                    this._userIndexesToSingleDim[index] = dimName;
                    this._userRead(this._propGet(dimName, index), dimName);
                }
            return indexes;
        },
        _userRead: function(reader, dimNames) {
            def.fun.is(reader) || def.fail.argumentInvalid("reader", "Reader must be a function.");
            def.array.is(dimNames) ? dimNames.forEach(function(name) {
                this._readDim(name, reader);
            }, this) : this._readDim(dimNames, reader);
            this._userDimsReaders.push(reader);
        },
        _readDim: function(name, reader) {
            var info, spec, index = this._userIndexesToSingleDim.indexOf(name);
            if (index >= 0) {
                info = this._itemInfos[index];
                if (info && !this.options.ignoreMetadataLabels) {
                    var label = info.label || info.name;
                    label && (spec = {
                        label: label
                    });
                }
            }
            this.complexTypeProj.readDim(name, spec);
            this._userDimsReadersByDim[name] = reader;
        },
        execute: function(data) {
            this.data = data;
            return this._executeCore();
        },
        _executeCore: function() {
            var dimsReaders = this._getDimensionsReaders();
            return def.query(this._getItems()).select(function(item) {
                return this._readItem(item, dimsReaders);
            }, this);
        },
        _getItems: function() {
            return this.source;
        },
        _getDimensionsReaders: function() {
            return this._userDimsReaders;
        },
        _readItem: function(item, dimsReaders) {
            var logItem = this._logItems;
            if (logItem) {
                var logItemCount = this._logItemCount;
                if (10 > logItemCount) {
                    pvc.log("virtual item [" + this._logItemCount + "]: " + pvc.stringify(item));
                    this._logItemCount++;
                } else {
                    pvc.log("...");
                    logItem = this._logItems = !1;
                }
            }
            for (var r = 0, R = dimsReaders.length, data = this.data, valuesByDimName = {}; R > r; )
                dimsReaders[r++].call(data, item, valuesByDimName);
            if (logItem) {
                var atoms = {};
                for (var dimName in valuesByDimName) {
                    var atom = valuesByDimName[dimName];
                    def.object.is(atom) && (atom = "v"in atom ? atom.v : "value"in atom ? atom.value : "...");
                    atoms[dimName] = atom;
                }
                pvc.log("-> read: " + pvc.stringify(atoms));
            }
            return valuesByDimName;
        },
        _propGet: function(dimName, prop) {
            function propGet(item, atoms) {
                atoms[dimName] = item[prop];
            }
            return propGet;
        },
        _nextAvailableItemIndex: function(index, L) {
            null == index && (index = 0);
            null == L && (L = 1 / 0);
            for (; L > index && def.hasOwn(this._userItem, index); )
                index++;
            return L > index ? index : -1;
        },
        _getUnboundRoleDefaultDimNames: function(roleName, count, dims, level) {
            var role = this.chart.visualRoles[roleName];
            if (role && !role.isPreBound()) {
                var dimGroupName = role.defaultDimensionName;
                if (dimGroupName) {
                    dimGroupName = dimGroupName.match(/^(.*?)(\*)?$/)[1];
                    dims || (dims = []);
                    null == level && (level = 0);
                    null == count && (count = 1);
                    for (; count--; ) {
                        var dimName = pvc.buildIndexedId(dimGroupName, level++);
                        this.complexTypeProj.isReadOrCalc(dimName) || dims.push(dimName);
                    }
                    return dims.length ? dims : null;
                }
            }
        },
        collectFreeDiscreteAndConstinuousIndexes: function(freeDisIndexes, freeMeaIndexes) {
            this._itemInfos.forEach(function(info, index) {
                if (!this._userUsedIndexes[index]) {
                    var indexes = 1 === info.type ? freeMeaIndexes : freeDisIndexes;
                    indexes && indexes.push(index);
                }
            }, this);
        }
    });
    def.type("pvc.data.MatrixTranslationOper", pvc.data.TranslationOper).add({
        _initType: function() {
            this.J = this.metadata.length;
            this.I = this.source.length;
            this._processMetadata();
            this.base();
        },
        setSource: function(source) {
            this.base(source);
            this.I = this.source.length;
        },
        _knownContinuousColTypes: {
            numeric: 1,
            number: 1,
            integer: 1
        },
        _processMetadata: function() {
            for (var knownContinColTypes = this._knownContinuousColTypes, columns = def.query(this.metadata).select(function(colDef, colIndex) {
                colDef.colIndex = colIndex;
                return colDef;
            }).where(function(colDef) {
                var colType = colDef.colType;
                return !colType || 1 !== knownContinColTypes[colType.toLowerCase()];
            }).select(function(colDef) {
                return colDef.colIndex;
            }).array(), columnTypes = def.array.create(this.J, 1), I = this.I, source = this.source, J = columns.length, i = 0; I > i && J > 0; i++)
                for (var row = source[i], m = 0; J > m; ) {
                    var j = columns[m]
                      , value = row[j];
                    if (null != value) {
                        columnTypes[j] = this._getSourceValueType(value);
                        columns.splice(m, 1);
                        J--;
                    } else
                        m++;
                }
            this._columnTypes = columnTypes;
        },
        _buildItemInfoFromMetadata: function(index) {
            var meta = this.metadata[index];
            return {
                type: this._columnTypes[index],
                name: meta.colName,
                label: meta.colLabel
            };
        },
        _getSourceValueType: function(value) {
            switch (typeof value) {
            case "number":
                return 1;

            case "object":
                if (value instanceof Date)
                    return 1;
            }
            return 0;
        },
        logSource: function() {
            var out = ["DATA SOURCE SUMMARY", pvc.logSeparator, "ROWS (" + Math.min(10, this.I) + "/" + this.I + ")"];
            def.query(this.source).take(10).each(function(row, index) {
                out.push("  [" + index + "] " + pvc.stringify(row));
            });
            this.I > 10 && out.push("  ...");
            out.push("COLS (" + this.J + ")");
            var colTypes = this._columnTypes;
            this.metadata.forEach(function(col, j) {
                out.push("  [" + j + "] '" + col.colName + "' (type: " + col.colType + ", inspected: " + (colTypes[j] ? "number" : "string") + (col.colLabel ? ", label: '" + col.colLabel + "'" : "") + ")");
            });
            out.push("");
            return out.join("\n");
        },
        _logVItem: function(kindList, kindScope) {
            var out = ["VIRTUAL ITEM ARRAY", pvc.logSeparator]
              , maxName = 4
              , maxLabel = 5
              , maxDim = 9;
            this._itemInfos.forEach(function(info, index) {
                maxName = Math.max(maxName, (info.name || "").length);
                maxLabel = Math.max(maxLabel, (info.label || "").length);
                var dimName = this._userIndexesToSingleDim[index];
                dimName && (maxDim = Math.max(maxDim, dimName.length));
            }, this);
            out.push("Index | Kind | Type   | " + def.string.padRight("Name", maxName) + " | " + def.string.padRight("Label", maxLabel) + " > Dimension", "------+------+--------+-" + def.string.padRight("", maxName, "-") + "-+-" + def.string.padRight("", maxLabel, "-") + "-+-" + def.string.padRight("", maxDim, "-") + "-");
            var index = 0;
            kindList.forEach(function(kind) {
                for (var i = 0, L = kindScope[kind]; L > i; i++) {
                    var info = this._itemInfos[index]
                      , dimName = this._userIndexesToSingleDim[index];
                    void 0 === dimName && (dimName = "");
                    out.push(" " + index + "    | " + kind + "    | " + (info.type ? "number" : "string") + " | " + def.string.padRight(info.name || "", maxName) + " | " + def.string.padRight(info.label || "", maxLabel) + " | " + dimName);
                    index++;
                }
            }, this);
            out.push("");
            return out.join("\n");
        },
        _createPlot2SeriesKeySet: function(plot2DataSeriesIndexes, seriesKeys) {
            var plot2SeriesKeySet = null
              , seriesCount = seriesKeys.length;
            def.query(plot2DataSeriesIndexes).each(function(indexText) {
                var seriesIndex = +indexText;
                if (isNaN(seriesIndex))
                    throw def.error.argumentInvalid("plot2DataSeriesIndexes", "Element is not a number '{0}'.", [indexText]);
                if (0 > seriesIndex) {
                    if (-seriesCount >= seriesIndex)
                        throw def.error.argumentInvalid("plot2DataSeriesIndexes", "Index is out of range '{0}'.", [seriesIndex]);
                    seriesIndex = seriesCount + seriesIndex;
                } else if (seriesIndex >= seriesCount)
                    throw def.error.argumentInvalid("plot2DataSeriesIndexes", "Index is out of range '{0}'.", [seriesIndex]);
                plot2SeriesKeySet || (plot2SeriesKeySet = {});
                plot2SeriesKeySet[seriesKeys[seriesIndex]] = !0;
            });
            return plot2SeriesKeySet;
        },
        _dataPartGet: function(calcAxis2SeriesKeySet, seriesReader) {
            function dataPartGet(item, outAtoms) {
                if (!dataPartDimension) {
                    plot2SeriesKeySet = calcAxis2SeriesKeySet();
                    dataPartDimension = me.data.dimensions(dataPartDimName);
                    pvc.debug >= 3 && plot2SeriesKeySet && pvc.log("Second axis series values: " + pvc.stringify(def.keys(plot2SeriesKeySet)));
                }
                var partAtom;
                seriesReader(item, outAtomsSeries);
                var series = outAtomsSeries.series;
                null != series && null != series.v && (series = series.v);
                partAtom = def.hasOwn(plot2SeriesKeySet, series) ? part2Atom || (part2Atom = dataPartDimension.intern("1")) : part1Atom || (part1Atom = dataPartDimension.intern("0"));
                outAtoms[dataPartDimName] = partAtom;
            }
            var dataPartDimension, plot2SeriesKeySet, part1Atom, part2Atom, me = this, dataPartDimName = this.options.dataPartDimName, outAtomsSeries = {};
            return dataPartGet;
        }
    });
    def.type("pvc.data.CrosstabTranslationOper", pvc.data.MatrixTranslationOper).add({
        _translType: "Crosstab",
        virtualItemSize: function() {
            return this.R + this.C + this.M;
        },
        _executeCore: function() {
            function updateVItemCrossGroup(crossGroupId, source) {
                for (var itemIndex = itemCrossGroupIndex[crossGroupId], sourceIndex = 0, depth = me[crossGroupId]; depth-- > 0; )
                    item[itemIndex++] = source[sourceIndex++];
            }
            function updateVItemMeasure(line, cg) {
                for (var itemIndex = itemCrossGroupIndex.M, cgIndexes = me._colGroupsIndexes[cg], depth = me.M, i = 0; depth > i; i++) {
                    var lineIndex = cgIndexes[i];
                    item[itemIndex++] = null != lineIndex ? line[lineIndex] : null;
                }
            }
            if (!this.metadata.length)
                return def.query();
            var dimsReaders = this._getDimensionsReaders()
              , item = new Array(this.virtualItemSize())
              , itemCrossGroupIndex = this._itemCrossGroupIndex
              , me = this
              , q = def.query(this.source);
            if (this._colGroups && this._colGroups.length) {
                var expandLine = function(line) {
                    updateVItemCrossGroup("R", line);
                    return def.query(this._colGroups).select(function(colGroup, cg) {
                        updateVItemCrossGroup("C", colGroup);
                        updateVItemMeasure(line, cg);
                        return this._readItem(item, dimsReaders);
                    }, this);
                };
                return q.selectMany(expandLine, this);
            }
            return q.select(function(line) {
                updateVItemCrossGroup("R", line);
                return this._readItem(item, dimsReaders);
            }, this);
        },
        _processMetadata: function() {
            this.base();
            this._separator = this.options.separator || "~";
            var R = this.R = 1;
            this.C = 1;
            this.M = 1;
            this.measuresDirection = null;
            var colNames, seriesInRows = this.options.seriesInRows, metadata = this.metadata;
            colNames = metadata.map(seriesInRows ? function(d) {
                return d.colName;
            }
            : this.options.compatVersion <= 1 ? function(d) {
                return {
                    v: d.colName
                };
            }
            : function(d) {
                return {
                    v: d.colName,
                    f: d.colLabel
                };
            }
            );
            var itemCrossGroupInfos = this._itemCrossGroupInfos = {};
            if (this.options.isMultiValued) {
                var measuresInColumns = def.get(this.options, "measuresInColumns", !0);
                if (measuresInColumns || null == this.options.measuresIndex) {
                    R = this.R = this._getCategoriesCount();
                    var encodedColGroups = colNames.slice(R)
                      , L = encodedColGroups.length;
                    if (L > 0) {
                        if (measuresInColumns) {
                            this.measuresDirection = "columns";
                            this._processEncodedColGroups(encodedColGroups);
                        } else {
                            this._colGroups = encodedColGroups;
                            this._colGroupsIndexes = [];
                            this._colGroups.forEach(function(colGroup, cg) {
                                this._colGroups[cg] = this._splitEncodedColGroupCell(colGroup);
                                this._colGroupsIndexes[cg] = [this.R + cg];
                            }, this);
                            itemCrossGroupInfos.M = [this._buildItemInfoFromMetadata(R)];
                        }
                        this.C = this._colGroups[0].length;
                        itemCrossGroupInfos.C = def.range(0, this.C).select(function() {
                            return {
                                type: 0
                            };
                        }).array();
                    } else {
                        this.C = this.M = 0;
                        itemCrossGroupInfos.M = [];
                        itemCrossGroupInfos.C = [];
                    }
                } else {
                    this.measuresDirection = "rows";
                    this.R = +this.options.measuresIndex;
                    var measuresCount = this.options.measuresCount;
                    null == measuresCount && (measuresCount = 1);
                    this.M = measuresCount;
                    this._colGroups = colNames.slice(this.R + 1);
                    this._colGroups.forEach(function(colGroup, cg) {
                        this._colGroups[cg] = [colGroup];
                    }, this);
                }
            } else {
                R = this.R = this._getCategoriesCount();
                this._colGroups = colNames.slice(R);
                this._colGroupsIndexes = new Array(this._colGroups.length);
                this._colGroups.forEach(function(colGroup, cg) {
                    this._colGroups[cg] = [colGroup];
                    this._colGroupsIndexes[cg] = [R + cg];
                }, this);
                itemCrossGroupInfos.C = [{
                    type: 0
                }];
                itemCrossGroupInfos.M = [{
                    type: this._columnTypes[R]
                }];
            }
            itemCrossGroupInfos.R = def.range(0, this.R).select(this._buildItemInfoFromMetadata, this).array();
            var itemGroupIndex = this._itemCrossGroupIndex = {
                C: seriesInRows ? this.R : 0,
                R: seriesInRows ? 0 : this.C,
                M: this.C + this.R
            }
              , itemInfos = this._itemInfos = new Array(this.virtualItemSize());
            def.eachOwn(itemGroupIndex, function(groupStartIndex, crossGroup) {
                itemCrossGroupInfos[crossGroup].forEach(function(info, groupIndex) {
                    itemInfos[groupStartIndex + groupIndex] = info;
                });
            });
            this._itemLogicalGroup = {
                series: seriesInRows ? this.R : this.C,
                category: seriesInRows ? this.C : this.R,
                value: this.M
            };
            this._itemLogicalGroupIndex = {
                series: 0,
                category: this._itemLogicalGroup.series,
                value: this.C + this.R
            };
        },
        logVItem: function() {
            return this._logVItem(["C", "R", "M"], {
                C: this.C,
                R: this.R,
                M: this.M
            });
        },
        _getCategoriesCount: function() {
            var R = this.options.categoriesCount;
            null != R && (!isFinite(R) || 0 > R) && (R = null);
            if (null == R) {
                R = def.query(this._columnTypes).whayl(function(type) {
                    return 0 === type;
                }).count();
                R || (R = 1);
            }
            return R;
        },
        _splitEncodedColGroupCell: function(colGroup) {
            var labels, values = colGroup.v;
            if (null == values)
                values = [];
            else {
                values = values.split(this._separator);
                labels = colGroup.f;
                labels && (labels = labels.split(this._separator));
            }
            return values.map(function(value, index) {
                return {
                    v: value,
                    f: labels && labels[index]
                };
            });
        },
        _processEncodedColGroups: function(encodedColGroups) {
            for (var currColGroup, L = encodedColGroups.length || def.assert("Must have columns"), R = this.R, colGroups = [], measuresInfo = {}, measuresInfoList = [], i = 0; L > i; i++) {
                var meaName, meaLabel, colGroupValues, colGroupLabels, colGroupCell = encodedColGroups[i], encColGroupValues = colGroupCell.v, encColGroupLabels = colGroupCell.f, sepIndex = encColGroupValues.lastIndexOf(this._separator);
                if (0 > sepIndex) {
                    meaName = encColGroupValues;
                    meaLabel = encColGroupLabels;
                    encColGroupValues = "";
                    colGroupValues = [];
                } else {
                    meaName = encColGroupValues.substring(sepIndex + 1);
                    encColGroupValues = encColGroupValues.substring(0, sepIndex);
                    colGroupValues = encColGroupValues.split(this._separator);
                    if (null != encColGroupLabels) {
                        colGroupLabels = encColGroupLabels.split(this._separator);
                        meaLabel = colGroupLabels.pop();
                    }
                    colGroupValues.forEach(function(value, index) {
                        var label = colGroupLabels && colGroupLabels[index];
                        colGroupValues[index] = {
                            v: value,
                            f: label
                        };
                    });
                }
                if (currColGroup && currColGroup.encValues === encColGroupValues)
                    currColGroup.measureNames.push(meaName);
                else {
                    currColGroup = {
                        startIndex: i,
                        encValues: encColGroupValues,
                        values: colGroupValues,
                        measureNames: [meaName]
                    };
                    colGroups.push(currColGroup);
                }
                var currMeaIndex = i - currColGroup.startIndex
                  , meaInfo = def.getOwn(measuresInfo, meaName);
                if (meaInfo)
                    currMeaIndex > meaInfo.groupIndex && (meaInfo.groupIndex = currMeaIndex);
                else {
                    measuresInfo[meaName] = meaInfo = {
                        name: meaName,
                        label: meaLabel,
                        type: this._columnTypes[R + i],
                        groupIndex: currMeaIndex,
                        index: i
                    };
                    measuresInfoList.push(meaInfo);
                }
            }
            measuresInfoList.sort(function(meaInfoA, meaInfoB) {
                return def.compare(meaInfoA.groupIndex, meaInfoB.groupIndex) || def.compare(meaInfoA.index, meaInfoB.index);
            });
            measuresInfoList.forEach(function(meaInfoA, index) {
                meaInfoA.groupIndex = index;
            });
            var CG = colGroups.length
              , colGroupsValues = new Array(CG)
              , colGroupsIndexes = new Array(CG)
              , M = measuresInfoList.length;
            colGroups.map(function(colGroup, cg) {
                colGroupsValues[cg] = colGroup.values;
                var colGroupStartIndex = colGroup.startIndex
                  , meaIndexes = colGroupsIndexes[cg] = new Array(M);
                colGroup.measureNames.forEach(function(meaName2, localMeaIndex) {
                    var meaIndex = measuresInfo[meaName2].groupIndex;
                    meaIndexes[meaIndex] = R + colGroupStartIndex + localMeaIndex;
                });
            });
            this._colGroups = colGroupsValues;
            this._colGroupsIndexes = colGroupsIndexes;
            this._itemCrossGroupInfos.M = measuresInfoList;
            this.M = M;
        },
        configureType: function() {
            if ("rows" === this.measuresDirection)
                throw def.error.notImplemented();
            this.base();
        },
        _configureTypeCore: function() {
            function add(dimGroupName, level, count) {
                for (var crossEndIndex = itemLogicalGroupIndex[dimGroupName] + count; count > 0; ) {
                    var dimName = pvc.buildIndexedId(dimGroupName, level);
                    if (!me.complexTypeProj.isReadOrCalc(dimName)) {
                        index = me._nextAvailableItemIndex(index);
                        if (index >= crossEndIndex)
                            return;
                        dimsReaders.push({
                            names: dimName,
                            indexes: index
                        });
                        index++;
                        count--;
                    }
                    level++;
                }
            }
            var me = this
              , itemLogicalGroup = me._itemLogicalGroup
              , itemLogicalGroupIndex = me._itemLogicalGroupIndex
              , index = 0
              , dimsReaders = []
              , dataPartDimName = this.options.dataPartDimName;
            if (dataPartDimName && 1 === this.C && !this.complexTypeProj.isReadOrCalc(dataPartDimName)) {
                var plot2DataSeriesIndexes = this.options.plot2DataSeriesIndexes;
                if (null != plot2DataSeriesIndexes) {
                    var seriesKeys = this._colGroups.map(function(colGroup) {
                        return "" + colGroup[0].v;
                    });
                    this._plot2SeriesKeySet = this._createPlot2SeriesKeySet(plot2DataSeriesIndexes, seriesKeys);
                }
            }
            ["series", "category", "value"].forEach(function(dimGroupName) {
                var L = itemLogicalGroup[dimGroupName];
                L > 0 && add(dimGroupName, 0, L);
            });
            dimsReaders && dimsReaders.forEach(this.defReader, this);
            if (this._plot2SeriesKeySet) {
                var seriesReader = this._userDimsReadersByDim.series;
                if (seriesReader) {
                    var calcAxis2SeriesKeySet = def.fun.constant(this._plot2SeriesKeySet);
                    this._userRead(this._dataPartGet(calcAxis2SeriesKeySet, seriesReader), dataPartDimName);
                }
            }
        }
    });
    def.type("pvc.data.RelationalTranslationOper", pvc.data.MatrixTranslationOper).add({
        M: 0,
        C: 0,
        S: 0,
        _translType: "Relational",
        _processMetadata: function() {
            this.base();
            var metadata = this.metadata
              , J = this.J
              , C = this.options.categoriesCount;
            null != C && (!isFinite(C) || 0 > C) && (C = 0);
            var S, valuesColIndexes, M;
            if (this.options.isMultiValued) {
                valuesColIndexes = pvc.parseDistinctIndexArray(this.options.measuresIndexes, 0, J - 1);
                M = valuesColIndexes ? valuesColIndexes.length : 0;
            }
            var D;
            if (null == M)
                if (J > 0 && 3 >= J && (null == C || 1 === C) && null == S) {
                    M = 1;
                    valuesColIndexes = [J - 1];
                    C = J >= 2 ? 1 : 0;
                    S = J >= 3 ? 1 : 0;
                    D = C + S;
                } else if (null != C && C >= J) {
                    D = J;
                    C = J;
                    S = 0;
                    M = 0;
                } else {
                    var Mmax = null != C ? J - C : 1 / 0;
                    valuesColIndexes = def.query(metadata).where(function(colDef, index) {
                        return 0 !== this._columnTypes[index];
                    }, this).select(function(colDef) {
                        return colDef.colIndex;
                    }).take(Mmax).array();
                    M = valuesColIndexes.length;
                }
            if (null == D) {
                D = J - M;
                if (0 === D)
                    S = C = 0;
                else if (null != C)
                    if (C > D) {
                        C = D;
                        S = 0;
                    } else
                        S = D - C;
                else {
                    S = D > 1 ? 1 : 0;
                    C = D - S;
                }
            }
            var seriesInRows = this.options.seriesInRows
              , colGroupSpecs = [];
            if (D) {
                S && !seriesInRows && colGroupSpecs.push({
                    name: "S",
                    count: S
                });
                C && colGroupSpecs.push({
                    name: "C",
                    count: C
                });
                S && seriesInRows && colGroupSpecs.push({
                    name: "S",
                    count: S
                });
            }
            M && colGroupSpecs.push({
                name: "M",
                count: M
            });
            var availableInputIndexes = def.range(0, J).array();
            valuesColIndexes && valuesColIndexes.forEach(function(inputIndex) {
                availableInputIndexes.splice(inputIndex, 1);
            });
            var specsByName = {};
            colGroupSpecs.forEach(function(groupSpec) {
                var count = groupSpec.count
                  , name = groupSpec.name;
                specsByName[name] = groupSpec;
                groupSpec.indexes = valuesColIndexes && "M" === name ? valuesColIndexes : availableInputIndexes.splice(0, count);
            });
            this.M = M;
            this.S = S;
            this.C = C;
            var itemPerm = [];
            ["S", "C", "M"].forEach(function(name) {
                var groupSpec = specsByName[name];
                groupSpec && def.array.append(itemPerm, groupSpec.indexes);
            });
            this._itemInfos = itemPerm.map(this._buildItemInfoFromMetadata, this);
            this._itemCrossGroupIndex = {
                S: 0,
                C: this.S,
                M: this.S + this.C
            };
            this._itemPerm = itemPerm;
        },
        logVItem: function() {
            return this._logVItem(["S", "C", "M"], {
                S: this.S,
                C: this.C,
                M: this.M
            });
        },
        _configureTypeCore: function() {
            function add(dimGroupName, colGroupName, level, count) {
                for (var groupEndIndex = me._itemCrossGroupIndex[colGroupName] + count; count > 0; ) {
                    var dimName = pvc.buildIndexedId(dimGroupName, level);
                    if (!me.complexTypeProj.isReadOrCalc(dimName)) {
                        index = me._nextAvailableItemIndex(index);
                        if (index >= groupEndIndex)
                            return;
                        dimsReaders.push({
                            names: dimName,
                            indexes: index
                        });
                        index++;
                        count--;
                    }
                    level++;
                }
            }
            var me = this
              , index = 0
              , dimsReaders = [];
            this.S > 0 && add("series", "S", 0, this.S);
            this.C > 0 && add("category", "C", 0, this.C);
            this.M > 0 && add("value", "M", 0, this.M);
            dimsReaders && dimsReaders.forEach(this.defReader, this);
            var dataPartDimName = this.options.dataPartDimName;
            if (dataPartDimName && !this.complexTypeProj.isReadOrCalc(dataPartDimName)) {
                var plot2DataSeriesIndexes = this.options.plot2DataSeriesIndexes;
                if (null != plot2DataSeriesIndexes) {
                    var seriesReader = this._userDimsReadersByDim.series;
                    seriesReader && this._userRead(relTransl_dataPartGet.call(this, plot2DataSeriesIndexes, seriesReader), dataPartDimName);
                }
            }
        },
        _executeCore: function() {
            var dimsReaders = this._getDimensionsReaders()
              , permIndexes = this._itemPerm;
            return def.query(this._getItems()).select(function(item) {
                item = pv.permute(item, permIndexes);
                return this._readItem(item, dimsReaders);
            }, this);
        }
    });
    def.type("pvc.data.Atom").init(function(dimension, value, label, rawValue, key) {
        this.dimension = dimension;
        this.id = null == value ? -def.nextId() : def.nextId();
        this.value = value;
        this.label = label;
        void 0 !== rawValue && (this.rawValue = rawValue);
        this.key = key;
    }).add({
        isVirtual: !1,
        rawValue: void 0,
        toString: function() {
            var label = this.label;
            if (null != label)
                return label;
            label = this.value;
            return null != label ? "" + label : "";
        }
    });
    var complex_nextId = 1;
    def.type("pvc.data.Complex").init(function(source, atomsByName, dimNames, atomsBase, wantLabel, calculate) {
        var me = this;
        me.id = complex_nextId++;
        var owner;
        if (source) {
            owner = source.owner;
            atomsBase || (atomsBase = source.atoms);
        }
        me.owner = owner = owner || me;
        var type = owner.type || def.fail.argumentRequired("owner.type");
        me.atoms = atomsBase ? Object.create(atomsBase) : {};
        var dimNamesSpecified = !!dimNames;
        dimNames || (dimNames = type._dimsNames);
        var i, dimName, atomsMap = me.atoms, D = dimNames.length;
        if (atomsByName) {
            var ownerDims = owner._dimensions
              , addAtom = function(dimName) {
                var v = atomsByName[dimName]
                  , atom = ownerDims[dimName].intern(v);
                null == v || atomsBase && atom === atomsBase[dimName] || (atomsMap[dimName] = atom);
            };
            if (dimNamesSpecified) {
                i = D;
                for (; i--; )
                    addAtom(dimNames[i]);
            } else
                for (dimName in atomsByName)
                    addAtom(dimName);
            if (calculate) {
                atomsByName = type._calculate(me);
                for (dimName in atomsByName)
                    def.hasOwnProp.call(atomsMap, dimName) || addAtom(dimName);
            }
        }
        var atom;
        if (D)
            if (1 === D) {
                atom = atomsMap[dimNames[0]];
                me.value = atom.value;
                me.rawValue = atom.rawValue;
                me.key = atom.key;
                wantLabel && (me.label = atom.label);
            } else {
                var key, label, alabel, keySep = owner.keySep, labelSep = owner.labelSep;
                for (i = 0; D > i; i++) {
                    atom = atomsMap[dimNames[i]];
                    i ? key += keySep + atom.key : key = atom.key;
                    wantLabel && (alabel = atom.label) && (label ? label += labelSep + alabel : label = alabel);
                }
                me.value = me.rawValue = me.key = key;
                wantLabel && (me.label = label);
            }
        else {
            me.value = null;
            me.key = "";
            wantLabel && (me.label = "");
        }
    }).add({
        labelSep: " ~ ",
        keySep: "~",
        value: null,
        label: null,
        rawValue: void 0,
        ensureLabel: function() {
            var label = this.label;
            if (null == label) {
                label = "";
                var labelSep = this.owner.labelSep;
                def.eachOwn(this.atoms, function(atom) {
                    var alabel = atom.label;
                    alabel && (label ? label += labelSep + alabel : label = alabel);
                });
                this.label = label;
            }
            return label;
        },
        view: function(dimNames) {
            return new pvc.data.ComplexView(this,dimNames);
        },
        toString: function() {
            var s = ["" + this.constructor.typeName];
            null != this.index && s.push("#" + this.index);
            this.owner.type.dimensionsNames().forEach(function(name) {
                s.push(name + ": " + pvc.stringify(this.atoms[name].value));
            }, this);
            return s.join(" ");
        },
        rightTrimKeySep: function(key) {
            return key && pvc.data.Complex.rightTrimKeySep(key, this.owner.keySep);
        },
        absKeyTrimmed: function() {
            return this.rightTrimKeySep(this.absKey);
        },
        keyTrimmed: function() {
            return this.rightTrimKeySep(this.key);
        }
    });
    pvc.data.Complex.rightTrimKeySep = function(key, keySep) {
        if (key && keySep)
            for (var j, K = keySep.length; key.lastIndexOf(keySep) === (j = key.length - K) && j >= 0; )
                key = key.substr(0, j);
        return key;
    }
    ;
    pvc.data.Complex.values = function(complex, dimNames) {
        var atoms = complex.atoms;
        return dimNames.map(function(dimName) {
            return atoms[dimName].value;
        });
    }
    ;
    pvc.data.Complex.compositeKey = function(complex, dimNames) {
        var atoms = complex.atoms;
        return dimNames.map(function(dimName) {
            return atoms[dimName].key;
        }).join(complex.owner.keySep);
    }
    ;
    pvc.data.Complex.labels = function(complex, dimNames) {
        var atoms = complex.atoms;
        return dimNames.map(function(dimName) {
            return atoms[dimName].label;
        });
    }
    ;
    var complex_id = def.propGet("id");
    def.type("pvc.data.ComplexView", pvc.data.Complex).init(function(source, viewDimNames) {
        this.source = source;
        this.viewDimNames = viewDimNames;
        this.base(source, source.atoms, viewDimNames, source.owner.atoms, !0);
    }).add({
        values: function() {
            return pvc.data.Complex.values(this, this.viewDimNames);
        },
        labels: function() {
            return pvc.data.Complex.labels(this, this.viewDimNames);
        }
    });
    def.type("pvc.data.Datum", pvc.data.Complex).init(function(data, atomsByName) {
        this.base(data, atomsByName, null, null, !1, !0);
    }).add({
        isSelected: !1,
        isVisible: !0,
        isNull: !1,
        isVirtual: !1,
        isTrend: !1,
        trend: null,
        isInterpolated: !1,
        interpolation: null,
        setSelected: function(select) {
            if (this.isNull)
                return !1;
            select = null == select || !!select;
            var changed = this.isSelected !== select;
            if (changed) {
                select ? this.isSelected = !0 : delete this.isSelected;
                data_onDatumSelectedChanged.call(this.owner, this, select);
            }
            return changed;
        },
        toggleSelected: function() {
            return this.setSelected(!this.isSelected);
        },
        setVisible: function(visible) {
            if (this.isNull)
                return !1;
            visible = null == visible || !!visible;
            var changed = this.isVisible !== visible;
            if (changed) {
                this.isVisible = visible;
                data_onDatumVisibleChanged.call(this.owner, this, visible);
            }
            return changed;
        },
        toggleVisible: function() {
            return this.setVisible(!this.isVisible);
        }
    });
    var datum_isSelected = def.propGet("isSelected");
    def.type("pvc.data.TrendDatum", pvc.data.Datum).init(function(data, atomsByName, trend) {
        this.base(data, atomsByName);
        this.trend = trend;
    }).add({
        isVirtual: !0,
        isTrend: !0
    });
    def.type("pvc.data.InterpolationDatum", pvc.data.Datum).init(function(data, atomsByName, interpolation) {
        this.base(data, atomsByName);
        this.interpolation = interpolation;
    }).add({
        isVirtual: !0,
        isInterpolated: !0
    });
    def.type("pvc.data.Dimension").init(function(data, type) {
        this.data = data;
        this.type = type;
        this.root = this;
        this.owner = this;
        var name = type.name;
        this.name = name;
        this._atomComparer = type.atomComparer();
        this._atomsByKey = {};
        if (data.isOwner()) {
            this._atoms = [];
            dim_createVirtualNullAtom.call(this);
        } else {
            var source, parentData = data.parent;
            if (parentData) {
                source = parentData._dimensions[name];
                dim_addChild.call(source, this);
                this.root = data.parent.root;
            } else {
                parentData = data.linkParent;
                parentData || def.assert("Data must have a linkParent");
                source = parentData._dimensions[name];
                dim_addLinkChild.call(source, this);
            }
            this._nullAtom = this.owner._nullAtom;
            this._lazyInit = function() {
                this._lazyInit = null;
                for (var datums = this.data._datums, L = datums.length, atomsByKey = this._atomsByKey, i = 0; L > i; i++) {
                    var atom = datums[i].atoms[name];
                    atomsByKey[atom.key] = atom;
                }
                this._atoms = source.atoms().filter(function(atom) {
                    return def.hasOwnProp.call(atomsByKey, atom.key);
                });
            }
            ;
        }
    }).add({
        parent: null,
        linkParent: null,
        _linkChildren: null,
        _atomsByKey: null,
        _atomVisibleDatumsCount: null,
        _disposed: !1,
        _nullAtom: null,
        _virtualNullAtom: null,
        _visibleAtoms: null,
        _visibleIndexes: null,
        _atomComparer: null,
        _atoms: null,
        _sumCache: null,
        count: function() {
            this._lazyInit && this._lazyInit();
            return this._atoms.length;
        },
        isVisible: function(atom) {
            this._lazyInit && this._lazyInit();
            def.hasOwn(this._atomsByKey, atom.key) || def.assert("Atom must exist in this dimension.");
            return dim_getVisibleDatumsCountMap.call(this)[atom.key] > 0;
        },
        atoms: function(keyArgs) {
            this._lazyInit && this._lazyInit();
            var visible = def.get(keyArgs, "visible");
            if (null == visible)
                return this._atoms;
            visible = !!visible;
            this._visibleAtoms || (this._visibleAtoms = {});
            return this._visibleAtoms[visible] || (this._visibleAtoms[visible] = dim_calcVisibleAtoms.call(this, visible));
        },
        indexes: function(keyArgs) {
            this._lazyInit && this._lazyInit();
            var visible = def.get(keyArgs, "visible");
            if (null == visible)
                return pv.range(0, this._atoms.length);
            visible = !!visible;
            this._visibleIndexes || (this._visibleIndexes = {});
            return this._visibleIndexes[visible] || (this._visibleIndexes[visible] = dim_calcVisibleIndexes.call(this, visible));
        },
        atom: function(value) {
            if (null == value || "" === value)
                return this._nullAtom;
            if (value instanceof pvc.data.Atom)
                return value;
            this._lazyInit && this._lazyInit();
            var typeKey = this.type._key
              , key = typeKey ? typeKey.call(null, value) : value;
            return this._atomsByKey[key] || null;
        },
        getDistinctAtoms: function(values) {
            var atoms = []
              , L = values ? values.length : 0;
            if (L)
                for (var atomsByKey = {}, i = 0; L > i; i++) {
                    var key, atom = this.atom(values[i]);
                    if (atom && !atomsByKey[key = "\x00" + atom.key]) {
                        atomsByKey[key] = atom;
                        atoms.push(atom);
                    }
                }
            return atoms;
        },
        extent: function(keyArgs) {
            var atoms = this.atoms(keyArgs)
              , L = atoms.length;
            if (!L)
                return void 0;
            var offset = this._nullAtom && null == atoms[0].value ? 1 : 0
              , countWithoutNull = L - offset;
            if (countWithoutNull > 0) {
                var tmp, min = atoms[offset], max = atoms[L - 1];
                if (min !== max && def.get(keyArgs, "abs", !1)) {
                    var minSign = min.value < 0 ? -1 : 1
                      , maxSign = max.value < 0 ? -1 : 1;
                    if (minSign === maxSign) {
                        if (0 > maxSign) {
                            tmp = max;
                            max = min;
                            min = tmp;
                        }
                    } else if (countWithoutNull > 2) {
                        max.value < -min.value && (max = min);
                        var zeroIndex = def.array.binarySearch(atoms, 0, this.type.comparer(), function(a) {
                            return a.value;
                        });
                        if (0 > zeroIndex) {
                            zeroIndex = ~zeroIndex;
                            var negAtom = atoms[zeroIndex - 1]
                              , posAtom = atoms[zeroIndex];
                            min = -negAtom.value < posAtom.value ? negAtom : posAtom;
                        } else
                            min = atoms[zeroIndex];
                    } else if (max.value < -min.value) {
                        tmp = max;
                        max = min;
                        min = tmp;
                    }
                }
                return {
                    min: min,
                    max: max
                };
            }
            return void 0;
        },
        min: function(keyArgs) {
            var atoms = this.atoms(keyArgs)
              , L = atoms.length;
            if (!L)
                return void 0;
            var offset = this._nullAtom && null == atoms[0].value ? 1 : 0;
            return L > offset ? atoms[offset] : void 0;
        },
        max: function(keyArgs) {
            var atoms = this.atoms(keyArgs)
              , L = atoms.length;
            return L && null != atoms[L - 1].value ? atoms[L - 1] : void 0;
        },
        sumAbs: function(keyArgs) {
            return this.sum(def.create(keyArgs, {
                abs: !0
            }));
        },
        value: function(keyArgs) {
            return this.sum(keyArgs && keyArgs.abs ? def.create(keyArgs, {
                abs: !1
            }) : keyArgs);
        },
        valueAbs: function(keyArgs) {
            var value = this.value(keyArgs);
            return value ? Math.abs(value) : value;
        },
        sum: function(keyArgs) {
            var isAbs = !!def.get(keyArgs, "abs", !1)
              , zeroIfNone = def.get(keyArgs, "zeroIfNone", !0)
              , key = dim_buildDatumsFilterKey(keyArgs) + ":" + isAbs
              , sum = def.getOwn(this._sumCache, key);
            if (void 0 === sum) {
                var dimName = this.name;
                sum = this.data.datums(null, keyArgs).reduce(function(sum2, datum) {
                    var value = datum.atoms[dimName].value;
                    isAbs && 0 > value && (value = -value);
                    return null != sum2 ? sum2 + value : value;
                }, null);
                (this._sumCache || (this._sumCache = {}))[key] = sum;
            }
            return zeroIfNone ? sum || 0 : sum;
        },
        percent: function(atomOrValue, keyArgs) {
            var value = atomOrValue instanceof pvc.data.Atom ? atomOrValue.value : atomOrValue;
            if (!value)
                return 0;
            var sum = this.sumAbs(keyArgs);
            return sum ? Math.abs(value) / sum : 0;
        },
        valuePercent: function(keyArgs) {
            var value = this.valueAbs(keyArgs);
            if (!value)
                return 0;
            var parentData = this.data.parent;
            if (!parentData)
                return 1;
            var sum = parentData.dimensionsSumAbs(this.name, keyArgs);
            return value / sum;
        },
        percentOverParent: function(keyArgs) {
            return this.valuePercent(keyArgs);
        },
        format: function(value, sourceValue) {
            return "" + (this.type._formatter ? this.type._formatter.call(null, value, sourceValue) : "");
        },
        intern: function(sourceValue, isVirtual) {
            if (null == sourceValue || "" === sourceValue)
                return this._nullAtom || dim_createNullAtom.call(this, sourceValue);
            if (sourceValue instanceof pvc.data.Atom) {
                if (sourceValue.dimension !== this)
                    throw def.error.operationInvalid("Atom is of a different dimension.");
                return sourceValue;
            }
            var value, label, type = this.type;
            if ("object" == typeof sourceValue && "v"in sourceValue) {
                label = sourceValue.f;
                sourceValue = sourceValue.v;
                if (null == sourceValue || "" === sourceValue)
                    return this._nullAtom || dim_createNullAtom.call(this);
            }
            if (isVirtual)
                value = sourceValue;
            else {
                var converter = type._converter;
                if (converter) {
                    value = converter(sourceValue);
                    if (null == value || "" === value)
                        return this._nullAtom || dim_createNullAtom.call(this, sourceValue);
                } else
                    value = sourceValue;
            }
            var cast = type.cast;
            if (cast) {
                value = cast(value);
                if (null == value || "" === value)
                    return this._nullAtom || dim_createNullAtom.call(this);
            }
            var keyFun = type._key
              , key = "" + (keyFun ? keyFun(value) : value);
            key || def.fail.operationInvalid("Only a null value can have an empty key.");
            var atom = this._atomsByKey[key];
            if (atom) {
                !isVirtual && atom.isVirtual && delete atom.isVirtual;
                return atom;
            }
            return dim_createAtom.call(this, type, sourceValue, key, value, label, isVirtual);
        },
        read: function(sourceValue, label) {
            if (null == sourceValue || "" === sourceValue)
                return null;
            var value, type = this.type;
            if ("object" == typeof sourceValue && "v"in sourceValue) {
                label = sourceValue.f;
                sourceValue = sourceValue.v;
                if (null == sourceValue || "" === sourceValue)
                    return null;
            }
            var converter = type._converter;
            value = converter ? converter(sourceValue) : sourceValue;
            if (null == value || "" === value)
                return null;
            var cast = type.cast;
            if (cast) {
                value = cast(value);
                if (null == value || "" === value)
                    return null;
            }
            var keyFun = type._key
              , key = "" + (keyFun ? keyFun(value) : value)
              , atom = this._atomsByKey[key];
            if (atom)
                return {
                    rawValue: sourceValue,
                    key: key,
                    value: atom.value,
                    label: "" + (null == label ? atom.label : label)
                };
            if (null == label) {
                var formatter = type._formatter;
                label = formatter ? formatter(value, sourceValue) : value;
            }
            label = "" + label;
            return {
                rawValue: sourceValue,
                key: key,
                value: value,
                label: label
            };
        },
        dispose: function() {
            var me = this;
            if (!me._disposed) {
                data_disposeChildList(me.childNodes, "parent");
                data_disposeChildList(me._linkChildren, "linkParent");
                var v;
                (v = me.parent) && data_removeColChild(v, "childNodes", me, "parent");
                (v = me.linkParent) && data_removeColChild(v, "_linkChildren", me, "linkParent");
                dim_clearVisiblesCache.call(me);
                me._lazyInit = me._atoms = me._nullAtom = me._virtualNullAtom = null;
                me._disposed = !0;
            }
        }
    });
    def.type("pvc.data.Data", pvc.data.Complex).init(function(keyArgs) {
        keyArgs || def.fail.argumentRequired("keyArgs");
        this._visibleNotNullDatums = new def.Map();
        var owner, atoms, atomsBase, atomsDimNames, datums, index, parent = this.parent = keyArgs.parent || null;
        if (parent) {
            this.root = parent.root;
            this.depth = parent.depth + 1;
            this.type = parent.type;
            datums = keyArgs.datums || def.fail.argumentRequired("datums");
            owner = parent.owner;
            atoms = keyArgs.atoms || def.fail.argumentRequired("atoms");
            atomsDimNames = keyArgs.atomsDimNames || def.fail.argumentRequired("atomsDimNames");
            atomsBase = parent.atoms;
        } else {
            this.root = this;
            atomsDimNames = [];
            var linkParent = keyArgs.linkParent || null;
            if (linkParent) {
                owner = linkParent.owner;
                this.type = owner.type;
                datums = keyArgs.datums || def.fail.argumentRequired("datums");
                this._leafs = [];
                this._wherePred = keyArgs.where || null;
                atomsBase = linkParent.atoms;
                index = def.get(keyArgs, "index", null);
                data_addLinkChild.call(linkParent, this, index);
            } else {
                owner = this;
                atomsBase = {};
                keyArgs.labelSep && (this.labelSep = keyArgs.labelSep);
                keyArgs.keySep && (this.keySep = keyArgs.keySep);
                this.type = keyArgs.type || def.fail.argumentRequired("type");
                this._selectedNotNullDatums = new def.Map();
            }
        }
        datums && data_setDatums.call(this, datums);
        this.owner = owner;
        this._atomsBase = atomsBase;
        this._dimensions = {};
        this._dimensionsList = [];
        this.type.dimensionsList().forEach(this._initDimension, this);
        this.base(owner, atoms, atomsDimNames, atomsBase, !0);
        pv.Dom.Node.call(this);
        if (parent) {
            index = def.get(keyArgs, "index", null);
            data_addChild.call(parent, this, index);
            this.absLabel = parent.absLabel ? def.string.join(owner.labelSep, parent.absLabel, this.label) : this.label;
            this.absKey = parent.absKey ? def.string.join(owner.keySep, parent.absKey, this.key) : this.key;
        } else {
            this.absLabel = this.label;
            this.absKey = this.key;
        }
    }).add(pv.Dom.Node).add({
        parent: null,
        linkParent: null,
        _dimensions: null,
        _dimensionsList: null,
        _freeDimensionNames: null,
        _linkChildren: null,
        _leafs: null,
        _childrenByKey: null,
        _visibleNotNullDatums: null,
        _selectedNotNullDatums: null,
        _groupByCache: null,
        _sumAbsCache: null,
        treeHeight: null,
        _groupOper: null,
        _wherePred: null,
        _groupSpec: null,
        _groupLevel: null,
        _datums: null,
        _datumsById: null,
        _datumsByKey: null,
        depth: 0,
        label: "",
        absLabel: "",
        _disposed: !1,
        _isFlattenGroup: !1,
        _isDegenerateFlattenGroup: !1,
        _initDimension: function(dimType) {
            var dim = new pvc.data.Dimension(this,dimType);
            this._dimensions[dimType.name] = dim;
            this._dimensionsList.push(dim);
        },
        dimensions: function(name, keyArgs) {
            if (null == name)
                return this._dimensions;
            var dim = def.getOwn(this._dimensions, name);
            if (!dim && def.get(keyArgs, "assertExists", !0))
                throw def.error.argumentInvalid("name", "Undefined dimension '{0}'.", [name]);
            return dim;
        },
        dimensionsList: function() {
            return this._dimensionsList;
        },
        freeDimensionsNames: function() {
            var free = this._freeDimensionNames;
            free || (this._freeDimensionNames = free = this.type.dimensionsNames().filter(function(dimName) {
                var atom = this.atoms[dimName];
                return !(atom instanceof pvc.data.Atom) || null == atom.value;
            }, this));
            return free;
        },
        isOwner: function() {
            return this.owner === this;
        },
        children: function() {
            var cs = this.childNodes;
            return cs.length ? def.query(cs) : def.query();
        },
        child: function(key) {
            return def.getOwn(this._childrenByKey, key, null);
        },
        childCount: function() {
            return this.childNodes.length;
        },
        leafs: function() {
            return def.query(this._leafs);
        },
        count: function() {
            return this._datums.length;
        },
        firstDatum: function() {
            return this._datums.length ? this._datums[0] : null;
        },
        firstAtoms: function() {
            return (this.firstDatum() || this).atoms;
        },
        singleDatum: function() {
            var datums = this._datums;
            return 1 === datums.length ? datums[0] : null;
        },
        dispose: function() {
            var me = this;
            if (!me._disposed) {
                data_disposeChildLists.call(me);
                var v;
                (v = me._selectedNotNullDatums) && v.clear();
                me._visibleNotNullDatums.clear();
                v = me._dimensionsList;
                for (var i = 0, L = v.length; L > i; i++)
                    v[i].dispose();
                me._dimensions = null;
                me._dimensionsLIst = null;
                if (v = me.parent) {
                    v.removeChild(me);
                    me.parent = null;
                }
                (v = me.linkParent) && data_removeLinkChild.call(v, me);
                me._disposed = !0;
            }
        },
        disposeChildren: function() {
            data_disposeChildLists.call(this);
        }
    });
    pvc.data.Data.add({
        selectedCount: function() {
            return this.isOwner() ? this._selectedNotNullDatums.count : this.datums(null, {
                selected: !0
            }).count();
        },
        selectedDatums: function() {
            return this.isOwner() ? this._selectedNotNullDatums.values() : this.datums(null, {
                selected: !0
            }).array();
        },
        selectedDatumMap: function() {
            if (!this.isOwner()) {
                var datums = this.datums(null, {
                    selected: !0
                }).object({
                    name: def.propGet("id")
                });
                return new def.Set(datums);
            }
            return this._selectedNotNullDatums.clone();
        },
        visibleCount: function() {
            return this._visibleNotNullDatums.count;
        },
        replaceSelected: function(datums) {
            def.array.is(datums) || (datums = datums.array());
            var alreadySelectedById = def.query(datums).where(datum_isSelected).object({
                name: complex_id
            })
              , changed = this.owner.clearSelected(function(datum) {
                return !def.hasOwn(alreadySelectedById, datum.id);
            });
            changed |= pvc.data.Data.setSelected(datums, !0);
            return changed;
        },
        clearSelected: function(funFilter) {
            if (this.owner !== this)
                return this.owner.clearSelected(funFilter);
            if (!this._selectedNotNullDatums.count)
                return !1;
            var changed;
            if (funFilter) {
                changed = !1;
                this._selectedNotNullDatums.values().filter(funFilter).forEach(function(datum) {
                    changed = !0;
                    datum_deselect.call(datum);
                    this._selectedNotNullDatums.rem(datum.id);
                }, this);
            } else {
                changed = !0;
                this._selectedNotNullDatums.values().forEach(function(datum) {
                    datum_deselect.call(datum);
                });
                this._selectedNotNullDatums.clear();
            }
            return changed;
        }
    });
    pvc.data.Data.setSelected = function(datums, selected) {
        var anyChanged = 0;
        datums && def.query(datums).each(function(datum) {
            anyChanged |= datum.setSelected(selected);
        });
        return !!anyChanged;
    }
    ;
    pvc.data.Data.toggleSelected = function(datums, any) {
        def.array.isLike(datums) || (datums = def.query(datums).array());
        var q = def.query(datums)
          , on = any ? q.any(datum_isSelected) : q.all(datum_isNullOrSelected);
        return this.setSelected(datums, !on);
    }
    ;
    pvc.data.Data.setVisible = function(datums, visible) {
        var anyChanged = 0;
        datums && def.query(datums).each(function(datum) {
            anyChanged |= datum.setVisible(visible);
        });
        return !!anyChanged;
    }
    ;
    pvc.data.Data.toggleVisible = function(datums) {
        def.array.isLike(datums) || (datums = def.query(datums).array());
        var allVisible = def.query(datums).all(def.propGet("isVisible"));
        return pvc.data.Data.setVisible(datums, !allVisible);
    }
    ;
    def.space("pvc.data").FlatteningMode = def.set(def.makeEnum(["DfsPre", "DfsPost"]), "None", 0);
    def.type("pvc.data.GroupingSpec").init(function(levelSpecs, type, ka) {
        this.type = type || null;
        var ids = [];
        this.hasCompositeLevels = !1;
        var dimNames = [];
        this.levels = def.query(levelSpecs || void 0).where(function(levelSpec) {
            return levelSpec.dimensions.length > 0;
        }).select(function(levelSpec) {
            ids.push(levelSpec.id);
            def.array.append(dimNames, levelSpec.dimensionNames());
            !this.hasCompositeLevels && levelSpec.dimensions.length > 1 && (this.hasCompositeLevels = !0);
            levelSpec._setAccDimNames(dimNames.slice(0));
            return levelSpec;
        }, this).array();
        this._dimNames = dimNames;
        this.depth = this.levels.length;
        this.isSingleLevel = 1 === this.depth;
        this.isSingleDimension = this.isSingleLevel && !this.hasCompositeLevels;
        this.firstDimension = this.depth > 0 ? this.levels[0].dimensions[0] : null;
        this.rootLabel = def.get(ka, "rootLabel") || "";
        this.flatteningMode = def.get(ka, "flatteningMode") || pvc.data.FlatteningMode.None;
        this._cacheKey = this._calcCacheKey();
        this.id = this._cacheKey + "##" + ids.join("||");
    }).add({
        _calcCacheKey: function(ka) {
            return [def.get(ka, "flatteningMode") || this.flatteningMode, def.get(ka, "reverse") || "false", def.get(ka, "isSingleLevel") || this.isSingleLevel, def.get(ka, "rootLabel") || this.rootLabel].join("#");
        },
        bind: function(type) {
            this.type = type || def.fail.argumentRequired("type");
            this.levels.forEach(function(levelSpec) {
                levelSpec.bind(type);
            });
        },
        dimensions: function() {
            return def.query(this.levels).prop("dimensions").selectMany();
        },
        dimensionNames: function() {
            return this._dimNames;
        },
        view: function(complex) {
            return complex.view(this.dimensionNames());
        },
        isDiscrete: function() {
            var d;
            return !this.isSingleDimension || !!(d = this.firstDimension) && d.type.isDiscrete;
        },
        firstDimensionType: function() {
            var d = this.firstDimension;
            return d && d.type;
        },
        firstDimensionName: function() {
            var dt = this.firstDimensionType();
            return dt && dt.name;
        },
        firstDimensionValueType: function() {
            var dt = this.firstDimensionType();
            return dt && dt.valueType;
        },
        isNull: function() {
            return !this.levels.length;
        },
        ensure: function(ka) {
            var result;
            if (ka) {
                var cacheKey = this._calcCacheKey(ka);
                if (cacheKey !== this._cacheKey) {
                    var cache = def.lazy(this, "_groupingCache");
                    result = def.getOwn(cache, cacheKey);
                    result || (result = cache[cacheKey] = this._ensure(ka));
                }
            }
            return result || this;
        },
        _ensure: function(ka) {
            var me = this;
            if (def.get(ka, "isSingleLevel") && !me.isSingleLevel)
                return me._singleLevelGrouping(ka);
            if (def.get(ka, "reverse"))
                return me._reverse(ka);
            var flatteningMode = def.get(ka, "flatteningMode") || me.flatteningMode
              , rootLabel = def.get(ka, "rootLabel") || me.rootLabel;
            return flatteningMode !== me.flatteningMode || rootLabel !== me.rootLabel ? new pvc.data.GroupingSpec(me.levels,me.type,{
                flatteningMode: flatteningMode,
                rootLabel: rootLabel
            }) : me;
        },
        _singleLevelGrouping: function(ka) {
            var reverse = !!def.get(ka, "reverse")
              , dimSpecs = this.dimensions().select(function(dimSpec) {
                return reverse ? new pvc.data.GroupingDimensionSpec(dimSpec.name,!dimSpec.reverse,dimSpec.type.complexType) : dimSpec;
            })
              , levelSpec = new pvc.data.GroupingLevelSpec(dimSpecs,this.type);
            return new pvc.data.GroupingSpec([levelSpec],this.type,{
                flatteningMode: null,
                rootLabel: def.get(ka, "rootLabel") || this.rootLabel
            });
        },
        _reverse: function(ka) {
            var levelSpecs = def.query(this.levels).select(function(levelSpec) {
                var dimSpecs = def.query(levelSpec.dimensions).select(function(dimSpec) {
                    return new pvc.data.GroupingDimensionSpec(dimSpec.name,!dimSpec.reverse,dimSpec.type.complexType);
                });
                return new pvc.data.GroupingLevelSpec(dimSpecs,this.type);
            });
            return new pvc.data.GroupingSpec(levelSpecs,this.type,{
                flatteningMode: def.get(ka, "flatteningMode") || this.flatteningMode,
                rootLabel: def.get(ka, "rootLabel") || this.rootLabel
            });
        },
        toString: function() {
            return def.query(this.levels).select(function(level) {
                return "" + level;
            }).array().join(", ");
        }
    });
    def.type("pvc.data.GroupingLevelSpec").init(function(dimSpecs, type) {
        var ids = []
          , dimNames = [];
        this.dimensions = def.query(dimSpecs).select(function(dimSpec) {
            ids.push(dimSpec.id);
            dimNames.push(dimSpec.name);
            return dimSpec;
        }).array();
        this._dimNames = dimNames;
        this.dimensionsInDefOrder = this.dimensions.slice(0);
        type && this._sortDimensions(type);
        this.id = ids.join(",");
        this.depth = this.dimensions.length;
        var me = this;
        this.comparer = function(a, b) {
            return me.compare(a, b);
        }
        ;
    }).add({
        _sortDimensions: function(type) {
            type.sortDimensionNames(this.dimensionsInDefOrder, function(d) {
                return d.name;
            });
        },
        _setAccDimNames: function(accDimNames) {
            this._accDimNames = accDimNames;
        },
        accDimensionNames: function() {
            return this._accDimNames;
        },
        dimensionNames: function() {
            return this._dimNames;
        },
        bind: function(type) {
            this._sortDimensions(type);
            this.dimensions.forEach(function(dimSpec) {
                dimSpec.bind(type);
            });
        },
        compare: function(a, b) {
            for (var dims = this.dimensions, D = this.depth, i = 0; D > i; i++) {
                var result = dims[i].compareDatums(a, b);
                if (result)
                    return result;
            }
            return 0;
        },
        key: function(datum) {
            for (var key = "", dimNames = this._dimNames, D = this.depth, keySep = datum.owner.keySep, datoms = datum.atoms, i = 0; D > i; i++) {
                var k = datoms[dimNames[i]].key;
                i ? key += keySep + k : key = k;
            }
            return key;
        },
        atomsInfo: function(datum) {
            for (var atoms = {}, dimNames = this._dimNames, D = this.depth, datoms = datum.atoms, i = (datum.owner.keySep,
            0); D > i; i++) {
                var dimName = dimNames[i];
                atoms[dimName] = datoms[dimName];
            }
            return {
                atoms: atoms,
                dimNames: dimNames
            };
        },
        toString: function() {
            return def.query(this.dimensions).select(function(dimSpec) {
                return "" + dimSpec;
            }).array().join("|");
        }
    });
    def.type("pvc.data.GroupingDimensionSpec").init(function(name, reverse, type) {
        this.name = name;
        this.reverse = !!reverse;
        this.id = name + ":" + (reverse ? "0" : "1");
        type && this.bind(type);
    }).add({
        type: null,
        comparer: null,
        bind: function(type) {
            type || def.fail.argumentRequired("type");
            this.type = type.dimensions(this.name);
            this.comparer = this.type.atomComparer(this.reverse);
        },
        compareDatums: function(a, b) {
            if (this.type.isComparable) {
                var name = this.name;
                return this.comparer(a.atoms[name], b.atoms[name]);
            }
            return this.reverse ? b.id - a.id : a.id - b.id;
        },
        toString: function() {
            return this.name + (this.reverse ? " desc" : "");
        }
    });
    pvc.data.GroupingSpec.parse = function(specText, type) {
        if (!specText)
            return new pvc.data.GroupingSpec(null,type);
        var levels;
        def.array.is(specText) ? levels = specText : def.string.is(specText) && (levels = specText.split(/\s*,\s*/));
        var levelSpecs = def.query(levels).select(function(levelText) {
            var dimSpecs = groupSpec_parseGroupingLevel(levelText, type);
            return new pvc.data.GroupingLevelSpec(dimSpecs,type);
        });
        return new pvc.data.GroupingSpec(levelSpecs,type);
    }
    ;
    var groupSpec_matchDimSpec = /^\s*(.+?)(?:\s+(asc|desc))?\s*$/i;
    def.type("pvc.data.DataOper").init(function(linkParent) {
        linkParent || def.fail.argumentRequired("linkParent");
        this._linkParent = linkParent;
    }).add({
        key: null,
        execute: def.method({
            isAbstract: !0
        })
    });
    def.type("pvc.data.GroupingOper", pvc.data.DataOper).init(function(linkParent, groupingSpecs, keyArgs) {
        groupingSpecs || def.fail.argumentRequired("groupingSpecs");
        this.base(linkParent, keyArgs);
        this._where = def.get(keyArgs, "where");
        this._visible = def.get(keyArgs, "visible", null);
        this._selected = def.get(keyArgs, "selected", null);
        var isNull = this._isNull = def.get(keyArgs, "isNull", null);
        this._postFilter = null != isNull ? function(d) {
            return d.isNull === isNull;
        }
        : null;
        var hasKey = null == this._selected
          , whereKey = "";
        if (this._where) {
            whereKey = def.get(keyArgs, "whereKey");
            if (!whereKey)
                if (keyArgs && null !== whereKey) {
                    whereKey = "" + def.nextId("dataOperWhereKey");
                    keyArgs.whereKey = whereKey;
                } else
                    hasKey = !1;
        }
        var ids = [];
        this._groupSpecs = def.array.as(groupingSpecs).map(function(groupSpec) {
            if (groupSpec instanceof pvc.data.GroupingSpec) {
                if (groupSpec.type !== linkParent.type)
                    throw def.error.argumentInvalid("groupingSpecText", "Invalid associated complex type.");
            } else
                groupSpec = pvc.data.GroupingSpec.parse(groupSpec, linkParent.type);
            ids.push(groupSpec.id);
            return groupSpec;
        });
        hasKey && (this.key = ids.join("!!") + "||visible:" + this._visible + "||isNull:" + this._isNull + "||where:" + whereKey);
    }).add({
        execute: function() {
            var datumsQuery = data_whereState(def.query(this._linkParent._datums), {
                visible: this._visible,
                selected: this._selected,
                where: this._where
            })
              , rootNode = this._group(datumsQuery);
            return this._generateData(rootNode, null, this._linkParent);
        },
        executeAdd: function(rootData, datums) {
            var datumsQuery = data_whereState(def.query(datums), {
                visible: this._visible,
                selected: this._selected,
                where: this._where
            })
              , rootNode = this._group(datumsQuery);
            this._generateData(rootNode, null, this._linkParent, rootData);
            return rootNode.datums;
        },
        _group: function(datumsQuery) {
            var rootNode = {
                isRoot: !0,
                treeHeight: def.query(this._groupSpecs).select(function(spec) {
                    var levelCount = spec.levels.length;
                    return levelCount ? spec.flatteningMode ? 1 : levelCount : 0;
                }).reduce(def.add, 0),
                datums: []
            };
            rootNode.treeHeight > 0 && this._groupSpecRecursive(rootNode, def.query(datumsQuery).array(), 0);
            return rootNode;
        },
        _groupSpecRecursive: function(groupParentNode, groupDatums, groupIndex) {
            var group = this._groupSpecs[groupIndex];
            group.flatteningMode ? this._groupSpecRecursiveFlattened(groupParentNode, groupDatums, group, groupIndex) : this._groupSpecRecursiveNormal(groupParentNode, groupDatums, group, groupIndex);
        },
        _groupSpecRecursiveNormal: function(groupParentNode, groupDatums, group, groupIndex) {
            function groupLevelRecursive(levelParentNode, levelDatums, levelIndex) {
                var level = levels[levelIndex]
                  , isLastLevel = levelIndex === L - 1
                  , isLastLevelOfLastGroupSpec = isLastGroup && isLastLevel;
                levelParentNode.groupSpec = group;
                levelParentNode.groupLevelSpec = level;
                for (var childNodes = levelParentNode.children = this._groupLevelDatums(level, levelParentNode, levelDatums, !1), i = 0, C = childNodes.length; C > i; i++) {
                    var childNode = childNodes[i];
                    if (!isLastLevelOfLastGroupSpec) {
                        var childDatums = childNode.datums;
                        childNode.datums = [];
                        isLastLevel ? this._groupSpecRecursive(childNode, childDatums, groupIndex + 1) : groupLevelRecursive.call(this, childNode, childDatums, levelIndex + 1);
                    }
                    def.array.append(levelParentNode.datums, childNode.datums);
                }
            }
            var levels = group.levels
              , L = levels.length
              , isLastGroup = groupIndex === this._groupSpecs.length - 1;
            groupParentNode.isRoot && (groupParentNode.label = group.rootLabel);
            groupLevelRecursive.call(this, groupParentNode, groupDatums, 0);
        },
        _groupSpecRecursiveFlattened: function(realGroupParentNode, groupDatums, group, groupIndex) {
            function groupLevelRecursive(levelParentNode, levelDatums, levelIndex) {
                for (var level = levels[levelIndex], isLastLevel = levelIndex === L - 1, isLastLevelOfLastGroupSpec = isLastGroup && isLastLevel, childNodes = this._groupLevelDatums(level, levelParentNode, levelDatums, !0), levelParentNodeDatums = isLastGroup ? levelParentNode.datums : [], i = 0, C = childNodes.length; C > i; i++) {
                    var childNode = childNodes[i]
                      , childDatums = childNode.datums;
                    def.array.lazy(levelParentNode, "_children").push(childNode);
                    if (def.hasOwn(flatChildrenByKey, childNode.key))
                        def.array.append(levelParentNodeDatums, childDatums);
                    else {
                        var specParentChildIndex = flatChildren.length;
                        if (!isPostOrder) {
                            addFlatChild(childNode);
                            levelParentNode.isFlattenGroup = !0;
                        }
                        if (!isLastLevelOfLastGroupSpec) {
                            childNode.datums = [];
                            isLastLevel ? this._groupSpecRecursive(childNode, childDatums, groupIndex + 1) : groupLevelRecursive.call(this, childNode, childDatums, levelIndex + 1);
                        }
                        def.array.append(levelParentNodeDatums, childNode.datums);
                        if (isPostOrder) {
                            if (def.hasOwn(flatChildrenByKey, childNode.key)) {
                                childNode.isFlattenGroup || def.assert("Must be a parent for duplicate keys to exist.");
                                if (1 === childNode._children.length) {
                                    flatChildren.splice(specParentChildIndex, flatChildren.length - specParentChildIndex);
                                    childNode.isDegenerateFlattenGroup = !0;
                                }
                            }
                            addFlatChild(childNode);
                            levelParentNode.isFlattenGroup = !0;
                        }
                    }
                }
                isLastGroup || this._groupSpecRecursive(levelParentNode, levelParentNodeDatums, groupIndex + 1);
            }
            var isPostOrder = group.flatteningMode === pvc.data.FlatteningMode.DfsPost
              , levels = group.levels
              , L = levels.length
              , isLastGroup = groupIndex === this._groupSpecs.length - 1
              , flatChildren = []
              , flatChildrenByKey = {};
            realGroupParentNode.children = flatChildren;
            realGroupParentNode.childrenByKey = flatChildrenByKey;
            var groupParentNode = {
                key: "",
                absKey: "",
                atoms: {},
                datums: [],
                label: group.rootLabel,
                dimNames: []
            }
              , addFlatChild = function(child) {
                flatChildren.push(child);
                flatChildrenByKey[child.key] = child;
            };
            isPostOrder || addFlatChild(groupParentNode);
            groupLevelRecursive.call(this, groupParentNode, groupDatums, 0);
            isPostOrder && addFlatChild(groupParentNode);
            realGroupParentNode.datums = groupParentNode.datums;
        },
        _groupLevelDatums: function(level, levelParentNode, levelDatums, doFlatten) {
            for (var keySep, childNodeList = [], childNodeMap = {}, postFilter = this._postFilter, datumComparer = level.comparer, nodeComparer = function(na, nb) {
                return datumComparer(na.firstDatum, nb.firstDatum);
            }, i = 0, L = levelDatums.length; L > i; i++) {
                var datum = levelDatums[i]
                  , key = level.key(datum)
                  , childNode = def.hasOwnProp.call(childNodeMap, key) && childNodeMap[key];
                if (childNode)
                    (!postFilter || postFilter(datum)) && childNode.datums.push(datum);
                else {
                    childNode = level.atomsInfo(datum);
                    childNode.key = key;
                    childNode.firstDatum = datum;
                    childNode.datums = !postFilter || postFilter(datum) ? [datum] : [];
                    if (doFlatten) {
                        keySep || (keySep = datum.owner.keySep);
                        this._onNewChildNodeFlattened(key, keySep, childNode, level, levelParentNode);
                    }
                    def.array.insert(childNodeList, childNode, nodeComparer);
                    childNodeMap[key] = childNode;
                }
            }
            if (postFilter) {
                i = childNodeList.length;
                for (; i--; )
                    childNodeList[i].datums.length || childNodeList.splice(i, 1);
            }
            return childNodeList;
        },
        _onNewChildNodeFlattened: function(key, keySep, childNode, level, levelParentNode) {
            def.copy(childNode.atoms, levelParentNode.atoms);
            childNode.dimNames = level.accDimensionNames();
            if (levelParentNode.dimNames.length) {
                var absKey = levelParentNode.absKey + keySep + key;
                childNode.absKey = absKey;
                childNode.key = pvc.data.Complex.rightTrimKeySep(absKey, keySep);
            } else
                childNode.absKey = key;
        },
        _generateData: function(node, parentNode, parentData, rootData) {
            var data, isNew;
            if (node.isRoot)
                if (rootData) {
                    data = rootData;
                    data_addDatumsLocal.call(data, node.datums);
                } else {
                    isNew = !0;
                    data = new pvc.data.Data({
                        linkParent: parentData,
                        datums: node.datums
                    });
                    data.treeHeight = node.treeHeight;
                    data._groupOper = this;
                }
            else {
                if (rootData) {
                    data = parentData.child(node.key);
                    data && data_addDatumsSimple.call(data, node.datums);
                }
                if (!data) {
                    isNew = !0;
                    var index, siblings;
                    rootData && (siblings = parentData.childNodes) && (index = ~def.array.binarySearch(siblings, node.datums[0], parentNode.groupLevelSpec.comparer));
                    data = new pvc.data.Data({
                        parent: parentData,
                        atoms: node.atoms,
                        atomsDimNames: node.dimNames,
                        datums: node.datums,
                        index: index
                    });
                }
            }
            if (isNew) {
                if (node.isFlattenGroup) {
                    data._isFlattenGroup = !0;
                    data._isDegenerateFlattenGroup = !!node.isDegenerateFlattenGroup;
                }
                var label = node.label;
                if (label) {
                    data.label += label;
                    data.absLabel += label;
                }
            }
            var childNodes = node.children
              , L = childNodes && childNodes.length;
            if (L) {
                if (isNew) {
                    data._groupSpec = node.groupSpec;
                    data._groupLevelSpec = node.groupLevelSpec;
                }
                for (var i = 0; L > i; i++)
                    this._generateData(childNodes[i], node, data, rootData);
            } else if (isNew && !node.isRoot) {
                var leafs = data.root._leafs;
                data.leafIndex = leafs.length;
                leafs.push(data);
            }
            return data;
        }
    });
    def.type("pvc.data.LinearInterpolationOper").init(function(baseData, partData, visibleData, catRole, serRole, valRole, stretchEnds) {
        this._newDatums = [];
        this._data = visibleData;
        var qAllCatDatas = catRole.flatten(baseData).children()
          , serDatas1 = serRole.isBound() ? serRole.flatten(partData, {
            visible: !0,
            isNull: !1
        }).children().array() : [null];
        this._isCatDiscrete = catRole.grouping.isDiscrete();
        this._firstCatDim = this._isCatDiscrete ? null : baseData.owner.dimensions(catRole.firstDimensionName());
        this._stretchEnds = stretchEnds;
        var valDim = this._valDim = baseData.owner.dimensions(valRole.firstDimensionName())
          , visibleKeyArgs = {
            visible: !0,
            zeroIfNone: !1
        };
        this._catInfos = qAllCatDatas.select(function(allCatData, catIndex) {
            var catData = visibleData.child(allCatData.key)
              , catInfo = {
                data: catData || allCatData,
                value: allCatData.value,
                isInterpolated: !1,
                serInfos: null,
                index: catIndex
            };
            catInfo.serInfos = serDatas1.map(function(serData1) {
                var group = catData;
                group && serData1 && (group = group.child(serData1.key));
                var value = group ? group.dimensions(valDim.name).value(visibleKeyArgs) : null;
                return {
                    data: serData1,
                    group: group,
                    value: value,
                    isNull: null == value,
                    catInfo: catInfo
                };
            });
            return catInfo;
        }).array();
        this._serCount = serDatas1.length;
        this._serStates = def.range(0, this._serCount).select(function(serIndex) {
            return new pvc.data.LinearInterpolationOperSeriesState(this,serIndex);
        }, this).array();
    }).add({
        interpolate: function() {
            for (var catInfo; catInfo = this._catInfos.shift(); )
                catInfo.serInfos.forEach(this._visitSeries, this);
            var newDatums = this._newDatums;
            newDatums.length && this._data.owner.add(newDatums);
        },
        _visitSeries: function(catSerInfo, serIndex) {
            this._serStates[serIndex].visit(catSerInfo);
        },
        nextUnprocessedNonNullCategOfSeries: function(serIndex) {
            for (var catIndex = 0, catCount = this._catInfos.length; catCount > catIndex; ) {
                var catInfo = this._catInfos[catIndex++]
                  , catSerInfo = catInfo.serInfos[serIndex];
                if (!catSerInfo.isNull)
                    return catSerInfo;
            }
        }
    });
    def.type("pvc.data.LinearInterpolationOperSeriesState").init(function(interpolation, serIndex) {
        this.interpolation = interpolation;
        this.index = serIndex;
        this._lastNonNull(null);
    }).add({
        visit: function(catSeriesInfo) {
            catSeriesInfo.isNull ? this._interpolate(catSeriesInfo) : this._lastNonNull(catSeriesInfo);
        },
        _lastNonNull: function(catSerInfo) {
            if (arguments.length) {
                this.__lastNonNull = catSerInfo;
                this.__nextNonNull = void 0;
            }
            return this.__lastNonNull;
        },
        _nextNonNull: function() {
            return this.__nextNonNull;
        },
        _initInterpData: function() {
            if (void 0 === this.__nextNonNull) {
                var last = this.__lastNonNull
                  , next = this.__nextNonNull = this.interpolation.nextUnprocessedNonNullCategOfSeries(this.index) || null;
                if (next && last) {
                    var fromValue = last.value
                      , toValue = next.value
                      , deltaValue = toValue - fromValue;
                    if (this.interpolation._isCatDiscrete) {
                        var stepCount = next.catInfo.index - last.catInfo.index;
                        stepCount >= 2 || def.assert("Must have at least one interpolation point.");
                        this._stepValue = deltaValue / stepCount;
                        this._middleIndex = ~~(stepCount / 2);
                        var dotCount = stepCount - 1;
                        this._isOdd = dotCount % 2 > 0;
                    } else {
                        var fromCat = +last.catInfo.value
                          , toCat = +next.catInfo.value
                          , deltaCat = toCat - fromCat;
                        this._steep = deltaValue / deltaCat;
                        this._middleCat = (toCat + fromCat) / 2;
                    }
                }
            }
        },
        _interpolate: function(catSerInfo) {
            this._initInterpData();
            var next = this.__nextNonNull
              , last = this.__lastNonNull
              , one = next || last;
            if (one) {
                var value, group, interpolation = this.interpolation, catInfo = catSerInfo.catInfo;
                if (next && last)
                    if (interpolation._isCatDiscrete) {
                        var groupIndex = catInfo.index - last.catInfo.index;
                        value = last.value + this._stepValue * groupIndex;
                        group = this._isOdd ? groupIndex < this._middleIndex ? last.group : next.group : groupIndex <= this._middleIndex ? last.group : next.group;
                    } else {
                        var cat = +catInfo.value
                          , lastCat = +last.catInfo.value;
                        value = last.value + this._steep * (cat - lastCat);
                        group = cat < this._middleCat ? last.group : next.group;
                    }
                else {
                    if (!interpolation._stretchEnds)
                        return;
                    value = one.value;
                    group = one.group;
                }
                var atoms = Object.create(group._datums[0].atoms);
                def.copyOwn(atoms, catInfo.data.atoms);
                var valueAtom = interpolation._valDim.intern(value, !0);
                atoms[valueAtom.dimension.name] = valueAtom;
                interpolation._newDatums.push(new pvc.data.InterpolationDatum(group.owner,atoms,"linear"));
            }
        }
    });
    def.type("pvc.data.ZeroInterpolationOper").init(function(baseData, partData, visibleData, catRole, serRole, valRole, stretchEnds) {
        this._newDatums = [];
        this._data = visibleData;
        var qAllCatDatas = catRole.flatten(baseData).children()
          , serDatas1 = serRole.isBound() ? serRole.flatten(partData, {
            visible: !0,
            isNull: !1
        }).children().array() : [null];
        this._isCatDiscrete = catRole.grouping.isDiscrete();
        this._firstCatDim = this._isCatDiscrete ? null : baseData.owner.dimensions(catRole.firstDimensionName());
        this._stretchEnds = stretchEnds;
        var valDim = this._valDim = baseData.owner.dimensions(valRole.firstDimensionName())
          , visibleKeyArgs = {
            visible: !0,
            zeroIfNone: !1
        };
        this._catInfos = qAllCatDatas.select(function(allCatData, catIndex) {
            var catData = visibleData.child(allCatData.key)
              , catInfo = {
                data: catData || allCatData,
                value: allCatData.value,
                isInterpolated: !1,
                serInfos: null,
                index: catIndex
            };
            catInfo.serInfos = serDatas1.map(function(serData1) {
                var group = catData;
                group && serData1 && (group = group.child(serData1.key));
                var value = group ? group.dimensions(valDim.name).value(visibleKeyArgs) : null;
                return {
                    data: serData1,
                    group: group,
                    value: value,
                    isNull: null == value,
                    catInfo: catInfo
                };
            });
            return catInfo;
        }).array();
        this._serCount = serDatas1.length;
        this._serStates = def.range(0, this._serCount).select(function(serIndex) {
            return new pvc.data.ZeroInterpolationOperSeriesState(this,serIndex);
        }, this).array();
    }).add({
        interpolate: function() {
            for (var catInfo; catInfo = this._catInfos.shift(); )
                catInfo.serInfos.forEach(this._visitSeries, this);
            var newDatums = this._newDatums;
            newDatums.length && this._data.owner.add(newDatums);
        },
        _visitSeries: function(catSerInfo, serIndex) {
            this._serStates[serIndex].visit(catSerInfo);
        },
        nextUnprocessedNonNullCategOfSeries: function(serIndex) {
            for (var catIndex = 0, catCount = this._catInfos.length; catCount > catIndex; ) {
                var catInfo = this._catInfos[catIndex++]
                  , catSerInfo = catInfo.serInfos[serIndex];
                if (!catSerInfo.isNull)
                    return catSerInfo;
            }
        }
    });
    def.type("pvc.data.ZeroInterpolationOperSeriesState").init(function(interpolation, serIndex) {
        this.interpolation = interpolation;
        this.index = serIndex;
        this._lastNonNull(null);
    }).add({
        visit: function(catSeriesInfo) {
            catSeriesInfo.isNull ? this._interpolate(catSeriesInfo) : this._lastNonNull(catSeriesInfo);
        },
        _lastNonNull: function(catSerInfo) {
            if (arguments.length) {
                this.__lastNonNull = catSerInfo;
                this.__nextNonNull = void 0;
            }
            return this.__lastNonNull;
        },
        _nextNonNull: function() {
            return this.__nextNonNull;
        },
        _initInterpData: function() {
            if (void 0 === this.__nextNonNull) {
                var last = this.__lastNonNull
                  , next = this.__nextNonNull = this.interpolation.nextUnprocessedNonNullCategOfSeries(this.index) || null;
                if (next && last) {
                    {
                        last.value,
                        next.value;
                    }
                    if (this.interpolation._isCatDiscrete) {
                        var stepCount = next.catInfo.index - last.catInfo.index;
                        stepCount >= 2 || def.assert("Must have at least one interpolation point.");
                        this._middleIndex = ~~(stepCount / 2);
                        var dotCount = stepCount - 1;
                        this._isOdd = dotCount % 2 > 0;
                    } else {
                        var fromCat = +last.catInfo.value
                          , toCat = +next.catInfo.value;
                        this._middleCat = (toCat + fromCat) / 2;
                    }
                }
            }
        },
        _interpolate: function(catSerInfo) {
            this._initInterpData();
            var next = this.__nextNonNull
              , last = this.__lastNonNull
              , one = next || last;
            if (one) {
                var group, interpolation = this.interpolation, catInfo = catSerInfo.catInfo;
                if (next && last)
                    if (interpolation._isCatDiscrete) {
                        var groupIndex = catInfo.index - last.catInfo.index;
                        group = this._isOdd ? groupIndex < this._middleIndex ? last.group : next.group : groupIndex <= this._middleIndex ? last.group : next.group;
                    } else {
                        var cat = +catInfo.value;
                        group = cat < this._middleCat ? last.group : next.group;
                    }
                else {
                    if (!interpolation._stretchEnds)
                        return;
                    group = one.group;
                }
                var atoms = Object.create(group._datums[0].atoms);
                def.copyOwn(atoms, catInfo.data.atoms);
                var zeroAtom = interpolation._zeroAtom || (interpolation._zeroAtom = interpolation._valDim.intern(0, !0));
                atoms[zeroAtom.dimension.name] = zeroAtom;
                interpolation._newDatums.push(new pvc.data.InterpolationDatum(group.owner,atoms,"zero"));
            }
        }
    });
    pvc.data.Data.add({
        load: function(atomz, keyArgs) {
            data_assertIsOwner.call(this);
            var whereFun = def.get(keyArgs, "where")
              , isNullFun = def.get(keyArgs, "isNull")
              , datums = def.query(atomz).select(function(atoms) {
                var datum = new pvc.data.Datum(this,atoms);
                isNullFun && isNullFun(datum) && (datum.isNull = !0);
                return whereFun && !whereFun(datum) ? null : datum;
            }, this);
            data_setDatums.call(this, datums, {
                isAdditive: !1,
                doAtomGC: !0
            });
        },
        clearVirtuals: function() {
            var datums = this._datums;
            if (datums) {
                this._sumAbsCache = null;
                for (var removed, visDatums = this._visibleNotNullDatums, selDatums = this._selectedNotNullDatums, datumsByKey = this._datumsByKey, datumsById = this._datumsById, i = 0, L = datums.length; L > i; ) {
                    var datum = datums[i];
                    if (datum.isVirtual) {
                        var id = datum.id
                          , key = datum.key;
                        datums.splice(i, 1);
                        delete datumsById[id];
                        delete datumsByKey[key];
                        selDatums && datum.isSelected && selDatums.rem(id);
                        datum.isVisible && visDatums.rem(id);
                        L--;
                        removed = !0;
                    } else
                        i++;
                }
                if (removed) {
                    if (!datums.length && this.parent) {
                        this.dispose();
                        return;
                    }
                    var children = this.childNodes;
                    if (children) {
                        i = 0;
                        L = children.length;
                        for (; L > i; ) {
                            var childData = children[i];
                            childData.clearVirtuals();
                            childData.parent ? i++ : L--;
                        }
                    }
                    this._linkChildren && this._linkChildren.forEach(function(linkChildData) {
                        linkChildData.clearVirtuals();
                    });
                }
            }
            def.eachOwn(this._dimensions, function(dim) {
                dim_uninternVirtualAtoms.call(dim);
            });
        },
        add: function(datums) {
            data_assertIsOwner.call(this);
            data_setDatums.call(this, datums, {
                isAdditive: !0,
                doAtomGC: !0
            });
        },
        groupBy: function(groupingSpecText, keyArgs) {
            var groupByCache, data, groupOper = new pvc.data.GroupingOper(this,groupingSpecText,keyArgs), cacheKey = groupOper.key;
            if (cacheKey) {
                groupByCache = this._groupByCache;
                data = groupByCache && groupByCache[cacheKey];
            }
            if (data)
                pvc.debug >= 7 && pvc.log("[GroupBy] Cache key hit '" + cacheKey + "'");
            else {
                pvc.debug >= 7 && pvc.log("[GroupBy] " + (cacheKey ? "Cache key not found: '" + cacheKey + "'" : "No Cache key"));
                data = groupOper.execute();
                cacheKey && ((groupByCache || (this._groupByCache = {}))[cacheKey] = data);
            }
            return data;
        },
        where: function(whereSpec, keyArgs) {
            var datums;
            if (whereSpec) {
                whereSpec = data_processWhereSpec.call(this, whereSpec, keyArgs);
                datums = data_where.call(this, whereSpec, keyArgs);
            } else {
                if (!keyArgs)
                    return def.query(this._datums);
                datums = data_whereState(def.query(this._datums), keyArgs);
            }
            var where = data_wherePredicate(whereSpec, keyArgs);
            return new pvc.data.Data({
                linkParent: this,
                datums: datums,
                where: where
            });
        },
        datums: function(whereSpec, keyArgs) {
            if (!whereSpec)
                return keyArgs ? data_whereState(def.query(this._datums), keyArgs) : def.query(this._datums);
            whereSpec = data_processWhereSpec.call(this, whereSpec, keyArgs);
            return data_where.call(this, whereSpec, keyArgs);
        },
        datum: function(whereSpec, keyArgs) {
            whereSpec || def.fail.argumentRequired("whereSpec");
            whereSpec = data_processWhereSpec.call(this, whereSpec, keyArgs);
            return data_where.call(this, whereSpec, keyArgs).first() || null;
        },
        dimensionsSumAbs: function(dimName, keyArgs) {
            var key = dimName + ":" + dim_buildDatumsFilterKey(keyArgs)
              , sum = def.getOwn(this._sumAbsCache, key);
            if (null == sum) {
                sum = this.children().where(function(childData) {
                    return !childData._isFlattenGroup || childData._isDegenerateFlattenGroup;
                }).select(function(childData) {
                    return childData.dimensions(dimName).valueAbs(keyArgs) || 0;
                }, this).reduce(def.add, 0);
                (this._sumAbsCache || (this._sumAbsCache = {}))[key] = sum;
            }
            return sum;
        }
    });
    pvc.data.Data.add({
        getInfo: function() {
            var out = ["DATA SUMMARY", pvc.logSeparator, "  Dimension", pvc.logSeparator];
            def.eachOwn(this.dimensions(), function(dimension, name) {
                var count = dimension.count()
                  , type = dimension.type
                  , features = [];
                features.push('"' + type.label + '"');
                features.push(type.valueTypeName);
                type.isComparable && features.push("comparable");
                type.isDiscrete || features.push("continuous");
                type.isHidden && features.push("hidden");
                out.push("  " + name + " (" + features.join(", ") + ") (" + count + ")\n	" + dimension.atoms().slice(0, 10).map(function(atom) {
                    return atom.label;
                }).join(", ") + (count > 10 ? "..." : ""));
            });
            return out.join("\n");
        },
        getValues: function() {
            return pv.range(0, this.getCategoriesSize()).map(function(categIndex) {
                return this._getValuesForCategoryIndex(categIndex);
            }, this);
        },
        _getDimensionValues: function(name) {
            return this.dimensions(name).atoms().map(function(atom) {
                return atom.value;
            });
        },
        _getDimensionVisibleValues: function(name) {
            return this.dimensions(name).atoms({
                visible: !0
            }).map(function(atom) {
                return atom.value;
            });
        },
        getSeries: function() {
            return this._getDimensionValues("series");
        },
        getVisibleSeriesIndexes: function() {
            return this.dimensions("series").indexes({
                visible: !0
            });
        },
        getVisibleCategoriesIndexes: function() {
            return this.dimensions("category").indexes({
                visible: !0
            });
        },
        getVisibleSeries: function() {
            return this._getDimensionVisibleValues("series");
        },
        getCategories: function() {
            return this._getDimensionValues("category");
        },
        getVisibleCategories: function() {
            return this._getDimensionVisibleValues("category");
        },
        _getValuesForCategoryIndex: function(categIdx) {
            var categAtom = this.dimensions("category").atoms()[categIdx]
              , datumsBySeriesKey = this.datums({
                category: categAtom
            }).uniqueIndex(function(datum) {
                return datum.atoms.series.key;
            });
            return this.dimensions("series").atoms().map(function(atom) {
                var datum = def.getOwn(datumsBySeriesKey, atom.key);
                return datum ? datum.atoms.value.value : null;
            });
        },
        getSeriesSize: function() {
            var dim = this.dimensions("series", {
                assertExists: !1
            });
            return dim ? dim.count() : 0;
        },
        getCategoriesSize: function() {
            var dim = this.dimensions("category", {
                assertExists: !1
            });
            return dim ? dim.count() : 0;
        }
    });
    def.scope(function() {
        var I = def.makeEnum(["Interactive", "ShowsActivity", "ShowsSelection", "ShowsTooltip", "Selectable", "Unselectable", "Hoverable", "Clickable", "DoubleClickable", "SelectableByClick", "SelectableByRubberband", "SelectableByFocusWindow", "Animatable"]);
        I.ShowsInteraction = I.ShowsActivity | I.ShowsSelection;
        I.Actionable = I.Hoverable | I.Clickable | I.DoubleClickable | I.SelectableByClick;
        I.HandlesEvents = I.Actionable | I.ShowsTooltip;
        I.HandlesClickEvent = I.Clickable | I.SelectableByClick;
        def.type("pvc.visual.Interactive").addStatic(I).addStatic({
            ShowsAny: I.ShowsInteraction | I.ShowsTooltip,
            SelectableAny: I.Selectable | I.SelectableByClick | I.SelectableByRubberband | I.SelectableByFocusWindow
        }).add({
            _ibits: -1
        }).add(def.query(def.ownKeys(I)).object({
            name: def.firstLowerCase,
            value: function(p) {
                var mask = I[p];
                return function() {
                    return !!(this._ibits & mask);
                }
                ;
            }
        }));
    });
    def.type("pvc.visual.Scene").init(function(parent, keyArgs) {
        pvc.debug >= 4 && (this.id = def.nextId("scene"));
        this._renderId = 0;
        this.renderState = {};
        pv.Dom.Node.call(this, null);
        this.parent = parent || null;
        if (parent) {
            this.root = parent.root;
            var index = def.get(keyArgs, "index", null);
            parent.insertAt(this, index);
        } else {
            this.root = this;
            this._active = null;
            this._panel = def.get(keyArgs, "panel") || def.fail.argumentRequired("panel", "Argument is required on root scene.");
        }
        var first, group, datum, datums, groups, atoms, firstAtoms, dataSource = def.array.to(def.get(keyArgs, "source"));
        if (dataSource && dataSource.length) {
            this.source = dataSource;
            first = dataSource[0];
            if (first instanceof pvc.data.Data) {
                group = first;
                groups = dataSource;
                datum = group.firstDatum() || def.query(groups).select(function(g) {
                    return g.firstDatum();
                }).first(def.notNully);
            } else {
                first instanceof pvc.data.Datum || def.assert("not a datum");
                datum = first;
                datums = dataSource;
            }
            atoms = first.atoms;
            firstAtoms = datum && datum.atoms || first.atoms;
        } else
            atoms = firstAtoms = parent ? Object.create(parent.atoms) : {};
        this.atoms = atoms;
        this.firstAtoms = firstAtoms;
        groups && (this.groups = groups);
        group && (this.group = group);
        datums && (this._datums = datums);
        datum && (this.datum = datum);
        (!first || first.isNull) && (this.isNull = !0);
        this.vars = parent ? Object.create(parent.vars) : {};
    }).add(pv.Dom.Node).add(pvc.visual.Interactive).add({
        source: null,
        groups: null,
        group: null,
        _datums: null,
        datum: null,
        isNull: !1,
        get: function(name, prop) {
            var avar = this.vars[name];
            return avar && avar[prop || "value"];
        },
        getSeries: function() {
            return this.get("series");
        },
        getCategory: function() {
            return this.get("category");
        },
        getValue: function() {
            return this.get("value");
        },
        getTick: function() {
            return this.get("tick");
        },
        getX: function() {
            return this.get("x");
        },
        getY: function() {
            return this.get("y");
        },
        getSeriesLabel: function() {
            return this.get("series", "label");
        },
        getCategoryLabel: function() {
            return this.get("category", "label");
        },
        getValueLabel: function() {
            return this.get("value", "label");
        },
        getTickLabel: function() {
            return this.get("tick", "label");
        },
        getXLabel: function() {
            return this.get("x", "label");
        },
        getYLabel: function() {
            return this.get("y", "label");
        },
        data: function() {
            var data = this.group;
            if (!data) {
                for (var scene = this; !data && (scene = scene.parent); )
                    data = scene.group;
                data || (data = this.panel.data);
            }
            return data;
        },
        datums: function() {
            return this.groups ? def.query(this.groups).selectMany(function(g) {
                return g.datums();
            }) : this._datums ? def.query(this._datums) : def.query();
        },
        format: function(mask) {
            return def.format(mask, this._formatScope, this);
        },
        _formatScope: function(prop) {
            if ("#" === prop.charAt(0)) {
                prop = prop.substr(1).split(".");
                if (prop.length > 2)
                    throw def.error.operationInvalid("Scene format mask is invalid.");
                var atom = this.firstAtoms[prop[0]];
                if (atom) {
                    if (prop.length > 1)
                        switch (prop[1]) {
                        case "value":
                            return atom.value;

                        case "label":
                            break;

                        default:
                            throw def.error.operationInvalid("Scene format mask is invalid.");
                        }
                    return atom;
                }
                return null;
            }
            return def.getPath(this.vars, prop);
        },
        isRoot: function() {
            return this.root === this;
        },
        panel: function() {
            return this.root._panel;
        },
        chart: function() {
            return this.root._panel.chart;
        },
        compatVersion: function() {
            return this.root._panel.compatVersion();
        },
        children: function() {
            var cs = this.childNodes;
            return cs.length ? def.query(cs) : def.query();
        },
        leafs: function() {
            function getFirstLeafFrom(leaf) {
                for (; leaf.childNodes.length; )
                    leaf = leaf.childNodes[0];
                return leaf;
            }
            var root = this;
            return def.query(function(nextIndex) {
                if (!nextIndex) {
                    var item = getFirstLeafFrom(root);
                    if (item === root)
                        return 0;
                    this.item = item;
                    return 1;
                }
                var next = this.item.nextSibling;
                if (next) {
                    this.item = next;
                    return 1;
                }
                for (var current = this.item; current !== root && (current = current.parentNode); )
                    if (next = current.nextSibling) {
                        this.item = getFirstLeafFrom(next);
                        return 1;
                    }
                return 0;
            });
        },
        anyInteraction: function() {
            return !!this.root._active || this.anySelected();
        },
        isActive: !1,
        setActive: function(isActive) {
            isActive = !!isActive;
            this.isActive !== isActive && rootScene_setActive.call(this.root, this.isActive ? null : this);
        },
        clearActive: function() {
            return rootScene_setActive.call(this.root, null);
        },
        anyActive: function() {
            return !!this.root._active;
        },
        active: function() {
            return this.root._active;
        },
        activeSeries: function() {
            var seriesVar, active = this.active();
            return active && (seriesVar = active.vars.series) && seriesVar.value;
        },
        isActiveSeries: function() {
            if (this.isActive)
                return !0;
            var isActiveSeries = this.renderState.isActiveSeries;
            if (null == isActiveSeries) {
                var activeSeries;
                isActiveSeries = null != (activeSeries = this.activeSeries()) && activeSeries === this.vars.series.value;
                this.renderState.isActiveSeries = isActiveSeries;
            }
            return isActiveSeries;
        },
        isActiveDatum: function() {
            return this.isActive ? !0 : !1;
        },
        isActiveDescendantOrSelf: function() {
            return this.isActive ? !0 : def.lazy(this.renderState, "isActiveDescOrSelf", this._calcIsActiveDescOrSelf, this);
        },
        _calcIsActiveDescOrSelf: function() {
            var scene = this.active();
            if (scene)
                for (; scene = scene.parent; )
                    if (scene === this)
                        return !0;
            return !1;
        },
        isVisible: function() {
            return this._visibleInfo().is;
        },
        anyVisible: function() {
            return this._visibleInfo().any;
        },
        _visibleInfo: function() {
            return def.lazy(this.renderState, "visibleInfo", this._createVisibleInfo, this);
        },
        _createVisibleInfo: function() {
            var any = this.chart().data.owner.visibleCount() > 0
              , isSelected = any && this.datums().any(def.propGet("isVisible"));
            return {
                any: any,
                is: isSelected
            };
        },
        isSelected: function() {
            return this._selectedInfo().is;
        },
        anySelected: function() {
            return this._selectedInfo().any;
        },
        _selectedInfo: function() {
            return def.lazy(this.renderState, "selectedInfo", this._createSelectedInfo, this);
        },
        _createSelectedInfo: function() {
            var any = this.chart().data.owner.selectedCount() > 0
              , isSelected = any && this.datums().any(datum_isSelected);
            return {
                any: any,
                is: isSelected
            };
        },
        select: function(ka) {
            var me = this
              , datums = me.datums().array();
            if (datums.length) {
                var chart = me.chart();
                chart._updatingSelections(function() {
                    datums = chart._onUserSelection(datums);
                    datums && datums.length && (chart.options.ctrlSelectMode && def.get(ka, "replace", !0) ? chart.data.replaceSelected(datums) : pvc.data.Data.toggleSelected(datums));
                });
            }
        },
        isSelectedDescendantOrSelf: function() {
            return this.isSelected() ? !0 : def.lazy(this.renderState, "isSelectedDescOrSelf", this._calcIsSelectedDescOrSelf, this);
        },
        _calcIsSelectedDescOrSelf: function() {
            var child = this.firstChild;
            if (child)
                do
                    if (child.isSelectedDescendantOrSelf())
                        return !0;
                while (child = child.nextSibling);return !1;
        },
        toggleVisible: function() {
            pvc.data.Data.toggleVisible(this.datums()) && this.chart().render(!0, !0, !1);
        }
    });
    pvc.visual.Scene.prototype.variable = function(name, impl) {
        var methods, proto = this;
        if (proto._vars && proto._vars[name])
            void 0 !== impl && (methods = def.set({}, "_" + name + "EvalCore", def.fun.to(impl)));
        else {
            proto.hasOwnProperty("_vars") || (proto._vars = def.create(proto._vars));
            proto._vars[name] = !0;
            methods = {};
            var nameEval = "_" + name + "Eval";
            methods[name] = scene_createVarMainMethod(name, nameEval);
            var nameEvalCore = nameEval + "Core";
            def.hasOwn(proto, nameEval) || (methods[nameEval] = def.methodCaller(nameEvalCore));
            def.hasOwn(proto, nameEvalCore) || (methods[nameEvalCore] = def.fun.to(void 0 === impl ? null : impl));
        }
        methods && proto.constructor.add(methods);
        return proto;
    }
    ;
    var pvc_ValueLabelVar = pvc.visual.ValueLabelVar = function(value, label, rawValue, absLabel) {
        this.value = value;
        this.label = label;
        void 0 !== rawValue && (this.rawValue = rawValue);
        void 0 !== absLabel && (this.absLabel = absLabel);
    }
    ;
    def.set(pvc_ValueLabelVar.prototype, "rawValue", void 0, "absLabel", void 0, "setValue", function(v) {
        this.value = v;
        return this;
    }, "setLabel", function(v) {
        this.label = v;
        return this;
    }, "clone", function() {
        return new pvc_ValueLabelVar(this.value,this.label,this.rawValue);
    }, "toString", function() {
        var label = this.label || this.value;
        return null == label ? "" : "string" != typeof label ? "" + label : label;
    });
    pvc_ValueLabelVar.fromComplex = function(complex) {
        return complex ? new pvc_ValueLabelVar(complex.value,complex.label,complex.rawValue,complex.absLabel) : new pvc_ValueLabelVar(null,"",null);
    }
    ;
    pvc_ValueLabelVar.fromAtom = pvc_ValueLabelVar.fromComplex;
    def.type("pvc.visual.Context").init(function(panel, mark, scene) {
        this.chart = panel.chart;
        this.panel = panel;
        visualContext_update.call(this, mark, scene);
    }).add({
        isPinned: !1,
        pin: function() {
            this.isPinned = !0;
            return this;
        },
        compatVersion: function() {
            return this.panel.compatVersion();
        },
        finished: function(v) {
            return this.sign.finished(v);
        },
        delegate: function(dv) {
            return this.sign.delegate(dv);
        },
        getV1Series: function() {
            var s;
            return def.nullyTo(this.scene.firstAtoms && (s = this.scene.firstAtoms[this.panel._getV1DimName("series")]) && s.rawValue, "Series");
        },
        getV1Category: function() {
            var c;
            return this.scene.firstAtoms && (c = this.scene.firstAtoms[this.panel._getV1DimName("category")]) && c.rawValue;
        },
        getV1Value: function() {
            var v;
            return this.scene.firstAtoms && (v = this.scene.firstAtoms[this.panel._getV1DimName("value")]) && v.value;
        },
        getV1Datum: function() {
            return this.panel._getV1Datum(this.scene);
        },
        get: function(name, prop) {
            return this.scene.get(name, prop);
        },
        getSeries: function() {
            return this.scene.get("series");
        },
        getCategory: function() {
            return this.scene.get("category");
        },
        getValue: function() {
            return this.scene.get("value");
        },
        getTick: function() {
            return this.scene.get("tick");
        },
        getX: function() {
            return this.scene.get("x");
        },
        getY: function() {
            return this.scene.get("y");
        },
        getSeriesLabel: function() {
            return this.scene.get("series", "label");
        },
        getCategoryLabel: function() {
            return this.scene.get("category", "label");
        },
        getValueLabel: function() {
            return this.scene.get("value", "label");
        },
        getTickLabel: function() {
            return this.scene.get("tick", "label");
        },
        getXLabel: function() {
            return this.scene.get("x", "label");
        },
        getYLabel: function() {
            return this.scene.get("y", "label");
        },
        select: function(ka) {
            return this.scene.select(ka);
        },
        toggleVisible: function() {
            return this.scene.toggleVisible();
        },
        click: function() {
            var me = this;
            me.clickable() && me.panel._onClick(me);
            if (me.selectableByClick()) {
                var ev = me.event;
                me.select({
                    replace: !ev || !ev.ctrlKey
                });
            }
        },
        doubleClick: function() {
            this.doubleClickable() && this.panel._onDoubleClick(this);
        },
        clickable: function() {
            var me = this;
            return (me.sign ? me.sign.clickable() : me.panel.clickable()) && (!me.scene || me.scene.clickable());
        },
        selectableByClick: function() {
            var me = this;
            return (me.sign ? me.sign.selectableByClick() : me.panel.selectableByClick()) && (!me.scene || me.scene.selectableByClick());
        },
        doubleClickable: function() {
            var me = this;
            return (me.sign ? me.sign.doubleClickable() : me.panel.doubleClickable()) && (!me.scene || me.scene.doubleClickable());
        },
        hoverable: function() {
            var me = this;
            return (me.sign ? me.sign.hoverable() : me.panel.hoverable()) && (!me.scene || me.scene.hoverable());
        }
    });
    if (Object.defineProperty)
        try {
            Object.defineProperty(pvc.visual.Context.prototype, "parent", {
                get: function() {
                    throw def.error.operationInvalid("The 'this.parent.index' idiom has no equivalent in this version. Please try 'this.pvMark.parent.index'.");
                }
            });
        } catch (ex) {}
    def.space("pvc.visual").TraversalMode = def.makeEnum(["Tree", "FlattenedSingleLevel", "FlattenDfsPre", "FlattenDfsPost"]);
    def.type("pvc.visual.Role").init(function(name, keyArgs) {
        this.name = name;
        this.label = def.get(keyArgs, "label") || pvc.buildTitleFromName(name);
        this.index = def.get(keyArgs, "index") || 0;
        this.dimensionDefaults = def.get(keyArgs, "dimensionDefaults") || {};
        def.get(keyArgs, "isRequired", !1) && (this.isRequired = !0);
        def.get(keyArgs, "autoCreateDimension", !1) && (this.autoCreateDimension = !0);
        var defaultSourceRoleName = def.get(keyArgs, "defaultSourceRole");
        defaultSourceRoleName && (this.defaultSourceRoleName = defaultSourceRoleName);
        var defaultDimensionName = def.get(keyArgs, "defaultDimension");
        defaultDimensionName && (this.defaultDimensionName = defaultDimensionName);
        if (!defaultDimensionName && this.autoCreateDimension)
            throw def.error.argumentRequired("defaultDimension");
        var requireSingleDimension, requireIsDiscrete = def.get(keyArgs, "requireIsDiscrete");
        null != requireIsDiscrete && (requireIsDiscrete || (requireSingleDimension = !0));
        if (null != requireSingleDimension) {
            requireSingleDimension = def.get(keyArgs, "requireSingleDimension", !1);
            if (requireSingleDimension) {
                if (def.get(keyArgs, "isMeasure", !1)) {
                    this.isMeasure = !0;
                    def.get(keyArgs, "isPercent", !1) && (this.isPercent = !0);
                }
                var valueType = def.get(keyArgs, "valueType", null);
                if (valueType !== this.valueType) {
                    this.valueType = valueType;
                    this.dimensionDefaults.valueType = valueType;
                }
            }
        }
        requireSingleDimension !== this.requireSingleDimension && (this.requireSingleDimension = requireSingleDimension);
        if (requireIsDiscrete != this.requireIsDiscrete) {
            this.requireIsDiscrete = !!requireIsDiscrete;
            this.dimensionDefaults.isDiscrete = this.requireIsDiscrete;
        }
        var traversalMode = def.get(keyArgs, "traversalMode");
        null != traversalMode && traversalMode !== this.traversalMode && (this.traversalMode = traversalMode);
    }).add({
        isRequired: !1,
        requireSingleDimension: !1,
        valueType: null,
        requireIsDiscrete: null,
        isMeasure: !1,
        isPercent: !1,
        defaultSourceRoleName: null,
        defaultDimensionName: null,
        grouping: null,
        traversalMode: pvc.visual.TraversalMode.FlattenedSingleLevel,
        rootLabel: "",
        autoCreateDimension: !1,
        isReversed: !1,
        label: null,
        sourceRole: null,
        isDefaultSourceRole: !1,
        firstDimensionType: function() {
            var g = this.grouping;
            return g && g.firstDimensionType();
        },
        firstDimensionName: function() {
            var g = this.grouping;
            return g && g.firstDimensionName();
        },
        firstDimensionValueType: function() {
            var g = this.grouping;
            return g && g.firstDimensionValueType();
        },
        isDiscrete: function() {
            var g = this.grouping;
            return g && g.isDiscrete();
        },
        setSourceRole: function(sourceRole, isDefault) {
            this.sourceRole = sourceRole;
            this.isDefaultSourceRole = !!isDefault;
        },
        setIsReversed: function(isReversed) {
            isReversed ? this.isReversed = !0 : delete this.isReversed;
        },
        setTraversalMode: function(travMode) {
            var T = pvc.visual.TraversalMode;
            travMode = def.nullyTo(travMode, T.FlattenedSingleLevel);
            travMode !== this.traversalMode && (travMode === T.FlattenedSingleLevel ? delete this.traversalMode : this.traversalMode = travMode);
        },
        setRootLabel: function(rootLabel) {
            if (rootLabel !== this.rootLabel) {
                rootLabel ? this.rootLabel = rootLabel : delete this.rootLabel;
                this.grouping && this._updateBind(this.grouping);
            }
        },
        flatten: function(data, keyArgs) {
            var grouping = this.flattenedGrouping(keyArgs) || def.fail.operationInvalid("Role is unbound.");
            return data.groupBy(grouping, keyArgs);
        },
        flattenedGrouping: function(keyArgs) {
            var grouping = this.grouping;
            if (grouping) {
                keyArgs = keyArgs ? Object.create(keyArgs) : {};
                var flatMode = keyArgs.flatteningMode;
                null == flatMode && (flatMode = keyArgs.flatteningMode = this._flatteningMode());
                null != keyArgs.isSingleLevel || flatMode || (keyArgs.isSingleLevel = !0);
                return grouping.ensure(keyArgs);
            }
        },
        _flatteningMode: function() {
            var T = pvc.visual.TraversalMode
              , F = pvc.data.FlatteningMode;
            switch (this.traversalMode) {
            case T.FlattenDfsPre:
                return F.DfsPre;

            case T.FlattenDfsPost:
                return F.DfsPost;
            }
            return T.None;
        },
        select: function(data, keyArgs) {
            var grouping = this.grouping;
            if (grouping) {
                def.setUDefaults(keyArgs, "flatteningMode", pvc.data.FlatteningMode.None);
                return data.groupBy(grouping.ensure(keyArgs), keyArgs);
            }
        },
        view: function(complex) {
            var grouping = this.grouping;
            return grouping ? grouping.view(complex) : void 0;
        },
        preBind: function(groupingSpec) {
            this.__grouping = groupingSpec;
            return this;
        },
        isPreBound: function() {
            return !!this.__grouping;
        },
        preBoundGrouping: function() {
            return this.__grouping;
        },
        isBound: function() {
            return !!this.grouping;
        },
        postBind: function(type) {
            var grouping = this.__grouping;
            if (grouping) {
                delete this.__grouping;
                grouping.bind(type);
                this.bind(grouping);
            }
            return this;
        },
        bind: function(groupingSpec) {
            groupingSpec = this._validateBind(groupingSpec);
            this._updateBind(groupingSpec);
            return this;
        },
        _validateBind: function(groupingSpec) {
            if (groupingSpec)
                if (groupingSpec.isNull())
                    groupingSpec = null;
                else {
                    if (this.requireSingleDimension && !groupingSpec.isSingleDimension)
                        throw def.error.operationInvalid("Role '{0}' only accepts a single dimension.", [this.name]);
                    var valueType = this.valueType
                      , requireIsDiscrete = this.requireIsDiscrete;
                    groupingSpec.dimensions().each(function(dimSpec) {
                        var dimType = dimSpec.type;
                        if (valueType && dimType.valueType !== valueType)
                            throw def.error.operationInvalid("Role '{0}' cannot be bound to dimension '{1}'. \nIt only accepts dimensions of type '{2}' and not of type '{3}'.", [this.name, dimType.name, pvc.data.DimensionType.valueTypeName(valueType), dimType.valueTypeName]);
                        if (null != requireIsDiscrete && dimType.isDiscrete !== requireIsDiscrete) {
                            if (!requireIsDiscrete)
                                throw def.error.operationInvalid("Role '{0}' cannot be bound to dimension '{1}'. \nIt only accepts {2} dimensions.", [this.name, dimType.name, requireIsDiscrete ? "discrete" : "continuous"]);
                            dimType._toDiscrete();
                        }
                    }, this);
                }
            return groupingSpec;
        },
        _updateBind: function(groupingSpec) {
            this.grouping && this.grouping.dimensions().each(function(dimSpec) {
                dimSpec.type && dimType_removeVisualRole.call(dimSpec.type, this);
            }, this);
            this.grouping = groupingSpec;
            if (this.grouping) {
                this.grouping = this.grouping.ensure({
                    reverse: this.isReversed,
                    rootLabel: this.rootLabel
                });
                this.grouping.dimensions().each(function(dimSpec) {
                    dimType_addVisualRole.call(dimSpec.type, this);
                }, this);
            }
        }
    });
    def.type("pvc.visual.RoleVarHelper").init(function(rootScene, role, keyArgs) {
        var hasPercentSubVar = def.get(keyArgs, "hasPercentSubVar", !1)
          , roleVarName = def.get(keyArgs, "roleVar")
          , g = this.grouping = role && role.grouping;
        if (g) {
            this.role = role;
            this.sourceRoleName = role.sourceRole && role.sourceRole.name;
            var panel = rootScene.panel();
            this.panel = panel;
            if (!g.isDiscrete()) {
                this.rootContDim = panel.data.owner.dimensions(g.firstDimensionName());
                hasPercentSubVar && (this.percentFormatter = panel.chart.options.percentValueFormat);
            }
        }
        if (!roleVarName) {
            if (!role)
                throw def.error.operationInvalid("Role is not defined, so the roleVar argument is required.");
            roleVarName = role.name;
        }
        if (!g) {
            var roleVar = rootScene.vars[roleVarName] = new pvc_ValueLabelVar(null,"");
            hasPercentSubVar && (roleVar.percent = new pvc_ValueLabelVar(null,""));
        }
        this.roleVarName = roleVarName;
        rootScene["is" + def.firstUpperCase(roleVarName) + "Bound"] = !!g;
        def.get(keyArgs, "allowNestedVars") && (this.allowNestedVars = !0);
    }).add({
        allowNestedVars: !1,
        isBound: function() {
            return !!this.grouping;
        },
        onNewScene: function(scene, isLeaf) {
            if (this.grouping) {
                var roleVarName = this.roleVarName;
                if (this.allowNestedVars ? !def.hasOwnProp.call(scene.vars, roleVarName) : !scene.vars[roleVarName]) {
                    var sourceName = this.sourceRoleName;
                    if (sourceName) {
                        var sourceVar = def.getOwn(scene.vars, sourceName);
                        if (sourceVar) {
                            scene.vars[roleVarName] = sourceVar.clone();
                            return;
                        }
                    }
                    if (isLeaf) {
                        var roleVar, rootContDim = this.rootContDim;
                        if (rootContDim) {
                            var valuePct, valueDim, group = scene.group, singleDatum = group ? group.singleDatum() : scene.datum;
                            if (singleDatum) {
                                if (!singleDatum.isNull) {
                                    roleVar = pvc_ValueLabelVar.fromAtom(singleDatum.atoms[rootContDim.name]);
                                    if (null != roleVar.value && this.percentFormatter)
                                        if (group) {
                                            valueDim = group.dimensions(rootContDim.name);
                                            valuePct = valueDim.valuePercent({
                                                visible: !0
                                            });
                                        } else
                                            valuePct = scene.data().dimensions(rootContDim.name).percent(roleVar.value);
                                }
                            } else if (group) {
                                valueDim = group.dimensions(rootContDim.name);
                                var value = valueDim.value({
                                    visible: !0,
                                    zeroIfNone: !1
                                });
                                if (null != value) {
                                    var label = rootContDim.format(value);
                                    roleVar = new pvc_ValueLabelVar(value,label,value);
                                    this.percentFormatter && (valuePct = valueDim.valuePercent({
                                        visible: !0
                                    }));
                                }
                            }
                            roleVar && this.percentFormatter && (roleVar.percent = null == roleVar.value ? new pvc_ValueLabelVar(null,"") : new pvc_ValueLabelVar(valuePct,this.percentFormatter.call(null, valuePct)));
                        } else {
                            var firstDatum = scene.datum;
                            if (firstDatum && !firstDatum.isNull) {
                                var view = this.grouping.view(firstDatum);
                                roleVar = pvc_ValueLabelVar.fromComplex(view);
                            }
                        }
                        if (!roleVar) {
                            roleVar = new pvc_ValueLabelVar(null,"");
                            this.percentFormatter && (roleVar.percent = new pvc_ValueLabelVar(null,""));
                        }
                        scene.vars[roleVarName] = roleVar;
                    }
                }
            }
        }
    });
    pv_Mark.prototype.getSign = function() {
        return this.sign || sign_createBasic(this);
    }
    ;
    pv_Mark.prototype.getScene = function() {
        return this.getSign().scene();
    }
    ;
    pv_Mark.prototype.getContext = function() {
        return this.getSign().context();
    }
    ;
    pv_Mark.prototype.preBuildInstance = function(s) {
        var scene = s.data;
        scene instanceof pvc.visual.Scene && scene_renderId.call(scene, this.renderId());
    }
    ;
    def.type("pvc.visual.BasicSign").init(function(panel, pvMark) {
        this.chart = panel.chart;
        this.panel = panel;
        !pvMark.sign || def.assert("Mark already has an attached Sign.");
        this.pvMark = pvMark;
        pvMark.sign = this;
    }).add({
        compatVersion: function() {
            return this.chart.compatVersion();
        },
        localProperty: function(name, type) {
            this.pvMark.localProperty(name, type);
            return this;
        },
        lock: function(pvName, value) {
            return this.lockMark(pvName, this._bindWhenFun(value, pvName));
        },
        optional: function(pvName, value, tag) {
            return this.optionalMark(pvName, this._bindWhenFun(value, pvName), tag);
        },
        lockMark: function(name, value) {
            return this.pvMark.lock(name, value),
            this;
        },
        optionalMark: function(name, value, tag) {
            return this.pvMark[name](value, tag),
            this;
        },
        delegate: function(dv, tag) {
            return this.pvMark.delegate(dv, tag);
        },
        delegateExtension: function(dv) {
            return this.pvMark.delegate(dv, pvc.extensionTag);
        },
        delegateNotExtension: function(dv) {
            return this.pvMark.delegateExcept(dv, pvc.extensionTag);
        },
        hasDelegate: function(tag) {
            return this.pvMark.hasDelegate(tag);
        },
        _createPropInterceptor: function(pvName, fun) {
            var me = this;
            return function() {
                var sign = this.sign;
                return sign && sign === me ? fun.apply(me, arguments) : me._getPvSceneProp(pvName, this.index);
            }
            ;
        },
        _getPvSceneProp: function(prop, defaultIndex) {
            var pvMark = this.pvMark
              , pvScenes = pvMark.scene;
            if (pvScenes) {
                var index = pvMark.hasOwnProperty("index") ? pvMark.index : Math.min(defaultIndex, pvScenes.length - 1);
                if (null != index)
                    return pvScenes[index][prop];
            }
            throw def.error.operationInvalid("Cannot evaluate inherited property.");
        },
        _bindWhenFun: function(value, pvName) {
            if (def.fun.is(value)) {
                var me = this;
                return me._createPropInterceptor(pvName, function(scene) {
                    return value.call(me, scene);
                });
            }
            return value;
        },
        _lockDynamic: function(pvName, method) {
            var me = this;
            return me.lockMark(pvName, me._createPropInterceptor(pvName, function(scene) {
                return me[method].call(me, scene);
            }));
        },
        scene: function() {
            var instance = this.pvMark.instance()
              , scene = instance && instance.data;
            return scene instanceof pvc.visual.Scene ? scene : null;
        },
        instanceState: function(s) {
            return this.pvMark.instanceState(s);
        },
        context: function(scene, createIndep) {
            var state;
            return createIndep || !(state = this.instanceState()) ? this._createContext(scene) : state.cccContext || (state.cccContext = this._createContext(scene));
        },
        _createContext: function(scene) {
            return new pvc.visual.Context(this.panel,this.pvMark,scene);
        }
    });
    def.type("pvc.visual.Sign", pvc.visual.BasicSign).init(function(panel, pvMark, keyArgs) {
        var me = this;
        me.base(panel, pvMark, keyArgs);
        me._ibits = panel._ibits;
        var extensionIds = def.get(keyArgs, "extensionId");
        null != extensionIds && (me.extensionAbsIds = def.array.to(panel._makeExtensionAbsId(extensionIds)));
        me.isActiveSeriesAware = def.get(keyArgs, "activeSeriesAware", !0);
        if (me.isActiveSeriesAware) {
            var roles = panel.visualRoles
              , seriesRole = roles && roles.series;
            seriesRole && seriesRole.isBound() || (me.isActiveSeriesAware = !1);
        }
        pvMark.wrapper(def.get(keyArgs, "wrapper") || me.createDefaultWrapper());
        def.get(keyArgs, "freeColor", !0) || me._bindProperty("fillStyle", "fillColor", "color")._bindProperty("strokeStyle", "strokeColor", "color");
    }).postInit(function(panel, pvMark, keyArgs) {
        this._addInteractive(keyArgs);
        panel._addSign(this);
    }).add({
        createDefaultWrapper: function() {
            var me = this;
            return function(f) {
                return function(scene) {
                    return f.call(me.context(), scene);
                }
                ;
            }
            ;
        },
        property: function(name) {
            var upperName = def.firstUpperCase(name)
              , baseName = "base" + upperName
              , defName = "default" + upperName
              , normalName = "normal" + upperName
              , interName = "interactive" + upperName
              , methods = {};
            methods[name] = function(scene, arg) {
                this._finished = !1;
                this._arg = arg;
                var value = this[baseName](scene, arg);
                if (null == value)
                    return null;
                if (this._finished)
                    return value;
                value = this.showsInteraction() && scene.anyInteraction() ? this[interName](scene, value, arg) : this[normalName](scene, value, arg);
                this._arg = null;
                return value;
            }
            ;
            methods[baseName] = function() {
                return this.delegateExtension();
            }
            ;
            methods[defName] = function() {}
            ;
            methods[normalName] = function(scene, value) {
                return value;
            }
            ;
            methods[interName] = function(scene, value) {
                return value;
            }
            ;
            this.constructor.add(methods);
            return this;
        },
        anyInteraction: function(scene) {
            return scene.anyInteraction();
        },
        finished: function(value) {
            this._finished = !0;
            return value;
        },
        applyExtensions: function() {
            if (!this._extended) {
                this._extended = !0;
                var extensionAbsIds = this.extensionAbsIds;
                extensionAbsIds && extensionAbsIds.forEach(function(extensionAbsId) {
                    this.panel.extendAbs(this.pvMark, extensionAbsId);
                }, this);
            }
            return this;
        },
        intercept: function(pvName, fun) {
            var interceptor = this._createPropInterceptor(pvName, fun);
            return this._intercept(pvName, interceptor);
        },
        lockDimensions: function() {
            this.pvMark.lock("left").lock("right").lock("top").lock("bottom").lock("width").lock("height");
            return this;
        },
        _extensionKeyArgs: {
            tag: pvc.extensionTag
        },
        _bindProperty: function(pvName, prop, realProp) {
            var me = this;
            realProp || (realProp = prop);
            var defaultPropName = "default" + def.firstUpperCase(realProp);
            if (def.fun.is(me[defaultPropName]) && !me.pvMark.hasDelegateValue(pvName, pvc.extensionTag)) {
                var defaultPropMethod = function(scene) {
                    return me[defaultPropName](scene, me._arg);
                };
                me.pvMark.intercept(pvName, defaultPropMethod, me._extensionKeyArgs);
            }
            var mainPropMethod = this._createPropInterceptor(pvName, function(scene) {
                return me[prop](scene);
            });
            return me._intercept(pvName, mainPropMethod);
        },
        _intercept: function(name, fun) {
            var mark = this.pvMark
              , extensionAbsIds = this.extensionAbsIds;
            extensionAbsIds && def.query(extensionAbsIds).select(function(extensionAbsId) {
                return this.panel._getExtensionAbs(extensionAbsId, name);
            }, this).where(def.notUndef).each(function(extValue) {
                extValue = mark.wrap(extValue, name);
                mark.intercept(name, extValue, this._extensionKeyArgs);
            }, this);
            (mark._intercepted || (mark._intercepted = {}))[name] = !0;
            mark.intercept(name, fun);
            return this;
        }
    }).prototype.property("color").constructor.add(pvc.visual.Interactive).add({
        extensionAbsIds: null,
        _addInteractive: function(ka) {
            var me = this
              , get = def.get;
            if (me.interactive()) {
                var bits = me._ibits
                  , I = pvc.visual.Interactive;
                get(ka, "noTooltip") && (bits &= ~I.ShowsTooltip);
                get(ka, "noHover") && (bits &= ~I.Hoverable);
                get(ka, "noClick") && (bits &= ~I.Clickable);
                get(ka, "noDoubleClick") && (bits &= ~I.DoubleClickable);
                if (get(ka, "noSelect"))
                    bits &= ~I.SelectableAny;
                else if (this.selectable()) {
                    get(ka, "noClickSelect") && (bits &= ~I.SelectableByClick);
                    get(ka, "noRubberSelect") && (bits &= ~I.SelectableByRubberband);
                }
                if (me.showsInteraction()) {
                    get(ka, "showsInteraction") === !1 && (bits &= ~I.ShowsInteraction);
                    me.showsActivity() && get(ka, "showsActivity") === !1 && (bits &= ~I.ShowsActivity);
                    me.showsSelection() && get(ka, "showsSelection") === !1 && (bits &= ~I.ShowsSelection);
                }
                me._ibits = bits;
            }
            if (me.handlesEvents()) {
                me.showsTooltip() && me._addPropTooltip(get(ka, "tooltipArgs"));
                me.hoverable() && me._addPropHoverable();
                me.handlesClickEvent() && me._addPropClick();
                me.doubleClickable() && me._addPropDoubleClick();
            } else
                me.pvMark.events("none");
        },
        fillColor: function(scene) {
            return this.color(scene, "fill");
        },
        strokeColor: function(scene) {
            return this.color(scene, "stroke");
        },
        defaultColor: function(scene) {
            return this.defaultColorSceneScale()(scene);
        },
        dimColor: function(color, type) {
            return "text" === type ? pvc.toGrayScale(color, -.75, null, null) : pvc.toGrayScale(color, -.3, null, null);
        },
        defaultColorSceneScale: function() {
            return def.lazy(this, "_defaultColorSceneScale", this._initDefColorScale, this);
        },
        _initDefColorScale: function() {
            var colorAxis = this.panel.axes.color;
            return colorAxis ? colorAxis.sceneScale({
                sceneVarName: "color"
            }) : def.fun.constant(pvc.defaultColor);
        },
        mayShowActive: function(scene, noSeries) {
            return this.showsActivity() ? scene.isActive || !noSeries && this.isActiveSeriesAware && scene.isActiveSeries() || scene.isActiveDatum() : !1;
        },
        mayShowNotAmongSelected: function(scene) {
            return this.mayShowAnySelected(scene) && !scene.isSelected();
        },
        mayShowSelected: function(scene) {
            return this.showsSelection() && scene.isSelected();
        },
        mayShowAnySelected: function(scene) {
            return this.showsSelection() && scene.anySelected();
        },
        _addPropTooltip: function(ka) {
            if (!this.pvMark.hasTooltip) {
                var tipOptions = def.create(this.chart._tooltipOptions, def.get(ka, "options"));
                tipOptions.isLazy = def.get(ka, "isLazy", !0);
                var tooltipFormatter = def.get(ka, "buildTooltip") || this._getTooltipFormatter(tipOptions);
                if (tooltipFormatter) {
                    tipOptions.isEnabled = this._isTooltipEnabled.bind(this);
                    var tipsyEvent = def.get(ka, "tipsyEvent");
                    tipsyEvent || (tipsyEvent = "mouseover");
                    this.pvMark.localProperty("tooltip").tooltip(this._createTooltipProp(tooltipFormatter, tipOptions.isLazy)).title(def.fun.constant("")).ensureEvents().event(tipsyEvent, pv.Behavior.tipsy(tipOptions)).hasTooltip = !0;
                }
            }
        },
        _getTooltipFormatter: function(tipOptions) {
            return this.panel._getTooltipFormatter(tipOptions);
        },
        _isTooltipEnabled: function() {
            return this.panel._isTooltipEnabled();
        },
        _createTooltipProp: function(tooltipFormatter, isLazy) {
            var formatTooltip, me = this;
            formatTooltip = isLazy ? function(scene) {
                var tooltip, context = me.context(scene, !0);
                return function() {
                    if (context) {
                        tooltip = tooltipFormatter(context);
                        context = null;
                    }
                    return tooltip;
                }
                ;
            }
            : function(scene) {
                var context = me.context(scene);
                return tooltipFormatter(context);
            }
            ;
            return function(scene) {
                return scene && !scene.isIntermediate && scene.showsTooltip() ? formatTooltip(scene) : void 0;
            }
            ;
        },
        _addPropHoverable: function() {
            var onEvent, offEvent, panel = this.panel;
            onEvent = "mouseover";
            offEvent = "mouseout";
            this.pvMark.ensureEvents().event(onEvent, function(scene) {
                if (scene.hoverable() && !panel.selectingByRubberband() && !panel.animating()) {
                    scene.setActive(!0);
                    panel.renderInteractive();
                }
            }).event(offEvent, function(scene) {
                !scene.hoverable() || panel.selectingByRubberband() || panel.animating() || scene.clearActive() && panel.renderInteractive();
            });
        },
        _ignoreClicks: 0,
        _propCursorClick: function(s) {
            var ibits = this._ibits & s._ibits
              , I = pvc.visual.Interactive;
            return ibits & I.HandlesClickEvent || ibits & I.DoubleClickable ? "pointer" : null;
        },
        _addPropClick: function() {
            var me = this;
            me.pvMark.cursor(me._propCursorClick.bind(me)).ensureEvents().event("click", me._handleClick.bind(me));
        },
        _addPropDoubleClick: function() {
            var me = this;
            me.pvMark.cursor(me._propCursorClick.bind(me)).ensureEvents().event("dblclick", me._handleDoubleClick.bind(me));
        },
        _handleClick: function() {
            var me = this
              , pvMark = me.pvMark
              , pvInstance = pvMark.instance()
              , scene = pvInstance.data
              , wait = me.doubleClickable() && scene.doubleClickable();
            if (wait) {
                var pvScene = pvMark.scene
                  , pvIndex = pvMark.index
                  , pvEvent = pv.event;
                window.setTimeout(function() {
                    if (me._ignoreClicks)
                        me._ignoreClicks--;
                    else
                        try {
                            pv.event = pvEvent;
                            pvMark.context(pvScene, pvIndex, function() {
                                me._handleClickCore();
                            });
                        } catch (ex) {
                            pv.error(ex);
                        } finally {
                            delete pv.event;
                        }
                }, me.chart.options.doubleClickMaxDelay || 300);
            } else
                me._ignoreClicks ? me._ignoreClicks-- : me._handleClickCore();
        },
        _handleClickCore: function() {
            this._onClick(this.context());
        },
        _handleDoubleClick: function() {
            var me = this
              , scene = me.scene();
            if (scene && scene.doubleClickable()) {
                me._ignoreClicks = 2;
                me._onDoubleClick(me.context(scene));
            }
        },
        _onClick: function(context) {
            context.click();
        },
        _onDoubleClick: function(context) {
            context.doubleClick();
        }
    });
    def.type("pvc.visual.Panel", pvc.visual.Sign).init(function(panel, protoMark, keyArgs) {
        var pvPanel = def.get(keyArgs, "panel");
        if (!pvPanel) {
            var pvPanelType = def.get(keyArgs, "panelType") || pv.Panel;
            pvPanel = protoMark.add(pvPanelType);
        }
        this.base(panel, pvPanel, keyArgs);
    }).add({
        _addInteractive: function(keyArgs) {
            var t = !0;
            keyArgs = def.setDefaults(keyArgs, "noSelect", t, "noHover", t, "noTooltip", t, "noClick", t, "noDoubleClick", t);
            this.base(keyArgs);
        }
    });
    def.type("pvc.visual.Label", pvc.visual.Sign).init(function(panel, protoMark, keyArgs) {
        var pvMark = protoMark.add(pv.Label);
        this.base(panel, pvMark, keyArgs);
    }).add({
        _addInteractive: function(keyArgs) {
            var t = !0;
            keyArgs = def.setDefaults(keyArgs, "noSelect", t, "noHover", t, "noTooltip", t, "noClick", t, "noDoubleClick", t, "showsInteraction", !1);
            this.base(keyArgs);
        },
        defaultColor: def.fun.constant(pv.Color.names.black)
    });
    var DEFAULT_BG_COLOR = pv.Color.names.white;
    def.type("pvc.visual.ValueLabel", pvc.visual.Label).init(function(panel, anchorMark, keyArgs) {
        this.valuesFont = def.get(keyArgs, "valuesFont") || panel.valuesFont;
        this.valuesMask = def.get(keyArgs, "valuesMask") || panel.valuesMask;
        this.valuesOptimizeLegibility = def.get(keyArgs, "valuesOptimizeLegibility", panel.valuesOptimizeLegibility);
        this.valuesOverflow = def.get(keyArgs, "valuesOverflow", panel.valuesOverflow);
        this.hideOverflowed = "hide" === this.valuesOverflow;
        this.trimOverflowed = !this.hideOverflowed && "trim" === this.valuesOverflow;
        this.hideOrTrimOverflowed = this.hideOverflowed || this.trimOverflowed;
        var protoMark;
        protoMark = def.get(keyArgs, "noAnchor", !1) ? anchorMark : anchorMark.anchor(panel.valuesAnchor);
        keyArgs && null == keyArgs.extensionId && (keyArgs.extensionId = "label");
        this.base(panel, protoMark, keyArgs);
        this.pvMark.font(this.valuesFont);
        this._bindProperty("text", "text")._bindProperty("textStyle", "textColor", "color").intercept("visible", this.visible);
    }).prototype.property("text").property("textStyle").constructor.addStatic({
        maybeCreate: function(panel, anchorMark, keyArgs) {
            return panel.valuesVisible && panel.valuesMask ? new pvc.visual.ValueLabel(panel,anchorMark,keyArgs) : null;
        },
        isNeeded: function(panel) {
            return panel.valuesVisible && panel.valuesMask;
        }
    }).add({
        _addInteractive: function(keyArgs) {
            keyArgs = def.setDefaults(keyArgs, "showsInteraction", !0, "noSelect", !0, "noTooltip", !0, "noClick", !0, "noDoubleClick", !0, "noHover", !0);
            this.base(keyArgs);
        },
        visible: function(scene) {
            var anchoredToMark = this.getAnchoredToMark();
            if (anchoredToMark && !anchoredToMark.visible())
                return !1;
            if (!this.hideOrTrimOverflowed)
                return this.delegate(!0);
            var visible;
            if (this.hasDelegate(pvc.extensionTag)) {
                visible = this.delegateExtension();
                if (null != visible)
                    return visible;
            }
            visible = this.delegateNotExtension();
            if (visible === !1)
                return !1;
            if (scene.isActive && this.showsActivity())
                return !0;
            var fitInfo = this.textFitInfo(scene);
            return !(fitInfo && fitInfo.hide);
        },
        textFitInfo: function(scene) {
            var state = scene.renderState
              , value = state.textFitInfo;
            return void 0 !== value ? value : state.textFitInfo = this.calcTextFitInfo(scene, this._evalBaseText()) || null;
        },
        calcTextFitInfo: function() {
            return null;
        },
        _evalBaseText: function() {
            var pvLabel = this.pvMark
              , pdelegate = pvLabel.binds.properties.text.proto;
            return pvLabel.evalInPropertyContext(this.baseText.bind(this), pdelegate);
        },
        baseText: function(scene) {
            var state = scene.renderState
              , text = state.baseText;
            return void 0 !== text ? text : this.base(scene);
        },
        defaultText: function(scene) {
            return scene.format(this.valuesMask);
        },
        normalText: function(scene, text) {
            var fitInfo;
            return this.trimOverflowed && (fitInfo = this.textFitInfo(scene)) ? this.trimText(scene, text, fitInfo) : text;
        },
        interactiveText: function(scene, text) {
            var fitInfo;
            return !this.trimOverflowed || scene.isActive && this.showsActivity() || !(fitInfo = this.textFitInfo(scene)) ? text : this.trimText(scene, text, fitInfo);
        },
        trimText: function(scene, text, fitInfo) {
            var twMax = fitInfo && fitInfo.widthMax;
            return null != twMax ? pvc.text.trimToWidthB(twMax, text, this.pvMark.font(), "..") : text;
        },
        textColor: function(scene) {
            return this.color(scene, "text");
        },
        backgroundColor: function(scene, type) {
            var state = this.instanceState();
            if (!state)
                return this.calcBackgroundColor(scene, type);
            var cache = def.lazy(state, "cccBgColorCache")
              , color = def.getOwn(cache, type);
            color || (color = cache[type] = this.calcBackgroundColor(scene, type));
            return color;
        },
        calcBackgroundColor: function(scene) {
            var anchoredToMark = this.getAnchoredToMark();
            if (anchoredToMark) {
                var fillColor = anchoredToMark.fillStyle();
                if (fillColor && fillColor !== DEFAULT_BG_COLOR && this.isAnchoredInside(scene, anchoredToMark))
                    return fillColor;
            }
            return DEFAULT_BG_COLOR;
        },
        getAnchoredToMark: function() {
            return this.pvMark.target || this.pvMark.parent;
        },
        isAnchoredInside: function(scene, anchoredToMark) {
            if (!anchoredToMark && !(anchoredToMark = this.getAnchoredToMark()))
                return !1;
            var p, pvLabel = this.pvMark, text = pvLabel.text(), m = pv.Text.measure(text, pvLabel.font()), l = pvLabel.left(), t = pvLabel.top();
            if (null == l) {
                p = pvLabel.parent;
                l = p.width() - (pvLabel.right() || 0);
            }
            if (null == t) {
                p || (p = pvLabel.parent);
                t = p.height() - (pvLabel.bottom() || 0);
            }
            var labelCenter = pv.Label.getPolygon(m.width, m.height, pvLabel.textAlign(), pvLabel.textBaseline(), pvLabel.textAngle(), pvLabel.textMargin()).center().plus(l, t)
              , anchoredToShape = anchoredToMark.getShape(anchoredToMark.scene, pvLabel.index);
            return anchoredToShape.containsPoint(labelCenter);
        },
        maybeOptimizeColorLegibility: function(scene, color, type) {
            if (this.valuesOptimizeLegibility) {
                var bgColor = this.backgroundColor(scene, type);
                return bgColor && bgColor !== DEFAULT_BG_COLOR && bgColor.isDark() === color.isDark() ? color.complementary().alpha(.9) : color;
            }
            return color;
        },
        normalColor: function(scene, color, type) {
            return this.maybeOptimizeColorLegibility(scene, color, type);
        },
        interactiveColor: function(scene, color, type) {
            return !this.mayShowActive(scene) && this.mayShowNotAmongSelected(scene) ? this.dimColor(color, type) : this.maybeOptimizeColorLegibility(scene, color, type);
        }
    });
    def.type("pvc.visual.Dot", pvc.visual.Sign).init(function(panel, parentMark, keyArgs) {
        var pvMark = parentMark.add(pv.Dot)
          , protoMark = def.get(keyArgs, "proto");
        protoMark && pvMark.extend(protoMark);
        keyArgs = def.setDefaults(keyArgs, "freeColor", !1);
        this.base(panel, pvMark, keyArgs);
        if (!def.get(keyArgs, "freePosition", !1)) {
            var a_left = panel.isOrientationVertical() ? "left" : "bottom"
              , a_bottom = panel.anchorOrtho(a_left);
            this._lockDynamic(a_left, "x")._lockDynamic(a_bottom, "y");
        }
        this._bindProperty("shape", "shape")._bindProperty("shapeRadius", "radius")._bindProperty("shapeSize", "size");
        this.optional("strokeDasharray", void 0).optional("lineWidth", 1);
    }).prototype.property("size").property("shape").constructor.add({
        y: def.fun.constant(0),
        x: def.fun.constant(0),
        radius: function() {
            this.instanceState().cccRadius = this.delegateExtension();
        },
        baseSize: function(scene) {
            var radius = this.instanceState().cccRadius;
            return null != radius ? def.sqr(radius) : this.base(scene);
        },
        defaultSize: def.fun.constant(12),
        interactiveSize: function(scene, size) {
            return this.mayShowActive(scene, !0) ? 2.5 * Math.max(size, 5) : size;
        },
        interactiveColor: function(scene, color, type) {
            if (this.mayShowActive(scene, !0)) {
                if ("stroke" === type)
                    return color.brighter(1);
            } else if (this.mayShowNotAmongSelected(scene)) {
                if (this.mayShowActive(scene))
                    return color.alpha(.8);
                switch (type) {
                case "fill":
                    return this.dimColor(color, type);

                case "stroke":
                    return color.alpha(.45);
                }
            }
            return this.base(scene, color, type);
        }
    });
    def.type("pvc.visual.DotSizeColor", pvc.visual.Dot).init(function(panel, parentMark, keyArgs) {
        this.base(panel, parentMark, keyArgs);
        var isV1Compat = this.compatVersion() <= 1;
        this._bindProperty("lineWidth", "strokeWidth").intercept("visible", function(scene) {
            if (!this.canShow(scene))
                return !1;
            var visible = this.delegateExtension();
            null == visible && (visible = isV1Compat || this.defaultVisible(scene));
            return visible;
        });
        this._initColor();
        this._initSize();
        if (this.isSizeBound) {
            var sizeAxis = panel.axes.size;
            if (sizeAxis.scaleUsesAbs()) {
                this.isSizeAbs = !0;
                var baseSceneDefColor = this._sceneDefColor;
                this._sceneDefColor = function(scene, type) {
                    return "stroke" === type && scene.vars.size.value < 0 ? pv.Color.names.black : baseSceneDefColor.call(this, scene, type);
                }
                ;
                this.pvMark.lineCap("round").strokeDasharray(function(scene) {
                    return scene.vars.size.value < 0 ? "dash" : null;
                });
            }
        }
    }).prototype.property("strokeWidth").constructor.add({
        isColorBound: !1,
        isColorDiscrete: !1,
        isSizeBound: !1,
        isSizeAbs: !1,
        canShow: function(scene) {
            return !scene.isIntermediate;
        },
        defaultVisible: function(scene) {
            return !scene.isNull && (!this.isSizeBound && !this.isColorBound || this.isSizeBound && null != scene.vars.size.value || this.isColorBound && (this.isColorDiscrete || null != scene.vars.color.value));
        },
        _initColor: function() {
            var colorConstant, sceneColorScale, panel = this.panel, colorRole = panel.visualRoles.color;
            if (colorRole) {
                this.isColorDiscrete = colorRole.isDiscrete();
                var colorAxis = panel.axes.color;
                if (colorRole.isBound()) {
                    this.isColorBound = !0;
                    sceneColorScale = colorAxis.sceneScale({
                        sceneVarName: "color"
                    });
                } else
                    colorAxis && (colorConstant = colorAxis.option("Unbound"));
            }
            sceneColorScale || (sceneColorScale = def.fun.constant(colorConstant || pvc.defaultColor));
            this._sceneDefColor = sceneColorScale;
        },
        _initSize: function() {
            var sceneSizeScale, sceneShapeScale, panel = this.panel, plot = panel.plot, shape = plot.option("Shape"), nullSizeShape = plot.option("NullShape"), sizeRole = panel.visualRoles.size;
            if (sizeRole) {
                var sizeAxis = panel.axes.size
                  , sizeScale = sizeAxis && sizeAxis.scale
                  , isSizeBound = !!sizeScale && sizeRole.isBound();
                if (isSizeBound) {
                    this.isSizeBound = !0;
                    var missingSize = sizeScale.min + .05 * (sizeScale.max - sizeScale.min);
                    this.nullSizeShapeHasStrokeOnly = "cross" === nullSizeShape;
                    sceneShapeScale = function(scene) {
                        return null != scene.vars.size.value ? shape : nullSizeShape;
                    }
                    ;
                    sceneSizeScale = function(scene) {
                        var sizeValue = scene.vars.size.value;
                        return null != sizeValue ? sizeScale(sizeValue) : nullSizeShape ? missingSize : 0;
                    }
                    ;
                }
            }
            if (!sceneSizeScale) {
                sceneShapeScale = def.fun.constant(shape);
                sceneSizeScale = function(scene) {
                    return this.base(scene);
                }
                ;
            }
            this._sceneDefSize = sceneSizeScale;
            this._sceneDefShape = sceneShapeScale;
        },
        defaultColor: function(scene, type) {
            return this._sceneDefColor(scene, type);
        },
        normalColor: function(scene, color, type) {
            return "stroke" === type ? color.darker() : this.base(scene, color, type);
        },
        interactiveColor: function(scene, color, type) {
            if (this.mayShowActive(scene, !0))
                switch (type) {
                case "fill":
                    return this.isSizeBound ? color.alpha(.75) : color;

                case "stroke":
                    return color.darker();
                }
            else if (this.showsSelection()) {
                var isSelected = scene.isSelected()
                  , notAmongSelected = !isSelected && scene.anySelected();
                if (notAmongSelected) {
                    if (this.mayShowActive(scene))
                        return color.alpha(.8);
                    switch (type) {
                    case "fill":
                        return this.dimColor(color, type);

                    case "stroke":
                        return color.alpha(.45);
                    }
                }
                if (isSelected && pvc_colorIsGray(color)) {
                    "stroke" === type && (color = color.darker(3));
                    return color.darker(2);
                }
            }
            return "stroke" === type ? color.darker() : color;
        },
        defaultSize: function(scene) {
            return this._sceneDefSize(scene);
        },
        defaultShape: function(scene) {
            return this._sceneDefShape(scene);
        },
        interactiveSize: function(scene, size) {
            if (!this.mayShowActive(scene, !0))
                return size;
            var radius = Math.sqrt(size)
              , radiusInc = Math.max(1, Math.min(1.1 * radius, 2));
            return def.sqr(radius + radiusInc);
        },
        defaultStrokeWidth: function(scene) {
            return this.nullSizeShapeHasStrokeOnly && null == scene.vars.size.value ? 1.8 : 1;
        },
        interactiveStrokeWidth: function(scene, width) {
            return this.mayShowActive(scene, !0) ? 2 * width : this.mayShowSelected(scene) ? 1.5 * width : width;
        }
    });
    pv.LineInterm = function() {
        pv.Line.call(this);
    }
    ;
    pv.LineInterm.prototype = pv.extend(pv.Line);
    pv.LineInterm.prototype.getNearestInstanceToMouse = function(scene, eventIndex) {
        var mouseIndex = pv.Line.prototype.getNearestInstanceToMouse.call(this, scene, eventIndex)
          , s = scene[mouseIndex];
        s && s.data && s.data.isIntermediate && mouseIndex + 1 < scene.length && mouseIndex++;
        return mouseIndex;
    }
    ;
    def.type("pvc.visual.Line", pvc.visual.Sign).init(function(panel, protoMark, keyArgs) {
        var pvMark = protoMark.add(pv.LineInterm);
        this.base(panel, pvMark, keyArgs);
        this.lock("segmented", "smart").lock("antialias", !0);
        if (!def.get(keyArgs, "freePosition", !1)) {
            var basePosProp = panel.isOrientationVertical() ? "left" : "bottom"
              , orthoPosProp = panel.anchorOrtho(basePosProp);
            this._lockDynamic(orthoPosProp, "y")._lockDynamic(basePosProp, "x");
        }
        this._bindProperty("strokeStyle", "strokeColor", "color")._bindProperty("lineWidth", "strokeWidth");
    }).prototype.property("strokeWidth").constructor.add({
        _addInteractive: function(keyArgs) {
            keyArgs = def.setDefaults(keyArgs, "noTooltip", !0);
            this.base(keyArgs);
        },
        y: def.fun.constant(0),
        x: def.fun.constant(0),
        defaultStrokeWidth: def.fun.constant(1),
        interactiveStrokeWidth: function(scene, strokeWidth) {
            return this.mayShowActive(scene) ? 2.5 * Math.max(1, strokeWidth) : strokeWidth;
        },
        interactiveColor: function(scene, color, type) {
            return this.mayShowNotAmongSelected(scene) ? this.mayShowActive(scene) ? pv.Color.names.darkgray.darker().darker() : this.dimColor(color, type) : this.base(scene, color, type);
        }
    });
    pv.AreaInterm = function() {
        pv.Area.call(this);
    }
    ;
    pv.AreaInterm.prototype = pv.extend(pv.Area);
    pv.AreaInterm.prototype.getNearestInstanceToMouse = function(scene, eventIndex) {
        var mouseIndex = pv.Area.prototype.getNearestInstanceToMouse.call(this, scene, eventIndex)
          , s = scene[mouseIndex];
        s && s.data && s.data.isIntermediate && mouseIndex + 1 < scene.length && mouseIndex++;
        return mouseIndex;
    }
    ;
    def.type("pvc.visual.Area", pvc.visual.Sign).init(function(panel, protoMark, keyArgs) {
        var pvMark = protoMark.add(pv.AreaInterm);
        keyArgs || (keyArgs = {});
        keyArgs.freeColor = !0;
        this.base(panel, pvMark, keyArgs);
        var antialias = def.get(keyArgs, "antialias", !0);
        this.lock("segmented", "smart").lock("antialias", antialias);
        if (!def.get(keyArgs, "freePosition", !1)) {
            var basePosProp = panel.isOrientationVertical() ? "left" : "bottom"
              , orthoPosProp = panel.anchorOrtho(basePosProp)
              , orthoLenProp = panel.anchorOrthoLength(orthoPosProp);
            this._lockDynamic(basePosProp, "x")._lockDynamic(orthoPosProp, "y")._lockDynamic(orthoLenProp, "dy");
        }
        this._bindProperty("fillStyle", "fillColor", "color");
        this.lock("strokeStyle", null).lock("lineWidth", 0);
    }).add({
        _addInteractive: function(keyArgs) {
            keyArgs = def.setDefaults(keyArgs, "noTooltip", !0);
            this.base(keyArgs);
        },
        y: def.fun.constant(0),
        x: def.fun.constant(0),
        dy: def.fun.constant(0),
        interactiveColor: function(scene, color, type) {
            return "fill" === type && this.mayShowNotAmongSelected(scene) ? this.dimColor(color, type) : this.base(scene, color, type);
        }
    });
    def.type("pvc.visual.Bar", pvc.visual.Sign).init(function(panel, protoMark, keyArgs) {
        var pvMark = protoMark.add(pv.Bar);
        keyArgs = def.setDefaults(keyArgs, "freeColor", !1);
        this.base(panel, pvMark, keyArgs);
        this.normalStroke = def.get(keyArgs, "normalStroke", !1);
        this._bindProperty("lineWidth", "strokeWidth");
    }).prototype.property("strokeWidth").constructor.add({
        normalColor: function(scene, color, type) {
            return "stroke" !== type || this.normalStroke ? color : null;
        },
        interactiveColor: function(scene, color, type) {
            if ("stroke" === type) {
                if (this.mayShowActive(scene, !0))
                    return color.brighter(1.3).alpha(.7);
                if (!this.normalStroke)
                    return null;
                if (this.mayShowNotAmongSelected(scene))
                    return this.mayShowActive(scene) ? pv.Color.names.darkgray.darker().darker() : this.dimColor(color, type);
                if (this.mayShowActive(scene))
                    return color.brighter(1).alpha(.7);
            } else if ("fill" === type) {
                if (this.mayShowActive(scene, !0))
                    return color.brighter(.2).alpha(.8);
                if (this.mayShowNotAmongSelected(scene))
                    return this.mayShowActive(scene) ? pv.Color.names.darkgray.darker(2).alpha(.8) : this.dimColor(color, type);
                if (this.mayShowActive(scene))
                    return color.brighter(.2).alpha(.8);
            }
            return this.base(scene, color, type);
        },
        defaultStrokeWidth: function() {
            return .5;
        },
        interactiveStrokeWidth: function(scene, strokeWidth) {
            return this.mayShowActive(scene, !0) ? 1.3 * Math.max(1, strokeWidth) : strokeWidth;
        }
    });
    pv.PieSlice = function() {
        pv.Wedge.call(this);
    }
    ;
    pv.PieSlice.prototype = pv.extend(pv.Wedge).property("offsetRadius");
    pv.PieSlice.prototype.midAngle = function() {
        var instance = this.instance();
        return instance.startAngle + instance.angle / 2;
    }
    ;
    pv.PieSlice.prototype.defaults = new pv.PieSlice().extend(pv.Wedge.prototype.defaults).offsetRadius(0);
    def.type("pvc.visual.PieSlice", pvc.visual.Sign).init(function(panel, protoMark, keyArgs) {
        var pvMark = protoMark.add(pv.PieSlice);
        keyArgs = def.setDefaults(keyArgs, "freeColor", !1);
        this.base(panel, pvMark, keyArgs);
        this._activeOffsetRadius = def.get(keyArgs, "activeOffsetRadius", 0);
        this._maxOffsetRadius = def.get(keyArgs, "maxOffsetRadius", 0);
        this._resolvePctRadius = def.get(keyArgs, "resolvePctRadius");
        this._center = def.get(keyArgs, "center");
        this.optional("lineWidth", .6)._bindProperty("angle", "angle")._bindProperty("offsetRadius", "offsetRadius")._lockDynamic("bottom", "y")._lockDynamic("left", "x").lock("top", null).lock("right", null);
    }).prototype.property("offsetRadius").constructor.add({
        angle: def.fun.constant(0),
        x: function() {
            return this._center.x + this._offsetSlice("cos");
        },
        y: function() {
            return this._center.y - this._offsetSlice("sin");
        },
        _offsetSlice: function(fun) {
            var offset = this.pvMark.offsetRadius() || 0;
            offset && (offset *= Math[fun](this.pvMark.midAngle()));
            return offset;
        },
        defaultColor: function(scene, type) {
            return "stroke" === type ? null : this.base(scene, type);
        },
        interactiveColor: function(scene, color, type) {
            if (this.mayShowActive(scene, !0))
                switch (type) {
                case "fill":
                    return color.brighter(.2).alpha(.8);

                case "stroke":
                    return color.brighter(1.3).alpha(.7);
                }
            else if (this.mayShowNotAmongSelected(scene) && "fill" === type)
                return this.dimColor(color, type);
            return this.base(scene, color, type);
        },
        offsetRadius: function(scene) {
            var offsetRadius = this.base(scene);
            return Math.min(Math.max(0, offsetRadius), this._maxOffsetRadius);
        },
        baseOffsetRadius: function(scene) {
            var offsetRadius = this.base(scene) || 0;
            return this._resolvePctRadius(pvc_PercentValue.parse(offsetRadius));
        },
        interactiveOffsetRadius: function(scene, offsetRadius) {
            return offsetRadius + (this.mayShowActive(scene, !0) ? this._activeOffsetRadius : 0);
        }
    });
    def.type("pvc.visual.Rule", pvc.visual.Sign).init(function(panel, parentMark, keyArgs) {
        var pvMark = parentMark.add(pv.Rule)
        var protoMark = def.get(keyArgs, "proto");
        protoMark && pvMark.extend(protoMark);
        this.base(panel, pvMark, keyArgs);
        def.get(keyArgs, "freeStyle") || this._bindProperty("strokeStyle", "strokeColor", "color")._bindProperty("lineWidth", "strokeWidth");
    }).prototype.property("strokeWidth").constructor.add({
        _addInteractive: function(keyArgs) {
            var t = !0;
            keyArgs = def.setDefaults(keyArgs, "noHover", t, "noSelect", t, "noTooltip", t, "noClick", t, "noDoubleClick", t, "showsInteraction", !1);
            this.base(keyArgs);
        },
        defaultStrokeWidth: def.fun.constant(1),
        interactiveStrokeWidth: function(scene, strokeWidth) {
            return this.mayShowActive(scene, !0) ? 2.2 * Math.max(1, strokeWidth) : strokeWidth;
        },
        interactiveColor: function(scene, color, type) {
            return scene.datum && !this.mayShowActive(scene, !0) && this.mayShowNotAmongSelected(scene) ? this.dimColor(color, type) : this.base(scene, color, type);
        }
    });
    def.type("pvc.visual.OptionsBase").init(function(chart, type, index, keyArgs) {
        this.chart = chart;
        this.type = type;
        this.index = null == index ? 0 : index;
        this.name = def.get(keyArgs, "name");
        this.id = this._buildId();
        this.optionId = this._buildOptionId();
        var rs = this._resolvers = [];
        this._registerResolversFull(rs, keyArgs);
        this.option = pvc.options(this._getOptionsDefinition(), this);
    }).add({
        _buildId: function() {
            return pvc.buildIndexedId(this.type, this.index);
        },
        _buildOptionId: function() {
            return this.id;
        },
        _chartOption: function(name) {
            return this.chart.options[name];
        },
        _getOptionsDefinition: def.method({
            isAbstract: !0
        }),
        _registerResolversFull: function(rs, keyArgs) {
            var fixed = def.get(keyArgs, "fixed");
            if (fixed) {
                this._fixed = fixed;
                rs.push(pvc.options.specify(function(optionInfo) {
                    return fixed[optionInfo.name];
                }));
            }
            this._registerResolversNormal(rs, keyArgs);
            var defaults = def.get(keyArgs, "defaults");
            defaults && (this._defaults = defaults);
            rs.push(this._resolveDefault);
        },
        _registerResolversNormal: function(rs, keyArgs) {
            def.get(keyArgs, "byV1", !0) && this.chart.compatVersion() <= 1 && rs.push(this._resolveByV1OnlyLogic);
            this.name && rs.push(pvc.options.specify(function(optionInfo) {
                return this._chartOption(this.name + def.firstUpperCase(optionInfo.name));
            }));
            rs.push(this._resolveByOptionId);
            def.get(keyArgs, "byNaked", !this.index) && rs.push(this._resolveByNaked);
        },
        _resolveFull: function(optionInfo) {
            for (var rs = this._resolvers, i = 0, L = rs.length; L > i; i++)
                if (rs[i].call(this, optionInfo))
                    return !0;
            return !1;
        },
        _resolveFixed: pvc.options.specify(function(optionInfo) {
            return this._fixed ? this._fixed[optionInfo.name] : void 0;
        }),
        _resolveByV1OnlyLogic: function(optionInfo) {
            var resolverV1, data = optionInfo.data;
            return data && (resolverV1 = data.resolveV1) ? resolverV1.call(this, optionInfo) : void 0;
        },
        _resolveByName: pvc.options.specify(function(optionInfo) {
            return this.name ? this._chartOption(this.name + def.firstUpperCase(optionInfo.name)) : void 0;
        }),
        _resolveByOptionId: pvc.options.specify(function(optionInfo) {
            return this._chartOption(this.optionId + def.firstUpperCase(optionInfo.name));
        }),
        _resolveByNaked: pvc.options.specify(function(optionInfo) {
            return this.index ? void 0 : this._chartOption(def.firstLowerCase(optionInfo.name));
        }),
        _resolveDefault: function(optionInfo) {
            var resolverDefault, data = optionInfo.data;
            if (data && (resolverDefault = data.resolveDefault) && resolverDefault.call(this, optionInfo))
                return !0;
            if (this._defaults) {
                var value = this._defaults[optionInfo.name];
                if (void 0 !== value) {
                    optionInfo.defaultValue(value);
                    return !0;
                }
            }
        },
        _specifyChartOption: function(optionInfo, asName) {
            var value = this._chartOption(asName);
            if (null != value) {
                optionInfo.specify(value);
                return !0;
            }
        }
    });
    def.type("pvc.visual.MultiChart", pvc.visual.OptionsBase).init(function(chart) {
        this.base(chart, "multiChart", 0, {
            byV1: !1,
            byNaked: !1
        });
    }).add({
        _getOptionsDefinition: function() {
            return pvc.visual.MultiChart.optionsDef;
        }
    }).addStatic({
        optionsDef: {
            Max: {
                resolve: "_resolveFull",
                cast: pvc.castPositiveNumber,
                value: 1 / 0
            },
            ColumnsMax: {
                resolve: "_resolveFull",
                cast: pvc.castPositiveNumber,
                value: 3
            },
            SingleRowFillsHeight: {
                resolve: "_resolveFull",
                cast: Boolean,
                value: !0
            },
            SingleColFillsHeight: {
                resolve: "_resolveFull",
                cast: Boolean,
                value: !0
            },
            Overflow: {
                resolve: "_resolveFull",
                cast: pvc.parseMultiChartOverflow,
                value: "grow"
            }
        }
    });
    def.type("pvc.visual.SmallChart", pvc.visual.OptionsBase).init(function(chart) {
        this.base(chart, "small", 0, {
            byV1: !1,
            byNaked: !1
        });
    }).add({
        _getOptionsDefinition: function() {
            return pvc.visual.SmallChart.optionsDef;
        }
    }).addStatic({
        optionsDef: {
            Width: {
                resolve: "_resolveFull",
                cast: pvc_PercentValue.parse,
                value: null
            },
            Height: {
                resolve: "_resolveFull",
                cast: pvc_PercentValue.parse,
                value: null
            },
            AspectRatio: {
                resolve: "_resolveFull",
                cast: pvc.castPositiveNumber,
                getDefault: function() {
                    return this.chart instanceof pvc.PieChart ? 10 / 7 : 5 / 4;
                }
            },
            Margins: {
                resolve: "_resolveFull",
                cast: pvc_Sides.as,
                value: new pvc_Sides(new pvc_PercentValue(.02))
            },
            Paddings: {
                resolve: "_resolveFull",
                cast: pvc_Sides.as,
                value: 0
            }
        }
    });
    var pvc_Axis = def.type("pvc.visual.Axis", pvc.visual.OptionsBase).init(function(chart, type, index, keyArgs) {
        this.base(chart, type, index, keyArgs);
        chart._addAxis(this);
    }).add({
        scaleTreatsNullAs: function() {
            return "null";
        },
        scaleNullRangeValue: function() {
            return null;
        },
        scaleUsesAbs: def.retFalse,
        scaleSumNormalized: def.retFalse,
        domainVisibleOnly: def.retTrue,
        domainIgnoreNulls: def.retFalse,
        domainGroupOperator: function() {
            return "flatten";
        },
        domainItemValueProp: function() {
            return "value";
        },
        bind: function(dataCells) {
            var me = this;
            dataCells || def.fail.argumentRequired("dataCells");
            !me.dataCells || def.fail.operationInvalid("Axis is already bound.");
            me.dataCells = def.array.to(dataCells);
            me.dataCell = me.dataCells[0];
            me.role = me.dataCell && me.dataCell.role;
            me.scaleType = axis_groupingScaleType(me.role.grouping);
            me._domainData = null;
            me._domainValues = null;
            me._domainItems = null;
            me._checkRoleCompatibility();
            return this;
        },
        domainData: function() {
            this.isBound() || def.fail.operationInvalid("Axis is not bound.");
            var domainData = this._domainData;
            if (!domainData) {
                var dataPartValues = this.dataCells.map(dataCell_dataPartValue)
                  , partsData = this.chart.partData(dataPartValues);
                this._domainData = domainData = this._createDomainData(partsData);
            }
            return domainData;
        },
        domainCellData: function(cellIndex) {
            var dataCells = this.dataCells;
            if (1 === dataCells.length)
                return this.domainData();
            var dataCell = dataCells[cellIndex]
              , partData = this.chart.partData(dataCell.dataPartValue);
            return this._createDomainData(partData);
        },
        domainCellItems: function(cellDataOrIndex) {
            var dataCells = this.dataCells;
            if (1 === dataCells.length)
                return this.domainItems();
            var cellData;
            cellData = "number" == typeof cellDataOrIndex ? this.domainCellData(cellDataOrIndex) : cellDataOrIndex;
            return this._selectDomainItems(cellData).array();
        },
        domainValues: function() {
            var domainValues = this._domainValues;
            if (!domainValues) {
                this._calcDomainItems();
                domainValues = this._domainValues;
            }
            return domainValues;
        },
        domainItems: function() {
            var domainItems = this._domainItems;
            if (!domainItems) {
                this._calcDomainItems();
                domainItems = this._domainItems;
            }
            return domainItems;
        },
        domainItemValue: function(itemData) {
            return def.nullyTo(itemData[this.domainItemValueProp()], "");
        },
        isDiscrete: function() {
            return !!this.role && this.role.isDiscrete();
        },
        isBound: function() {
            return !!this.role;
        },
        setScale: function(scale, noWrap) {
            this.isBound() || def.fail.operationInvalid("Axis is not bound.");
            this.scale = scale ? noWrap ? scale : this._wrapScale(scale) : null;
            return this;
        },
        _wrapScale: function(scale) {
            scale.type = this.scaleType;
            var by;
            if ("discrete" !== scale.type) {
                var useAbs = this.scaleUsesAbs()
                  , nullAs = this.scaleTreatsNullAs();
                if (nullAs && "null" !== nullAs) {
                    var nullIsMin = "min" === nullAs;
                    by = useAbs ? function(v) {
                        return scale(null == v ? nullIsMin ? scale.domain()[0] : 0 : 0 > v ? -v : v);
                    }
                    : function(v) {
                        return scale(null == v ? nullIsMin ? scale.domain()[0] : 0 : v);
                    }
                    ;
                } else {
                    var nullRangeValue = this.scaleNullRangeValue();
                    by = useAbs ? function(v) {
                        return null == v ? nullRangeValue : scale(0 > v ? -v : v);
                    }
                    : function(v) {
                        return null == v ? nullRangeValue : scale(v);
                    }
                    ;
                }
            } else
                by = function(v) {
                    return scale(null == v ? "" : v);
                }
                ;
            return def.copy(by, scale);
        },
        sceneScale: function(keyArgs) {
            var varName = def.get(keyArgs, "sceneVarName") || this.role.name
              , grouping = this.role.grouping;
            if (grouping.isSingleDimension && grouping.firstDimensionValueType() === Number) {
                var scale = this.scale
                  , nullToZero = def.get(keyArgs, "nullToZero", !0)
                  , by = function(scene) {
                    var value = scene.vars[varName].value;
                    if (null == value) {
                        if (!nullToZero)
                            return value;
                        value = 0;
                    }
                    return scale(value);
                };
                def.copy(by, scale);
                return by;
            }
            return this.scale.by1(function(scene) {
                return scene.vars[varName].value;
            });
        },
        _checkRoleCompatibility: function() {
            var L = this.dataCells.length;
            if (L > 1) {
                var otherGrouping, i, grouping = this._getBoundRoleGrouping(this.role);
                if ("discrete" === this.scaleType)
                    for (i = 1; L > i; i++) {
                        otherGrouping = this._getBoundRoleGrouping(this.dataCells[i].role);
                        if (grouping.id !== otherGrouping.id)
                            throw def.error.operationInvalid("Discrete roles on the same axis must have equal groupings.");
                    }
                else {
                    if (!grouping.firstDimensionType().isComparable)
                        throw def.error.operationInvalid("Continuous roles on the same axis must have 'comparable' groupings.");
                    for (i = 1; L > i; i++) {
                        otherGrouping = this._getBoundRoleGrouping(this.dataCells[i].role);
                        if (this.scaleType !== axis_groupingScaleType(otherGrouping))
                            throw def.error.operationInvalid("Continuous roles on the same axis must have scales of the same type.");
                    }
                }
            }
        },
        _getBoundRoleGrouping: function(role) {
            var grouping = role.grouping;
            if (!grouping)
                throw def.error.operationInvalid("Axis' role '" + role.name + "' is unbound.");
            return grouping;
        },
        _createDomainData: function(baseData) {
            var keyArgs = {
                visible: this.domainVisibleOnly() ? !0 : null,
                isNull: this.chart.options.ignoreNulls || this.domainIgnoreNulls() ? !1 : null
            };
            return this.role[this.domainGroupOperator()](baseData, keyArgs);
        },
        _selectDomainItems: function(domainData) {
            return domainData.children();
        },
        _calcDomainItems: function() {
            var hasOwn = def.hasOwnProp
              , domainValuesSet = {}
              , domainValues = []
              , domainItems = []
              , domainData = (this.domainItemValueProp(),
            this.domainData());
            this._selectDomainItems(domainData).each(function(itemData) {
                var itemValue = this.domainItemValue(itemData);
                if (!hasOwn.call(domainValuesSet, itemValue)) {
                    domainValuesSet[itemValue] = 1;
                    domainValues.push(itemValue);
                    domainItems.push(itemData);
                }
            }, this);
            this._domainItems = domainItems;
            this._domainValues = domainValues;
        },
        _getOptionsDefinition: function() {
            return axis_optionsDef;
        }
    })
      , axis_optionsDef = {}
      , pvc_CartesianAxis = def.type("pvc.visual.CartesianAxis", pvc_Axis).init(function(chart, type, index, keyArgs) {
        var options = chart.options;
        this.orientation = pvc_CartesianAxis.getOrientation(type, options.orientation);
        this.orientedId = pvc_CartesianAxis.getOrientedId(this.orientation, index);
        chart._allowV1SecondAxis && 1 === index && (this.v1SecondOrientedId = "second" + this.orientation.toUpperCase());
        this.base(chart, type, index, keyArgs);
        var extensions = this.extensionPrefixes = [this.id + "Axis", this.orientedId + "Axis"];
        this.v1SecondOrientedId && extensions.push(this.v1SecondOrientedId + "Axis");
        this._extPrefAxisPosition = extensions.length;
        extensions.push("axis");
    }).add({
        bind: function(dataCells) {
            this.base(dataCells);
            this._syncExtensionPrefixes();
            return this;
        },
        _syncExtensionPrefixes: function() {
            var extensions = this.extensionPrefixes;
            extensions.length = this._extPrefAxisPosition;
            var st = this.scaleType;
            if (st) {
                extensions.push(st + "Axis");
                "discrete" !== st && extensions.push("continuousAxis");
            }
            extensions.push("axis");
        },
        setScale: function(scale) {
            var oldScale = this.scale;
            this.base(scale);
            if (oldScale) {
                delete this.domain;
                delete this.ticks;
                delete this._roundingPaddings;
            }
            if (scale && !scale.isNull && "discrete" !== this.scaleType) {
                this.domain = scale.domain();
                this.domain.minLocked = !!scale.minLocked;
                this.domain.maxLocked = !!scale.maxLocked;
                var roundMode = this.option("DomainRoundMode");
                "nice" === roundMode && scale.nice();
                var tickFormatter = this.option("TickFormatter");
                tickFormatter && scale.tickFormatter(tickFormatter);
            }
            return this;
        },
        setTicks: function(ticks) {
            var scale = this.scale;
            scale && !scale.isNull || def.fail.operationInvalid("Scale must be set and non-null.");
            this.ticks = ticks;
            if ("discrete" !== scale.type && "tick" === this.option("DomainRoundMode")) {
                delete this._roundingPaddings;
                var tickCount = ticks && ticks.length;
                tickCount ? this.scale.domain(ticks[0], ticks[tickCount - 1]) : this.scale.domain(this.domain[0], this.domain[1]);
            }
        },
        setScaleRange: function(size) {
            var scale = this.scale;
            scale.min = 0;
            scale.max = size;
            scale.size = size;
            if ("discrete" === scale.type) {
                if (scale.domain().length > 0) {
                    var bandRatio = this.chart.options.panelSizeRatio || .8;
                    scale.splitBandedCenter(scale.min, scale.max, bandRatio);
                }
            } else
                scale.range(scale.min, scale.max);
            return scale;
        },
        getScaleRoundingPaddings: function() {
            var roundingPaddings = this._roundingPaddings;
            if (!roundingPaddings) {
                roundingPaddings = {
                    begin: 0,
                    end: 0,
                    beginLocked: !1,
                    endLocked: !1
                };
                var scale = this.scale;
                if (scale && !scale.isNull && "discrete" !== scale.type) {
                    var originalDomain = this.domain;
                    roundingPaddings.beginLocked = originalDomain.minLocked;
                    roundingPaddings.endLocked = originalDomain.maxLocked;
                    if ("numeric" === scale.type && "none" !== this.option("DomainRoundMode")) {
                        var currDomain = scale.domain()
                          , origDomain = this.domain || def.assert("Original domain must be set")
                          , currLength = currDomain[1] - currDomain[0];
                        if (currLength) {
                            var diff = origDomain[0] - currDomain[0];
                            diff > 0 && (roundingPaddings.begin = diff / currLength);
                            diff = currDomain[1] - origDomain[1];
                            diff > 0 && (roundingPaddings.end = diff / currLength);
                        }
                    }
                }
                this._roundingPaddings = roundingPaddings;
            }
            return roundingPaddings;
        },
        calcContinuousTicks: function(desiredTickCount) {
            null == desiredTickCount && (desiredTickCount = this.option("DesiredTickCount"));
            return this.scale.ticks(desiredTickCount, {
                roundInside: "tick" !== this.option("DomainRoundMode"),
                numberExponentMin: this.option("TickExponentMin"),
                numberExponentMax: this.option("TickExponentMax")
            });
        },
        _getOptionsDefinition: function() {
            return cartAxis_optionsDef;
        },
        _buildOptionId: function() {
            return this.id + "Axis";
        },
        _registerResolversNormal: function(rs) {
            this.chart.compatVersion() <= 1 && rs.push(this._resolveByV1OnlyLogic);
            rs.push(this._resolveByOptionId, this._resolveByOrientedId);
            1 === this.index && rs.push(this._resolveByV1OptionId);
            rs.push(this._resolveByScaleType, this._resolveByCommonId);
        },
        _resolveByOrientedId: pvc.options.specify(function(optionInfo) {
            return this._chartOption(this.orientedId + "Axis" + optionInfo.name);
        }),
        _resolveByV1OptionId: pvc.options.specify(function(optionInfo) {
            return this._chartOption("secondAxis" + optionInfo.name);
        }),
        _resolveByScaleType: pvc.options.specify(function(optionInfo) {
            var st = this.scaleType;
            if (st) {
                var name = optionInfo.name
                  , value = this._chartOption(st + "Axis" + name);
                void 0 === value && "discrete" !== st && (value = this._chartOption("continuousAxis" + name));
                return value;
            }
        }),
        _resolveByCommonId: pvc.options.specify(function(optionInfo) {
            return this._chartOption("axis" + optionInfo.name);
        })
    });
    pvc_CartesianAxis.getOrientation = function(type, chartOrientation) {
        return "base" === type == ("vertical" === chartOrientation) ? "x" : "y";
    }
    ;
    pvc_CartesianAxis.getOrientedId = function(orientation, index) {
        return 0 === index ? orientation : orientation + (index + 1);
    }
    ;
    var cartAxis_fixedMinMaxSpec = {
        resolve: "_resolveFull",
        data: {
            resolveV1: function(optionInfo) {
                this.index || "ortho" !== this.type || this._specifyChartOption(optionInfo, this.id + optionInfo.name);
                return !0;
            }
        }
    }
      , cartAxis_normalV1Data = {
        resolveV1: function(optionInfo) {
            if (this.index) {
                if (this._resolveByV1OptionId(optionInfo))
                    return !0;
            } else if (this._resolveByOrientedId(optionInfo))
                return !0;
            this._resolveDefault(optionInfo);
            return !0;
        }
    }
      , defaultPosition = pvc.options.defaultValue(function() {
        if (!this.typeIndex)
            return "x" === this.orientation ? "bottom" : "left";
        var firstAxis = this.chart.axesByType[this.type].first
          , position = firstAxis.option("Position");
        return pvc.BasePanel.oppositeAnchor[position];
    })
      , cartAxis_optionsDef = def.create(axis_optionsDef, {
        Visible: {
            resolve: "_resolveFull",
            data: {
                resolveV1: function(optionInfo) {
                    if (this.index <= 1) {
                        var v1OptionId = 0 === this.index ? def.firstUpperCase(this.orientation) : "Second";
                        this._specifyChartOption(optionInfo, "show" + v1OptionId + "Scale");
                    }
                    return !0;
                }
            },
            cast: Boolean,
            value: !0
        },
        Composite: {
            resolve: function(optionInfo) {
                if (this.index > 0) {
                    optionInfo.specify(!1);
                    return !0;
                }
                return this._resolveFull(optionInfo);
            },
            data: {
                resolveV1: function(optionInfo) {
                    this._specifyChartOption(optionInfo, "useCompositeAxis");
                    return !0;
                }
            },
            cast: Boolean,
            value: !1
        },
        Size: {
            resolve: "_resolveFull",
            data: cartAxis_normalV1Data,
            cast: cartAxis_castSize
        },
        SizeMax: {
            resolve: "_resolveFull",
            cast: cartAxis_castSize
        },
        Position: {
            resolve: "_resolveFull",
            data: {
                resolveV1: cartAxis_normalV1Data.resolveV1,
                resolveDefault: defaultPosition
            },
            cast: pvc_castAxisPosition
        },
        FixedMin: cartAxis_fixedMinMaxSpec,
        FixedMax: cartAxis_fixedMinMaxSpec,
        OriginIsZero: {
            resolve: "_resolveFull",
            data: {
                resolveV1: function(optionInfo) {
                    switch (this.index) {
                    case 0:
                        this._specifyChartOption(optionInfo, "originIsZero");
                        break;

                    case 1:
                        this.chart._allowV1SecondAxis && this._specifyChartOption(optionInfo, "secondAxisOriginIsZero");
                    }
                    return !0;
                }
            },
            cast: Boolean,
            value: !0
        },
        DomainScope: {
            resolve: "_resolveFull",
            cast: pvc_castDomainScope,
            value: "global"
        },
        Offset: {
            resolve: "_resolveFull",
            data: {
                resolveV1: function(optionInfo) {
                    switch (this.index) {
                    case 0:
                        this._specifyChartOption(optionInfo, "axisOffset");
                        break;

                    case 1:
                        if (this.chart._allowV1SecondAxis) {
                            this._specifyChartOption(optionInfo, "secondAxisOffset");
                            break;
                        }
                    }
                    return !0;
                }
            },
            cast: pvc.castNumber
        },
        LabelSpacingMin: {
            resolve: "_resolveFull",
            cast: pvc.castNumber
        },
        OverlappedLabelsMode: {
            resolve: "_resolveFull",
            cast: pvc.parseOverlappedLabelsMode,
            value: "rotatethenhide"
        },
        Grid: {
            resolve: "_resolveFull",
            data: {
                resolveV1: function(optionInfo) {
                    this.index || this._specifyChartOption(optionInfo, this.orientation + "AxisFullGrid");
                    return !0;
                }
            },
            cast: Boolean,
            value: !1
        },
        GridCrossesMargin: {
            resolve: "_resolveFull",
            cast: Boolean,
            value: !0
        },
        EndLine: {
            resolve: "_resolveFull",
            cast: Boolean
        },
        ZeroLine: {
            resolve: "_resolveFull",
            cast: Boolean,
            value: !0
        },
        RuleCrossesMargin: {
            resolve: "_resolveFull",
            cast: Boolean,
            value: !0
        },
        Ticks: {
            resolve: "_resolveFull",
            cast: Boolean
        },
        DesiredTickCount: {
            resolve: "_resolveFull",
            data: {
                resolveV1: cartAxis_normalV1Data.resolveV1,
                resolveDefault: function(optionInfo) {
                    if (this.chart.compatVersion() <= 1) {
                        optionInfo.defaultValue(5);
                        return !0;
                    }
                }
            },
            cast: pvc.castNumber
        },
        MinorTicks: {
            resolve: "_resolveFull",
            data: cartAxis_normalV1Data,
            cast: Boolean,
            value: !0
        },
        TickFormatter: {
            resolve: "_resolveFull",
            cast: def.fun.as
        },
        DomainRoundMode: {
            resolve: "_resolveFull",
            data: {
                resolveV1: cartAxis_normalV1Data.resolveV1,
                resolveDefault: function(optionInfo) {
                    if (this.chart.compatVersion() <= 1) {
                        optionInfo.defaultValue("none");
                        return !0;
                    }
                }
            },
            cast: pvc.parseDomainRoundingMode,
            value: "tick"
        },
        TickExponentMin: {
            resolve: "_resolveFull",
            cast: pvc.castNumber
        },
        TickExponentMax: {
            resolve: "_resolveFull",
            cast: pvc.castNumber
        },
        Title: {
            resolve: "_resolveFull",
            cast: String
        },
        TitleSize: {
            resolve: "_resolveFull",
            cast: cartAxis_castTitleSize
        },
        TitleSizeMax: {
            resolve: "_resolveFull",
            cast: cartAxis_castTitleSize
        },
        TitleFont: {
            resolve: "_resolveFull",
            cast: String
        },
        TitleMargins: {
            resolve: "_resolveFull",
            cast: pvc_Sides.as
        },
        TitlePaddings: {
            resolve: "_resolveFull",
            cast: pvc_Sides.as
        },
        TitleAlign: {
            resolve: "_resolveFull",
            cast: function(align) {
                var position = this.option("Position");
                return pvc.parseAlign(position, align);
            }
        },
        Font: {
            resolve: "_resolveFull",
            cast: String
        },
        ClickAction: {
            resolve: "_resolveFull",
            data: cartAxis_normalV1Data
        },
        DoubleClickAction: {
            resolve: "_resolveFull",
            data: cartAxis_normalV1Data
        },
        TooltipEnabled: {
            resolve: "_resolveFull",
            cast: Boolean,
            value: !0
        },
        TooltipFormat: {
            resolve: "_resolveFull",
            cast: def.fun.as,
            value: null
        },
        TooltipAutoContent: {
            resolve: "_resolveFull",
            cast: pvc.parseTooltipAutoContent,
            value: "value"
        }
    });
    def.type("pvc.visual.CartesianAxisRootScene", pvc.visual.Scene);
    def.type("pvc.visual.CartesianAxisTickScene", pvc.visual.Scene).init(function(parent, keyArgs) {
        this.base(parent, keyArgs);
        this.vars.tick = new pvc_ValueLabelVar(def.get(keyArgs, "tick"),def.get(keyArgs, "tickLabel"),def.get(keyArgs, "tickRaw"));
        def.get(keyArgs, "isHidden") && (this.isHidden = !0);
    }).add({
        isHidden: !1
    });
    def.type("pvc.visual.CartesianFocusWindow", pvc.visual.OptionsBase).init(function(chart) {
        this.base(chart, "focusWindow", 0, {
            byNaked: !1
        });
        var baseAxis = chart.axes.base;
        this.base = new pvc.visual.CartesianFocusWindowAxis(this,baseAxis);
    }).add({
        _getOptionsDefinition: function() {
            return focusWindow_optionsDef;
        },
        _exportData: function() {
            return {
                base: def.copyProps(this.base, pvc.visual.CartesianFocusWindow.props)
            };
        },
        _importData: function(data) {
            var baseData = data.base;
            this.base.option.specify({
                Begin: baseData.begin,
                End: baseData.end,
                Length: baseData.length
            });
        },
        _initFromOptions: function() {
            this.base._initFromOptions();
        },
        _onAxisChanged: function() {
            var changed = this.option("Changed");
            changed && changed.call(this.chart.basePanel.context());
        }
    });
    var focusWindow_optionsDef = def.create(axis_optionsDef, {
        Changed: {
            resolve: "_resolveFull",
            cast: def.fun.as
        }
    });
    def.type("pvc.visual.CartesianFocusWindowAxis", pvc.visual.OptionsBase).init(function(fw, axis) {
        this.window = fw;
        this.axis = axis;
        this.isDiscrete = axis.isDiscrete();
        this.base(axis.chart, "focusWindow" + def.firstUpperCase(axis.type), 0, {
            byNaked: !1
        });
    }).addStatic({
        props: ["begin", "end", "length"]
    }).add({
        _getOptionsDefinition: function() {
            return focusWindowAxis_optionsDef;
        },
        _initFromOptions: function() {
            var o = this.option;
            this.set({
                begin: o("Begin"),
                end: o("End"),
                length: o("Length")
            });
        },
        set: function(keyArgs) {
            var b, e, l, me = this, render = def.get(keyArgs, "render"), select = def.get(keyArgs, "select", !0);
            keyArgs = me._readArgs(keyArgs);
            if (keyArgs) {
                b = keyArgs.begin;
                e = keyArgs.end;
                l = keyArgs.length;
            } else if (null != this.begin && null != this.end && null != this.length)
                return;
            var a, L, axis = me.axis, scale = axis.scale, isDiscrete = me.isDiscrete, contCast = isDiscrete ? null : axis.role.firstDimensionType().cast, domain = scale.domain();
            if (isDiscrete) {
                L = domain.length;
                var ib, ie, ia;
                if (null != b) {
                    var nb = +b;
                    if (!isNaN(nb))
                        if (1 / 0 === nb) {
                            ib = L - 1;
                            b = domain[ib];
                        } else if (nb === -1 / 0) {
                            ib = 0;
                            b = domain[ib];
                        }
                    if (null == ib) {
                        ib = domain.indexOf("" + b);
                        if (0 > ib) {
                            ib = 0;
                            b = domain[ib];
                        }
                    }
                }
                if (null != e) {
                    var ne = +e;
                    if (!isNaN(ne))
                        if (1 / 0 === ne) {
                            ie = L - 1;
                            e = domain[ie];
                        } else if (ne === -1 / 0) {
                            ie = 0;
                            e = domain[ie];
                        }
                    if (null == ie) {
                        ie = domain.indexOf("" + e);
                        if (0 > ie) {
                            ie = L - 1;
                            e = domain[ie];
                        }
                    }
                }
                if (null != l) {
                    l = +l;
                    if (isNaN(l))
                        l = null;
                    else if (0 > l && (null != b || null != e)) {
                        a = b;
                        ia = ib;
                        b = e,
                        ib = ie,
                        e = a,
                        ie = ia;
                        l = -l;
                    }
                }
                if (null != b)
                    if (null != e) {
                        if (ib > ie) {
                            a = b;
                            ia = ib;
                            b = e,
                            ib = ie,
                            e = a,
                            ie = ia;
                        }
                        l = ie - ib + 1;
                    } else {
                        null == l && (l = L - ib);
                        ie = ib + l - 1;
                        if (ie > L - 1) {
                            ie = L - 1;
                            l = ie - ib + 1;
                        }
                        e = domain[ie];
                    }
                else if (null != e) {
                    null == l && (l = ie);
                    ib = ie - l + 1;
                    if (0 > ib) {
                        ib = 0;
                        l = ie - ib + 1;
                    }
                    b = domain[ib];
                } else {
                    null == l && (l = Math.max(~~(L / 3), 1));
                    if (l > L) {
                        l = L;
                        ib = 0;
                        ie = L - 1;
                    } else {
                        ia = ~~(L / 2);
                        ib = ia - ~~(l / 2);
                        ie = ib + l - 1;
                    }
                    b = domain[ib];
                    e = domain[ie];
                }
            } else {
                if (null != l) {
                    l = +l;
                    if (isNaN(l))
                        l = null;
                    else if (0 > l && (null != b || null != e)) {
                        a = b;
                        b = e,
                        e = a;
                        l = -l;
                    }
                }
                var min = domain[0]
                  , max = domain[1];
                L = max - min;
                if (null != b) {
                    min > b && (b = min);
                    b > max && (b = max);
                }
                if (null != e) {
                    min > e && (e = min);
                    e > max && (e = max);
                }
                if (null != b)
                    if (null != e) {
                        if (b > e) {
                            a = b;
                            b = e,
                            e = a;
                        }
                        l = e - b;
                    } else {
                        null == l && (l = max - b);
                        e = b + l;
                        if (e > max) {
                            e = max;
                            l = e - b;
                        }
                    }
                else if (null != e) {
                    null == l && (l = e - min);
                    b = e - l;
                    if (min > b) {
                        b = min;
                        l = e - b;
                    }
                } else {
                    null == l && (l = Math.max(~~(L / 3), 1));
                    if (l > L) {
                        l = L;
                        b = min;
                        e = max;
                    } else {
                        a = ~~(L / 2);
                        b = a - ~~(l / 2);
                        var bAux = +b
                          , lAux = +l;
                        e = bAux + lAux;
                    }
                }
                b = contCast(b);
                e = contCast(e);
                l = contCast(l);
                var constraint = me.option("Constraint");
                if (constraint) {
                    var oper2 = {
                        type: "new",
                        target: "begin",
                        value: b,
                        length: l,
                        length0: l,
                        min: min,
                        max: max,
                        minView: min,
                        maxView: max
                    };
                    constraint(oper2);
                    b = contCast(oper2.value);
                    l = contCast(oper2.length);
                    var bAux = +b
                      , lAux = +l;
                    e = contCast(bAux + lAux);
                }
            }
            me._set(b, e, l, select, render);
        },
        _updatePosition: function(pbeg, pend, select, render) {
            var b, e, l, me = this, axis = me.axis, scale = axis.scale;
            if (me.isDiscrete) {
                var ib = scale.invertIndex(pbeg)
                  , ie = scale.invertIndex(pend) - 1
                  , domain = scale.domain();
                b = domain[ib];
                e = domain[ie];
                l = ie - ib + 1;
            } else {
                b = scale.invert(pbeg);
                e = scale.invert(pend);
                l = e - b;
            }
            this._set(b, e, l, select, render);
        },
        _constraintPosition: function(oper) {
            var constraint, me = this, axis = me.axis, scale = axis.scale;
            if (me.isDiscrete) {
                var index = Math.floor(scale.invertIndex(oper.point, !0));
                if (index >= 0) {
                    var r = scale.range()
                      , L = scale.domain().length
                      , S = (r.max - r.min) / L;
                    index >= L && ("new" === oper.type || "resize-begin" === oper.type) && (index = L - 1);
                    oper.point = index * S;
                }
            } else if (constraint = me.option("Constraint")) {
                var vlength0, pother0, vother0, contCast = axis.role.firstDimensionType().cast, v = contCast(scale.invert(oper.point)), sign = "begin" === oper.target ? 1 : -1, pother = oper.point + sign * oper.length, vother = contCast(scale.invert(pother)), vlength = contCast(sign * (vother - v));
                if (oper.length === oper.length0)
                    vlength0 = vlength;
                else {
                    pother0 = oper.point + sign * oper.length0;
                    vother0 = contCast(scale.invert(pother0));
                    vlength0 = sign * (vother0 - v);
                }
                var vmin = contCast(scale.invert(oper.min))
                  , vmax = contCast(scale.invert(oper.max))
                  , oper2 = {
                    type: oper.type,
                    target: oper.target,
                    value: v,
                    length: vlength,
                    length0: vlength0,
                    min: vmin,
                    max: vmax,
                    minView: contCast(scale.invert(oper.minView)),
                    maxView: contCast(scale.invert(oper.maxView))
                };
                constraint(oper2);
                if (+oper2.value !== +v) {
                    v = oper2.value;
                    oper.point = scale(v);
                }
                var vlength2 = oper2.length;
                if (+vlength2 !== +vlength)
                    if (+vlength2 === +vlength0)
                        oper.length = oper.length0;
                    else {
                        var vother2 = +v + sign * +vlength2
                          , pother2 = scale(vother2);
                        oper.length = pother2 - sign * oper.point;
                    }
                +oper2.min !== +vmin && (oper.min = scale(oper2.min));
                +oper2.max !== +vmax && (oper.max = scale(oper2.max));
            }
        },
        _compare: function(a, b) {
            return this.isDiscrete ? "" + a == "" + b : +a === +b;
        },
        _set: function(b, e, l, select, render) {
            var me = this
              , changed = !1;
            if (!me._compare(b, me.begin)) {
                me.begin = b;
                changed = !0;
            }
            if (!me._compare(e, me.end)) {
                me.end = e;
                changed = !0;
            }
            if (!me._compare(l, me.length)) {
                me.length = l;
                changed = !0;
            }
            changed && me.window._onAxisChanged(this);
            select && me._updateSelection({
                render: render
            });
            return changed;
        },
        _readArgs: function(keyArgs) {
            if (keyArgs) {
                var out = {}
                  , any = 0
                  , read = function(p) {
                    var v = keyArgs[p];
                    null != v ? any = !0 : v = this[p];
                    out[p] = v;
                };
                pvc.visual.CartesianFocusWindowAxis.props.forEach(read, this);
                if (any)
                    return out;
            }
        },
        _updateSelection: function(keyArgs) {
            var selectDatums, domainData, me = this, axis = me.axis, isDiscrete = axis.isDiscrete(), chart = axis.chart, dataCell = axis.dataCell, role = dataCell.role, partData = chart.partData(dataCell.dataPartValue);
            if (isDiscrete) {
                domainData = role.flatten(partData);
                var dataBegin = domainData.child(me.begin)
                  , dataEnd = domainData.child(me.end);
                if (dataBegin && dataEnd) {
                    var indexBegin = dataBegin.childIndex()
                      , indexEnd = dataEnd.childIndex();
                    selectDatums = def.range(indexBegin, indexEnd - indexBegin + 1).select(function(index) {
                        return domainData.childNodes[index];
                    }).selectMany(def.propGet("_datums")).where(datum_isVisibleT).distinct(def.propGet("key"));
                }
            } else {
                domainData = partData;
                var dimName = role.firstDimensionName();
                selectDatums = def.query(partData._datums).where(datum_isVisibleT).where(function(datum) {
                    var v = datum.atoms[dimName].value;
                    return null != v && v >= me.begin && v <= me.end;
                });
            }
            if (selectDatums) {
                chart.data.replaceSelected(selectDatums);
                chart.root.updateSelections(keyArgs);
            }
        }
    });
    var focusWindowAxis_optionsDef = def.create(axis_optionsDef, {
        Resizable: {
            resolve: "_resolveFull",
            cast: Boolean,
            value: !0
        },
        Movable: {
            resolve: "_resolveFull",
            cast: Boolean,
            value: !0
        },
        Begin: {
            resolve: "_resolveFull"
        },
        End: {
            resolve: "_resolveFull"
        },
        Length: {
            resolve: "_resolveFull"
        },
        Constraint: {
            resolve: "_resolveFull",
            cast: def.fun.as
        }
    });
    def.type("pvc.visual.ColorAxis", pvc_Axis).add({
        scaleNullRangeValue: function() {
            return this.option("Missing") || null;
        },
        scaleUsesAbs: function() {
            return this.option("UseAbs");
        },
        domainVisibleOnly: function() {
            return "discrete" !== this.scaleType;
        },
        bind: function(dataCells) {
            this.base(dataCells);
            this._legendGroupScene = null;
            this._plotList = def.query(dataCells).select(function(dataCell) {
                return dataCell.plot;
            }).distinct(function(plot) {
                return plot && plot.id;
            }).array();
            return this;
        },
        _wrapScale: function(scale) {
            var applyTransf;
            applyTransf = "discrete" === this.scaleType ? this.option.isSpecified("Transform") || !this.option.isSpecified("Colors") && !this.option.isSpecified("Map") : !0;
            if (applyTransf) {
                var colorTransf = this.option("Transform");
                colorTransf && (scale = scale.transform(colorTransf));
            }
            return this.base(scale);
        },
        scheme: function() {
            return def.lazy(this, "_scheme", this._createScheme, this);
        },
        _createColorMapFilter: function(colorMap) {
            var fixedColors = def.uniqueIndex(colorMap, function(c) {
                return c.key;
            });
            return {
                domain: function(k) {
                    return !def.hasOwn(colorMap, k);
                },
                color: function(c) {
                    return !def.hasOwn(fixedColors, c.key);
                }
            };
        },
        _getBaseScheme: function() {
            return this.option("Colors");
        },
        _createScheme: function() {
            var me = this
              , baseScheme = me._getBaseScheme();
            if ("discrete" !== me.scaleType)
                return function() {
                    var scale = baseScheme.apply(null, arguments);
                    return me._wrapScale(scale);
                }
                ;
            var colorMap = me.option("Map");
            if (!colorMap)
                return function() {
                    var scale = baseScheme.apply(null, arguments);
                    return me._wrapScale(scale);
                }
                ;
            var filter = this._createColorMapFilter(colorMap);
            return function(d) {
                var scale;
                d instanceof Array || (d = def.array.copy(arguments));
                d = d.filter(filter.domain);
                var baseScale = baseScheme(d)
                  , r = baseScale.range().filter(filter.color);
                baseScale.range(r);
                scale = function(k) {
                    var c = def.getOwn(colorMap, k);
                    return c || baseScale(k);
                }
                ;
                def.copy(scale, baseScale);
                var dx, rx;
                scale.domain = function() {
                    if (arguments.length)
                        throw def.operationInvalid("The scale cannot be modified.");
                    dx || (dx = def.array.append(def.ownKeys(colorMap), d));
                    return dx;
                }
                ;
                scale.range = function() {
                    if (arguments.length)
                        throw def.operationInvalid("The scale cannot be modified.");
                    rx || (rx = def.array.append(def.own(colorMap), r));
                    return rx;
                }
                ;
                return me._wrapScale(scale);
            }
            ;
        },
        sceneScale: function(keyArgs) {
            var varName = def.get(keyArgs, "sceneVarName") || this.role.name
              , fillColorScaleByColKey = this.scalesByCateg;
            if (fillColorScaleByColKey) {
                var colorMissing = this.option("Missing");
                return function(scene) {
                    var colorValue = scene.vars[varName].value;
                    if (null == colorValue)
                        return colorMissing;
                    var catAbsKey = scene.group.parent.absKey;
                    return fillColorScaleByColKey[catAbsKey](colorValue);
                }
                ;
            }
            return this.scale.by1(function(scene) {
                return scene && scene.vars[varName].value;
            });
        },
        _buildOptionId: function() {
            return this.id + "Axis";
        },
        _getOptionsDefinition: function() {
            return colorAxis_optionsDef;
        },
        _resolveByNaked: pvc.options.specify(function(optionInfo) {
            return this.index ? void 0 : this._chartOption(this.id + def.firstUpperCase(optionInfo.name));
        }),
        _specifyV1ChartOption: function(optionInfo, asName) {
            return !this.index && this.chart.compatVersion() <= 1 && this._specifyChartOption(optionInfo, asName) ? !0 : void 0;
        }
    });
    var colorAxis_defContColors, colorAxis_legendDataSpec = {
        resolveDefault: function(optionInfo) {
            return !this.index && this._specifyChartOption(optionInfo, def.firstLowerCase(optionInfo.name)) ? !0 : void 0;
        }
    }, colorAxis_optionsDef = def.create(axis_optionsDef, {
        Colors: {
            resolve: "_resolveFull",
            getDefault: colorAxis_getDefaultColors,
            data: {
                resolveV1: function(optionInfo) {
                    "discrete" === this.scaleType ? 0 === this.index ? this._specifyChartOption(optionInfo, "colors") : 1 === this.index && this.chart._allowV1SecondAxis && this._specifyChartOption(optionInfo, "secondAxisColor") : this._specifyChartOption(optionInfo, "colorRange");
                    return !0;
                },
                resolveDefault: function(optionInfo) {
                    0 === this.index && this._specifyChartOption(optionInfo, "colors");
                }
            },
            cast: pvc.colorScheme
        },
        Map: {
            resolve: "_resolveFull",
            cast: colorAxis_castColorMap
        },
        Transform: {
            resolve: "_resolveFull",
            data: {
                resolveDefault: function(optionInfo) {
                    var plotList = this._plotList;
                    if (plotList.length <= 2) {
                        var onlyTrendAndPlot2 = def.query(plotList).all(function(plot) {
                            var name = plot.name;
                            return "plot2" === name || "trend" === name;
                        });
                        if (onlyTrendAndPlot2) {
                            optionInfo.defaultValue(pvc.brighterColorTransform);
                            return !0;
                        }
                    }
                }
            },
            cast: def.fun.to
        },
        NormByCategory: {
            resolve: function(optionInfo) {
                if (!this.chart._allowColorPerCategory) {
                    optionInfo.specify(!1);
                    return !0;
                }
                return this._resolveFull(optionInfo);
            },
            data: {
                resolveV1: function(optionInfo) {
                    this._specifyV1ChartOption(optionInfo, "normPerBaseCategory");
                    return !0;
                }
            },
            cast: Boolean,
            value: !1
        },
        ScaleType: {
            resolve: "_resolveFull",
            data: {
                resolveV1: function(optionInfo) {
                    this._specifyV1ChartOption(optionInfo, "scalingType");
                    return !0;
                }
            },
            cast: pvc.parseContinuousColorScaleType,
            value: "linear"
        },
        UseAbs: {
            resolve: "_resolveFull",
            cast: Boolean,
            value: !1
        },
        Domain: {
            resolve: "_resolveFull",
            data: {
                resolveV1: function(optionInfo) {
                    this._specifyV1ChartOption(optionInfo, "colorRangeInterval");
                    return !0;
                }
            },
            cast: def.array.to
        },
        Min: {
            resolve: "_resolveFull",
            data: {
                resolveV1: function(optionInfo) {
                    this._specifyV1ChartOption(optionInfo, "minColor");
                    return !0;
                }
            },
            cast: pv.color
        },
        Max: {
            resolve: "_resolveFull",
            data: {
                resolveV1: function(optionInfo) {
                    this._specifyV1ChartOption(optionInfo, "maxColor");
                    return !0;
                }
            },
            cast: pv.color
        },
        Missing: {
            resolve: "_resolveFull",
            data: {
                resolveV1: function(optionInfo) {
                    this._specifyV1ChartOption(optionInfo, "nullColor");
                    return !0;
                }
            },
            cast: pv.color,
            value: pv.color("lightgray")
        },
        Unbound: {
            resolve: "_resolveFull",
            getDefault: function() {
                var scheme = this.option("Colors");
                return scheme().range()[0] || pvc.defaultColor;
            },
            cast: pv.color
        },
        LegendVisible: {
            resolve: "_resolveFull",
            data: colorAxis_legendDataSpec,
            cast: Boolean,
            value: !0
        },
        LegendClickMode: {
            resolve: "_resolveFull",
            data: colorAxis_legendDataSpec,
            cast: pvc.parseLegendClickMode,
            value: "togglevisible"
        },
        LegendDrawLine: {
            resolve: "_resolveFull",
            data: colorAxis_legendDataSpec,
            cast: Boolean,
            value: !1
        },
        LegendDrawMarker: {
            resolve: "_resolveFull",
            data: colorAxis_legendDataSpec,
            cast: Boolean,
            value: !0
        },
        LegendShape: {
            resolve: "_resolveFull",
            data: colorAxis_legendDataSpec,
            cast: pvc.parseShape
        }
    });
    def.type("pvc.visual.SizeAxis", pvc_Axis).init(function(chart, type, index, keyArgs) {
        keyArgs = def.set(keyArgs, "byNaked", !1);
        this.base(chart, type, index, keyArgs);
    }).add({
        _buildOptionId: function() {
            return this.id + "Axis";
        },
        scaleTreatsNullAs: function() {
            return "min";
        },
        scaleUsesAbs: function() {
            return this.option("UseAbs");
        },
        setScaleRange: function(range) {
            var scale = this.scale;
            scale.min = range.min;
            scale.max = range.max;
            scale.size = range.max - range.min;
            scale.range(scale.min, scale.max);
            pvc.debug >= 4 && pvc.log("Scale: " + pvc.stringify(def.copyOwn(scale)));
            return this;
        },
        _getOptionsDefinition: function() {
            return sizeAxis_optionsDef;
        }
    });
    var sizeAxis_optionsDef = def.create(axis_optionsDef, {
        OriginIsZero: {
            resolve: "_resolveFull",
            cast: Boolean,
            value: !1
        },
        FixedMin: {
            resolve: "_resolveFull",
            cast: pvc.castNumber
        },
        FixedMax: {
            resolve: "_resolveFull",
            cast: pvc.castNumber
        },
        UseAbs: {
            resolve: "_resolveFull",
            cast: Boolean,
            value: !1
        }
    });
    def.type("pvc.visual.NormalizedAxis", pvc_Axis).init(function(chart, type, index, keyArgs) {
        keyArgs = def.set(keyArgs, "byNaked", !1);
        this.base(chart, type, index, keyArgs);
    }).add({
        _buildOptionId: function() {
            return this.id + "Axis";
        },
        scaleTreatsNullAs: function() {
            return "zero";
        },
        scaleUsesAbs: def.retTrue,
        scaleSumNormalized: def.retTrue,
        setScaleRange: function(range) {
            var scale = this.scale;
            scale.min = range.min;
            scale.max = range.max;
            scale.size = range.max - range.min;
            scale.range(scale.min, scale.max);
            pvc.debug >= 4 && pvc.log("Scale: " + pvc.stringify(def.copyOwn(scale)));
            return this;
        },
        _getOptionsDefinition: function() {
            return normAxis_optionsDef;
        }
    });
    var normAxis_optionsDef = def.create(axis_optionsDef, {
        OriginIsZero: {
            value: !0
        }
    });
    def.type("pvc.visual.Legend", pvc.visual.OptionsBase).init(function(chart, type, index, keyArgs) {
        keyArgs = def.set(keyArgs, "byNaked", !1);
        this.base(chart, type, index, keyArgs);
    }).add({
        _getOptionsDefinition: function() {
            return legend_optionsDef;
        }
    });
    var legend_optionsDef = {
        Position: {
            resolve: "_resolveFull",
            cast: pvc.parsePosition,
            value: "bottom"
        },
        Size: {
            resolve: "_resolveFull",
            cast: legend_castSize
        },
        SizeMax: {
            resolve: "_resolveFull",
            cast: legend_castSize
        },
        Align: {
            resolve: "_resolveFull",
            data: {
                resolveDefault: function(optionInfo) {
                    var align, position = this.option("Position");
                    "top" !== position && "bottom" !== position ? align = "top" : this.chart.compatVersion() <= 1 && (align = "left");
                    optionInfo.defaultValue(align);
                    return !0;
                }
            },
            cast: legend_castAlign
        },
        Margins: {
            resolve: "_resolveFull",
            data: {
                resolveDefault: function(optionInfo) {
                    if (this.chart.compatVersion() > 1) {
                        var position = this.option("Position")
                          , margins = def.set({}, pvc.BasePanel.oppositeAnchor[position], 5);
                        optionInfo.defaultValue(margins);
                    }
                    return !0;
                }
            },
            cast: pvc_Sides.as
        },
        Paddings: {
            resolve: "_resolveFull",
            cast: pvc_Sides.as,
            value: 5
        },
        Font: {
            resolve: "_resolveFull",
            cast: String
        },
        ItemSize: {
            resolve: "_resolveFull",
            cast: legendItem_castSize
        }
    };
    def.type("pvc.visual.legend.BulletRootScene", pvc.visual.Scene).init(function(parent, keyArgs) {
        this.base(parent, keyArgs);
        this._unresolvedMarkerDiam = def.get(keyArgs, "markerSize");
        this._unresolvedItemPadding = new pvc_Sides(def.get(keyArgs, "itemPadding", 5));
        this._unresolvedItemSize = pvc_Size.to(def.get(keyArgs, "itemSize")) || new pvc_Size();
        def.set(this.vars, "horizontal", def.get(keyArgs, "horizontal", !1), "font", def.get(keyArgs, "font"), "textMargin", def.get(keyArgs, "textMargin", 6) - 3);
    }).add({
        layout: function(layoutInfo) {
            function layoutItem(itemScene) {
                var textSize = itemScene.labelTextSize()
                  , hidden = !textSize || !textSize.width || !textSize.height;
                itemScene.isHidden = hidden;
                if (!hidden) {
                    var isFirstInSection, itemContentSize = {
                        width: textLeft + textSize.width,
                        height: Math.max(textSize.height, markerDiam)
                    }, itemSize = {
                        width: desiredItemSize.width || itemPadding.width + itemContentSize.width,
                        height: desiredItemSize.height || itemPadding.height + itemContentSize.height
                    }, itemClientSize = {
                        width: Math.max(0, itemSize.width - itemPadding.width),
                        height: Math.max(0, itemSize.height - itemPadding.height)
                    };
                    if (section)
                        isFirstInSection = !section.items.length;
                    else {
                        section = new pvc.visual.legend.BulletItemSceneSection(0);
                        isFirstInSection = !0;
                    }
                    var $newSectionWidth = section.size[a_width] + itemClientSize[a_width];
                    isFirstInSection || ($newSectionWidth += itemPadding[a_width]);
                    if (!isFirstInSection && $newSectionWidth > $maxSectionWidth) {
                        commitSection(!1);
                        $newSectionWidth = itemClientSize[a_width];
                    }
                    var sectionSize = section.size;
                    sectionSize[a_width] = $newSectionWidth;
                    sectionSize[a_height] = Math.max(sectionSize[a_height], itemClientSize[a_height]);
                    var sectionIndex = section.items.length;
                    section.items.push(itemScene);
                    def.set(itemScene.vars, "section", section, "sectionIndex", sectionIndex, "textSize", textSize, "itemSize", itemSize, "itemClientSize", itemClientSize, "itemContentSize", itemContentSize);
                }
            }
            function commitSection(isLast) {
                var sectionSize = section.size;
                contentSize[a_height] += sectionSize[a_height];
                sections.length && (contentSize[a_height] += itemPadding[a_height]);
                contentSize[a_width] = Math.max(contentSize[a_width], sectionSize[a_width]);
                sections.push(section);
                isLast || (section = new pvc.visual.legend.BulletItemSceneSection(sections.length));
            }
            var clientSize = layoutInfo.clientSize;
            if (!(clientSize.width > 0 && clientSize.height > 0))
                return new pvc_Size(0,0);
            var desiredClientSize = layoutInfo.desiredClientSize
              , itemPadding = this._unresolvedItemPadding.resolve(clientSize)
              , extClientSize = {
                width: clientSize.width + itemPadding.width,
                height: clientSize.height + itemPadding.height
            }
              , desiredItemSize = this._unresolvedItemSize.resolve(extClientSize)
              , desiredItemClientSize = {
                width: desiredItemSize.width && Math.max(0, desiredItemSize.width - itemPadding.width),
                height: desiredItemSize.height && Math.max(0, desiredItemSize.height - itemPadding.height)
            }
              , markerDiam = this._unresolvedMarkerDiam || desiredItemClientSize.height || 15;
            this.vars.itemPadding = itemPadding;
            this.vars.desiredItemSize = desiredItemSize;
            this.vars.desiredItemClientSize = desiredItemClientSize;
            this.vars.markerSize = markerDiam;
            var textLeft = markerDiam + this.vars.textMargin
              , labelWidthMax = Math.max(0, Math.min(desiredItemClientSize.width || 1 / 0, desiredClientSize.width || 1 / 0, clientSize.width) - textLeft)
              , a_width = this.vars.horizontal ? "width" : "height"
              , a_height = pvc.BasePanel.oppositeLength[a_width]
              , $maxSectionWidth = desiredClientSize[a_width];
            (!$maxSectionWidth || 0 > $maxSectionWidth) && ($maxSectionWidth = clientSize[a_width]);
            var section, sections = [], contentSize = {
                width: 0,
                height: 0
            };
            this.childNodes.forEach(function(groupScene) {
                groupScene.childNodes.forEach(layoutItem, this);
            }, this);
            if (!section)
                return new pvc_Size(0,0);
            commitSection(!0);
            def.set(this.vars, "sections", sections, "contentSize", contentSize, "labelWidthMax", labelWidthMax);
            var isV1Compat = this.compatVersion() <= 1
              , $w = isV1Compat ? $maxSectionWidth : contentSize[a_width]
              , $h = desiredClientSize[a_height];
            (!$h || 0 > $h) && ($h = contentSize[a_height]);
            var requestSize = this.vars.size = def.set({}, a_width, Math.min($w, clientSize[a_width]), a_height, Math.min($h, clientSize[a_height]));
            return requestSize;
        },
        defaultGroupSceneType: function() {
            var GroupType = this._bulletGroupType;
            if (!GroupType) {
                GroupType = def.type(pvc.visual.legend.BulletGroupScene);
                this._bulletGroupType = GroupType;
            }
            return GroupType;
        },
        createGroup: function(keyArgs) {
            var GroupType = this.defaultGroupSceneType();
            return new GroupType(this,keyArgs);
        }
    });
    def.type("pvc.visual.legend.BulletItemSceneSection").init(function(index) {
        this.index = index;
        this.items = [];
        this.size = {
            width: 0,
            height: 0
        };
    });
    def.type("pvc.visual.legend.BulletGroupScene", pvc.visual.Scene).init(function(rootScene, keyArgs) {
        this.base(rootScene, keyArgs);
        this.extensionPrefix = def.get(keyArgs, "extensionPrefix") || "";
        this._renderer = def.get(keyArgs, "renderer");
        this.colorAxis = def.get(keyArgs, "colorAxis");
        this.clickMode = def.get(keyArgs, "clickMode");
        !this.clickMode && this.colorAxis && (this.clickMode = this.colorAxis.option("LegendClickMode"));
    }).add({
        hasRenderer: function() {
            return !!this._renderer;
        },
        renderer: function(renderer) {
            if (null != renderer)
                this._renderer = renderer;
            else {
                renderer = this._renderer;
                if (!renderer) {
                    var keyArgs, colorAxis = this.colorAxis;
                    colorAxis && (keyArgs = {
                        drawRule: colorAxis.option("LegendDrawLine"),
                        drawMarker: colorAxis.option("LegendDrawMarker"),
                        markerShape: colorAxis.option("LegendShape")
                    });
                    renderer = new pvc.visual.legend.BulletItemDefaultRenderer(keyArgs);
                    this._renderer = renderer;
                }
            }
            return renderer;
        },
        itemSceneType: function() {
            var ItemType = this._itemSceneType;
            if (!ItemType) {
                ItemType = def.type(pvc.visual.legend.BulletItemScene);
                var clickMode = this.clickMode;
                switch (clickMode) {
                case "toggleselected":
                    ItemType.add(pvc.visual.legend.BulletItemSceneSelection);
                    break;

                case "togglevisible":
                    ItemType.add(pvc.visual.legend.BulletItemSceneVisibility);
                }
                var legendPanel = this.panel();
                legendPanel._extendSceneType("item", ItemType, ["isOn", "executable", "execute", "value", "labelText"]);
                var itemSceneExtIds = pvc.makeExtensionAbsId(pvc.makeExtensionAbsId("ItemScene", [this.extensionPrefix, "$"]), legendPanel._getExtensionPrefix())
                  , impl = legendPanel.chart._getExtension(itemSceneExtIds, "value");
                void 0 !== impl && ItemType.prototype.variable("value", impl);
                this._itemSceneType = ItemType;
            }
            return ItemType;
        },
        createItem: function(keyArgs) {
            var ItemType = this.itemSceneType();
            return new ItemType(this,keyArgs);
        }
    });
    def.type("pvc.visual.legend.BulletItemScene", pvc.visual.Scene).init(function() {
        this.base.apply(this, arguments);
        if (!this.executable()) {
            var I = pvc.visual.Interactive;
            this._ibits = I.Interactive | I.ShowsInteraction | I.Hoverable | I.SelectableAny;
        }
    }).add({
        isOn: def.fun.constant(!0),
        executable: def.fun.constant(!1),
        execute: def.fun.constant(),
        labelText: function() {
            return this.value().label;
        },
        labelTextSize: function() {
            return pv.Text.measure(this.labelText(), this.vars.font);
        },
        _valueEval: function() {
            var valueVar = this._valueEvalCore();
            valueVar instanceof pvc_ValueLabelVar || (valueVar = new pvc_ValueLabelVar(valueVar,valueVar));
            return valueVar;
        },
        _valueEvalCore: function() {
            var value, rawValue, label, absLabel, trendSuffix, source = this.group || this.datum;
            if (source) {
                value = source.value;
                rawValue = source.rawValue;
                trendSuffix = this._getTrendLineSuffix(source);
                label = source.ensureLabel() + trendSuffix;
                absLabel = source.absLabel ? source.absLabel + trendSuffix : label;
            }
            return new pvc_ValueLabelVar(value || null,label || "",rawValue,absLabel);
        },
        _getTrendLineSuffix: function(source) {
            var datum, trendOptions;
            return (datum = source.firstDatum()) && (trendOptions = datum.trend) ? " (" + trendOptions.label + ")" : "";
        }
    }).prototype.variable("value");
    def.type("pvc.visual.legend.BulletItemSceneSelection").add({
        isOn: function() {
            var source = this.group || this.datum;
            return !source.owner.selectedCount() || this.isSelected();
        },
        executable: function() {
            return this.chart().selectableByClick();
        },
        execute: function() {
            var datums = this.datums().array();
            if (datums.length) {
                var chart = this.chart();
                chart._updatingSelections(function() {
                    datums = chart._onUserSelection(datums);
                    datums && datums.length && pvc.data.Data.toggleSelected(datums, !0);
                });
            }
        }
    });
    def.type("pvc.visual.legend.BulletItemSceneVisibility").add({
        isOn: function() {
            return this.datums().any(function(datum) {
                return !datum.isNull && datum.isVisible;
            });
        },
        executable: def.fun.constant(!0),
        execute: function() {
            pvc.data.Data.toggleVisible(this.datums()) && this.chart().render(!0, !0, !1);
        }
    });
    def.type("pvc.visual.legend.BulletItemRenderer");
    def.type("pvc.visual.legend.BulletItemDefaultRenderer", pvc.visual.legend.BulletItemRenderer).init(function(keyArgs) {
        this.drawRule = def.get(keyArgs, "drawRule", !0);
        this.drawRule && (this.rulePvProto = def.get(keyArgs, "rulePvProto"));
        this.drawMarker = this.drawRule || def.get(keyArgs, "drawMarker", !0);
        if (this.drawMarker) {
            this.markerShape = def.get(keyArgs, "markerShape", "square");
            this.markerPvProto = def.get(keyArgs, "markerPvProto");
        }
    }).add({
        drawRule: !0,
        drawMarker: !0,
        markerShape: null,
        rulePvProto: null,
        markerPvProto: null,
        create: function(legendPanel, pvBulletPanel, extensionPrefix, wrapper) {
            var renderInfo = {}
              , drawRule = this.drawRule
              , sceneColorProp = function(scene) {
                return scene.color;
            };
            if (drawRule) {
                var rulePvBaseProto = new pv_Mark().left(0).top(function() {
                    return this.parent.height() / 2;
                }).width(function() {
                    return this.parent.width();
                }).lineWidth(10, pvc.extensionTag).strokeStyle(sceneColorProp, pvc.extensionTag)
                  , rp = this.rulePvProto;
                rp && (rulePvBaseProto = rp.extend(rulePvBaseProto));
                renderInfo.pvRule = new pvc.visual.Rule(legendPanel,pvBulletPanel,{
                    proto: rulePvBaseProto,
                    noSelect: !1,
                    noHover: !1,
                    activeSeriesAware: !1,
                    extensionId: extensionPrefix + "Rule",
                    extensionId: pvc.makeExtensionAbsId("Rule", [extensionPrefix, "$"]),
                    showsInteraction: !0,
                    wrapper: wrapper
                }).pvMark;
            }
            if (this.drawMarker) {
                var markerPvBaseProto = new pv_Mark().left(function() {
                    return this.parent.width() / 2;
                }).top(function() {
                    return this.parent.height() / 2;
                }).shapeSize(function() {
                    return this.parent.width();
                }, pvc.extensionTag).lineWidth(2, pvc.extensionTag).fillStyle(sceneColorProp, pvc.extensionTag).strokeStyle(sceneColorProp, pvc.extensionTag).shape(this.markerShape, pvc.extensionTag).angle(drawRule ? 1 : Math.PI / 2, pvc.extensionTag).antialias(function() {
                    var cos = Math.abs(Math.cos(this.angle()));
                    if (0 !== cos && 1 !== cos)
                        switch (this.shape()) {
                        case "square":
                        case "bar":
                            return !1;
                        }
                    return !0;
                }, pvc.extensionTag)
                  , mp = this.markerPvProto;
                mp && (markerPvBaseProto = mp.extend(markerPvBaseProto));
                renderInfo.pvDot = new pvc.visual.Dot(legendPanel,pvBulletPanel,{
                    proto: markerPvBaseProto,
                    freePosition: !0,
                    activeSeriesAware: !1,
                    noTooltip: !0,
                    noClick: !0,
                    extensionId: pvc.makeExtensionAbsId("Dot", [extensionPrefix, "$"]),
                    wrapper: wrapper
                }).pvMark;
            }
            return renderInfo;
        }
    });
    def.type("pvc.visual.DataCell").init(function(plot, axisType, axisIndex, roleName, dataPartValue) {
        this.plot = plot;
        this.axisType = axisType;
        this.axisIndex = axisIndex;
        this.role = plot.chart.visualRoles[roleName] || def.fail.argumentInvalid("roleName", "Role is not defined.");
        this.dataPartValue = dataPartValue;
    });
    def.type("pvc.visual.ColorDataCell", pvc.visual.DataCell).init(function(plot, axisType, axisIndex, roleName, dataPartValue) {
        this.base(plot, axisType, axisIndex, roleName, dataPartValue);
        this._legendGroupScene = null;
    }).add({
        legendGroupScene: function(_) {
            if (arguments.length) {
                this._legendGroupScene = _;
                return this;
            }
            return this._legendGroupScene;
        }
    });
    def.type("pvc.visual.Plot", pvc.visual.OptionsBase).init(function(chart, keyArgs) {
        var typePlots = def.getPath(chart, ["plotsByType", this.type])
          , index = typePlots ? typePlots.length : 0
          , globalIndex = chart.plotList.length;
        keyArgs = def.set(keyArgs, "byNaked", !globalIndex);
        this.base(chart, this.type, index, keyArgs);
        chart._addPlot(this);
        var prefixes = this.extensionPrefixes = [this.id];
        this.globalIndex || prefixes.push("");
        this.name && prefixes.push(this.name);
    }).add({
        _getOptionsDefinition: function() {
            return pvc.visual.Plot.optionsDef;
        },
        _resolveByNaked: pvc.options.specify(function(optionInfo) {
            return this.globalIndex ? void 0 : this._chartOption(def.firstLowerCase(optionInfo.name));
        }),
        collectDataCells: function(dataCells) {
            var dataCell = this._getColorDataCell();
            dataCell && dataCells.push(dataCell);
        },
        _getColorDataCell: function() {
            var colorRoleName = this.option("ColorRole");
            return colorRoleName ? new pvc.visual.ColorDataCell(this,"color",this.option("ColorAxis") - 1,colorRoleName,this.option("DataPart")) : void 0;
        }
    });
    pvc.visual.Plot.optionsDef = {
        Orientation: {
            resolve: function(optionInfo) {
                optionInfo.specify(this._chartOption("orientation") || "vertical");
                return !0;
            },
            cast: String
        },
        ValuesVisible: {
            resolve: "_resolveFull",
            data: {
                resolveV1: function(optionInfo) {
                    if (0 === this.globalIndex) {
                        var show = this._chartOption("showValues");
                        if (void 0 !== show)
                            optionInfo.specify(show);
                        else {
                            show = "point" !== this.type;
                            optionInfo.defaultValue(show);
                        }
                        return !0;
                    }
                }
            },
            cast: Boolean,
            value: !1
        },
        ValuesAnchor: {
            resolve: "_resolveFull",
            cast: pvc.parseAnchor
        },
        ValuesFont: {
            resolve: "_resolveFull",
            cast: String,
            value: "10px sans-serif"

        },
        ValuesMask: {
            resolve: "_resolveFull",
            cast: String,
            value: "{value}"
        },
        ValuesOptimizeLegibility: {
            resolve: "_resolveFull",
            cast: Boolean,
            value: !1
        },
        ValuesOverflow: {
            resolve: "_resolveFull",
            cast: pvc.parseValuesOverflow,
            value: "hide"
        },
        DataPart: {
            resolve: "_resolveFixed",
            cast: String,
            value: "0"
        },
        ColorRole: {
            resolve: "_resolveFixed",
            cast: String,
            value: "color"
        },
        ColorAxis: {
            resolve: pvc.options.resolvers([function(optionInfo) {
                if (0 === this.globalIndex) {
                    optionInfo.specify(1);
                    return !0;
                }
            }
            , "_resolveFull"]),
            cast: function(value) {
                value = pvc.castNumber(value);
                value = null != value ? def.between(value, 1, 10) : 1;
                return value;
            },
            value: 1
        }
    };
    def.type("pvc.visual.CartesianOrthoDataCell", pvc.visual.DataCell).init(function(plot, axisType, axisIndex, roleName, dataPartValue, isStacked, nullInterpolationMode, trend) {
        this.base(plot, axisType, axisIndex, roleName, dataPartValue);
        this.isStacked = isStacked;
        this.nullInterpolationMode = nullInterpolationMode;
        this.trend = trend;
    });
    def.type("pvc.visual.CartesianPlot", pvc.visual.Plot).add({
        collectDataCells: function(dataCells) {
            this.base(dataCells);
            dataCells.push(new pvc.visual.DataCell(this,"base",this.option("BaseAxis") - 1,this.option("BaseRole"),this.option("DataPart")));
            var orthoRoleNames = def.array.to(this.option("OrthoRole"))
              , dataPartValue = this.option("DataPart")
              , orthoAxisIndex = this.option("OrthoAxis") - 1
              , isStacked = this.option.isDefined("Stacked") ? this.option("Stacked") : void 0
              , nullInterpolationMode = this.option("NullInterpolationMode")
              , trend = this.option("Trend");
            orthoRoleNames.forEach(function(orthoRoleName) {
                dataCells.push(new pvc.visual.CartesianOrthoDataCell(this,"ortho",orthoAxisIndex,orthoRoleName,dataPartValue,isStacked,nullInterpolationMode,trend));
            }, this);
        },
        _getOptionsDefinition: function() {
            return pvc.visual.CartesianPlot.optionsDef;
        }
    });
    pvc.visual.CartesianPlot.optionsDef = def.create(pvc.visual.Plot.optionsDef, {
        BaseAxis: {
            value: 1
        },
        BaseRole: {
            resolve: "_resolveFixed",
            cast: String
        },
        OrthoAxis: {
            resolve: function(optionInfo) {
                if (0 === this.globalIndex) {
                    optionInfo.specify(1);
                    return !0;
                }
                return this._resolveFull(optionInfo);
            },
            data: {
                resolveV1: function(optionInfo) {
                    "plot2" === this.name && this.chart._allowV1SecondAxis && this._chartOption("secondAxisIndependentScale") && optionInfo.specify(2);
                    return !0;
                }
            },
            cast: function(value) {
                value = pvc.castNumber(value);
                return null != value ? def.between(value, 1, 10) : 1;
            },
            value: 1
        },
        OrthoRole: {
            resolve: pvc.options.resolvers(["_resolveFixed", "_resolveDefault"])
        },
        Trend: {
            resolve: "_resolveFull",
            data: {
                resolveDefault: function(optionInfo) {
                    var type = this.option("TrendType");
                    if (type) {
                        optionInfo.defaultValue({
                            type: type
                        });
                        return !0;
                    }
                }
            },
            cast: pvc_castTrend
        },
        TrendType: {
            resolve: "_resolveFull",
            cast: pvc.parseTrendType
        },
        TrendLabel: {
            resolve: "_resolveFull",
            cast: String
        },
        NullInterpolationMode: {
            resolve: "_resolveFull",
            cast: pvc.parseNullInterpolationMode,
            value: "none"
        }
    });
    def.type("pvc.visual.CategoricalPlot", pvc.visual.CartesianPlot).add({
        _getOptionsDefinition: function() {
            return pvc.visual.CategoricalPlot.optionsDef;
        }
    });
    pvc.visual.CategoricalPlot.optionsDef = def.create(pvc.visual.CartesianPlot.optionsDef, {
        Stacked: {
            resolve: "_resolveFull",
            cast: Boolean,
            value: !1
        },
        BaseRole: {
            value: "category"
        },
        OrthoRole: {
            value: "value"
        }
    });
    def.type("pvc.visual.BarPlotAbstract", pvc.visual.CategoricalPlot).add({
        _getOptionsDefinition: function() {
            return pvc.visual.BarPlotAbstract.optionsDef;
        }
    });
    pvc.visual.BarPlotAbstract.optionsDef = def.create(pvc.visual.CategoricalPlot.optionsDef, {
        BarSizeRatio: {
            resolve: "_resolveFull",
            cast: function(value) {
                value = pvc.castNumber(value);
                null == value ? value = 1 : .05 > value ? value = .05 : value > 1 && (value = 1);
                return value;
            },
            value: .9
        },
        BarSizeMax: {
            resolve: "_resolveFull",
            data: {
                resolveV1: function(optionInfo) {
                    this._specifyChartOption(optionInfo, "maxBarSize");
                    return !0;
                }
            },
            cast: function(value) {
                value = pvc.castNumber(value);
                null == value ? value = 1 / 0 : 1 > value && (value = 1);
                return value;
            },
            value: 2e3
        },
        BarOrthoSizeMin: {
            resolve: "_resolveFull",
            cast: pvc.castNonNegativeNumber,
            value: 1.5
        },
        BarStackedMargin: {
            resolve: "_resolveFull",
            cast: function(value) {
                value = pvc.castNumber(value);
                null != value && 0 > value && (value = 0);
                return value;
            },
            value: 0
        },
        OverflowMarkersVisible: {
            resolve: "_resolveFull",
            cast: Boolean,
            value: !0
        },
        ValuesAnchor: {
            value: "center"
        }
    });
    def.type("pvc.visual.BarPlot", pvc.visual.BarPlotAbstract).add({
        type: "bar"
    });
    def.type("pvc.visual.NormalizedBarPlot", pvc.visual.BarPlotAbstract).add({
        type: "bar",
        _getOptionsDefinition: function() {
            return pvc.visual.NormalizedBarPlot.optionsDef;
        }
    });
    pvc.visual.NormalizedBarPlot.optionsDef = def.create(pvc.visual.BarPlotAbstract.optionsDef, {
        Stacked: {
            resolve: null,
            value: !0
        }
    });
    def.type("pvc.visual.WaterfallPlot", pvc.visual.BarPlotAbstract).add({
        type: "water",
        _getOptionsDefinition: function() {
            return pvc.visual.WaterfallPlot.optionsDef;
        }
    });
    pvc.visual.WaterfallPlot.optionsDef = def.create(pvc.visual.BarPlotAbstract.optionsDef, {
        Stacked: {
            resolve: null,
            value: !0
        },
        TotalLineLabel: {
            resolve: "_resolveFull",
            cast: String,
            value: "Accumulated"
        },
        TotalValuesVisible: {
            resolve: "_resolveFull",
            data: {
                resolveDefault: function(optionInfo) {
                    optionInfo.defaultValue(this.option("ValuesVisible"));
                    return !0;
                }
            },
            cast: Boolean
        },
        Direction: {
            resolve: "_resolveFull",
            cast: pvc.parseWaterDirection,
            value: "down"
        },
        AreasVisible: {
            resolve: "_resolveFull",
            cast: Boolean,
            value: !0
        },
        AllCategoryLabel: {
            resolve: "_resolveFull",
            cast: String,
            value: "All"
        }
    });
    def.type("pvc.visual.PointPlot", pvc.visual.CategoricalPlot).add({
        type: "point",
        _getOptionsDefinition: function() {
            return pvc.visual.PointPlot.optionsDef;
        }
    });
    pvc.visual.PointPlot.optionsDef = def.create(pvc.visual.CategoricalPlot.optionsDef, {
        DotsVisible: {
            resolve: "_resolveFull",
            data: pvcPoint_buildVisibleOption("Dots", !0),
            cast: Boolean,
            value: !1
        },
        LinesVisible: {
            resolve: "_resolveFull",
            data: pvcPoint_buildVisibleOption("Lines", !0),
            cast: Boolean,
            value: !1
        },
        RulesVisible: {
            resolve: "_resolveFull",
            data: pvcPoint_buildVisibleOption("Lines", !0),
            cast: Boolean,
            value: !1
        },
        AreasVisible: {
            resolve: "_resolveFull",
            data: pvcPoint_buildVisibleOption("Areas", !1),
            cast: Boolean,
            value: !1
        },
        ValuesAnchor: {
            value: "right"
        }
    });
    def.type("pvc.visual.MetricXYPlot", pvc.visual.CartesianPlot).add({
        _getOptionsDefinition: function() {
            return pvc.visual.MetricXYPlot.optionsDef;
        }
    });
    pvc.visual.MetricXYPlot.optionsDef = def.create(pvc.visual.CartesianPlot.optionsDef, {
        BaseRole: {
            value: "x"
        },
        OrthoAxis: {
            resolve: null
        },
        OrthoRole: {
            value: "y"
        }
    });
    def.type("pvc.visual.MetricPointPlot", pvc.visual.MetricXYPlot).add({
        type: "scatter",
        collectDataCells: function(dataCells) {
            this.base(dataCells);
            if (this.option("DotsVisible")) {
                var sizeRole = this.chart.visualRole(this.option("SizeRole"));
                sizeRole.isBound() && dataCells.push(new pvc.visual.DataCell(this,"size",this.option("SizeAxis") - 1,sizeRole.name,this.option("DataPart")));
            }
        },
        _getOptionsDefinition: function() {
            return pvc.visual.MetricPointPlot.optionsDef;
        }
    });
    pvc.visual.MetricPointPlot.optionsDef = def.create(pvc.visual.MetricXYPlot.optionsDef, {
        SizeRole: {
            resolve: "_resolveFixed",
            value: "size"
        },
        SizeAxis: {
            resolve: "_resolveFixed",
            value: 1
        },
        Shape: {
            resolve: "_resolveFull",
            cast: pvc.parseShape,
            value: "circle"
        },
        NullShape: {
            resolve: "_resolveFull",
            cast: pvc.parseShape,
            value: "cross"
        },
        DotsVisible: {
            resolve: "_resolveFull",
            data: pvcMetricPoint_buildVisibleOption("Dots"),
            cast: Boolean,
            value: !1
        },
        LinesVisible: {
            resolve: "_resolveFull",
            data: pvcMetricPoint_buildVisibleOption("Lines"),
            cast: Boolean,
            value: !1
        },
        ValuesAnchor: {
            value: "right"
        },
        ValuesMask: {
            value: "{x},{y}"
        }
    });
    def.type("pvc.visual.PiePlot", pvc.visual.Plot).add({
        type: "pie",
        collectDataCells: function(dataCells) {
            this.base(dataCells);
            var dataPartValue = this.option("DataPart");
            dataCells.push(new pvc.visual.DataCell(this,"category",0,"category",dataPartValue));
            dataCells.push(new pvc.visual.DataCell(this,"angle",0,"value",dataPartValue));
        },
        _getOptionsDefinition: function() {
            return pvc.visual.PiePlot.optionsDef;
        }
    });
    pvc.visual.PiePlot.optionsDef = def.create(pvc.visual.Plot.optionsDef, {
        ActiveSliceRadius: {
            resolve: "_resolveFull",
            cast: pvc_PercentValue.parse,
            value: new pvc_PercentValue(.05)
        },
        ExplodedSliceRadius: {
            resolve: "_resolveFull",
            cast: pvc_PercentValue.parse,
            value: 0
        },
        ExplodedSliceIndex: {
            resolve: "_resolveFull",
            cast: pvc.castNumber,
            value: null
        },
        ValuesAnchor: {
            cast: pvc.parseAnchorWedge,
            value: "outer"
        },
        ValuesVisible: {
            value: !0
        },
        ValuesLabelStyle: {
            resolve: function(optionInfo) {
                var isV1Compat = this.chart.compatVersion() <= 1;
                if (isV1Compat) {
                    optionInfo.specify("inside");
                    return !0;
                }
                return this._resolveFull(optionInfo);
            },
            cast: function(value) {
                switch (value) {
                case "inside":
                case "linked":
                    return value;
                }
                pvc.debug >= 2 && pvc.log("[Warning] Invalid 'ValuesLabelStyle' value: '" + value + "'.");
                return "linked";
            },
            value: "linked"
        },
        ValuesMask: {
            resolve: "_resolveFull",
            data: {
                resolveDefault: function(optionInfo) {
                    optionInfo.defaultValue("linked" === this.option("ValuesLabelStyle") ? "{value} ({value.percent})" : "{value}");
                    return !0;
                }
            }
        },
        LinkInsetRadius: {
            resolve: "_resolveFull",
            cast: pvc_PercentValue.parse,
            value: new pvc_PercentValue(.05)
        },
        LinkOutsetRadius: {
            resolve: "_resolveFull",
            cast: pvc_PercentValue.parse,
            value: new pvc_PercentValue(.025)
        },
        LinkMargin: {
            resolve: "_resolveFull",
            cast: pvc_PercentValue.parse,
            value: new pvc_PercentValue(.025)
        },
        LinkHandleWidth: {
            resolve: "_resolveFull",
            cast: pvc.castNumber,
            value: .5
        },
        LinkLabelSize: {
            resolve: "_resolveFull",
            cast: pvc_PercentValue.parse,
            value: new pvc_PercentValue(.15)
        },
        LinkLabelSpacingMin: {
            resolve: "_resolveFull",
            cast: pvc.castNumber,
            value: .5
        }
    });
    def.type("pvc.visual.HeatGridPlot", pvc.visual.CategoricalPlot).add({
        type: "heatGrid",
        collectDataCells: function(dataCells) {
            this.base(dataCells);
            if (this.option("UseShapes")) {
                var sizeRole = this.chart.visualRole(this.option("SizeRole"));
                sizeRole.isBound() && dataCells.push(new pvc.visual.DataCell(this,"size",this.option("SizeAxis") - 1,sizeRole.name,this.option("DataPart")));
            }
        },
        _getOptionsDefinition: function() {
            return pvc.visual.HeatGridPlot.optionsDef;
        }
    });
    pvc.visual.HeatGridPlot.optionsDef = def.create(pvc.visual.CategoricalPlot.optionsDef, {
        SizeRole: {
            value: "size"
        },
        SizeAxis: {
            value: 1
        },
        UseShapes: {
            resolve: "_resolveFull",
            cast: Boolean,
            value: !1
        },
        Shape: {
            resolve: "_resolveFull",
            cast: pvc.parseShape,
            value: "square"
        },
        NullShape: {
            resolve: "_resolveFull",
            cast: pvc.parseShape,
            value: "cross"
        },
        ValuesVisible: {
            getDefault: function() {
                return !this.option("UseShapes");
            },
            value: null
        },
        ValuesMask: {
            value: null
        },
        ValuesAnchor: {
            value: "center"
        },
        OrthoRole: {
            value: "series"
        },
        OrthoAxis: {
            resolve: null
        },
        NullInterpolationMode: {
            resolve: null,
            value: "none"
        },
        Stacked: {
            resolve: null,
            value: !1
        }
    });
    def.type("pvc.visual.BoxPlot", pvc.visual.CategoricalPlot).add({
        type: "box",
        _getOptionsDefinition: function() {
            return pvc.visual.BoxPlot.optionsDef;
        }
    });
    pvc.visual.BoxPlot.optionsDef = def.create(pvc.visual.CategoricalPlot.optionsDef, {
        Stacked: {
            resolve: null,
            value: !1
        },
        OrthoRole: {
            value: ["median", "lowerQuartil", "upperQuartil", "minimum", "maximum"]
        },
        BoxSizeRatio: {
            resolve: "_resolveFull",
            cast: function(value) {
                value = pvc.castNumber(value);
                null == value ? value = 1 : .05 > value ? value = .05 : value > 1 && (value = 1);
                return value;
            },
            value: 1 / 3
        },
        BoxSizeMax: {
            resolve: "_resolveFull",
            data: {
                resolveV1: function(optionInfo) {
                    this._specifyChartOption(optionInfo, "maxBoxSize");
                    return !0;
                }
            },
            cast: function(value) {
                value = pvc.castNumber(value);
                null == value ? value = 1 / 0 : 1 > value && (value = 1);
                return value;
            },
            value: 1 / 0
        }
    });
    def.type("pvc.visual.BulletPlot", pvc.visual.Plot).add({
        type: "bullet",
        _getOptionsDefinition: function() {
            return pvc.visual.BulletPlot.optionsDef;
        }
    });
    pvc.visual.BulletPlot.optionsDef = def.create(pvc.visual.Plot.optionsDef, {
        ValuesVisible: {
            value: !0
        },
        ColorRole: {
            value: null
        }
    });
    def.type("pvc.visual.TreemapPlot", pvc.visual.Plot).add({
        type: "treemap",
        _getOptionsDefinition: function() {
            return pvc.visual.TreemapPlot.optionsDef;
        },
        collectDataCells: function(dataCells) {
            this.base(dataCells);
            var sizeRoleName = this.option("SizeRole");
            sizeRoleName && dataCells.push(new pvc.visual.DataCell(this,"size",this.option("SizeAxis") - 1,sizeRoleName,this.option("DataPart")));
        }
    });
    pvc.visual.TreemapPlot.optionsDef = def.create(pvc.visual.Plot.optionsDef, {
        SizeRole: {
            resolve: "_resolveFixed",
            value: "size"
        },
        SizeAxis: {
            resolve: "_resolveFixed",
            value: 1
        },
        ValuesAnchor: {
            cast: pvc.parseAnchor,
            value: "center"
        },
        ValuesVisible: {
            value: !0
        },
        ValuesMask: {
            resolve: "_resolveFull",
            value: "{category}"
        },
        ValuesOptimizeLegibility: {
            value: !0
        },
        LayoutMode: {
            resolve: "_resolveFull",
            cast: pvc.parseTreemapLayoutMode,
            value: "squarify"
        },
        ColorMode: {
            resolve: "_resolveFull",
            cast: pvc.parseTreemapColorMode,
            value: "byparent"
        },
        RootCategoryLabel: {
            resolve: "_resolveFull",
            cast: String,
            value: "All"
        }
    });
    def.type("pvc.visual.SunburstPlot", pvc.visual.Plot).add({
        type: "sunburst",
        _getOptionsDefinition: function() {
            return pvc.visual.SunburstPlot.optionsDef;
        },
        collectDataCells: function(dataCells) {
            this.base(dataCells);
            var sizeRoleName = this.option("SizeRole");
            sizeRoleName && dataCells.push(new pvc.visual.DataCell(this,"size",this.option("SizeAxis") - 1,sizeRoleName,this.option("DataPart")));
        }
    });
    pvc.visual.SunburstPlot.optionsDef = def.create(pvc.visual.Plot.optionsDef, {
        SizeRole: {
            resolve: "_resolveFixed",
            value: "size"
        },
        SizeAxis: {
            resolve: "_resolveFixed",
            value: 1
        },
        ValuesAnchor: {
            cast: pvc.parseAnchor,
            value: "center"
        },
        ValuesVisible: {
            value: !0
        },
        ValuesMask: {
            resolve: "_resolveFull",
            value: "{category}"
        },
        ValuesOptimizeLegibility: {
            value: !0
        },
        RootCategoryLabel: {
            resolve: "_resolveFull",
            cast: String,
            value: "All"
        },
        SliceOrder: {
            resolve: "_resolveFull",
            cast: pvc.parseSunburstSliceOrder,
            value: "bySizeDescending"
        },
        EmptySlicesVisible: {
            resolve: "_resolveFull",
            cast: Boolean,
            value: !1
        },
        EmptySlicesLabel: {
            resolve: "_resolveFull",
            cast: String,
            value: ""
        }
    });
    def.type("pvc.Abstract").init(function() {
        this._syncLog();
    }).add({
        invisibleLineWidth: .001,
        defaultLineWidth: 1,
        _logInstanceId: null,
        _syncLog: function() {
            if (pvc.debug && "undefined" != typeof console) {
                var logId = this._getLogInstanceId();
                ["log", "info", ["trace", "debug"], "error", "warn", ["group", "groupCollapsed"], "groupEnd"].forEach(function(ps) {
                    ps = ps instanceof Array ? ps : [ps, ps];
                    pvc_installLog(this, "_" + ps[0], ps[1], logId);
                }, this);
            }
        },
        _getLogInstanceId: function() {
            return this._logInstanceId || (this._logInstanceId = this._processLogInstanceId(this._createLogInstanceId()));
        },
        _createLogInstanceId: function() {
            return "" + this.constructor;
        },
        _processLogInstanceId: function(logInstanceId) {
            var L = 30
              , s = logInstanceId.substr(0, L);
            s.length < L && (s += def.array.create(L - s.length, " ").join(""));
            return "[" + s + "]";
        }
    });
    def.scope(function() {
        var o = pvc.Abstract.prototype
          , syncLogHook = function() {
            this._syncLog();
        };
        ["log", "info", "trace", "error", "warn", "group", "groupEnd"].forEach(function(p) {
            o["_" + p] = syncLogHook;
        });
    });
    def.type("pvc.BaseChart", pvc.Abstract).add(pvc.visual.Interactive).init(function(options) {
        var originalOptions = options
          , parent = this.parent = def.get(options, "parent") || null;
        parent ? options || def.fail.argumentRequired("options") : options = def.mixin.copy({}, this.defaults, options);
        this.options = options;
        if (parent) {
            this.root = parent.root;
            this.smallColIndex = options.smallColIndex;
            this.smallRowIndex = options.smallRowIndex;
        } else
            this.root = this;
        this.base();
        pvc.debug >= 3 && this._info("NEW CHART\n" + pvc.logSeparator.replace(/-/g, "=") + "\n  DebugLevel: " + pvc.debug);
        if (pvc.debug >= 3 && !parent && originalOptions) {
            this._info("OPTIONS:\n", originalOptions);
            pvc.debug >= 5 && this._trace(pvc.stringify(options, {
                ownOnly: !1,
                funs: !0
            }));
        }
        parent && parent._addChild(this);
        this._constructData(options);
        this._constructVisualRoles(options);
    }).add({
        _disposed: !1,
        _animatable: !1,
        parent: null,
        children: null,
        root: null,
        isCreated: !1,
        _createVersion: 0,
        renderCallback: void 0,
        multiChartPageCount: null,
        multiChartPageIndex: null,
        _multiChartOverflowClipped: !1,
        left: 0,
        top: 0,
        width: null,
        height: null,
        margins: null,
        paddings: null,
        _allowV1SecondAxis: !1,
        compatVersion: function(options) {
            return (options || this.options).compatVersion;
        },
        _createLogInstanceId: function() {
            return "" + this.constructor + this._createLogChildSuffix();
        },
        _createLogChildSuffix: function() {
            return this.parent ? " (" + (this.smallRowIndex + 1) + "," + (this.smallColIndex + 1) + ")" : "";
        },
        _addChild: function(childChart) {
            childChart.parent === this || def.assert("Not a child of this chart.");
            this.children.push(childChart);
        },
        _create: function(keyArgs) {
            this._createPhase1(keyArgs);
            this._createPhase2(keyArgs);
        },
        _createPhase1: function(keyArgs) {
            this._createVersion++;
            this.isCreated = !1;
            pvc.debug >= 3 && this._log("Creating");
            this.children = [];
            this.parent || pvc.removeTipsyLegends();
            this._processOptions();
            this.parent || this._checkNoDataI();
            if (!this.parent && !this.data) {
                this._initVisualRoles();
                this._bindVisualRolesPreI();
                this._complexTypeProj = this._createComplexTypeProject();
                this._bindVisualRolesPreII();
            }
            this._initData(keyArgs);
            this.parent || this._checkNoDataII();
            var hasMultiRole = this.visualRoles.multiChart.isBound()
              , chartLevel = this._chartLevel();
            this._initPlots(hasMultiRole);
            this._initAxes(hasMultiRole);
            hasMultiRole && !this.parent && this._initMultiCharts();
            if (!this.parent) {
                this._interpolate(hasMultiRole);
                this._generateTrends(hasMultiRole);
            }
            this._setAxesScales(chartLevel);
        },
        _createPhase2: function() {
            var hasMultiRole = this.visualRoles.multiChart.isBound();
            this._initChartPanels(hasMultiRole);
            this.isCreated = !0;
        },
        _setSmallLayout: function(keyArgs) {
            if (keyArgs) {
                var basePanel = this.basePanel;
                this._setProp("left", keyArgs) | this._setProp("top", keyArgs) && basePanel && def.set(basePanel.position, "left", this.left, "top", this.top);
                this._setProp("width", keyArgs) | this._setProp("height", keyArgs) && basePanel && (basePanel.size = new pvc_Size(this.width,this.height));
                this._setProp("margins", keyArgs) && basePanel && (basePanel.margins = new pvc_Sides(this.margins));
                this._setProp("paddings", keyArgs) && basePanel && (basePanel.paddings = new pvc_Sides(this.paddings));
            }
        },
        _setProp: function(p, keyArgs) {
            var v = keyArgs[p];
            if (null != v) {
                this[p] = v;
                return !0;
            }
        },
        _processOptions: function() {
            var options = this.options;
            if (!this.parent) {
                this.width = options.width;
                this.height = options.height;
                this.margins = options.margins;
                this.paddings = options.paddings;
            }
            this.compatVersion() <= 1 && (options.plot2 = this._allowV1SecondAxis && !!options.secondAxis);
            this._processOptionsCore(options);
            this._processExtensionPoints();
            return options;
        },
        _processOptionsCore: function(options) {
            if (this.parent) {
                this._ibits = this.parent._ibits;
                this._tooltipOptions = this.parent._tooltipOptions;
            } else {
                var interactive = "batik" !== pv.renderer();
                if (interactive) {
                    interactive = options.interactive;
                    null == interactive && (interactive = !0);
                }
                var ibits;
                if (interactive) {
                    var I = pvc.visual.Interactive;
                    ibits = I.Interactive | I.ShowsInteraction;
                    this._processTooltipOptions(options) && (ibits |= I.ShowsTooltip);
                    options.animate && $.support.svg && (ibits |= I.Animatable);
                    var preventUnselect = !1;
                    if (options.selectable) {
                        ibits |= I.Selectable;
                        switch (pvc.parseSelectionMode(options.selectionMode)) {
                        case "rubberband":
                            ibits |= I.SelectableByRubberband | I.SelectableByClick;
                            break;

                        case "focuswindow":
                            ibits |= I.SelectableByFocusWindow;
                            preventUnselect = !0;
                        }
                    }
                    preventUnselect || "emptyspaceclick" !== pvc.parseClearSelectionMode(options.clearSelectionMode) || (ibits |= I.Unselectable);
                    options.hoverable && (ibits |= I.Hoverable);
                    options.clickable && (ibits |= I.Clickable | I.DoubleClickable);
                } else
                    ibits = 0;
                this._ibits = ibits;
            }
        },
        _tooltipDefaults: {
            gravity: "s",
            delayIn: 200,
            delayOut: 80,
            offset: 2,
            opacity: .9,
            html: !0,
            fade: !0,
            useCorners: !1,
            arrowVisible: !0,
            followMouse: !1,
            format: void 0
        },
        _processTooltipOptions: function(options) {
            var isV1Compat = this.compatVersion() <= 1
              , tipOptions = options.tooltip
              , tipEnabled = options.tooltipEnabled;
            if (null == tipEnabled) {
                tipOptions && (tipEnabled = tipOptions.enabled);
                if (null == tipEnabled) {
                    isV1Compat && (tipEnabled = options.showTooltips);
                    null == tipEnabled && (tipEnabled = !0);
                }
            }
            if (tipEnabled) {
                tipOptions || (tipOptions = {});
                isV1Compat && this._importV1TooltipOptions(tipOptions, options);
                def.eachOwn(this._tooltipDefaults, function(dv, p) {
                    var value = options["tooltip" + def.firstUpperCase(p)];
                    void 0 !== value ? tipOptions[p] = value : void 0 === tipOptions[p] && (tipOptions[p] = dv);
                });
            } else
                tipOptions = {};
            this._tooltipOptions = tipOptions;
            return tipEnabled;
        },
        _importV1TooltipOptions: function(tipOptions, options) {
            var v1TipOptions = options.tipsySettings;
            if (v1TipOptions) {
                this.extend(v1TipOptions, "tooltip");
                for (var p in v1TipOptions)
                    void 0 === tipOptions[p] && (tipOptions[p] = v1TipOptions[p]);
                null == tipOptions.html && (tipOptions.html = !1);
            }
        },
        render: function(bypassAnimation, recreate, reloadData) {
            var hasError;
            pvc.debug > 1 && pvc.group("CCC RENDER");
            this._suspendSelectionUpdate();
            try {
                this.useTextMeasureCache(function() {
                    try {
                        for (; ; ) {
                            !this.isCreated || recreate ? this._create({
                                reloadData: reloadData
                            }) : !this.parent && this.isCreated && pvc.removeTipsyLegends();
                            this.basePanel.render({
                                bypassAnimation: bypassAnimation,
                                recreate: recreate
                            });
                            if (!this._isMultiChartOverflowClip) {
                                this._isMultiChartOverflowClipRetry = !1;
                                break;
                            }
                            recreate = !0;
                            reloadData = !1;
                            this._isMultiChartOverflowClipRetry = !0;
                            this._isMultiChartOverflowClip = !1;
                            this._multiChartOverflowClipped = !0;
                        }
                    } catch (e) {
                        if (e instanceof NoDataException) {
                            pvc.debug > 1 && this._log("No data found.");
                            this._addErrorPanelMessage("No data found", !0);
                        } else {
                            hasError = !0;
                            pvc.logError(e.message);
                            pvc.debug > 0 && this._addErrorPanelMessage("Error: " + e.message, !1);
                        }
                        console.log(e);
                    }
                });
            } finally {
                hasError || this._resumeSelectionUpdate();
                pvc.debug > 1 && pvc.groupEnd();
            }
            return this;
        },
        _addErrorPanelMessage: function(text, isNoData) {
            var options = this.options
              , pvPanel = new pv.Panel().canvas(options.canvas).width(this.width).height(this.height)
              , pvMsg = pvPanel.anchor("center").add(pv.Label).text(text);
            isNoData && this.extend(pvMsg, "noDataMessage");
            pvPanel.render();
        },
        useTextMeasureCache: function(fun, ctx) {
            var root = this.root
              , textMeasureCache = root._textMeasureCache || (root._textMeasureCache = pv.Text.createCache());
            return pv.Text.usingCache(textMeasureCache, fun, ctx || this);
        },
        animate: function(start, end) {
            return this.basePanel.animate(start, end);
        },
        animatingStart: function() {
            return this.basePanel.animatingStart();
        },
        animatable: function() {
            return this._animatable && this.base();
        },
        isOrientationVertical: function(orientation) {
            return (orientation || this.options.orientation) === pvc.orientation.vertical;
        },
        isOrientationHorizontal: function(orientation) {
            return (orientation || this.options.orientation) === pvc.orientation.horizontal;
        },
        dispose: function() {
            this._disposed || (this._disposed = !0);
        },
        defaults: {
            width: 400,
            height: 300,
            orientation: "vertical",
            ignoreNulls: !0,
            crosstabMode: !0,
            isMultiValued: !1,
            seriesInRows: !1,
            groupedLabelSep: void 0,
            animate: !0,
            titlePosition: "top",
            titleAlign: "center",
            legend: !1,
            legendPosition: "bottom",
            v1StyleTooltipFormat: function(s, c, v, datum) {
                return s + ", " + c + ":  " + this.chart.options.valueFormat(v) + (datum && datum.percent ? " (" + datum.percent.label + ")" : "");
            },
            valueFormat: def.scope(function() {
                var pvFormat = pv.Format.number().fractionDigits(0, 2);
                return function(d) {
                    return pvFormat.format(d);
                }
                ;
            }),
            percentValueFormat: def.scope(function() {
                var pvFormat = pv.Format.number().fractionDigits(0, 1);
                return function(d) {
                    return pvFormat.format(100 * d) + "%";
                }
                ;
            }),
            clickable: !1,
            doubleClickMaxDelay: 300,
            hoverable: !1,
            selectable: !1,
            selectionMode: "rubberband",
            ctrlSelectMode: !0,
            clearSelectionMode: "emptySpaceClick",
            compatVersion: 1 / 0
        }
    });
    pvc.BaseChart.add({
        visualRoles: null,
        visualRoleList: null,
        _serRole: null,
        _dataPartRole: null,
        _measureVisualRoles: null,
        visualRole: function(roleName) {
            var role = def.getOwn(this.visualRoles, roleName);
            if (!role)
                throw def.error.operationInvalid("roleName", "There is no visual role with name '{0}'.", [roleName]);
            return role;
        },
        measureVisualRoles: function() {
            return this._measureVisualRoles;
        },
        measureDimensionsNames: function() {
            return def.query(this._measureVisualRoles).select(function(role) {
                return role.firstDimensionName();
            }).where(def.notNully).array();
        },
        _constructVisualRoles: function() {
            var parent = this.parent;
            if (parent) {
                this.visualRoles = parent.visualRoles;
                this.visualRoleList = parent.visualRoleList;
                this._measureVisualRoles = parent._measureVisualRoles;
                ["_multiChartRole", "_serRole", "_colorRole", "_dataPartRole"].forEach(function(p) {
                    var parentRole = parent[p];
                    parentRole && (this[p] = parentRole);
                }, this);
            } else {
                this.visualRoles = {};
                this.visualRoleList = [];
                this._measureVisualRoles = [];
            }
        },
        _hasDataPartRole: def.fun.constant(!1),
        _getSeriesRoleSpec: def.fun.constant(null),
        _getColorRoleSpec: def.fun.constant(null),
        _addVisualRole: function(name, keyArgs) {
            keyArgs = def.set(keyArgs, "index", this.visualRoleList.length);
            var role = new pvc.visual.Role(name,keyArgs);
            this.visualRoleList.push(role);
            this.visualRoles[name] = role;
            role.isMeasure && this._measureVisualRoles.push(role);
            return role;
        },
        _initVisualRoles: function() {
            this._multiChartRole = this._addVisualRole("multiChart", {
                defaultDimension: "multiChart*",
                requireIsDiscrete: !0
            });
            this._hasDataPartRole() && (this._dataPartRole = this._addVisualRole("dataPart", {
                defaultDimension: "dataPart",
                requireSingleDimension: !0,
                requireIsDiscrete: !0,
                dimensionDefaults: {
                    isHidden: !0,
                    comparer: def.compare
                }
            }));
            var serRoleSpec = this._getSeriesRoleSpec();
            serRoleSpec && (this._serRole = this._addVisualRole("series", serRoleSpec));
            var colorRoleSpec = this._getColorRoleSpec();
            colorRoleSpec && (this._colorRole = this._addVisualRole("color", colorRoleSpec));
        },
        _assertUnboundRoleIsOptional: function(role) {
            if (role.isRequired)
                throw def.error.operationInvalid("Chart type requires unassigned role '{0}'.", [role.name]);
        },
        _bindVisualRolesPreI: function() {
            def.eachOwn(this.visualRoles, function(role) {
                role.setIsReversed(!1);
            });
            var sourcedRoles = []
              , options = this.options
              , roleOptions = options.visualRoles;
            this.visualRoleList.forEach(function(role) {
                var name = role.name
                  , roleSpec = options[name + "Role"];
                if (void 0 !== roleSpec) {
                    roleOptions || (roleOptions = options.visualRoles = {});
                    void 0 === roleOptions[name] && (roleOptions[name] = roleSpec);
                }
            });
            var dimsBoundToSingleRole;
            if (roleOptions) {
                dimsBoundToSingleRole = {};
                var rolesWithOptions = def.query(def.keys(roleOptions)).select(this.visualRole, this).array();
                rolesWithOptions.sort(function(a, b) {
                    return a.index - b.index;
                });
                rolesWithOptions.forEach(function(role) {
                    var groupingSpec, sourceRoleName, name = role.name, roleSpec = roleOptions[name];
                    if (def.object.is(roleSpec)) {
                        def.nullyTo(roleSpec.isReversed, !1) && role.setIsReversed(!0);
                        sourceRoleName = roleSpec.from;
                        if (sourceRoleName && sourceRoleName !== name) {
                            var sourceRole = this.visualRoles[sourceRoleName] || def.fail.operationInvalid("Source role '{0}' is not supported by the chart type.", [sourceRoleName]);
                            role.setSourceRole(sourceRole);
                            sourcedRoles.push(role);
                        } else
                            groupingSpec = roleSpec.dimensions;
                    } else
                        groupingSpec = roleSpec;
                    if (void 0 !== groupingSpec) {
                        groupingSpec || this._assertUnboundRoleIsOptional(role);
                        var grouping = pvc.data.GroupingSpec.parse(groupingSpec);
                        role.preBind(grouping);
                        grouping.dimensions().each(function(groupDimSpec) {
                            def.hasOwn(dimsBoundToSingleRole, groupDimSpec.name) ? delete dimsBoundToSingleRole[groupDimSpec.name] : dimsBoundToSingleRole[groupDimSpec.name] = role;
                        });
                    }
                }, this);
            }
            this._sourcedRoles = sourcedRoles;
            this._dimsBoundToSingleRole = dimsBoundToSingleRole;
        },
        _bindVisualRolesPreII: function() {
            var dimsBoundToSingleRole = this._dimsBoundToSingleRole;
            if (dimsBoundToSingleRole) {
                delete this._dimsBoundToSingleRole;
                def.eachOwn(dimsBoundToSingleRole, this._setRoleBoundDimensionDefaults, this);
            }
            var sourcedRoles = this._sourcedRoles;
            delete this._sourcedRoles;
            def.query(this.visualRoleList).where(function(role) {
                return role.defaultSourceRoleName && !role.sourceRole && !role.isPreBound();
            }).each(function(role) {
                var sourceRole = this.visualRoles[role.defaultSourceRoleName];
                if (sourceRole) {
                    role.setSourceRole(sourceRole, !0);
                    sourcedRoles.push(role);
                }
            }, this);
            sourcedRoles.forEach(function(role) {
                var sourceRole = role.sourceRole;
                sourceRole.isReversed && role.setIsReversed(!role.isReversed);
                !role.defaultDimensionName && sourceRole.isPreBound() && role.preBind(sourceRole.preBoundGrouping());
            });
        },
        _setRoleBoundDimensionDefaults: function(role, dimName) {
            this._complexTypeProj.setDimDefaults(dimName, role.dimensionDefaults);
        },
        _bindVisualRolesPostI: function() {
            function markDimBoundTo(dimName, role) {
                def.array.lazy(boundDimTypes, dimName).push(role);
            }
            function dimIsDefined(dimName) {
                return complexTypeProj.hasDim(dimName);
            }
            function preBindRoleTo(role, dimNames) {
                def.array.is(dimNames) ? dimNames.forEach(function(dimName) {
                    markDimBoundTo(dimName, role);
                }) : markDimBoundTo(dimNames, role);
                role.setSourceRole(null);
                role.preBind(pvc.data.GroupingSpec.parse(dimNames));
            }
            function preBindRoleToGroupDims(role, groupDimNames) {
                groupDimNames.length && (role.requireSingleDimension ? preBindRoleTo(role, groupDimNames[0]) : preBindRoleTo(role, groupDimNames));
            }
            function preBindRoleToNewDim(role, dimName) {
                complexTypeProj.setDim(dimName, {
                    isHidden: !0
                });
                preBindRoleTo(role, dimName);
            }
            function roleIsUnbound(role) {
                me._assertUnboundRoleIsOptional(role);
                role.bind(null);
                role.setSourceRole(null);
            }
            function markPreBoundRoleDims(role) {
                role.preBoundGrouping().dimensionNames().forEach(markDimBoundTo);
            }
            function autoBindUnboundRole(role) {
                if (!role.sourceRole || role.isDefaultSourceRole) {
                    var dimName = role.defaultDimensionName;
                    if (dimName) {
                        var match = dimName.match(/^(.*?)(\*)?$/) || def.fail.argumentInvalid("defaultDimensionName")
                          , defaultName = match[1]
                          , greedy = match[2];
                        if (greedy) {
                            var groupDimNames = complexTypeProj.groupDimensionsNames(defaultName);
                            if (groupDimNames) {
                                preBindRoleToGroupDims(role, groupDimNames);
                                return;
                            }
                        } else if (dimIsDefined(defaultName)) {
                            preBindRoleTo(role, defaultName);
                            return;
                        }
                        role.autoCreateDimension ? preBindRoleToNewDim(role, defaultName) : role.sourceRole ? unboundSourcedRoles.push(role) : roleIsUnbound(role);
                    } else
                        role.sourceRole ? unboundSourcedRoles.push(role) : roleIsUnbound(role);
                } else
                    unboundSourcedRoles.push(role);
            }
            function tryPreBindSourcedRole(role) {
                var sourceRole = role.sourceRole;
                sourceRole.isPreBound() ? role.preBind(sourceRole.preBoundGrouping()) : roleIsUnbound(role);
            }
            var me = this
              , complexTypeProj = me._complexTypeProj
              , boundDimTypes = {}
              , unboundSourcedRoles = [];
            def.query(me.visualRoleList).where(function(role) {
                return role.isPreBound();
            }).each(markPreBoundRoleDims);
            def.query(me.visualRoleList).where(function(role) {
                return !role.isPreBound();
            }).each(autoBindUnboundRole);
            unboundSourcedRoles.forEach(tryPreBindSourcedRole);
            def.query(def.ownKeys(boundDimTypes)).where(function(dimName) {
                return 1 === boundDimTypes[dimName].length;
            }).each(function(dimName) {
                var singleRole = boundDimTypes[dimName][0];
                me._setRoleBoundDimensionDefaults(singleRole, dimName);
            });
        },
        _bindVisualRolesPostII: function(complexType) {
            def.query(this.visualRoleList).where(function(role) {
                return role.isPreBound();
            }).each(function(role) {
                role.postBind(complexType);
            });
        },
        _logVisualRoles: function() {
            var names = def.ownKeys(this.visualRoles)
              , maxLen = Math.max(10, def.query(names).select(function(s) {
                return s.length;
            }).max())
              , header = def.string.padRight("VisualRole", maxLen) + " < Dimension(s)"
              , out = ["VISUAL ROLES MAP SUMMARY", pvc.logSeparator, header, def.string.padRight("", maxLen + 1, "-") + "+--------------"];
            def.eachOwn(this.visualRoles, function(role, name) {
                out.push(def.string.padRight(name, maxLen) + " | " + (role.grouping || "-"));
            });
            out.push("");
            this._log(out.join("\n"));
        },
        _getDataPartDimName: function() {
            var role = this._dataPartRole;
            if (role) {
                if (role.isBound())
                    return role.firstDimensionName();
                var preGrouping = role.preBoundGrouping();
                return preGrouping ? preGrouping.firstDimensionName() : role.defaultDimensionName;
            }
        }
    });
    pvc.BaseChart.add({
        dataEngine: null,
        data: null,
        _partsDataCache: null,
        _visibleDataCache: null,
        resultset: [],
        metadata: [],
        _trendable: !1,
        _interpolatable: !1,
        _constructData: function(options) {
            this.parent && (this.dataEngine = this.data = options.data || def.fail.argumentRequired("options.data"));
        },
        _checkNoDataI: function() {
            if (!this.allowNoData && !this.resultset.length)
                throw new NoDataException();
        },
        _checkNoDataII: function() {
            if (!(this.allowNoData || this.data && this.data.count())) {
                this.data = null;
                throw new NoDataException();
            }
        },
        _initData: function(ka) {
            if (!this.parent) {
                var data = this.data;
                if (data)
                    if (def.get(ka, "reloadData", !0))
                        this._onReloadData();
                    else {
                        data.disposeChildren();
                        data.clearVirtuals();
                    }
                else
                    this._onLoadData();
            }
            delete this._partsDataCache;
            delete this._visibleDataCache;
            pvc.debug >= 3 && this._log(this.data.getInfo());
        },
        _onLoadData: function() {
            var data = this.data
              , translation = this._translation;
            !data && !translation || def.assert("Invalid state.");
            var options = this.options
              , dataPartDimName = this._getDataPartDimName()
              , complexTypeProj = this._complexTypeProj || def.assert("Invalid state.")
              , translOptions = this._createTranslationOptions(dataPartDimName);
            translation = this._translation = this._createTranslation(translOptions);
            if (pvc.debug >= 3) {
                this._log(translation.logSource());
                this._log(translation.logTranslatorType());
            }
            translation.configureType();
            dataPartDimName && !complexTypeProj.isReadOrCalc(dataPartDimName) && this._addDefaultDataPartCalculation(dataPartDimName);
            pvc.debug >= 3 && this._log(translation.logVItem());
            this._bindVisualRolesPostI();
            var complexType = new pvc.data.ComplexType();
            complexTypeProj.configureComplexType(complexType, translOptions);
            this._bindVisualRolesPostII(complexType);
            pvc.debug >= 10 && this._log(complexType.describe());
            pvc.debug >= 3 && this._logVisualRoles();
            data = this.dataEngine = this.data = new pvc.data.Data({
                type: complexType,
                labelSep: options.groupedLabelSep,
                keySep: translOptions.separator
            });
            var loadKeyArgs = {
                where: this._getLoadFilter(),
                isNull: this._getIsNullDatum()
            }
              , resultQuery = translation.execute(data);
            data.load(resultQuery, loadKeyArgs);
        },
        _onReloadData: function() {
            var data = this.data
              , translation = this._translation;
            data && translation || def.assert("Invalid state.");
            this.options;
            translation.setSource(this.resultset);
            pvc.debug >= 3 && this._log(translation.logSource());
            var loadKeyArgs = {
                where: this._getLoadFilter(),
                isNull: this._getIsNullDatum()
            }
              , resultQuery = translation.execute(data);
            data.load(resultQuery, loadKeyArgs);
        },
        _createComplexTypeProject: function() {
            var options = this.options
              , complexTypeProj = new pvc.data.ComplexTypeProject(options.dimensionGroups)
              , userDimsSpec = options.dimensions;
            for (var dimName in userDimsSpec)
                complexTypeProj.setDim(dimName, userDimsSpec[dimName]);
            var dataPartDimName = this._getDataPartDimName();
            if (dataPartDimName) {
                complexTypeProj.setDim(dataPartDimName);
                this._addPlot2SeriesDataPartCalculation(complexTypeProj, dataPartDimName);
            }
            var calcSpecs = options.calculations;
            calcSpecs && calcSpecs.forEach(function(calcSpec) {
                complexTypeProj.setCalc(calcSpec);
            });
            return complexTypeProj;
        },
        _getLoadFilter: function() {},
        _getIsNullDatum: function() {
            var measureDimNames = this.measureDimensionsNames()
              , M = measureDimNames.length;
            return M ? function(datum) {
                for (var atoms = datum.atoms, i = 0; M > i; i++)
                    if (null != atoms[measureDimNames[i]].value)
                        return !1;
                return !0;
            }
            : void 0;
        },
        _createTranslation: function(translOptions) {
            var TranslationClass = this._getTranslationClass(translOptions);
            return new TranslationClass(this,this._complexTypeProj,this.resultset,this.metadata,translOptions);
        },
        _getTranslationClass: function(translOptions) {
            return translOptions.crosstabMode ? pvc.data.CrosstabTranslationOper : pvc.data.RelationalTranslationOper;
        },
        _createTranslationOptions: function(dataPartDimName) {
            var options = this.options
              , dataOptions = options.dataOptions || {}
              , dataSeparator = options.dataSeparator;
            void 0 === dataSeparator && (dataSeparator = dataOptions.separator);
            dataSeparator || (dataSeparator = "~");
            var dataMeasuresInColumns = options.dataMeasuresInColumns;
            void 0 === dataMeasuresInColumns && (dataMeasuresInColumns = dataOptions.measuresInColumns);
            var dataCategoriesCount = options.dataCategoriesCount;
            void 0 === dataCategoriesCount && (dataCategoriesCount = dataOptions.categoriesCount);
            var dataIgnoreMetadataLabels = options.dataIgnoreMetadataLabels;
            void 0 === dataIgnoreMetadataLabels && (dataIgnoreMetadataLabels = dataOptions.ignoreMetadataLabels);
            var valueFormatter, plot2 = options.plot2, valueFormat = options.valueFormat;
            valueFormat && valueFormat !== this.defaults.valueFormat && (valueFormatter = function(v) {
                return null != v ? valueFormat(v) : "";
            }
            );
            var plot2Series, plot2DataSeriesIndexes;
            if (plot2) {
                if (this._allowV1SecondAxis && this.compatVersion() <= 1)
                    plot2DataSeriesIndexes = options.secondAxisIdx;
                else {
                    plot2Series = null != this._serRole && options.plot2Series && def.array.as(options.plot2Series);
                    if (!plot2Series || !plot2Series.length) {
                        plot2Series = null;
                        plot2DataSeriesIndexes = options.plot2SeriesIndexes;
                    }
                }
                plot2Series || (plot2DataSeriesIndexes = pvc.parseDistinctIndexArray(plot2DataSeriesIndexes, -1 / 0) || -1);
            }
            return {
                compatVersion: this.compatVersion(),
                plot2DataSeriesIndexes: plot2DataSeriesIndexes,
                seriesInRows: options.seriesInRows,
                crosstabMode: options.crosstabMode,
                isMultiValued: options.isMultiValued,
                dataPartDimName: dataPartDimName,
                dimensionGroups: options.dimensionGroups,
                dimensions: options.dimensions,
                readers: options.readers,
                measuresIndexes: options.measuresIndexes,
                multiChartIndexes: options.multiChartIndexes,
                separator: dataSeparator,
                measuresInColumns: dataMeasuresInColumns,
                categoriesCount: dataCategoriesCount,
                measuresIndex: dataOptions.measuresIndex || dataOptions.measuresIdx,
                measuresCount: dataOptions.measuresCount || dataOptions.numMeasures,
                isCategoryTimeSeries: options.timeSeries,
                timeSeriesFormat: options.timeSeriesFormat,
                valueNumberFormatter: valueFormatter,
                ignoreMetadataLabels: dataIgnoreMetadataLabels
            };
        },
        _addPlot2SeriesDataPartCalculation: function(complexTypeProj, dataPartDimName) {
            if (!(this.compatVersion() <= 1)) {
                var options = this.options
                  , serRole = this._serRole
                  , plot2Series = null != serRole && options.plot2 && options.plot2Series && def.array.as(options.plot2Series);
                if (plot2Series && plot2Series.length) {
                    var dimNames, dataPartDim, part1Atom, part2Atom, inited = !1, plot2SeriesSet = def.query(plot2Series).uniqueIndex();
                    complexTypeProj.setCalc({
                        names: dataPartDimName,
                        calculation: function(datum, atoms) {
                            if (!inited) {
                                if (serRole.isBound()) {
                                    dimNames = serRole.grouping.dimensionNames();
                                    dataPartDim = datum.owner.dimensions(dataPartDimName);
                                }
                                inited = !0;
                            }
                            if (dataPartDim) {
                                var seriesKey = pvc.data.Complex.compositeKey(datum, dimNames);
                                atoms[dataPartDimName] = def.hasOwnProp.call(plot2SeriesSet, seriesKey) ? part2Atom || (part2Atom = dataPartDim.intern("1")) : part1Atom || (part1Atom = dataPartDim.intern("0"));
                            }
                        }
                    });
                }
            }
        },
        _addDefaultDataPartCalculation: function(dataPartDimName) {
            var dataPartDim, part1Atom;
            this._complexTypeProj.setCalc({
                names: dataPartDimName,
                calculation: function(datum, atoms) {
                    dataPartDim || (dataPartDim = datum.owner.dimensions(dataPartDimName));
                    atoms[dataPartDimName] = part1Atom || (part1Atom = dataPartDim.intern("0"));
                }
            });
        },
        partData: function(dataPartValues, baseData) {
            baseData || (baseData = this.data);
            if (null == dataPartValues)
                return baseData;
            if (this.parent)
                return this.root.partData(dataPartValues, baseData);
            var partRole = this._dataPartRole;
            if (!partRole || !partRole.isBound())
                return baseData;
            var cacheKey = "\x00" + baseData.id + ":" + def.nullyTo(dataPartValues, "")
              , partitionedDataCache = def.lazy(this, "_partsDataCache")
              , partData = partitionedDataCache[cacheKey];
            if (!partData) {
                partData = this._createPartData(baseData, partRole, dataPartValues);
                partitionedDataCache[cacheKey] = partData;
            }
            return partData;
        },
        _createPartData: function(baseData, partRole, dataPartValues) {
            var dataPartDimName = partRole.firstDimensionName()
              , dataPartAtoms = baseData.dimensions(dataPartDimName).getDistinctAtoms(def.array.to(dataPartValues))
              , where = data_whereSpecPredicate([def.set({}, dataPartDimName, dataPartAtoms)]);
            return baseData.where(null, {
                where: where
            });
        },
        visibleData: function(dataPartValue, ka) {
            var baseData = def.get(ka, "baseData") || this.data;
            if (this.parent) {
                ka = ka ? Object.create(ka) : {};
                ka.baseData = baseData;
                return this.root.visibleData(dataPartValue, ka);
            }
            var inverted = !!def.get(ka, "inverted", !1)
              , ignoreNulls = !(!this.options.ignoreNulls && !def.get(ka, "ignoreNulls", !0))
              , key = "\x00" + baseData.id + "|" + inverted + "|" + ignoreNulls + "|" + (null != dataPartValue ? dataPartValue : null)
              , cache = def.lazy(this, "_visibleDataCache")
              , data = cache[key];
            if (!data) {
                var partData = this.partData(dataPartValue, baseData);
                ka = ka ? Object.create(ka) : {};
                ka.visible = !0;
                ka.isNull = ignoreNulls ? !1 : null;
                data = cache[key] = this._createVisibleData(partData, ka);
            }
            return data;
        },
        _createVisibleData: function(baseData, ka) {
            var serRole = this._serRole;
            return serRole && serRole.isBound() ? serRole.flatten(baseData, ka) : baseData.where(null, ka);
        },
        _initMultiCharts: function() {
            var chart = this;
            chart.multiOptions = new pvc.visual.MultiChart(chart);
            chart.smallOptions = new pvc.visual.SmallChart(chart);
            var colCount, rowCount, multiChartMax, colsMax, multiOption = chart.multiOptions.option, data = chart.visualRoles.multiChart.flatten(chart.data, {
                visible: !0,
                isNull: null
            }), smallDatas = data.childNodes;
            if (chart._isMultiChartOverflowClipRetry) {
                rowCount = chart._clippedMultiChartRowsMax;
                colCount = chart._clippedMultiChartColsMax;
                colsMax = colCount;
                multiChartMax = rowCount * colCount;
            } else
                multiChartMax = multiOption("Max");
            var count = Math.min(smallDatas.length, multiChartMax);
            if (0 === count)
                colCount = rowCount = colsMax = 0;
            else if (!chart._isMultiChartOverflowClipRetry) {
                colsMax = multiOption("ColumnsMax");
                colCount = Math.min(count, colsMax);
                colCount >= 1 && isFinite(colCount) || def.assert("Must be at least 1 and finite");
                rowCount = Math.ceil(count / colCount);
                rowCount >= 1 || def.assert("Must be at least 1");
            }
            chart._multiInfo = {
                data: data,
                smallDatas: smallDatas,
                count: count,
                rowCount: rowCount,
                colCount: colCount,
                colsMax: colsMax
            };
        },
        _interpolate: function(hasMultiRole) {
            if (this._interpolatable) {
                var dataCells = def.query(this.axesList).selectMany(def.propGet("dataCells")).where(function(dataCell) {
                    var nim = dataCell.nullInterpolationMode;
                    return !!nim && "none" !== nim;
                }).distinct(function(dataCell) {
                    return dataCell.role.name + "|" + (dataCell.dataPartValue || "");
                }).array();
                this._eachLeafDatasAndDataCells(hasMultiRole, dataCells, this._interpolateDataCell, this);
            }
        },
        _generateTrends: function(hasMultiRole) {
            var dataPartDimName = this._getDataPartDimName();
            if (this._trendable && dataPartDimName) {
                var dataCells = def.query(this.axesList).selectMany(def.propGet("dataCells")).where(def.propGet("trend")).distinct(function(dataCell) {
                    return dataCell.role.name + "|" + (dataCell.dataPartValue || "");
                }).array()
                  , newDatums = [];
                this._eachLeafDatasAndDataCells(hasMultiRole, dataCells, function(dataCell, data) {
                    this._generateTrendsDataCell(newDatums, dataCell, data);
                }, this);
                newDatums.length && this.data.owner.add(newDatums);
            }
        },
        _eachLeafDatasAndDataCells: function(hasMultiRole, dataCells, f, x) {
            var C = dataCells.length;
            if (C) {
                var leafDatas, D;
                if (hasMultiRole) {
                    leafDatas = this._multiInfo.smallDatas;
                    D = this._multiInfo.count;
                } else {
                    leafDatas = [this.data];
                    D = 1;
                }
                for (var d = 0; D > d; d++)
                    for (var leafData = leafDatas[d], c = 0; C > c; c++)
                        f.call(x, dataCells[c], leafData, c, d);
            }
        },
        _interpolateDataCell: function() {},
        _generateTrendsDataCell: function() {},
        _getTrendDataPartAtom: function() {
            var dataPartDimName = this._getDataPartDimName();
            return dataPartDimName ? this.data.owner.dimensions(dataPartDimName).intern("trend") : void 0;
        },
        setData: function(data, options) {
            this.setResultset(data && data.resultset);
            this.setMetadata(data && data.metadata);
            $.extend(this.options, options);
            return this;
        },
        setResultset: function(resultset) {
            !this.parent || def.fail.operationInvalid("Can only set resultset on root chart.");
            this.resultset = resultset || [];
            this.resultset.length || this._warn("Resultset is empty");
            return this;
        },
        setMetadata: function(metadata) {
            !this.parent || def.fail.operationInvalid("Can only set metadata on root chart.");
            this.metadata = metadata || [];
            this.metadata.length || this._warn("Metadata is empty");
            return this;
        }
    });
    pvc.BaseChart.add({
        _initPlots: function(hasMultiRole) {
            this.plotPanelList = null;
            if (this.parent) {
                var root = this.root;
                this.plots = root.plots;
                this.plotList = root.plotList;
                this.plotsByType = root.plotsByType;
            } else {
                this.plots = {};
                this.plotList = [];
                this.plotsByType = {};
                this._initPlotsCore(hasMultiRole);
            }
        },
        _initPlotsCore: function() {},
        _addPlot: function(plot) {
            var plotsByType = this.plotsByType
              , plots = this.plots
              , plotType = plot.type
              , plotIndex = plot.index
              , plotName = plot.name
              , plotId = plot.id;
            if (plotName && def.hasOwn(plots, plotName))
                throw def.error.operationInvalid("Plot name '{0}' already taken.", [plotName]);
            if (def.hasOwn(plots, plotId))
                throw def.error.operationInvalid("Plot id '{0}' already taken.", [plotId]);
            var typePlots = def.array.lazy(plotsByType, plotType);
            if (def.hasOwn(typePlots, plotIndex))
                throw def.error.operationInvalid("Plot index '{0}' of type '{1}' already taken.", [plotIndex, plotType]);
            plot.globalIndex = this.plotList.length;
            typePlots[plotIndex] = plot;
            this.plotList.push(plot);
            plots[plotId] = plot;
            plotName && (plots[plotName] = plot);
        },
        _collectPlotAxesDataCells: function(plot, dataCellsByAxisTypeThenIndex) {
            var dataCells = [];
            plot.collectDataCells(dataCells);
            dataCells.length && def.query(dataCells).where(function(dataCell) {
                return dataCell.role.isBound();
            }).each(function(dataCell) {
                var dataCellsByAxisIndex = def.array.lazy(dataCellsByAxisTypeThenIndex, dataCell.axisType);
                def.array.lazy(dataCellsByAxisIndex, dataCell.axisIndex).push(dataCell);
            });
        },
        _addPlotPanel: function(plotPanel) {
            def.lazy(this, "plotPanels")[plotPanel.plot.id] = plotPanel;
            def.array.lazy(this, "plotPanelList").push(plotPanel);
        },
        _createPlotPanels: function() {
            throw def.error.notImplemented();
        }
    });
    pvc.BaseChart.add({
        colors: null,
        axes: null,
        axesList: null,
        axesByType: null,
        _axisClassByType: {
            color: pvc.visual.ColorAxis,
            size: pvc.visual.SizeAxis,
            base: pvc_CartesianAxis,
            ortho: pvc_CartesianAxis
        },
        _axisCreateChartLevel: {
            color: 1,
            size: 2,
            base: 3,
            ortho: 3
        },
        _axisSetScaleChartLevel: {
            color: 1,
            size: 2,
            base: 2,
            ortho: 2
        },
        _axisCreationOrder: ["color", "size", "base", "ortho"],
        _axisCreateIfUnbound: {},
        _chartLevel: function() {
            var level = 0;
            this.parent || (level |= 1);
            (this.parent || !this.visualRoles.multiChart.isBound()) && (level |= 2);
            return level;
        },
        _initAxes: function() {
            this.axes = {};
            this.axesList = [];
            this.axesByType = {};
            delete this._rolesColorScale;
            var dataCellsByAxisTypeThenIndex;
            if (this.parent)
                dataCellsByAxisTypeThenIndex = this.root._dataCellsByAxisTypeThenIndex;
            else {
                dataCellsByAxisTypeThenIndex = {};
                this.plotList.forEach(function(plot) {
                    this._collectPlotAxesDataCells(plot, dataCellsByAxisTypeThenIndex);
                }, this);
                this._dataCellsByAxisTypeThenIndex = dataCellsByAxisTypeThenIndex;
            }
            var chartLevel = this._chartLevel();
            this._axisCreationOrder.forEach(function(type) {
                if (0 !== (this._axisCreateChartLevel[type] & chartLevel)) {
                    var AxisClass, dataCellsByAxisIndex = dataCellsByAxisTypeThenIndex[type];
                    if (dataCellsByAxisIndex) {
                        AxisClass = this._axisClassByType[type];
                        AxisClass && dataCellsByAxisIndex.forEach(function(dataCells, axisIndex) {
                            new AxisClass(this,type,axisIndex);
                        }, this);
                    } else if (this._axisCreateIfUnbound[type]) {
                        AxisClass = this._axisClassByType[type];
                        AxisClass && new AxisClass(this,type,0);
                    }
                }
            }, this);
            this.parent && this.root.axesList.forEach(function(axis) {
                def.hasOwn(this.axes, axis.id) || this._addAxis(axis);
            }, this);
            def.eachOwn(dataCellsByAxisTypeThenIndex, function(dataCellsByAxisIndex, type) {
                this._axisCreateChartLevel[type] & chartLevel && dataCellsByAxisIndex.forEach(function(dataCells, index) {
                    var axis = this.axes[pvc.buildIndexedId(type, index)];
                    axis.isBound() || axis.bind(dataCells);
                }, this);
            }, this);
        },
        _addAxis: function(axis) {
            this.axes[axis.id] = axis;
            axis.chart === this && (axis.axisIndex = this.axesList.length);
            this.axesList.push(axis);
            var typeAxes = def.array.lazy(this.axesByType, axis.type)
              , typeIndex = typeAxes.count || 0;
            axis.typeIndex = typeIndex;
            typeAxes[axis.index] = axis;
            typeIndex || (typeAxes.first = axis);
            typeAxes.count = typeIndex + 1;
            "color" === axis.type && axis.isBound() && this._onColorAxisScaleSet(axis);
            return this;
        },
        _getAxis: function(type, index) {
            var typeAxes = this.axesByType[type];
            return typeAxes && null != index && +index >= 0 ? typeAxes[index] : void 0;
        },
        _setAxesScales: function(chartLevel) {
            this.axesList.forEach(function(axis) {
                this._axisSetScaleChartLevel[axis.type] & chartLevel && axis.isBound() && this._setAxisScale(axis, chartLevel);
            }, this);
        },
        _setAxisScale: function(axis, chartLevel) {
            this._setAxisScaleByScaleType(axis, chartLevel);
        },
        _setAxisScaleByScaleType: function(axis, chartLevel) {
            switch (axis.scaleType) {
            case "discrete":
                this._setDiscreteAxisScale(axis, chartLevel);
                break;

            case "numeric":
                this._setNumericAxisScale(axis, chartLevel);
                break;

            case "timeSeries":
                this._setTimeSeriesAxisScale(axis, chartLevel);
                break;

            default:
                throw def.error("Unknown axis scale type.");
            }
        },
        _describeScale: function(axis, scale) {
            scale.isNull && pvc.debug >= 3 && this._log(def.format("{0} scale for axis '{1}'- no data", [axis.scaleType, axis.id]));
        },
        _setDiscreteAxisScale: function(axis) {
            if ("color" !== axis.type) {
                var values = axis.domainValues()
                  , scale = new pv.Scale.ordinal();
                values.length ? scale.domain(values) : scale.isNull = !0;
                this._describeScale(axis, scale);
                axis.setScale(scale);
            } else
                this._setDiscreteColorAxisScale(axis);
        },
        _setTimeSeriesAxisScale: function(axis) {
            var extent = this._getContinuousVisibleExtentConstrained(axis)
              , scale = new pv.Scale.linear();
            if (extent) {
                var dMin = extent.min
                  , dMax = extent.max
                  , epsi = 1
                  , normalize = function() {
                    var d = dMax - dMin;
                    if (d && Math.abs(d) < epsi) {
                        dMax = dMin = new Date(Math.round((dMin + dMax) / 2));
                        d = 0;
                    }
                    if (d)
                        0 > d && (!extent.maxLocked || extent.minLocked ? dMax = new Date(dMin.getTime() + pvc.time.intervals.h) : dMin = new Date(dMax.getTime() - pvc.time.intervals.h));
                    else {
                        extent.minLocked || (dMin = new Date(dMin.getTime() - pvc.time.intervals.h));
                        (!extent.maxLocked || extent.minLocked) && (dMax = new Date(dMax.getTime() + pvc.time.intervals.h));
                    }
                };
                normalize();
                scale.domain(dMin, dMax);
                scale.minLocked = extent.minLocked;
                scale.maxLocked = extent.maxLocked;
            } else
                scale.isNull = !0;
            this._describeScale(axis, scale);
            axis.setScale(scale);
        },
        _setNumericAxisScale: function(axis) {
            if ("color" !== axis.type) {
                var extent = this._getContinuousVisibleExtentConstrained(axis)
                  , scale = new pv.Scale.linear();
                if (extent) {
                    var dMin = extent.min
                      , dMax = extent.max
                      , epsi = 1e-10
                      , normalize = function() {
                        var d = dMax - dMin;
                        if (d && Math.abs(d) <= epsi) {
                            dMin = (dMin + dMax) / 2;
                            dMin = dMax = +dMin.toFixed(10);
                            d = 0;
                        }
                        if (d)
                            0 > d && (!extent.maxLocked || extent.minLocked ? dMax = Math.abs(dMin) > epsi ? 1.01 * dMin : .1 : dMin = Math.abs(dMax) > epsi ? .99 * dMax : -.1);
                        else {
                            extent.minLocked || (dMin = Math.abs(dMin) > epsi ? .99 * dMin : -.1);
                            (!extent.maxLocked || extent.minLocked) && (dMax = Math.abs(dMax) > epsi ? 1.01 * dMax : .1);
                        }
                    };
                    normalize();
                    var originIsZero = axis.option.isDefined("OriginIsZero") && axis.option("OriginIsZero");
                    if (originIsZero)
                        if (0 === dMin)
                            extent.minLocked = !0;
                        else if (0 === dMax)
                            extent.maxLocked = !0;
                        else if (dMin * dMax > 0) {
                            if (dMin > 0) {
                                if (!extent.minLocked) {
                                    extent.minLocked = !0;
                                    dMin = 0;
                                }
                            } else if (!extent.maxLocked) {
                                extent.maxLocked = !0;
                                dMax = 0;
                            }
                            normalize();
                        }
                    scale.domain(dMin, dMax);
                    scale.minLocked = extent.minLocked;
                    scale.maxLocked = extent.maxLocked;
                } else
                    scale.isNull = !0;
                this._describeScale(axis, scale);
                axis.setScale(scale);
            } else
                this._setNumericColorAxisScale(axis);
        },
        _warnSingleContinuousValueRole: function(valueRole) {
            valueRole.grouping.isSingleDimension || this._warn("A linear scale can only be obtained for a single dimension role.");
            valueRole.grouping.isDiscrete() && this._warn(def.format("The single dimension of role '{0}' should be continuous.", [valueRole.name]));
        },
        _getContinuousVisibleExtentConstrained: function(axis, min, max) {
            var dim, getDim = function() {
                return dim || (dim = this.data.owner.dimensions(axis.role.grouping.firstDimensionName()));
            }, minLocked = !1, maxLocked = !1;
            if (null == min && axis.option.isDefined("FixedMin")) {
                min = axis.option("FixedMin");
                null != min && (min = getDim.call(this).read(min));
                minLocked = null != min;
                if (minLocked) {
                    min = min.value;
                    0 > min && axis.scaleUsesAbs() && (min = -min);
                }
            }
            if (null == max && axis.option.isDefined("FixedMax")) {
                max = axis.option("FixedMax");
                null != max && (max = getDim.call(this).read(max));
                maxLocked = null != max;
                if (maxLocked) {
                    max = max.value;
                    0 > max && axis.scaleUsesAbs() && (max = -max);
                }
            }
            if (null == min || null == max) {
                var baseExtent = this._getContinuousVisibleExtent(axis);
                if (!baseExtent)
                    return null;
                null == min && (min = baseExtent.min);
                null == max && (max = baseExtent.max);
            }
            return {
                min: min,
                max: max,
                minLocked: minLocked,
                maxLocked: maxLocked
            };
        },
        _getContinuousVisibleExtent: function(valueAxis) {
            var dataCells = valueAxis.dataCells;
            return 1 === dataCells.length ? this._getContinuousVisibleCellExtent(valueAxis, dataCells[0]) : def.query(dataCells).select(function(dataCell) {
                return this._getContinuousVisibleCellExtent(valueAxis, dataCell);
            }, this).reduce(pvc.unionExtents, null);
        },
        _getContinuousVisibleCellExtent: function(valueAxis, valueDataCell) {
            var valueRole = valueDataCell.role;
            this._warnSingleContinuousValueRole(valueRole);
            if ("series" === valueRole.name)
                throw def.error.notImplemented();
            var sumNorm = valueAxis.scaleSumNormalized()
              , data = this.visibleData(valueDataCell.dataPartValue)
              , dimName = valueRole.firstDimensionName();
            if (sumNorm) {
                var sum = data.dimensionsSumAbs(dimName);
                if (sum)
                    return {
                        min: 0,
                        max: sum
                    };
            } else {
                var useAbs = valueAxis.scaleUsesAbs()
                  , extent = data.dimensions(dimName).extent({
                    abs: useAbs
                });
                if (extent) {
                    var minValue = extent.min.value
                      , maxValue = extent.max.value;
                    return {
                        min: useAbs ? Math.abs(minValue) : minValue,
                        max: useAbs ? Math.abs(maxValue) : maxValue
                    };
                }
            }
        },
        _setDiscreteColorAxisScale: function(axis) {
            var domainValues = axis.domainValues()
              , scale = axis.scheme()(domainValues);
            this._describeScale(axis, scale);
            axis.setScale(scale, !0);
            this._onColorAxisScaleSet(axis);
        },
        _setNumericColorAxisScale: function(axis) {
            if (1 !== axis.dataCells.length)
                throw def.error("Can't handle multiple continuous datacells in color axis.");
            this._warnSingleContinuousValueRole(axis.role);
            var visibleDomainData = this.visibleData(axis.dataCell.dataPartValue)
              , normByCateg = axis.option("NormByCategory")
              , scaleOptions = {
                type: axis.option("ScaleType"),
                colors: axis.option("Colors")().range(),
                colorDomain: axis.option("Domain"),
                colorMin: axis.option("Min"),
                colorMax: axis.option("Max"),
                colorMissing: axis.option("Missing"),
                data: visibleDomainData,
                colorDimension: axis.role.firstDimensionName(),
                normPerBaseCategory: normByCateg
            };
            if (normByCateg)
                axis.scalesByCateg = pvc_colorScales(scaleOptions);
            else {
                var scale = pvc_colorScale(scaleOptions);
                this._describeScale(axis, scale);
                axis.setScale(scale);
            }
            this._onColorAxisScaleSet(axis);
        },
        _onColorAxisScaleSet: function(axis) {
            switch (axis.index) {
            case 0:
                this.colors = axis.scheme();
                break;

            case 1:
                this._allowV1SecondAxis && (this.secondAxisColor = axis.scheme());
            }
        },
        _getRoleColorScale: function(roleName) {
            return def.lazy(def.lazy(this, "_rolesColorScale"), roleName, this._createRoleColorScale, this);
        },
        _createRoleColorScale: function(roleName) {
            function addDomainValue(value) {
                var key = "" + value;
                def.hasOwnProp.call(valueToColorMap, key) || (valueToColorMap[key] = scale(value));
            }
            var firstScale, scale, valueToColorMap = {};
            this.axesByType.color.forEach(function(axis) {
                var axisRole = axis.role
                  , isRoleCompatible = axisRole.name === roleName || axisRole.sourceRole && axisRole.sourceRole.name === roleName;
                if (isRoleCompatible && axis.scale && (0 === axis.index || axis.option.isSpecified("Colors") || axis.option.isSpecified("Map"))) {
                    scale = axis.scale;
                    firstScale || (firstScale = scale);
                    axis.domainValues().forEach(addDomainValue);
                }
            }, this);
            if (!firstScale)
                return pvc.createColorScheme()();
            scale = function(value) {
                var key = "" + value;
                if (def.hasOwnProp.call(valueToColorMap, key))
                    return valueToColorMap[key];
                var color = firstScale(value);
                valueToColorMap[key] = color;
                return color;
            }
            ;
            def.copy(scale, firstScale);
            return scale;
        },
        _onLaidOut: function() {}
    });
    pvc.BaseChart.add({
        basePanel: null,
        titlePanel: null,
        legendPanel: null,
        _multiChartPanel: null,
        _initChartPanels: function(hasMultiRole) {
            this._initBasePanel();
            this._initTitlePanel();
            var legendPanel = this._initLegendPanel()
              , isMultichartRoot = hasMultiRole && !this.parent;
            isMultichartRoot && this._initMultiChartPanel();
            legendPanel && this._initLegendScenes(legendPanel);
            if (!isMultichartRoot) {
                var o = this.options;
                this._createContent({
                    margins: hasMultiRole ? o.smallContentMargins : o.contentMargins,
                    paddings: hasMultiRole ? o.smallContentPaddings : o.contentPaddings,
                    clickAction: o.clickAction,
                    doubleClickAction: o.doubleClickAction
                });
            }
        },
        _createContent: function() {},
        _initBasePanel: function() {
            var p = this.parent;
            this.basePanel = new pvc.BasePanel(this,p && p._multiChartPanel,{
                margins: this.margins,
                paddings: this.paddings,
                size: {
                    width: this.width,
                    height: this.height
                }
            });

        },
        _initTitlePanel: function() {
            var me = this
              , o = me.options
              , title = o.title;
            if (!def.empty(title)) {
                {
                    !me.parent;
                }
                this.titlePanel = new pvc.TitlePanel(me,me.basePanel,{
                    title: title,
                    font: o.titleFont,
                    anchor: o.titlePosition,
                    align: o.titleAlign,
                    alignTo: o.titleAlignTo,
                    offset: o.titleOffset,
                    keepInBounds: o.titleKeepInBounds,
                    margins: o.titleMargins,
                    paddings: o.titlePaddings,
                    titleSize: o.titleSize,
                    titleSizeMax: o.titleSizeMax
                });
            }
        },
        _initLegendPanel: function() {
            var o = this.options;
            if (o.legend) {
                var legend = new pvc.visual.Legend(this,"legend",0);
                return this.legendPanel = new pvc.LegendPanel(this,this.basePanel,{
                    anchor: legend.option("Position"),
                    align: legend.option("Align"),
                    alignTo: o.legendAlignTo,
                    offset: o.legendOffset,
                    keepInBounds: o.legendKeepInBounds,
                    size: legend.option("Size"),
                    sizeMax: legend.option("SizeMax"),
                    margins: legend.option("Margins"),
                    paddings: legend.option("Paddings"),
                    font: legend.option("Font"),
                    scenes: def.getPath(o, "legend.scenes"),
                    textMargin: o.legendTextMargin,
                    itemPadding: o.legendItemPadding,
                    itemSize: legend.option("ItemSize"),
                    markerSize: o.legendMarkerSize
                });
            }
        },
        _getLegendBulletRootScene: function() {
            return this.legendPanel && this.legendPanel._getBulletRootScene();
        },
        _initMultiChartPanel: function() {
            var basePanel = this.basePanel
              , options = this.options;
            this._multiChartPanel = new pvc.MultiChartPanel(this,basePanel,{
                margins: options.contentMargins,
                paddings: options.contentPaddings
            });
            this._multiChartPanel.createSmallCharts();
            basePanel._children.unshift(basePanel._children.pop());
        },
        _coordinateSmallChartsLayout: function() {},
        _initLegendScenes: function(legendPanel) {
            var colorAxes = this.axesByType.color;
            if (colorAxes) {
                var _dataPartAtom, _dataPartDimName, _rootScene, legendIndex = 0, me = this, getCellClickMode = function(axis, cellData) {
                    if ("togglevisible" === axis.option("LegendClickMode")) {
                        if (void 0 === _dataPartAtom) {
                            _dataPartAtom = me._getTrendDataPartAtom() || null;
                            _dataPartAtom && (_dataPartDimName = _dataPartAtom.dimension.name);
                        }
                        if (_dataPartAtom && cellData.firstAtoms()[_dataPartDimName] === _dataPartAtom)
                            return "none";
                    }
                }, getRootScene = function() {
                    return _rootScene || (rootScene = legendPanel._getBulletRootScene());
                };
                def.query(colorAxes).where(function(axis) {
                    return axis.option("LegendVisible") && axis.isBound() && axis.isDiscrete();
                }).each(function(axis) {
                    for (var colorScale = axis.scale, cellIndex = -1, dataCells = axis.dataCells, C = dataCells.length; ++cellIndex < C; ) {
                        var dataCell = dataCells[cellIndex]
                          , cellData = axis.domainCellData(cellIndex)
                          , groupScene = getRootScene().createGroup({
                            source: cellData,
                            colorAxis: axis,
                            clickMode: getCellClickMode(axis, cellData),
                            extensionPrefix: pvc.buildIndexedId("", legendIndex++)
                        });
                        dataCell.legendGroupScene(groupScene);
                        axis.domainCellItems(cellData).forEach(function(itemData) {
                            var itemScene = groupScene.createItem({
                                source: itemData
                            })
                              , itemValue = axis.domainItemValue(itemData);
                            itemScene.color = colorScale(itemValue);
                        });
                    }
                });
            }
        }
    });
    pvc.BaseChart.add({
        _updateSelectionSuspendCount: 0,
        _lastSelectedDatums: null,
        clearSelections: function() {
            this.data.owner.clearSelected() && this.updateSelections();
            return this;
        },
        _updatingSelections: function(method, context) {
            this._suspendSelectionUpdate();
            try {
                method.call(context || this);
            } finally {
                this._resumeSelectionUpdate();
            }
        },
        _suspendSelectionUpdate: function() {
            this === this.root ? this._updateSelectionSuspendCount++ : this.root._suspendSelectionUpdate();
        },
        _resumeSelectionUpdate: function() {
            this === this.root ? this._updateSelectionSuspendCount > 0 && (--this._updateSelectionSuspendCount || this.updateSelections()) : this.root._resumeSelectionUpdate();
        },
        updateSelections: function(keyArgs) {
            if (this === this.root) {
                if (this._inUpdateSelections || this._updateSelectionSuspendCount)
                    return this;
                var selectedChangedDatumMap = this._calcSelectedChangedDatums();
                if (!selectedChangedDatumMap)
                    return this;
                pvc.removeTipsyLegends();
                this._inUpdateSelections = !0;
                try {
                    var action = this.options.selectionChangedAction;
                    if (action) {
                        var selectedDatums = this.data.selectedDatums()
                          , selectedChangedDatums = selectedChangedDatumMap.values();
                        action.call(this.basePanel.context(), selectedDatums, selectedChangedDatums);
                    }
                    def.get(keyArgs, "render", !0) && this.useTextMeasureCache(function() {
                        this.basePanel.renderInteractive();
                    }, this);
                } finally {
                    this._inUpdateSelections = !1;
                }
            } else
                this.root.updateSelections();
            return this;
        },
        _calcSelectedChangedDatums: function() {
            if (this.data) {
                var selectedChangedDatums, nowSelectedDatums = this.data.selectedDatumMap(), lastSelectedDatums = this._lastSelectedDatums;
                if (lastSelectedDatums) {
                    selectedChangedDatums = lastSelectedDatums.symmetricDifference(nowSelectedDatums);
                    if (!selectedChangedDatums.count)
                        return;
                } else {
                    if (!nowSelectedDatums.count)
                        return;
                    selectedChangedDatums = nowSelectedDatums.clone();
                }
                this._lastSelectedDatums = nowSelectedDatums;
                return selectedChangedDatums;
            }
        },
        _onUserSelection: function(datums) {
            if (!datums || !datums.length)
                return datums;
            if (this === this.root) {
                var action = this.options.userSelectionAction;
                return action ? action.call(this.basePanel.context(), datums) || datums : datums;
            }
            return this.root._onUserSelection(datums);
        }
    });
    pvc.BaseChart.add({
        _processExtensionPoints: function() {
            var components;
            if (this.parent)
                components = this.parent._components;
            else {
                var points = this.options.extensionPoints;
                components = {};
                if (points)
                    for (var p in points) {
                        var id, prop, splitIndex = p.indexOf("_");
                        if (splitIndex > 0) {
                            id = p.substring(0, splitIndex);
                            prop = p.substr(splitIndex + 1);
                            if (id && prop) {
                                var component = def.getOwn(components, id) || (components[id] = new def.OrderedMap());
                                component.add(prop, points[p]);
                            }
                        }
                    }
            }
            this._components = components;
        },
        extend: function(mark, ids, keyArgs) {
            def.array.is(ids) ? ids.forEach(function(id) {
                this._extendCore(mark, id, keyArgs);
            }, this) : this._extendCore(mark, ids, keyArgs);
        },
        _extendCore: function(mark, id, keyArgs) {
            if (mark) {
                var component = def.getOwn(this._components, id);
                if (component) {
                    mark.borderPanel && (mark = mark.borderPanel);
                    var logOut = pvc.debug >= 3 ? [] : null
                      , constOnly = def.get(keyArgs, "constOnly", !1)
                      , wrap = mark.wrap
                      , keyArgs2 = {
                        tag: pvc.extensionTag
                    }
                      , isRealMark = mark instanceof pv_Mark
                      , isRealMarkAndWrapOrConstOnly = isRealMark && (wrap || constOnly)
                      , processValue = function(v, m) {
                        if (null != v) {
                            var type = typeof v;
                            if ("object" === type) {
                                if ("svg" === m || "css" === m) {
                                    var v2 = mark.propertyValue(m);
                                    v2 && (v = def.copy(v2, v));
                                } else if (v instanceof Array)
                                    return v.map(function(vi) {
                                        return processValue(vi, m);
                                    });
                            } else if (isRealMarkAndWrapOrConstOnly && "function" === type) {
                                if (constOnly)
                                    return;
                                "add" !== m && "call" !== m && (v = wrap.call(mark, v, m));
                            }
                        }
                        return v;
                    }
                      , callMethod = function(mm, v) {
                        v instanceof Array ? mm.apply(mark, v) : mm.call(mark, v);
                    };
                    component.forEach(function(v, m) {
                        if (mark.isLocked && mark.isLocked(m))
                            logOut && logOut.push(m + ": locked extension point!");
                        else if (mark.isIntercepted && mark.isIntercepted(m))
                            logOut && logOut.push(m + ":" + pvc.stringify(v) + " (controlled)");
                        else {
                            logOut && logOut.push(m + ": " + pvc.stringify(v));
                            v = processValue(v, m);
                            if (void 0 !== v) {
                                var mm = mark[m];
                                "function" == typeof mm ? isRealMark && mark.properties[m] ? mark.intercept(m, v, keyArgs2) : v instanceof Array ? v.forEach(function(vi) {
                                    callMethod(mm, vi);
                                }) : callMethod(mm, v) : mark[m] = v;
                            }
                        }
                    });
                    logOut && (logOut.length ? this._log("Applying Extension Points for: '" + id + "'\n	* " + logOut.join("\n	* ")) : pvc.debug >= 5 && this._log("No Extension Points for: '" + id + "'"));
                }
            } else
                pvc.debug >= 4 && this._log("Applying Extension Points for: '" + id + "' (target mark does not exist)");
        },
        _getExtension: function(id, prop) {
            var component;
            if (def.array.is(id))
                for (var value, i = id.length - 1; i >= 0; ) {
                    component = def.getOwn(this._components, id[i--]);
                    if (component && void 0 !== (value = component.get(prop)))
                        return value;
                }
            else {
                component = def.getOwn(this._components, id);
                if (component)
                    return component.get(prop);
            }
        },
        _getComponentExtensions: function(id) {
            return def.getOwn(this._components, id);
        },
        _getConstantExtension: function(id, prop) {
            var value = this._getExtension(id, prop);
            return def.fun.is(value) ? void 0 : value;
        }
    });
    def.type("pvc.BasePanel", pvc.Abstract).add(pvc.visual.Interactive).init(function(chart, parent, options) {
        this.chart = chart;
        this.base();
        this.axes = Object.create(chart.axes);
        if (options) {
            if (options.scenes) {
                this._sceneTypeExtensions = options.scenes;
                delete options.scenes;
            }
            var axes = options.axes;
            if (axes) {
                def.copy(this.axes, axes);
                delete options.axes;
            }
        }
        $.extend(this, options);
        this.axes.color || (this.axes.color = chart.axes.color);
        this.position = {};
        var margins = options && options.margins;
        parent || void 0 !== margins || (margins = 3);
        this.margins = new pvc_Sides(margins);
        this.paddings = new pvc_Sides(options && options.paddings);
        this.size = new pvc_Size(options && options.size);
        this.sizeMax = new pvc_Size(options && options.sizeMax);
        if (parent) {
            this.parent = parent;
            this.isTopRoot = !1;
            this.isRoot = parent.chart !== chart;
            this.root = this.isRoot ? this : parent.root;
            this.topRoot = parent.topRoot;
            this._ibits = parent._ibits;
            if (this.isRoot) {
                this.position.left = chart.left;
                this.position.top = chart.top;
            }
            parent._addChild(this);
        } else {
            this.parent = null;
            this.root = this;
            this.topRoot = this;
            this.isRoot = !0;
            this.isTopRoot = !0;
            this._ibits = chart._ibits;
        }
        this.data = (this.isRoot ? chart : parent).data;
        if (this.isRoot) {
            this.anchor = null;
            this.align = null;
            this.alignTo = null;
            this.offset = null;
        } else {
            this.align = pvc.parseAlign(this.anchor, this.align);
            var alignTo = this.alignTo
              , side = this.anchor;
            null == alignTo || "" === alignTo || "left" !== side && "right" !== side ? alignTo = this.align : "page-middle" !== alignTo && (alignTo = isNaN(+alignTo.charAt(0)) ? pvc.parseAlign(side, alignTo) : pvc_PercentValue.parse(alignTo));
            this.alignTo = alignTo;
            this.offset = new pvc_Offset(this.offset);
        }
        if (null == this.borderWidth) {
            var borderWidth, extensionId = this._getExtensionId();
            if (extensionId) {
                var strokeStyle = this._getExtension(extensionId, "strokeStyle");
                if (null != strokeStyle) {
                    borderWidth = +this._getConstantExtension(extensionId, "lineWidth");
                    (isNaN(borderWidth) || !isFinite(borderWidth)) && (borderWidth = null);
                }
            }
            this.borderWidth = null == borderWidth ? 0 : 1.5;
        }
        var I = pvc.visual.Interactive
          , ibits = this._ibits;
        ibits = def.bit.set(ibits, I.Clickable, chart._ibits & I.Clickable && !!this.clickAction);
        ibits = def.bit.set(ibits, I.DoubleClickable, chart._ibits & I.DoubleClickable && !!this.doubleClickAction);
        this._ibits = ibits;
    }).add({
        chart: null,
        parent: null,
        _children: null,
        type: pv.Panel,
        _extensionPrefix: "",
        _rubberSelectableMarks: null,
        height: null,
        width: null,
        borderWidth: null,
        anchor: "top",
        pvPanel: null,
        margins: null,
        paddings: null,
        isRoot: !1,
        isTopRoot: !1,
        root: null,
        topRoot: null,
        _layoutInfo: null,
        _signs: null,
        data: null,
        dataPartValue: null,
        _animating: !0,
        _selectingByRubberband: !1,
        _v1DimRoleName: {
            series: "series",
            category: "category",
            value: "value"
        },
        _sceneTypeExtensions: null,
        clickAction: null,
        doubleClickAction: null,
        compatVersion: function(options) {
            return this.chart.compatVersion(options);
        },
        _createLogInstanceId: function() {
            return "" + this.constructor + this.chart._createLogChildSuffix();
        },
        _getLegendBulletRootScene: function() {
            return this.chart._getLegendBulletRootScene();
        },
        _addChild: function(child) {
            child.parent === this || def.assert("Child has a != parent.");
            (this._children || (this._children = [])).push(child);
        },
        _addSign: function(sign) {
            def.array.lazy(this, "_signs").push(sign);
            sign.selectableByRubberband() && def.array.lazy(this, "_rubberSelectableMarks").push(sign.pvMark);
        },
        visibleData: function(ka) {
            return this.chart.visibleData(this.dataPartValue, ka);
        },
        partData: function() {
            return this.chart.partData(this.dataPartValue);
        },
        layout: function(availableSize, ka) {
            if (!this._layoutInfo || def.get(ka, "force", !1)) {
                var referenceSize = def.get(ka, "referenceSize");
                !referenceSize && availableSize && (referenceSize = def.copyOwn(availableSize));
                var desiredSize = this.size.resolve(referenceSize)
                  , sizeMax = this.sizeMax.resolve(referenceSize);
                if (!availableSize) {
                    if (null == desiredSize.width || null == desiredSize.height)
                        throw def.error.operationInvalid("Panel layout without width or height set.");
                    availableSize = def.copyOwn(desiredSize);
                }
                !referenceSize && availableSize && (referenceSize = def.copyOwn(availableSize));
                null != sizeMax.width && availableSize.width > sizeMax.width && (availableSize.width = sizeMax.width);
                null != sizeMax.height && availableSize.height > sizeMax.height && (availableSize.height = sizeMax.height);
                var halfBorder = this.borderWidth / 2
                  , realMargins = (def.get(ka, "margins") || this.margins).resolve(referenceSize)
                  , realPaddings = (def.get(ka, "paddings") || this.paddings).resolve(referenceSize)
                  , margins = pvc_Sides.inflate(realMargins, halfBorder)
                  , paddings = pvc_Sides.inflate(realPaddings, halfBorder)
                  , spaceWidth = margins.width + paddings.width
                  , spaceHeight = margins.height + paddings.height
                  , availableClientSize = new pvc_Size(Math.max(availableSize.width - spaceWidth, 0),Math.max(availableSize.height - spaceHeight, 0))
                  , desiredClientSize = def.copyOwn(desiredSize);
                null != desiredClientSize.width && (desiredClientSize.width = Math.max(desiredClientSize.width - spaceWidth, 0));
                null != desiredClientSize.height && (desiredClientSize.height = Math.max(desiredClientSize.height - spaceHeight, 0));
                var prevLayoutInfo = this._layoutInfo || null
                  , canChange = def.get(ka, "canChange", !0)
                  , layoutInfo = this._layoutInfo = {
                    canChange: canChange,
                    referenceSize: referenceSize,
                    realMargins: realMargins,
                    realPaddings: realPaddings,
                    borderWidth: this.borderWidth,
                    margins: margins,
                    paddings: paddings,
                    desiredClientSize: desiredClientSize,
                    clientSize: availableClientSize,
                    pageClientSize: prevLayoutInfo ? prevLayoutInfo.pageClientSize : availableClientSize.clone(),
                    previous: prevLayoutInfo
                };
                if (prevLayoutInfo) {
                    delete prevLayoutInfo.previous;
                    delete prevLayoutInfo.pageClientSize;
                }
                var size, clientSize = this._calcLayout(layoutInfo);
                if (clientSize) {
                    layoutInfo.clientSize = clientSize;
                    size = {
                        width: clientSize.width + spaceWidth,
                        height: clientSize.height + spaceHeight
                    };
                } else {
                    size = availableSize;
                    clientSize = availableClientSize;
                }
                this.isVisible = clientSize.width > 0 && clientSize.height > 0;
                delete layoutInfo.desiredClientSize;
                this.width = size.width;
                this.height = size.height;
                !canChange && prevLayoutInfo && delete layoutInfo.previous;
                if (pvc.debug >= 5) {
                    this._log("Size       = " + pvc.stringify(size));
                    this._log("Margins    = " + pvc.stringify(layoutInfo.margins));
                    this._log("Paddings   = " + pvc.stringify(layoutInfo.paddings));
                    this._log("ClientSize = " + pvc.stringify(layoutInfo.clientSize));
                }
                this._onLaidOut();
            }
        },
        _onLaidOut: function() {
            this.isRoot && this.chart._onLaidOut();
        },
        _calcLayout: function(layoutInfo) {
            function doMaxTimes(maxTimes, fun, ctx) {
                for (var index = 0; maxTimes--; ) {
                    if (fun.call(ctx, maxTimes, index) === !1)
                        return !0;
                    index++;
                }
                return !1;
            }
            function layoutCycle(remTimes, iteration) {
                useLog && me._group("LayoutCycle #" + (iteration + 1) + " (remaining: " + remTimes + ")");
                try {
                    var canResize = remTimes > 0;
                    margins = new pvc_Sides(0);
                    remSize = def.copyOwn(clientSize);
                    for (var child, index = 0, count = sideChildren.length; count > index; ) {
                        child = sideChildren[index];
                        useLog && me._group("SIDE Child #" + (index + 1) + " at " + child.anchor);
                        try {
                            if (layoutChild.call(this, child, canResize))
                                return !0;
                        } finally {
                            useLog && me._groupEnd();
                        }
                        index++;
                    }
                    index = 0;
                    count = fillChildren.length;
                    for (; count > index; ) {
                        child = fillChildren[index];
                        useLog && me._group("FILL Child #" + (index + 1));
                        try {
                            if (layoutChild.call(this, child, canResize))
                                return !0;
                        } finally {
                            useLog && me._groupEnd();
                        }
                        index++;
                    }
                    return !1;
                } finally {
                    useLog && me._groupEnd();
                }
            }
            function layoutChild(child, canResize) {
                var paddings, resized = !1;
                childKeyArgs.canChange = canResize;
                doMaxTimes(3, function(remTimes, iteration) {
                    useLog && me._group("Attempt #" + (iteration + 1));
                    try {
                        childKeyArgs.paddings = paddings;
                        childKeyArgs.canChange = remTimes > 0;
                        child.layout(new pvc_Size(remSize), childKeyArgs);
                        if (child.isVisible) {
                            resized = checkChildResize.call(this, child, canResize);
                            if (resized)
                                return !1;
                            var requestPaddings = child._layoutInfo.requestPaddings;
                            if (checkPaddingsChanged(paddings, requestPaddings)) {
                                paddings = requestPaddings;
                                if (remTimes > 0) {
                                    paddings = new pvc_Sides(paddings);
                                    useLog && this._log("Child requested paddings change: " + pvc.stringify(paddings));
                                    return !0;
                                }
                                pvc.debug >= 2 && this._warn("Child requests paddings change but iterations limit has been reached.");
                            }
                            positionChild.call(this, child);
                            "fill" !== child.anchor && updateSide.call(this, child);
                        }
                        return !1;
                    } finally {
                        useLog && me._groupEnd();
                    }
                }, this);
                return resized;
            }
            function checkPaddingsChanged(paddings, newPaddings) {
                return newPaddings ? def.query(pvc_Sides.names).each(function(side) {
                    var curPad = paddings && paddings[side] || 0
                      , newPad = newPaddings && newPaddings[side] || 0;
                    return Math.abs(newPad - curPad) >= .1 ? !1 : void 0;
                }) : !1;
            }
            function checkChildResize(child, canResize) {
                var resized = !1
                  , addWidth = child.width - remSize.width;
                if (addWidth > 0) {
                    pvc.debug >= 3 && this._log("Child added width = " + addWidth);
                    if (canResize) {
                        resized = !0;
                        remSize.width += addWidth;
                        clientSize.width += addWidth;
                    } else
                        pvc.debug >= 2 && this._warn("Child wanted more width, but layout iterations limit has been reached.");
                }
                var addHeight = child.height - remSize.height;
                if (addHeight > 0) {
                    pvc.debug >= 3 && this._log("Child added height =" + addHeight);
                    if (canResize) {
                        resized = !0;
                        remSize.height += addHeight;
                        clientSize.height += addHeight;
                    } else
                        pvc.debug >= 2 && this._warn("Child wanted more height, but layout iterations limit has been reached.");
                }
                return resized;
            }
            function positionChild(child) {
                var sidePos, side = child.anchor, align = child.align, alignTo = child.alignTo;
                if ("fill" === side) {
                    side = "left";
                    sidePos = margins.left + remSize.width / 2 - child.width / 2;
                    align = alignTo = "middle";
                } else
                    sidePos = margins[side];
                var sideo, sideOPosChildOffset;
                switch (align) {
                case "top":
                case "bottom":
                case "left":
                case "right":
                    sideo = align;
                    sideOPosChildOffset = 0;
                    break;

                case "center":
                case "middle":
                    sideo = altMap[aoMap[side]];
                    sideOPosChildOffset = -child[aolMap[sideo]] / 2;
                }
                var sideOPosParentOffset, sideOTo;
                switch (alignTo) {
                case "top":
                case "bottom":
                case "left":
                case "right":
                    sideOTo = alignTo;
                    sideOPosParentOffset = sideOTo !== sideo ? remSize[aolMap[sideo]] : 0;
                    break;

                case "center":
                case "middle":
                    sideOTo = altMap[aoMap[side]];
                    sideOPosParentOffset = remSize[aolMap[sideo]] / 2;
                    break;

                case "page-center":
                case "page-middle":
                    sideOTo = altMap[aoMap[side]];
                    var lenProp = aolMap[sideo]
                      , pageLen = Math.min(remSize[lenProp], layoutInfo.pageClientSize[lenProp]);
                    sideOPosParentOffset = pageLen / 2;
                }
                var sideOPos = margins[sideOTo] + sideOPosParentOffset + sideOPosChildOffset
                  , resolvedOffset = child.offset.resolve(remSize);
                if (resolvedOffset) {
                    sidePos += resolvedOffset[aofMap[side]] || 0;
                    sideOPos += resolvedOffset[aofMap[sideo]] || 0;
                }
                if (child.keepInBounds) {
                    0 > sidePos && (sidePos = 0);
                    0 > sideOPos && (sideOPos = 0);
                }
                child.setPosition(def.set({}, side, sidePos, sideo, sideOPos));
            }
            function updateSide(child) {
                var side = child.anchor
                  , sideol = aolMap[side]
                  , olen = child[sideol];
                margins[side] += olen;
                remSize[sideol] -= olen;
            }
            var clientSize, margins, remSize, useLog, me = this;
            if (me._children) {
                var aolMap = pvc.BasePanel.orthogonalLength
                  , aoMap = pvc.BasePanel.relativeAnchor
                  , altMap = pvc.BasePanel.leftTopAnchor
                  , aofMap = pvc_Offset.namesSidesToOffset
                  , fillChildren = []
                  , sideChildren = [];
                me._children.forEach(function(child) {
                    var a = child.anchor;
                    if (a)
                        if ("fill" === a)
                            fillChildren.push(child);
                        else {
                            def.hasOwn(aoMap, a) || def.fail.operationInvalid("Unknown anchor value '{0}'", [a]);
                            sideChildren.push(child);
                        }
                });
                useLog = pvc.debug >= 5;
                clientSize = def.copyOwn(layoutInfo.clientSize);
                var childKeyArgs = {
                    force: !0,
                    referenceSize: clientSize
                };
                useLog && me._group("CCC DOCK LAYOUT clientSize = " + pvc.stringify(clientSize));
                try {
                    doMaxTimes(5, layoutCycle, me);
                } finally {
                    useLog && me._groupEnd();
                }
            }
            return clientSize;
        },
        invalidateLayout: function() {
            this._layoutInfo = null;
            this._children && this._children.forEach(function(child) {
                child.invalidateLayout();
            });
        },
        _create: function(force) {
            if (!this.pvPanel || force) {
                var invalidDataError;
                delete this._invalidDataError;
                this.pvPanel = null;
                this.pvRootPanel && (this.pvRootPanel = null);
                delete this._signs;
                try {
                    this.layout();
                } catch (ex) {
                    if (!(ex instanceof InvalidDataException))
                        throw ex;
                    this._invalidDataError = invalidDataError = ex;
                }
                if (this.isTopRoot && this.chart._isMultiChartOverflowClip)
                    return;
                if (!this.isVisible)
                    return;
                this.isRoot && this._creating();
                var margins = this._layoutInfo.margins
                  , paddings = this._layoutInfo.paddings;
                if (this.isTopRoot) {
                    this.pvRootPanel = this.pvPanel = new pv.Panel().canvas(this.chart.options.canvas);
                    var scene = new pvc.visual.Scene(null,{
                        panel: this
                    });
                    this.pvRootPanel.lock("data", [scene]);
                    if (margins.width > 0 || margins.height > 0) {
                        this.pvPanel.width(this.width).height(this.height);
                        this.pvPanel = this.pvPanel.add(pv.Panel);
                    }
                } else
                    this.pvPanel = this.parent.pvPanel.add(this.type);
                var pvBorderPanel = this.pvPanel
                  , width = this.width - margins.width
                  , height = this.height - margins.height;
                pvBorderPanel.width(width).height(height);
                pvc.debug >= 15 && (margins.width > 0 || margins.height > 0) && (this.isTopRoot ? this.pvRootPanel : this.parent.pvPanel).add(this.type).width(this.width).height(this.height).left(null != this.position.left ? this.position.left : null).right(null != this.position.right ? this.position.right : null).top(null != this.position.top ? this.position.top : null).bottom(null != this.position.bottom ? this.position.bottom : null).strokeStyle("orange").lineWidth(1).strokeDasharray("- .");
                var hasPositions = {};
                def.eachOwn(this.position, function(v, side) {
                    pvBorderPanel[side](v + margins[side]);
                    hasPositions[this.anchorLength(side)] = !0;
                }, this);
                if (!hasPositions.width) {
                    margins.left > 0 && pvBorderPanel.left(margins.left);
                    margins.right > 0 && pvBorderPanel.right(margins.right);
                }
                if (!hasPositions.height) {
                    margins.top > 0 && pvBorderPanel.top(margins.top);
                    margins.bottom > 0 && pvBorderPanel.bottom(margins.bottom);
                }
                (paddings.width > 0 || paddings.height > 0) && (this.pvPanel = pvBorderPanel.add(pv.Panel).width(width - paddings.width).height(height - paddings.height).left(paddings.left).top(paddings.top));
                pvBorderPanel.borderPanel = pvBorderPanel;
                pvBorderPanel.paddingPanel = this.pvPanel;
                this.pvPanel.paddingPanel = this.pvPanel;
                this.pvPanel.borderPanel = pvBorderPanel;
                if (pvc.debug >= 15) {
                    this.pvPanel.strokeStyle("lightgreen").lineWidth(1).strokeDasharray("- ");
                    this.pvPanel !== pvBorderPanel && pvBorderPanel.strokeStyle("blue").lineWidth(1).strokeDasharray(". ");
                }
                var extensionId = this._getExtensionId();
                new pvc.visual.Panel(this,null,{
                    panel: pvBorderPanel,
                    extensionId: extensionId
                });
                if (!invalidDataError)
                    try {
                        this._createCore(this._layoutInfo);
                    } catch (ex) {
                        if (!(ex instanceof InvalidDataException))
                            throw ex;
                        this._invalidDataError = invalidDataError = ex;
                    }
                if (invalidDataError) {
                    var pvMsg = pvBorderPanel.anchor("center").add(pv.Label).text(invalidDataError.message);
                    this.chart.extend(pvMsg, "invalidDataMessage");
                }
                if (this.isTopRoot) {
                    this.chart._multiChartOverflowClipped && this._addMultichartOverflowClipMarker();
                    this._initSelection();
                }
                this.applyExtensions();
                if (this.isRoot && pvc.debug > 5) {
                    var out = ["SCALES SUMMARY", pvc.logSeparator];
                    this.chart.axesList.forEach(function(axis) {
                        var scale = axis.scale;
                        if (scale) {
                            var d = scale.domain && scale.domain()
                              , r = scale.range && scale.range();
                            out.push(axis.id);
                            out.push("    domain: " + (d ? pvc.stringify(d) : "?"));
                            out.push("    range : " + (r ? pvc.stringify(r) : "?"));
                        }
                    }, this);
                    this._log(out.join("\n"));
                }
            }
        },
        _creating: function() {
            this._children && this._children.forEach(function(child) {
                child._creating();
            });
        },
        _createCore: function() {
            this._children && this._children.forEach(function(child) {
                child._create();
            });
        },
        render: function(ka) {
            if (!this.isTopRoot)
                return this.topRoot.render(ka);
            this._create(def.get(ka, "recreate", !1));
            if ((!this.isTopRoot || !this.chart._isMultiChartOverflowClip) && this.isVisible) {
                var pvPanel = this.pvRootPanel;
                if (this._invalidDataError)
                    pvPanel.render();
                else {
                    this._onRender();
                    var prevAnimating = (this.chart.options,
                    this._animating)
                      , animate = this.chart.animatable();
                    this._animating = animate && !def.get(ka, "bypassAnimation", !1) ? 1 : 0;
                    try {
                        pvPanel.render();
                        if (this._animating) {
                            this._animating = 2;
                            var me = this;
                            pvPanel.transition().duration(2e3).ease("cubic-in-out").start(function() {
                                if (prevAnimating)
                                    prevAnimating = 0;
                                else {
                                    me._animating = 0;
                                    me._onRenderEnd(!0);
                                }
                            });
                        } else
                            this._onRenderEnd(!1);
                    } finally {
                        this._animating = 0;
                    }
                }
            }
        },
        _onRender: function() {
            var renderCallback = this.chart.options.renderCallback;
            if (renderCallback)
                if (this.compatVersion() <= 1)
                    renderCallback.call(this.chart);
                else {
                    var context = this.context();
                    renderCallback.call(context, context.scene);
                }
        },
        _onRenderEnd: function(animated) {
            this._children && this._children.forEach(function(child) {
                child._onRenderEnd(animated);
            });
        },
        renderInteractive: function() {
            if (this.isVisible) {
                var pvMarks = this._getSelectableMarks();
                if (pvMarks && pvMarks.length)
                    pvMarks.forEach(function(pvMark) {
                        pvMark.render();
                    });
                else if (!this._children) {
                    this.pvPanel.render();
                    return;
                }
                this._children && this._children.forEach(function(child) {
                    child.renderInteractive();
                });
            }
        },
        _getSelectableMarks: function() {
            return this._rubberSelectableMarks;
        },
        animate: function(start, end) {
            return 1 === this.topRoot._animating ? start : end;
        },
        animatingStart: function() {
            return 1 === this.topRoot._animating;
        },
        animating: function() {
            return this.topRoot._animating > 0;
        },
        setPosition: function(position) {
            for (var side in position)
                if (def.hasOwn(pvc_Sides.namesSet, side)) {
                    var s = position[side];
                    if (null === s)
                        delete this.position[side];
                    else {
                        s = +s;
                        !isNaN(s) && isFinite(s) && (this.position[side] = s);
                    }
                }
        },
        createAnchoredSize: function(anchorLength, size) {
            return this.isAnchorTopOrBottom() ? new pvc_Size(size.width,Math.min(size.height, anchorLength)) : new pvc_Size(Math.min(size.width, anchorLength),size.height);
        },
        applyExtensions: function() {
            this._signs && this._signs.forEach(function(sign) {
                sign.applyExtensions();
            });
        },
        extend: function(mark, id, ka) {
            this.chart.extend(mark, this._makeExtensionAbsId(id), ka);
        },
        extendAbs: function(mark, absId, ka) {
            this.chart.extend(mark, absId, ka);
        },
        _extendSceneType: function(typeKey, type, names) {
            var typeExts = def.get(this._sceneTypeExtensions, typeKey);
            typeExts && pvc.extendType(type, typeExts, names);
        },
        _absBaseExtId: {
            abs: "base"
        },
        _absSmallBaseExtId: {
            abs: "smallBase"
        },
        _getExtensionId: function() {
            return this.isRoot ? this.chart.parent ? this._absSmallBaseExtId : this._absBaseExtId : void 0;
        },
        _getExtensionPrefix: function() {
            return this._extensionPrefix;
        },
        _makeExtensionAbsId: function(id) {
            return pvc.makeExtensionAbsId(id, this._getExtensionPrefix());
        },
        _getExtension: function(id, prop) {
            return this.chart._getExtension(this._makeExtensionAbsId(id), prop);
        },
        _getExtensionAbs: function(absId, prop) {
            return this.chart._getExtension(absId, prop);
        },
        _getConstantExtension: function(id, prop) {
            return this.chart._getConstantExtension(this._makeExtensionAbsId(id), prop);
        },
        getPvPanel: function(layer) {
            var mainPvPanel = this.pvPanel;
            if (!layer)
                return mainPvPanel;
            if (!this.parent)
                throw def.error.operationInvalid("Layers are not possible in a root panel.");
            if (!mainPvPanel)
                throw def.error.operationInvalid("Cannot access layer panels without having created the main panel.");
            var pvPanel = null;
            this._layers ? pvPanel = this._layers[layer] : this._layers = {};
            if (!pvPanel) {
                var pvParentPanel = this.parent.pvPanel;
                pvPanel = pvParentPanel.borderPanel.add(this.type).extend(mainPvPanel.borderPanel);
                var pvBorderPanel = pvPanel;
                mainPvPanel !== mainPvPanel.borderPanel && (pvPanel = pvBorderPanel.add(pv.Panel).extend(mainPvPanel));
                pvBorderPanel.borderPanel = pvBorderPanel;
                pvBorderPanel.paddingPanel = pvPanel;
                pvPanel.paddingPanel = pvPanel;
                pvPanel.borderPanel = pvBorderPanel;
                this.initLayerPanel(pvPanel, layer);
                this._layers[layer] = pvPanel;
            }
            return pvPanel;
        },
        initLayerPanel: function() {},
        _getV1DimName: function(v1Dim) {
            var dimNames = this._v1DimName || (this._v1DimNameCache = {})
              , dimName = dimNames[v1Dim];
            if (null == dimName) {
                var role = this.chart.visualRoles[this._v1DimRoleName[v1Dim]];
                dimName = role ? role.firstDimensionName() : "";
                dimNames[v1Dim] = dimName;
            }
            return dimName;
        },
        _getV1Datum: function(scene) {
            return scene.datum;
        },
        context: function() {
            var context = this._context;
            !context || context.isPinned ? context = this._context = new pvc.visual.Context(this) : visualContext_update.call(context);
            return context;
        },
        _isTooltipEnabled: function() {
            return !this.selectingByRubberband() && !this.animating();
        },
        _getTooltipFormatter: function(tipOptions) {
            var isV1Compat = this.compatVersion() <= 1
              , tooltipFormat = tipOptions.format;
            if (!tooltipFormat) {
                if (!isV1Compat)
                    return this._summaryTooltipFormatter;
                tooltipFormat = this.chart.options.v1StyleTooltipFormat;
                if (!tooltipFormat)
                    return;
            }
            return isV1Compat ? function(context) {
                return tooltipFormat.call(context.panel, context.getV1Series(), context.getV1Category(), context.getV1Value() || "", context.getV1Datum());
            }
            : function(context) {
                return tooltipFormat.call(context, context.scene);
            }
            ;
        },
        _summaryTooltipFormatter: function(context) {
            function addDim(escapedDimLabel, label) {
                tooltip.push("<b>" + escapedDimLabel + "</b>: " + (def.html.escape(label) || " - ") + "<br/>");
            }
            function calcPercent(atom, dimName) {
                var pct;
                pct = group ? group.dimensions(dimName).valuePercent(visibleKeyArgs) : data.dimensions(dimName).percent(atom.value, visibleKeyArgs);
                return percentValueFormat(pct);
            }
            var scene = context.scene;
            if (!scene.datum)
                return "";
            var group = scene.group
              , isMultiDatumGroup = group && group.count() > 1
              , firstDatum = scene.datum;
            if (!isMultiDatumGroup && (!firstDatum || firstDatum.isNull))
                return "";
            var data = scene.data()
              , visibleKeyArgs = {
                visible: !0
            }
              , tooltip = [];
            firstDatum.isInterpolated ? tooltip.push("<i>Interpolation</i>: " + def.html.escape(firstDatum.interpolation) + "<br/>") : firstDatum.isTrend && tooltip.push("<i>" + def.html.escape(firstDatum.trend.label) + "</i><br/>");
            var complexType = data.type
              , playingPercentMap = context.panel.stacked === !1 ? null : complexType.getPlayingPercentVisualRoleDimensionMap()
              , percentValueFormat = playingPercentMap ? context.chart.options.percentValueFormat : null
              , commonAtoms = isMultiDatumGroup ? group.atoms : scene.datum.atoms
              , commonAtomsKeys = complexType.sortDimensionNames(def.keys(commonAtoms))
              , anyCommonAtom = !1;
            commonAtomsKeys.forEach(function(dimName) {
                var atom = commonAtoms[dimName]
                  , dimType = atom.dimension.type;
                if (!(dimType.isHidden || isMultiDatumGroup && null == atom.value)) {
                    anyCommonAtom = !0;
                    var valueLabel = atom.label;
                    playingPercentMap && playingPercentMap.has(dimName) && (valueLabel += " (" + calcPercent(atom, dimName) + ")");
                    addDim(def.html.escape(atom.dimension.type.label), valueLabel);
                }
            });
            if (isMultiDatumGroup) {
                anyCommonAtom && tooltip.push("<hr />");
                tooltip.push("<b>#</b>: " + group._datums.length + "<br/>");
                complexType.sortDimensionNames(group.freeDimensionsNames()).forEach(function(dimName) {
                    var dim = group.dimensions(dimName);
                    if (!dim.type.isHidden) {
                        var valueLabel, dimLabel = def.html.escape(dim.type.label);
                        if (dim.type.valueType === Number) {
                            valueLabel = dim.format(dim.value(visibleKeyArgs));
                            playingPercentMap && playingPercentMap.has(dimName) && (valueLabel += " (" + calcPercent(null, dimName) + ")");
                            dimLabel = "&sum; " + dimLabel;
                        } else
                            valueLabel = dim.atoms(visibleKeyArgs).map(function(atom) {
                                return atom.label || "- ";
                            }).join(", ");
                        addDim(dimLabel, valueLabel);
                    }
                });
            }
            return '<div style="text-align: left;">' + tooltip.join("\n") + "</div>";
        },
        _onClick: function(context) {
            var handler = this.clickAction;
            handler && (this.compatVersion() <= 1 ? this._onV1Click(context, handler) : handler.call(context, context.scene));
        },
        _onDoubleClick: function(context) {
            var handler = this.doubleClickAction;
            handler && (this.compatVersion() <= 1 ? this._onV1DoubleClick(context, handler) : handler.call(context, context.scene));
        },
        _onV1Click: function(context, handler) {
            handler.call(context.pvMark, context.getV1Series(), context.getV1Category(), context.getV1Value(), context.event, context.getV1Datum());
        },
        _onV1DoubleClick: function(context, handler) {
            handler.call(context.pvMark, context.getV1Series(), context.getV1Category(), context.getV1Value(), context.event, context.getV1Datum());
        },
        _addMultichartOverflowClipMarker: function() {
            function getRadius(mark) {
                var r = mark.shapeRadius();
                if (null == r) {
                    var s = mark.shapeSize();
                    null != s && (r = Math.sqrt(s));
                }
                return r || dr;
            }
            var m = 10
              , dr = 5
              , pvDot = new pvc.visual.Dot(this,this.pvPanel,{
                noSelect: !0,
                noHover: !0,
                noClick: !0,
                noDoubleClick: !0,
                noTooltip: !1,
                freePosition: !0,
                extensionId: "multiChartOverflowMarker"
            }).lock("data").pvMark.shape("triangle").shapeRadius(dr).top(null).left(null).bottom(function() {
                return getRadius(this) + m;
            }).right(function() {
                return getRadius(this) + m;
            }).shapeAngle(0).lineWidth(1.5).strokeStyle("red").fillStyle("rgba(255, 0, 0, 0.2)");
            def.fun.is(pvDot.tooltip) && pvDot.tooltip("Some charts did not fit the available space.");
        },
        selectingByRubberband: function() {
            return this.topRoot._selectingByRubberband;
        },
        _initSelection: function() {
            var me = this
              , chart = me.chart;
            if (me.interactive()) {
                var clickClearsSelection = me.unselectable()
                  , useRubberband = me.selectableByRubberband();
                if (useRubberband || clickClearsSelection) {
                    var data = me.data
                      , pvParentPanel = me.pvRootPanel || me.pvPanel.paddingPanel;
                    me._getExtensionAbs("base", "fillStyle") || pvParentPanel.fillStyle(pvc.invisibleFill);
                    pvParentPanel.lock("events", "all");
                    if (useRubberband) {
                        var dMin2 = 4;
                        me._selectingByRubberband = !1;
                        var toScreen, rb, selectionEndedDate, selectBar = this.selectBar = new pvc.visual.Bar(me,pvParentPanel,{
                            extensionId: "rubberBand",
                            normalStroke: !0,
                            noHover: !0,
                            noSelect: !0,
                            noClick: !0,
                            noDoubleClick: !0,
                            noTooltip: !0
                        }).override("defaultStrokeWidth", def.fun.constant(1.5)).override("defaultColor", function(scene, type) {
                            return "stroke" === type ? "#86fe00" : "rgba(203, 239, 163, 0.6)";
                        }).override("interactiveColor", function(scene, color) {
                            return color;
                        }).pvMark.lock("visible", function() {
                            return !!rb;
                        }).lock("left", function() {
                            return rb.x;
                        }).lock("right").lock("top", function() {
                            return rb.y;
                        }).lock("bottom").lock("width", function() {
                            return rb.dx;
                        }).lock("height", function() {
                            return rb.dy;
                        }).lock("cursor").lock("events", "none");
                        pvParentPanel.intercept("data", function() {
                            var scenes = this.delegate();
                            scenes && scenes.forEach(function(scene) {
                                null == scene.x && (scene.x = scene.y = scene.dx = scene.dy = 0);
                            });
                            return scenes;
                        }).event("mousedown", pv.Behavior.select().autoRender(!1)).event("select", function(scene) {
                            if (rb)
                                rb = new pv.Shape.Rect(scene.x,scene.y,scene.dx,scene.dy);
                            else {
                                if (me.animating())
                                    return;
                                if (scene.dx * scene.dx + scene.dy * scene.dy <= dMin2)
                                    return;
                                rb = new pv.Shape.Rect(scene.x,scene.y,scene.dx,scene.dy);
                                me._selectingByRubberband = !0;
                                toScreen || (toScreen = pvParentPanel.toScreenTransform());
                                me.rubberBand = rb.apply(toScreen);
                            }
                            selectBar.render();
                        }).event("selectend", function() {
                            if (rb) {
                                var ev = arguments[arguments.length - 1];
                                toScreen || (toScreen = pvParentPanel.toScreenTransform());
                                var rbs = rb.apply(toScreen);
                                rb = null;
                                me._selectingByRubberband = !1;
                                selectBar.render();
                                try {
                                    me._processRubberBand(rbs, ev);
                                } finally {
                                    selectionEndedDate = new Date();
                                }
                            }
                        });
                        clickClearsSelection && pvParentPanel.event("click", function() {
                            if (selectionEndedDate) {
                                var timeSpan = new Date() - selectionEndedDate;
                                if (300 > timeSpan) {
                                    selectionEndedDate = null;
                                    return;
                                }
                            }
                            data.clearSelected() && chart.updateSelections();
                        });
                    } else
                        clickClearsSelection && pvParentPanel.event("click", function() {
                            data.clearSelected() && chart.updateSelections();
                        });
                }
            }
        },
        _processRubberBand: function(rb, ev, ka) {
            this.rubberBand = rb;
            try {
                this._onRubberBandSelectionEnd(ev, ka);
            } finally {
                this.rubberBand = null;
            }
        },
        _onRubberBandSelectionEnd: function(ev, ka) {
            pvc.debug >= 20 && this._log("rubberBand " + pvc.stringify(this.rubberBand));
            ka = Object.create(ka || {});
            ka.toggle = !1;
            var datums = this._getDatumsOnRubberBand(ev, ka);
            if (datums) {
                var chart = this.chart;
                chart._updatingSelections(function() {
                    var clearBefore = !ev.ctrlKey && chart.options.ctrlSelectMode;
                    if (clearBefore) {
                        chart.data.owner.clearSelected();
                        pvc.data.Data.setSelected(datums, !0);
                    } else
                        ka.toggle ? pvc.data.Data.toggleSelected(datums) : pvc.data.Data.setSelected(datums, !0);
                });
            }
        },
        _getDatumsOnRubberBand: function(ev, ka) {
            var datumMap = new def.Map();
            this._getDatumsOnRect(datumMap, this.rubberBand, ka);
            var datums = datumMap.values();
            if (datums.length) {
                datums = this.chart._onUserSelection(datums);
                datums && !datums.length && (datums = null);
            }
            return datums;
        },
        _getDatumsOnRect: function(datumMap, rect, ka) {
            this._getOwnDatumsOnRect(datumMap, rect, ka);
            var cs = this._children;
            cs && cs.forEach(function(c) {
                c._getDatumsOnRect(datumMap, rect, ka);
            });
        },
        _getOwnDatumsOnRect: function(datumMap, rect, ka) {
            var me = this;
            if (!me.isVisible)
                return !1;
            var pvMarks = me._getSelectableMarks();
            if (!pvMarks || !pvMarks.length)
                return !1;
            var inCount = datumMap.count
              , selectionMode = def.get(ka, "markSelectionMode")
              , processDatum = function(datum) {
                datum.isNull || datumMap.set(datum.id, datum);
            }
              , processScene = function(scene) {
                scene.selectableByRubberband() && scene.datums().each(processDatum);
            }
              , processMark = function(pvMark) {
                pvMark.eachSceneWithDataOnRect(rect, processScene, null, selectionMode);
            };
            pvMarks.forEach(processMark);
            return inCount < datumMap.count;
        },
        isAnchorTopOrBottom: function(anchor) {
            anchor || (anchor = this.anchor);
            return "top" === anchor || "bottom" === anchor;
        },
        isOrientationVertical: function(o) {
            return this.chart.isOrientationVertical(o);
        },
        isOrientationHorizontal: function(o) {
            return this.chart.isOrientationHorizontal(o);
        }
    }).addStatic({
        relativeAnchor: {
            top: "left",
            bottom: "left",
            left: "bottom",
            right: "bottom"
        },
        leftBottomAnchor: {
            top: "bottom",
            bottom: "bottom",
            left: "left",
            right: "left"
        },
        leftTopAnchor: {
            top: "top",
            bottom: "top",
            left: "left",
            right: "left"
        },
        horizontalAlign: {
            top: "right",
            bottom: "left",
            middle: "center",
            right: "right",
            left: "left",
            center: "center"
        },
        verticalAlign: {
            top: "top",
            bottom: "bottom",
            middle: "middle",
            right: "bottom",
            left: "top",
            center: "middle"
        },
        verticalAlign2: {
            top: "top",
            bottom: "bottom",
            middle: "middle",
            right: "top",
            left: "bottom",
            center: "middle"
        },
        relativeAnchorMirror: {
            top: "right",
            bottom: "right",
            left: "top",
            right: "top"
        },
        oppositeAnchor: {
            top: "bottom",
            bottom: "top",
            left: "right",
            right: "left"
        },
        parallelLength: {
            top: "width",
            bottom: "width",
            right: "height",
            left: "height"
        },
        orthogonalLength: {
            top: "height",
            bottom: "height",
            right: "width",
            left: "width"
        },
        oppositeLength: {
            width: "height",
            height: "width"
        }
    });
    def.scope(function() {
        var BasePanel = pvc.BasePanel
          , methods = {}
          , anchorDicts = {
            anchorOrtho: "relativeAnchor",
            anchorOrthoMirror: "relativeAnchorMirror",
            anchorOpposite: "oppositeAnchor",
            anchorLength: "parallelLength",
            anchorOrthoLength: "orthogonalLength"
        };
        def.eachOwn(anchorDicts, function(d, am) {
            var dict = BasePanel[d];
            methods[am] = function(a) {
                return dict[a || this.anchor];
            }
            ;
        });
        BasePanel.add(methods);
    });
    def.type("pvc.PlotPanel", pvc.BasePanel).init(function(chart, parent, plot, options) {
        this.base(chart, parent, options);
        this.plot = plot;
        this._extensionPrefix = plot.extensionPrefixes;
        this.dataPartValue = plot.option("DataPart");
        this.axes.color = chart._getAxis("color", (plot.option("ColorAxis") || 0) - 1);
        this.orientation = plot.option("Orientation");
        this.valuesVisible = plot.option("ValuesVisible");
        this.valuesAnchor = plot.option("ValuesAnchor");
        this.valuesMask = plot.option("ValuesMask");
        this.valuesFont = plot.option("ValuesFont");
        this.valuesOverflow = plot.option("ValuesOverflow");
        this.valuesOptimizeLegibility = plot.option("ValuesOptimizeLegibility");
        var roles = this.visualRoles = Object.create(chart.visualRoles)
          , colorRoleName = plot.option("ColorRole");
        roles.color = colorRoleName ? chart.visualRole(colorRoleName) : null;
        this.chart._addPlotPanel(this);
    }).add({
        anchor: "fill",
        visualRoles: null,
        _getExtensionId: function() {
            var extensionIds = ["chart", "plot"];
            this.plotName && extensionIds.push(this.plotName);
            return extensionIds;
        },
        defaultLegendGroupScene: function() {
            var colorAxis = this.axes.color;
            return colorAxis && colorAxis.option("LegendVisible") && colorAxis.isBound() ? def.query(colorAxis.dataCells).where(function(dataCell) {
                return dataCell.plot === this.plot;
            }, this).select(function(dataCell) {
                return dataCell.legendGroupScene();
            }).first(def.notNully) : void 0;
        },
        isOrientationVertical: function() {
            return this.orientation === pvc.orientation.vertical;
        },
        isOrientationHorizontal: function() {
            return this.orientation === pvc.orientation.horizontal;
        }
    });
    def.type("pvc.MultiChartPanel", pvc.BasePanel).add({
        anchor: "fill",
        createSmallCharts: function() {
            var count, chart = this.chart, multiInfo = chart._multiInfo;
            if (multiInfo && (count = multiInfo.count)) {
                var coordScopesByType, addChartToScope, indexChartByScope, coordRootAxesByScopeType = this._getCoordinatedRootAxesByScopeType();
                if (coordRootAxesByScopeType) {
                    coordScopesByType = {};
                    addChartToScope = function(childChart, scopeType, scopeIndex) {
                        var scopes = def.array.lazy(coordScopesByType, scopeType);
                        def.array.lazy(scopes, scopeIndex).push(childChart);
                    }
                    ;
                    indexChartByScope = function(childChart) {
                        coordRootAxesByScopeType.row && addChartToScope(childChart, "row", childChart.smallRowIndex);
                        coordRootAxesByScopeType.column && addChartToScope(childChart, "column", childChart.smallColIndex);
                        coordRootAxesByScopeType.global && addChartToScope(childChart, "global", 0);
                    }
                    ;
                }
                for (var childOptionsBase = this._buildSmallChartsBaseOptions(), ChildClass = chart.constructor, smallDatas = multiInfo.smallDatas, colCount = multiInfo.colCount, index = 0; count > index; index++) {
                    var smallData = smallDatas[index]
                      , colIndex = index % colCount
                      , rowIndex = Math.floor(index / colCount)
                      , childOptions = def.set(Object.create(childOptionsBase), "smallColIndex", colIndex, "smallRowIndex", rowIndex, "title", smallData.absLabel, "data", smallData)
                      , smallChart = new ChildClass(childOptions);
                    if (coordRootAxesByScopeType) {
                        smallChart._createPhase1();
                        indexChartByScope(smallChart);
                    } else
                        smallChart._create();
                }
                if (coordRootAxesByScopeType) {
                    var me = this;
                    def.eachOwn(coordRootAxesByScopeType, function(axes, scopeType) {
                        axes.forEach(function(axis) {
                            coordScopesByType[scopeType].forEach(function(scopeCharts) {
                                me._coordinateScopeAxes(axis.id, scopeCharts);
                            });
                        });
                    });
                    chart.children.forEach(function(childChart) {
                        childChart._createPhase2();
                    });
                }
                multiInfo.coordScopesByType = coordScopesByType;
            }
        },
        _getCoordinatedRootAxesByScopeType: function() {
            var hasCoordination = !1
              , rootAxesByScopeType = def.query(this.chart.axesList).multipleIndex(function(axis) {
                if ("discrete" !== axis.scaleType && axis.option.isDefined("DomainScope")) {
                    var scopeType = axis.option("DomainScope");
                    if ("cell" !== scopeType) {
                        hasCoordination = !0;
                        return scopeType;
                    }
                }
            });
            return hasCoordination ? rootAxesByScopeType : null;
        },
        _coordinateScopeAxes: function(axisId, scopeCharts) {
            var unionExtent = def.query(scopeCharts).select(function(childChart) {
                var scale = childChart.axes[axisId].scale;
                if (!scale.isNull) {
                    var domain = scale.domain();
                    return {
                        min: domain[0],
                        max: domain[1]
                    };
                }
            }).reduce(pvc.unionExtents, null);
            unionExtent && scopeCharts.forEach(function(childChart) {
                var axis = childChart.axes[axisId]
                  , scale = axis.scale;
                if (!scale.isNull) {
                    scale.domain(unionExtent.min, unionExtent.max);
                    axis.setScale(scale);
                }
            });
        },
        _buildSmallChartsBaseOptions: function() {
            var chart = this.chart
              , options = chart.options;
            return def.set(Object.create(options), "parent", chart, "legend", !1, "titleFont", options.smallTitleFont, "titlePosition", options.smallTitlePosition, "titleAlign", options.smallTitleAlign, "titleAlignTo", options.smallTitleAlignTo, "titleOffset", options.smallTitleOffset, "titleKeepInBounds", options.smallTitleKeepInBounds, "titleMargins", options.smallTitleMargins, "titlePaddings", options.smallTitlePaddings, "titleSize", options.smallTitleSize, "titleSizeMax", options.smallTitleSizeMax);
        },
        _calcLayout: function(layoutInfo) {
            var chart = this.chart
              , multiInfo = chart._multiInfo;
            if (multiInfo) {
                var multiOption = chart.multiOptions.option
                  , smallOption = chart.smallOptions.option
                  , clientSize = layoutInfo.clientSize
                  , prevLayoutInfo = layoutInfo.previous
                  , initialClientWidth = prevLayoutInfo ? prevLayoutInfo.initialClientWidth : clientSize.width
                  , initialClientHeight = prevLayoutInfo ? prevLayoutInfo.initialClientHeight : clientSize.height
                  , smallWidth = smallOption("Width");
                null != smallWidth && (smallWidth = pvc_PercentValue.resolve(smallWidth, initialClientWidth));
                var smallHeight = smallOption("Height");
                null != smallHeight && (smallHeight = pvc_PercentValue.resolve(smallHeight, initialClientHeight));
                var ar = smallOption("AspectRatio")
                  , rowCount = multiInfo.rowCount
                  , colCount = multiInfo.colCount;
                if (null == smallWidth)
                    if (isFinite(multiInfo.colsMax))
                        smallWidth = clientSize.width / colCount;
                    else {
                        null == smallHeight && (smallHeight = initialClientHeight);
                        smallWidth = ar * smallHeight;
                    }
                null == smallHeight && (smallHeight = 1 === rowCount && multiOption("SingleRowFillsHeight") || 1 === colCount && multiOption("SingleColFillsHeight") ? initialClientHeight : smallWidth / ar);
                var finalClientWidth = smallWidth * colCount
                  , finalClientHeight = smallHeight * rowCount;
                if (!chart._isMultiChartOverflowClipRetry) {
                    chart._isMultiChartOverflowClip = !1;
                    switch (multiOption("Overflow")) {
                    case "fit":
                        if (finalClientWidth > initialClientWidth) {
                            finalClientWidth = initialClientWidth;
                            smallWidth = finalClientWidth / colCount;
                        }
                        if (finalClientHeight > initialClientHeight) {
                            finalClientHeight = initialClientHeight;
                            smallHeight = finalClientHeight / rowCount;
                        }
                        break;

                    case "clip":
                        var colsMax = colCount
                          , rowsMax = rowCount
                          , clipW = finalClientWidth > initialClientWidth;
                        clipW && (colsMax = Math.floor(initialClientWidth / smallWidth));
                        var clipH = finalClientHeight > initialClientHeight;
                        clipH && (rowsMax = Math.floor(initialClientHeight / smallHeight));
                        if (clipH || clipW) {
                            chart._isMultiChartOverflowClip = !0;
                            chart._clippedMultiChartRowsMax = rowsMax;
                            chart._clippedMultiChartColsMax = colsMax;
                        }
                    }
                }
                def.set(layoutInfo, "initialClientWidth", initialClientWidth, "initialClientHeight", initialClientHeight, "width", smallWidth, "height", smallHeight);
                return {
                    width: finalClientWidth,
                    height: Math.max(clientSize.height, finalClientHeight)
                };
            }
        },
        _getExtensionId: function() {
            return "content";
        },
        _createCore: function(li) {
            var chart = this.chart;
            !chart._isMultiChartOverflowClip || def.assert("Overflow&clip condition should be resolved.");
            var mi = chart._multiInfo;
            if (mi) {
                var smallOption = chart.smallOptions.option
                  , smallMargins = smallOption("Margins")
                  , smallPaddings = smallOption("Paddings");
                chart.children.forEach(function(childChart) {
                    childChart._setSmallLayout({
                        left: childChart.smallColIndex * li.width,
                        top: childChart.smallRowIndex * li.height,
                        width: li.width,
                        height: li.height,
                        margins: this._buildSmallMargins(childChart, smallMargins, mi),
                        paddings: smallPaddings
                    });
                }, this);
                var coordScopesByType = mi.coordScopesByType;
                coordScopesByType && chart._coordinateSmallChartsLayout(coordScopesByType);
                this.base(li);
            }
        },
        _buildSmallMargins: function(childChart, smallMargins, mi) {
            var C = mi.colCount - 1
              , R = mi.rowCount - 1
              , c = childChart.smallColIndex
              , r = childChart.smallRowIndex
              , margins = {};
            c > 0 && (margins.left = smallMargins.left);
            C > c && (margins.right = smallMargins.right);
            r > 0 && (margins.top = smallMargins.top);
            R > r && (margins.bottom = smallMargins.bottom);
            return margins;
        }
    });
    def.type("pvc.TitlePanelAbstract", pvc.BasePanel).init(function(chart, parent, options) {
        options || (options = {});
        var anchor = options.anchor || this.anchor;
        if (null == options.size) {
            var size = options.titleSize;
            null != size && (options.size = new pvc_Size().setSize(size, {
                singleProp: this.anchorOrthoLength(anchor)
            }));
        }
        if (null == options.sizeMax) {
            var sizeMax = options.titleSizeMax;
            null != sizeMax && (options.sizeMax = new pvc_Size().setSize(sizeMax, {
                singleProp: this.anchorOrthoLength(anchor)
            }));
        }
        null == options.paddings && (options.paddings = this.defaultPaddings);
        this.base(chart, parent, options);
        if (void 0 === options.font) {
            var extensionFont = this._getExtension("label", "font");
            "string" == typeof extensionFont && (this.font = extensionFont);
        }
    }).add({
        pvLabel: null,
        anchor: "top",
        title: null,
        titleSize: void 0,
        font: "14px sans-serif",
        defaultPaddings: 2,
        _extensionPrefix: "title",
        _calcLayout: function(layoutInfo) {
            var requestSize = new pvc_Size()
              , a = this.anchor
              , a_width = this.anchorLength(a)
              , a_height = this.anchorOrthoLength(a)
              , textWidth = pv.Text.measureWidth(this.title, this.font) + 2
              , clientWidth = layoutInfo.clientSize[a_width]
              , desiredWidth = layoutInfo.desiredClientSize[a_width];
            null == desiredWidth ? desiredWidth = textWidth > clientWidth ? clientWidth : textWidth : desiredWidth > clientWidth && (desiredWidth = clientWidth);
            var lines;
            lines = textWidth > desiredWidth ? pvc.text.justify(this.title, desiredWidth, this.font) : this.title ? [this.title] : [];
            var lineHeight = pv.Text.fontHeight(this.font)
              , realHeight = lines.length * lineHeight
              , availableHeight = layoutInfo.clientSize[a_height]
              , desiredHeight = layoutInfo.desiredClientSize[a_height];
            null == desiredHeight ? desiredHeight = realHeight : desiredHeight > availableHeight && (desiredHeight = availableHeight);
            if (realHeight > desiredHeight) {
                var maxLineCount = Math.max(1, Math.floor(desiredHeight / lineHeight));
                if (lines.length > maxLineCount) {
                    var firstCroppedLine = lines[maxLineCount];
                    lines.length = maxLineCount;
                    realHeight = desiredHeight = maxLineCount * lineHeight;
                    var lastLine = lines[maxLineCount - 1] + " " + firstCroppedLine;
                    lines[maxLineCount - 1] = pvc.text.trimToWidthB(desiredWidth, lastLine, this.font, "..");
                }
            }
            layoutInfo.lines = lines;
            layoutInfo.topOffset = (desiredHeight - realHeight) / 2;
            layoutInfo.lineSize = {
                width: desiredWidth,
                height: lineHeight
            };
            layoutInfo.a_width = a_width;
            layoutInfo.a_height = a_height;
            requestSize[a_width] = desiredWidth;
            requestSize[a_height] = desiredHeight;
            return requestSize;
        },
        _createCore: function(layoutInfo) {
            var wrapper, rootScene = this._buildScene(layoutInfo), rotationByAnchor = {
                top: 0,
                right: Math.PI / 2,
                bottom: 0,
                left: -Math.PI / 2
            }, textAlign = pvc.BasePanel.horizontalAlign[this.align], textAnchor = pvc.BasePanel.leftTopAnchor[this.anchor];
            this.compatVersion() <= 1 && (wrapper = function(v1f) {
                return function() {
                    return v1f.call(this);
                }
                ;
            }
            );
            this.pvLabel = new pvc.visual.Label(this,this.pvPanel,{
                extensionId: "label",
                wrapper: wrapper
            }).lock("data", rootScene.lineScenes).pvMark[textAnchor](function(lineScene) {
                return layoutInfo.topOffset + lineScene.vars.size.height / 2 + this.index * lineScene.vars.size.height;
            }).textAlign(textAlign)[this.anchorOrtho(textAnchor)](function(lineScene) {
                switch (this.textAlign()) {
                case "center":
                    return lineScene.vars.size.width / 2;

                case "left":
                    return 0;

                case "right":
                    return lineScene.vars.size.width;
                }
            }).text(function(lineScene) {
                return lineScene.vars.textLines[this.index];
            }).font(this.font).textBaseline("middle").textAngle(rotationByAnchor[this.anchor]);
        },
        _buildScene: function(layoutInfo) {
            var rootScene = new pvc.visual.Scene(null,{
                panel: this,
                source: this.chart.data
            })
              , textLines = layoutInfo.lines;
            rootScene.vars.size = layoutInfo.lineSize;
            rootScene.vars.textLines = textLines;
            rootScene.lineScenes = def.array.create(textLines.length, rootScene);
            return rootScene;
        },
        _getExtensionId: def.fun.constant("")
    });
    def.type("pvc.TitlePanel", pvc.TitlePanelAbstract).init(function(chart, parent, options) {
        options || (options = {});
        var isV1Compat = chart.compatVersion() <= 1;
        if (isV1Compat) {
            var size = options.titleSize;
            null == size && (options.titleSize = 25);
        }
        this._extensionPrefix = chart.parent ? "smallTitle" : "title";
        this.base(chart, parent, options);
    }).add({
        font: "15px sans-serif",
        defaultPaddings: 4
    });
    def.type("pvc.LegendPanel", pvc.BasePanel).init(function(chart, parent, options) {
        this.base(chart, parent, options);
        if (void 0 === options.font) {
            var extFont = this._getConstantExtension("label", "font");
            extFont && (this.font = extFont);
        }
        var I = pvc.visual.Interactive;
        this._ibits & I.Interactive && (this._ibits |= I.Clickable);
    }).add({
        pvRule: null,
        pvDot: null,
        pvLabel: null,
        anchor: "bottom",
        pvLegendPanel: null,
        textMargin: 6,
        itemPadding: 2.5,
        itemSize: null,
        markerSize: 15,
        font: "15px sans-serif",
        _calcLayout: function(layoutInfo) {
            return this._getBulletRootScene().layout(layoutInfo);
        },
        _createCore: function(layoutInfo) {
            var clientSize = layoutInfo.clientSize
              , rootScene = this._getBulletRootScene()
              , itemPadding = rootScene.vars.itemPadding
              , contentSize = rootScene.vars.contentSize
              , isHorizontal = this.isAnchorTopOrBottom()
              , a_top = isHorizontal ? "top" : "left"
              , a_bottom = this.anchorOpposite(a_top)
              , a_width = this.anchorLength(a_top)
              , a_height = this.anchorOrthoLength(a_top)
              , a_center = isHorizontal ? "center" : "middle"
              , a_left = isHorizontal ? "left" : "top"
              , a_right = this.anchorOpposite(a_left)
              , leftOffset = 0;
            switch (this.align) {
            case a_right:
                leftOffset = clientSize[a_width] - contentSize[a_width];
                break;

            case a_center:
                leftOffset = (clientSize[a_width] - contentSize[a_width]) / 2;
            }
            this.pvPanel.borderPanel.overflow("hidden");
            var wrapper, pvLegendSectionPanel = this.pvPanel.add(pv.Panel).data(rootScene.vars.sections)[a_left](leftOffset)[a_top](function() {
                var prevSection = this.sibling();
                return prevSection ? prevSection[a_top] + prevSection[a_height] + itemPadding[a_height] : 0;
            })[a_width](function(section) {
                return section.size[a_width];
            })[a_height](function(section) {
                return section.size[a_height];
            });
            this.compatVersion() <= 1 && (wrapper = function(v1f) {
                return function(itemScene) {
                    return v1f.call(this, itemScene.vars.value.rawValue);
                }
                ;
            }
            );
            var pvLegendItemPanel = this.pvLegendPanel = new pvc.visual.Panel(this,pvLegendSectionPanel,{
                extensionId: "panel",
                wrapper: wrapper,
                noSelect: !1,
                noHover: !0,
                noClick: !1,
                noClickSelect: !0
            }).pvMark.lock("data", function(section) {
                return section.items;
            })[a_right](null)[a_bottom](null)[a_left](function(clientScene) {
                var itemPadding = clientScene.vars.itemPadding
                  , prevItem = this.sibling();
                return prevItem ? prevItem[a_left] + prevItem[a_width] + itemPadding[a_width] : 0;
            })[a_top](isHorizontal ? function(itemScene) {
                var vars = itemScene.vars;
                return vars.section.size.height / 2 - vars.itemClientSize.height / 2;
            }
            : 0).height(function(itemScene) {
                return itemScene.vars.itemClientSize.height;
            }).width(isHorizontal ? function(itemScene) {
                return itemScene.vars.itemClientSize.width;
            }
            : function() {
                return this.parent.width();
            }
            ).def("hidden", "false").fillStyle(function() {
                return "true" == this.hidden() ? "rgba(200,200,200,1)" : "rgba(200,200,200,0.0001)";
            })
              , pvLegendMarkerPanel = new pvc.visual.Panel(this,pvLegendItemPanel,{
                extensionId: "markerPanel"
            }).pvMark.left(0).top(0).right(null).bottom(null).width(function(itemScene) {
                return itemScene.vars.markerSize;
            }).height(function(itemScene) {
                return itemScene.vars.itemClientSize.height;
            });
            if (pvc.debug >= 20) {
                pvLegendSectionPanel.strokeStyle("red").lineWidth(.5).strokeDasharray(".");
                pvLegendItemPanel.strokeStyle("green").lineWidth(.5).strokeDasharray(".");
                pvLegendMarkerPanel.strokeStyle("blue").lineWidth(.5).strokeDasharray(".");
            }
            rootScene.childNodes.forEach(function(groupScene) {
                var pvGroupPanel = new pvc.visual.Panel(this,pvLegendMarkerPanel).pvMark.visible(function(itemScene) {
                    return itemScene.parent === groupScene;
                });
                groupScene.renderer().create(this, pvGroupPanel, groupScene.extensionPrefix, wrapper);
            }, this);
            this.pvLabel = new pvc.visual.Label(this,pvLegendMarkerPanel.anchor("right"),{
                extensionId: "label",
                noTooltip: !1,
                noClick: !1,
                wrapper: wrapper
            }).intercept("textStyle", function(itemScene) {
                //var baseTextStyle = this.delegateExtension() || "black";
                var baseTextStyle = "black";
                return itemScene.isOn() ? baseTextStyle : pvc.toGrayScale(baseTextStyle, null, void 0, 150);
            }).pvMark.textAlign("left").text(function(itemScene) {
                var text = itemScene.labelText()
                  , vars = itemScene.vars;
                vars.textSize.width > vars.labelWidthMax && (text = pvc.text.trimToWidthB(vars.labelWidthMax, text, vars.font, "..", !1));
                return text;
            }).textMargin(function(itemScene) {
                return itemScene.vars.textMargin;
            }).font(function(itemScene) {
                return itemScene.vars.font;
            }).textDecoration(function(itemScene) {
                return itemScene.isOn() ? "" : "line-through";
            });
            pvc.debug >= 16 && pvLegendMarkerPanel.anchor("right").add(pv.Panel)[this.anchorLength()](0)[this.anchorOrthoLength()](0).fillStyle(null).strokeStyle(null).lineWidth(0).add(pv.Line).data(function(scene) {
                var vars = scene.vars
                  , labelBBox = pvc.text.getLabelBBox(Math.min(vars.labelWidthMax, vars.textSize.width), 2 * vars.textSize.height / 3, "left", "middle", 0, vars.textMargin)
                  , corners = labelBBox.source.points();
                corners.length > 1 && (corners = corners.concat(corners[0]));
                return corners;
            }).left(function(p) {
                return p.x;
            }).top(function(p) {
                return p.y;
            }).strokeStyle("red").lineWidth(.5).strokeDasharray("-");
        },
        _onClick: function(context) {
            var scene = context.scene;
            def.fun.is(scene.execute) && scene.executable() && scene.execute();
        },
        _getExtensionPrefix: function() {
            return "legend";
        },
        _getExtensionId: function() {
            return "area";
        },
        _getSelectableMarks: function() {
            return [this.pvLegendPanel];
        },
        _getBulletRootScene: function() {
            var rootScene = this._rootScene;
            if (!rootScene) {
                rootScene = new pvc.visual.legend.BulletRootScene(null,{
                    panel: this,
                    source: this.chart.data,
                    horizontal: this.isAnchorTopOrBottom(),
                    font: this.font,
                    markerSize: this.markerSize,
                    textMargin: this.textMargin,
                    itemPadding: this.itemPadding,
                    itemSize: this.itemSize
                });
                this._rootScene = rootScene;
            }
            return rootScene;
        },
        _getTooltipFormatter: function(tipOptions) {
            tipOptions.isLazy = !1;
            return function(context) {
                var valueVar = context.scene.vars.value
                  , valueText = valueVar.absLabel || valueVar.label
                  , itemText = context.pvMark.text();
                return valueText !== itemText ? valueText : "";
            }
            ;
        }
    });
    def.type("pvc.CartesianAbstract", pvc.BaseChart).init(function(options) {
        this.axesPanels = {};
        this.base(options);
    }).add({
        _gridDockPanel: null,
        axesPanels: null,
        yAxisPanel: null,
        xAxisPanel: null,
        secondXAxisPanel: null,
        secondYAxisPanel: null,
        yScale: null,
        xScale: null,
        _getSeriesRoleSpec: function() {
            return {
                isRequired: !0,
                defaultDimension: "series*",
                autoCreateDimension: !0,
                requireIsDiscrete: !0
            };
        },
        _getColorRoleSpec: function() {
            return {
                isRequired: !0,
                defaultDimension: "color*",
                defaultSourceRole: "series",
                requireIsDiscrete: !0
            };
        },
        _addAxis: function(axis) {
            this.base(axis);
            switch (axis.type) {
            case "base":
            case "ortho":
                this.axes[axis.orientedId] = axis;
                axis.v1SecondOrientedId && (this.axes[axis.v1SecondOrientedId] = axis);
            }
            return this;
        },
        _setAxisScale: function(axis, chartLevel) {
            this.base(axis, chartLevel);
            var isOrtho = "ortho" === axis.type
              , isCart = isOrtho || "base" === axis.type;
            isCart && (isOrtho && 1 === axis.index ? this.secondScale = axis.scale : axis.index || (this[axis.orientation + "Scale"] = axis.scale));
        },
        _createContent: function(contentOptions) {
            this._createFocusWindow();
            this._gridDockPanel = new pvc.CartesianGridDockingPanel(this,this.basePanel,{
                margins: contentOptions.margins,
                paddings: contentOptions.paddings
            });
            ["base", "ortho"].forEach(function(type) {
                var typeAxes = this.axesByType[type];
                typeAxes && def.query(typeAxes).reverse().each(function(axis) {
                    this._createAxisPanel(axis);
                }, this);
            }, this);
            this._createPlotPanels(this._gridDockPanel, {
                clickAction: contentOptions.clickAction,
                doubleClickAction: contentOptions.doubleClickAction
            });
        },
        _createFocusWindow: function() {
            if (this.selectableByFocusWindow()) {
                var fwData, fw = this.focusWindow;
                fw && (fwData = fw._exportData());
                fw = this.focusWindow = new pvc.visual.CartesianFocusWindow(this);
                fwData && fw._importData(fwData);
                fw._initFromOptions();
            } else
                this.focusWindow && delete this.focusWindow;
        },
        _createAxisPanel: function(axis) {
            if (axis.option("Visible")) {
                var titlePanel, title = axis.option("Title");
                def.empty(title) || (titlePanel = new pvc.AxisTitlePanel(this,this._gridDockPanel,axis,{
                    title: title,
                    font: axis.option("TitleFont") || axis.option("Font"),
                    anchor: axis.option("Position"),
                    align: axis.option("TitleAlign"),
                    margins: axis.option("TitleMargins"),
                    paddings: axis.option("TitlePaddings"),
                    titleSize: axis.option("TitleSize"),
                    titleSizeMax: axis.option("TitleSizeMax")
                }));
                var panel = new pvc.AxisPanel(this,this._gridDockPanel,axis,{
                    anchor: axis.option("Position"),
                    size: axis.option("Size"),
                    sizeMax: axis.option("SizeMax"),
                    clickAction: axis.option("ClickAction"),
                    doubleClickAction: axis.option("DoubleClickAction"),
                    useCompositeAxis: axis.option("Composite"),
                    font: axis.option("Font"),
                    labelSpacingMin: axis.option("LabelSpacingMin"),
                    grid: axis.option("Grid"),
                    gridCrossesMargin: axis.option("GridCrossesMargin"),
                    ruleCrossesMargin: axis.option("RuleCrossesMargin"),
                    zeroLine: axis.option("ZeroLine"),
                    desiredTickCount: axis.option("DesiredTickCount"),
                    showTicks: axis.option("Ticks"),
                    showMinorTicks: axis.option("MinorTicks")
                });
                titlePanel && (panel.titlePanel = titlePanel);
                this.axesPanels[axis.id] = panel;
                this.axesPanels[axis.orientedId] = panel;
                axis.index <= 1 && axis.v1SecondOrientedId && (this[axis.v1SecondOrientedId + "AxisPanel"] = panel);
                return panel;
            }
        },
        _onLaidOut: function() {
            this.plotPanelList && this.plotPanelList[0] && ["base", "ortho"].forEach(function(type) {
                var axes = this.axesByType[type];
                axes && axes.forEach(this._setCartAxisScaleRange, this);
            }, this);
        },
        _setCartAxisScaleRange: function(axis) {
            var info = this.plotPanelList[0]._layoutInfo
              , size = info.clientSize
              , length = "x" === axis.orientation ? size.width : size.height;
            axis.setScaleRange(length);
            return axis.scale;
        },
        _getAxesRoundingPaddings: function() {
            function setSide(side, pct, locked) {
                var value = axesPaddings[side];
                if (null == value || pct > value) {
                    axesPaddings[side] = pct;
                    axesPaddings[side + "Locked"] = locked;
                } else
                    locked && (axesPaddings[side + "Locked"] = locked);
            }
            function processAxis(axis) {
                if (axis) {
                    var tickRoundPads = axis.getScaleRoundingPaddings();
                    if (tickRoundPads) {
                        var isX = "x" === axis.orientation;
                        setSide(isX ? "left" : "bottom", tickRoundPads.begin, tickRoundPads.beginLocked);
                        setSide(isX ? "right" : "top", tickRoundPads.end, tickRoundPads.endLocked);
                    }
                }
            }
            var axesPaddings = {}
              , axesByType = this.axesByType;
            ["base", "ortho"].forEach(function(type) {
                var typeAxes = axesByType[type];
                typeAxes && typeAxes.forEach(processAxis);
            });
            return axesPaddings;
        },
        markEventDefaults: {
            strokeStyle: "#5BCBF5",
            lineWidth: "0.5",
            textStyle: "#5BCBF5",
            verticalOffset: 10,
            verticalAnchor: "bottom",
            horizontalAnchor: "right",
            forceHorizontalAnchor: !1,
            horizontalAnchorSwapLimit: 80,
            font: "10px sans-serif"
        },
        markEvent: function(sourceValue, label, options) {
            {
                var me = this
                  , baseAxis = me.axes.base
                  , orthoAxis = me.axes.ortho
                  , baseRole = baseAxis.role
                  , baseScale = baseAxis.scale
                  , baseDim = me.data.owner.dimensions(baseRole.grouping.firstDimensionName());
                baseDim.type;
            }
            if (baseAxis.isDiscrete()) {
                me._warn("Can only mark events in charts with a continuous base scale.");
                return me;
            }
            var o = $.extend({}, me.markEventDefaults, options)
              , pseudoAtom = baseDim.read(sourceValue, label)
              , basePos = baseScale(pseudoAtom.value)
              , baseRange = baseScale.range()
              , baseEndPos = baseRange[1];
            if (basePos < baseRange[0] || basePos > baseEndPos) {
                this._warn("Cannot mark event because it is outside the base scale's domain.");
                return this;
            }
            var pvPanel = this.plotPanelList[0].pvPanel
              , h = orthoAxis.scale.range()[1]
              , ha = o.horizontalAnchor;
            if (!o.forceHorizontalAnchor) {
                var alignRight = "right" === ha
                  , availableSize = alignRight ? baseEndPos - basePos : basePos
                  , labelSize = pv.Text.measureWidth(pseudoAtom.label, o.font);
                labelSize > availableSize && (ha = alignRight ? "left" : "right");
            }
            var topPos = "top" === o.verticalAnchor ? o.verticalOffset : h - o.verticalOffset
              , line = pvPanel.add(pv.Line).data([0, h]).bottom(def.identity).left(basePos).lineWidth(o.lineWidth).strokeStyle(o.strokeStyle);
            line.anchor(ha).visible(function() {
                return !this.index;
            }).top(topPos).add(pv.Label).font(o.font).text(pseudoAtom.label).textStyle(o.textStyle);
            return me;
        },
        defaults: {
            panelSizeRatio: .9,
            timeSeries: !1,
            timeSeriesFormat: "%Y-%m-%d"
        }
    });
    def.type("pvc.GridDockingPanel", pvc.BasePanel).add({
        anchor: "fill",
        _calcLayout: function(layoutInfo) {
            function layoutCycle(remTimes, iteration) {
                useLog && me._group("LayoutCycle " + (isDisasterRecovery ? "- Disaster MODE" : "#" + (iteration + 1)));
                try {
                    var index, count, paddingsChanged, breakAndRepeat, canChange = layoutInfo.canChange !== !1 && !isDisasterRecovery && remTimes > 0, ownPaddingsChanged = !1;
                    index = 0;
                    count = sideChildren.length;
                    for (; count > index; ) {
                        useLog && me._group("SIDE Child #" + (index + 1));
                        try {
                            paddingsChanged = layoutChild2Side(sideChildren[index], canChange);
                            if (!isDisasterRecovery && paddingsChanged) {
                                breakAndRepeat = !1;
                                if (0 !== (paddingsChanged & OverflowPaddingsChanged)) {
                                    useLog && me._log("SIDE Child #" + (index + 1) + " changed overflow paddings");
                                    if (!ownPaddingsChanged) {
                                        ownPaddingsChanged = !0;
                                        layoutInfo.requestPaddings = layoutInfo.paddings;
                                    }
                                }
                                if (0 !== (paddingsChanged & NormalPaddingsChanged))
                                    if (remTimes > 0) {
                                        useLog && me._log("SIDE Child #" + (index + 1) + " changed normal paddings");
                                        breakAndRepeat = !0;
                                    } else
                                        pvc.debug >= 2 && me._warn("SIDE Child #" + (index + 1) + " changed paddings but no more iterations possible.");
                                if (0 !== (paddingsChanged & LoopDetected)) {
                                    isDisasterRecovery = !0;
                                    layoutCycle(0);
                                    return !1;
                                }
                                if (breakAndRepeat)
                                    return !0;
                            }
                        } finally {
                            useLog && me._groupEnd();
                        }
                        index++;
                    }
                    if (ownPaddingsChanged) {
                        useLog && me._log("Restarting due to overflowPaddings change");
                        return !1;
                    }
                    index = 0;
                    count = fillChildren.length;
                    for (; count > index; ) {
                        useLog && me._group("FILL Child #" + (index + 1));
                        try {
                            paddingsChanged = layoutChildFill(fillChildren[index], canChange);
                            if (!isDisasterRecovery && paddingsChanged) {
                                breakAndRepeat = !1;
                                if (0 !== (paddingsChanged & NormalPaddingsChanged))
                                    if (remTimes > 0) {
                                        pvc.debug >= 5 && me._log("FILL Child #" + (index + 1) + " increased paddings");
                                        breakAndRepeat = !0;
                                    } else
                                        pvc.debug >= 2 && me._warn("FILL Child #" + (index + 1) + " increased paddings but no more iterations possible.");
                                if (0 !== (paddingsChanged & LoopDetected)) {
                                    isDisasterRecovery = !0;
                                    layoutCycle(0);
                                    return !1;
                                }
                                if (breakAndRepeat)
                                    return !0;
                            }
                        } finally {
                            useLog && me._groupEnd();
                        }
                        index++;
                    }
                    return !1;
                } finally {
                    useLog && me._groupEnd();
                }
            }
            function doMaxTimes(maxTimes, fun) {
                for (var index = 0; maxTimes--; ) {
                    if (fun(maxTimes, index) === !1)
                        return !0;
                    index++;
                }
                return !1;
            }
            function initChild(child) {
                var a = child.anchor;
                if (a)
                    if ("fill" === a) {
                        fillChildren.push(child);
                        var childPaddings = child.paddings.resolve(childKeyArgs.referenceSize);
                        paddings = pvc_Sides.resolvedMax(paddings, childPaddings);
                    } else {
                        def.hasOwn(aoMap, a) || def.fail.operationInvalid("Unknown anchor value '{0}'", [a]);
                        sideChildren.push(child);
                    }
            }
            function layoutChild1Side(child, index) {
                useLog && me._group("SIDE Child #" + (index + 1));
                try {
                    var paddingsChanged = 0
                      , a = child.anchor;
                    childKeyArgs.paddings = filterAnchorPaddings(a, paddings);
                    child.layout(new pvc_Size(remSize), childKeyArgs);
                    if (child.isVisible) {
                        paddingsChanged |= checkAnchorPaddingsChanged(a, paddings, child);
                        positionChildNormal(a, child);
                        updateSide(a, child);
                    }
                    return paddingsChanged;
                } finally {
                    useLog && me._groupEnd();
                }
            }
            function layoutChildFill(child, canChange) {
                var paddingsChanged = 0
                  , a = child.anchor;
                childKeyArgs.paddings = filterAnchorPaddings(a, paddings);
                childKeyArgs.canChange = canChange;
                child.layout(new pvc_Size(remSize), childKeyArgs);
                if (child.isVisible) {
                    paddingsChanged |= checkAnchorPaddingsChanged(a, paddings, child, canChange);
                    positionChildNormal(a, child);
                    positionChildOrtho(child, a);
                }
                return paddingsChanged;
            }
            function layoutChild2Side(child, canChange) {
                var paddingsChanged = 0;
                if (child.isVisible) {
                    var a = child.anchor
                      , al = alMap[a]
                      , aol = aolMap[a]
                      , length = remSize[al]
                      , olength = child[aol]
                      , childSize2 = new pvc_Size(def.set({}, al, length, aol, olength));
                    childKeyArgs.paddings = filterAnchorPaddings(a, paddings);
                    childKeyArgs.canChange = canChange;
                    child.layout(childSize2, childKeyArgs);
                    if (child.isVisible) {
                        paddingsChanged = checkAnchorPaddingsChanged(a, paddings, child, canChange) | checkOverflowPaddingsChanged(a, layoutInfo.paddings, child, canChange);
                        paddingsChanged || positionChildOrtho(child, child.align);
                    }
                }
                return paddingsChanged;
            }
            function positionChildNormal(side, child) {
                var sidePos;
                if ("fill" === side) {
                    side = "left";
                    sidePos = margins.left + remSize.width / 2 - child.width / 2;
                } else
                    sidePos = margins[side];
                child.setPosition(def.set({}, side, sidePos));
            }
            function updateSide(side, child) {
                var sideol = aolMap[side]
                  , olen = child[sideol];
                margins[side] += olen;
                remSize[sideol] -= olen;
            }
            function positionChildOrtho(child, align) {
                var sideo;
                "fill" === align && (align = "middle");
                var sideOPos;
                switch (align) {
                case "top":
                case "bottom":
                case "left":
                case "right":
                    sideo = align;
                    sideOPos = margins[sideo];
                    break;

                case "middle":
                    sideo = "bottom";
                    sideOPos = margins.bottom + remSize.height / 2 - child.height / 2;
                    break;

                case "center":
                    sideo = "left";
                    sideOPos = margins.left + remSize.width / 2 - child.width / 2;
                }
                child.setPosition(def.set({}, sideo, sideOPos));
            }
            function filterAnchorPaddings(a, paddings) {
                var filtered = new pvc_Sides();
                getAnchorPaddingsNames(a).forEach(function(side) {
                    filtered.set(side, paddings[side]);
                });
                return filtered;
            }
            function checkAnchorPaddingsChanged(a, paddings, child, canChange) {
                var newPaddings = child._layoutInfo.requestPaddings
                  , changed = 0;
                if (newPaddings) {
                    if (useLog && pvc.debug >= 10) {
                        me._log("=> clientSize=" + pvc.stringify(child._layoutInfo.clientSize));
                        me._log("<= requestPaddings=" + pvc.stringify(newPaddings));
                    }
                    getAnchorPaddingsNames(a).forEach(function(side) {
                        var value = paddings[side] || 0
                          , newValue = Math.floor(1e4 * (newPaddings[side] || 0)) / 1e4
                          , increase = newValue - value
                          , minChange = Math.max(1, Math.abs(.01 * value));
                        if (0 !== increase && Math.abs(increase) >= minChange)
                            if (canChange) {
                                changed |= NormalPaddingsChanged;
                                paddings[side] = newValue;
                                useLog && me._log("Changed padding " + side + " <- " + newValue);
                            } else
                                pvc.debug >= 2 && me._warn("CANNOT change but child wanted to: " + side + "=" + newValue);
                    });
                    if (changed) {
                        var paddingKey = pvc_Sides.names.map(function(side) {
                            return (paddings[side] || 0).toFixed(0);
                        }).join("|");
                        if (def.hasOwn(paddingHistory, paddingKey)) {
                            pvc.debug >= 2 && me._warn("LOOP detected!!!!");
                            changed |= LoopDetected;
                        } else
                            paddingHistory[paddingKey] = !0;
                        paddings.width = paddings.left + paddings.right;
                        paddings.height = paddings.top + paddings.bottom;
                    }
                }
                return changed;
            }
            function checkOverflowPaddingsChanged(a, ownPaddings, child, canChange) {
                var overflowPaddings = child._layoutInfo.overflowPaddings || emptyNewPaddings
                  , changed = 0;
                useLog && pvc.debug >= 10 && me._log("<= overflowPaddings=" + pvc.stringify(overflowPaddings));
                getAnchorPaddingsNames(a).forEach(function(side) {
                    if (overflowPaddings.hasOwnProperty(side)) {
                        var value = ownPaddings[side] || 0
                          , newValue = Math.floor(1e4 * (overflowPaddings[side] || 0)) / 1e4;
                        newValue -= margins[side];
                        var increase = newValue - value
                          , minChange = Math.max(1, Math.abs(.05 * value));
                        if (increase >= minChange)
                            if (canChange) {
                                changed |= OverflowPaddingsChanged;
                                ownPaddings[side] = newValue;
                                useLog && me._log("changed overflow padding " + side + " <- " + newValue);
                            } else
                                pvc.debug >= 2 && me._warn("CANNOT change overflow padding but child wanted to: " + side + "=" + newValue);
                    }
                });
                if (changed) {
                    ownPaddings.width = ownPaddings.left + ownPaddings.right;
                    ownPaddings.height = ownPaddings.top + ownPaddings.bottom;
                }
                return changed;
            }
            function getAnchorPaddingsNames(a) {
                switch (a) {
                case "left":
                case "right":
                    return pvc_Sides.vnames;

                case "top":
                case "bottom":
                    return pvc_Sides.hnames;

                case "fill":
                    return pvc_Sides.names;
                }
            }
            var me = this;
            if (me._children) {
                var useLog = pvc.debug >= 5
                  , margins = new pvc_Sides(0)
                  , paddings = new pvc_Sides(0)
                  , remSize = def.copyOwn(layoutInfo.clientSize)
                  , aolMap = pvc.BasePanel.orthogonalLength
                  , aoMap = pvc.BasePanel.relativeAnchor
                  , alMap = pvc.BasePanel.parallelLength
                  , childKeyArgs = {
                    force: !0,
                    referenceSize: layoutInfo.clientSize
                }
                  , fillChildren = []
                  , sideChildren = []
                  , paddingHistory = {}
                  , LoopDetected = 1
                  , NormalPaddingsChanged = 2
                  , OverflowPaddingsChanged = 4
                  , emptyNewPaddings = new pvc_Sides()
                  , isDisasterRecovery = !1;
                useLog && me._group("CCC GRID LAYOUT clientSize = " + pvc.stringify(remSize));
                try {
                    this._children.forEach(initChild);
                    useLog && me._group("Phase 1 - Determine MARGINS and FILL SIZE from SIDE panels");
                    try {
                        sideChildren.forEach(layoutChild1Side);
                    } finally {
                        if (useLog) {
                            me._groupEnd();
                            me._log("Final FILL margins = " + pvc.stringify(margins));
                            me._log("Final FILL border size = " + pvc.stringify(remSize));
                        }
                    }
                    useLog && me._group("Phase 2 - Determine COMMON PADDINGS");
                    try {
                        doMaxTimes(9, layoutCycle);
                    } finally {
                        if (useLog) {
                            me._groupEnd();
                            me._log("Final FILL clientSize = " + pvc.stringify({
                                width: remSize.width - paddings.width,
                                height: remSize.height - paddings.height
                            }));
                            me._log("Final COMMON paddings = " + pvc.stringify(paddings));
                        }
                    }
                    layoutInfo.gridMargins = new pvc_Sides(margins);
                    layoutInfo.gridPaddings = new pvc_Sides(paddings);
                    layoutInfo.gridSize = new pvc_Size(remSize);
                } finally {
                    useLog && me._groupEnd();
                }
            }
        }
    });
    def.type("pvc.CartesianGridDockingPanel", pvc.GridDockingPanel).init(function(chart, parent, options) {
        this.base(chart, parent, options);
        this._plotBgPanel = new pvc.PlotBgPanel(chart,this);
    }).add({
        _getExtensionId: function() {
            return this.chart.parent ? "smallContent" : "content";
        },
        _createCore: function(layoutInfo) {
            var chart = this.chart
              , axes = chart.axes
              , xAxis = axes.x
              , yAxis = axes.y;
            xAxis.isBound() || (xAxis = null);
            yAxis.isBound() || (yAxis = null);
            xAxis && xAxis.option("Grid") && (this.xGridRule = this._createGridRule(xAxis));
            yAxis && yAxis.option("Grid") && (this.yGridRule = this._createGridRule(yAxis));
            this.base(layoutInfo);
            chart.focusWindow && this._createFocusWindow(layoutInfo);
            var plotFrameVisible;
            plotFrameVisible = chart.compatVersion() <= 1 ? !(!xAxis.option("EndLine") && !yAxis.option("EndLine")) : def.get(chart.options, "plotFrameVisible", !0);
            plotFrameVisible && (this.pvFrameBar = this._createFrame(layoutInfo, axes));
            xAxis && "discrete" !== xAxis.scaleType && xAxis.option("ZeroLine") && (this.xZeroLine = this._createZeroLine(xAxis, layoutInfo));
            yAxis && "discrete" !== yAxis.scaleType && yAxis.option("ZeroLine") && (this.yZeroLine = this._createZeroLine(yAxis, layoutInfo));
        },
        _createGridRule: function(axis) {
            var scale = axis.scale;
            if (!scale.isNull) {
                var isDiscrete = axis.role.grouping.isDiscrete()
                  , rootScene = this._getAxisGridRootScene(axis);
                if (rootScene) {
                    var margins = this._layoutInfo.gridMargins
                      , paddings = this._layoutInfo.gridPaddings
                      , tick_a = "x" === axis.orientation ? "left" : "bottom"
                      , len_a = this.anchorLength(tick_a)
                      , obeg_a = this.anchorOrtho(tick_a)
                      , oend_a = this.anchorOpposite(obeg_a)
                      , tick_offset = margins[tick_a] + paddings[tick_a]
                      , obeg = margins[obeg_a]
                      , oend = margins[oend_a]
                      , tickScenes = rootScene.leafs().array()
                      , tickCount = tickScenes.length;
                    isDiscrete && tickCount && tickScenes.push(tickScenes[tickCount - 1]);
                    var wrapper;
                    this.compatVersion() <= 1 && (wrapper = function(v1f) {
                        return function(tickScene) {
                            return v1f.call(this, tickScene.vars.tick.rawValue);
                        }
                        ;
                    }
                    );
                    var pvGridRule = new pvc.visual.Rule(this,this.pvPanel,{
                        extensionId: axis.extensionPrefixes.map(function(prefix) {
                            return prefix + "Grid";
                        }),
                        wrapper: wrapper
                    }).lock("data", tickScenes).lock(len_a, null).override("defaultColor", def.fun.constant(pv.color("#f0f0f0"))).pvMark.antialias(!0)[obeg_a](obeg)[oend_a](oend).zOrder(-12).events("none");
                    if (isDiscrete) {
                        var halfStep = scale.range().step / 2;
                        pvGridRule[tick_a](function(tickScene) {
                            var tickPosition = tick_offset + scale(tickScene.vars.tick.value)
                              , isLastLine = this.index === tickCount;
                            return tickPosition + (isLastLine ? halfStep : -halfStep);
                        });
                    } else
                        pvGridRule[tick_a](function(tickScene) {
                            return tick_offset + scale(tickScene.vars.tick.value);
                        });
                    return pvGridRule;
                }
            }
        },
        _getAxisGridRootScene: function(axis) {
            var isDiscrete = axis.isDiscrete()
              , data = isDiscrete ? axis.domainData() : this.data
              , rootScene = new pvc.visual.CartesianAxisRootScene(null,{
                panel: this,
                source: data
            });
            if (isDiscrete)
                data.childNodes.forEach(function(tickData) {
                    new pvc.visual.CartesianAxisTickScene(rootScene,{
                        source: tickData,
                        tick: tickData.value,
                        tickRaw: tickData.rawValue,
                        tickLabel: tickData.label
                    });
                });
            else {
                var ticks = axis.ticks || axis.calcContinuousTicks();
                ticks.forEach(function(majorTick) {
                    new pvc.visual.CartesianAxisTickScene(rootScene,{
                        tick: majorTick,
                        tickRaw: majorTick,
                        tickLabel: axis.scale.tickFormat(majorTick)
                    });
                }, this);
            }
            return rootScene;
        },
        _createFrame: function(layoutInfo, axes) {
            if (!axes.base.scale.isNull && (!axes.ortho.scale.isNull || axes.ortho2 && !axes.ortho2.scale.isNull)) {
                var margins = layoutInfo.gridMargins
                  , left = margins.left
                  , right = margins.right
                  , top = margins.top
                  , bottom = margins.bottom
                  , extensionIds = [];
                if (this.compatVersion() <= 1) {
                    extensionIds.push("xAxisEndLine");
                    extensionIds.push("yAxisEndLine");
                }
                extensionIds.push("plotFrame");
                return new pvc.visual.Panel(this,this.pvPanel,{
                    extensionId: extensionIds
                }).pvMark.lock("left", left).lock("right", right).lock("top", top).lock("bottom", bottom).lock("fillStyle", null).events("none").strokeStyle("#666666").lineWidth(1).antialias(!1).zOrder(-8);
            }
        },
        _createZeroLine: function(axis, layoutInfo) {
            var scale = axis.scale;
            if (!scale.isNull) {
                var domain = scale.domain();
                if (domain[0] * domain[1] < -1e-12) {
                    var a = "x" === axis.orientation ? "left" : "bottom"
                      , len_a = this.anchorLength(a)
                      , obeg_a = this.anchorOrtho(a)
                      , oend_a = this.anchorOpposite(obeg_a)
                      , margins = layoutInfo.gridMargins
                      , paddings = layoutInfo.gridPaddings
                      , zeroPosition = margins[a] + paddings[a] + scale(0)
                      , obeg = margins[obeg_a]
                      , oend = margins[oend_a]
                      , rootScene = new pvc.visual.Scene(null,{
                        panel: this
                    });
                    return new pvc.visual.Rule(this,this.pvPanel,{
                        extensionId: axis.extensionPrefixes.map(function(prefix) {
                            return prefix + "ZeroLine";
                        })
                    }).lock("data", [rootScene]).lock(len_a, null).lock(obeg_a, obeg).lock(oend_a, oend).lock(a, zeroPosition).override("defaultColor", def.fun.constant(pv.color("#666666"))).pvMark.events("none").lineWidth(1).antialias(!0).zOrder(-9);
                }
            }
        },
        _createFocusWindow: function(layoutInfo) {
            function resetSceneY() {
                scene[a_y] = 0 - paddings[a_top];
                scene[a_dy] = h + paddings[a_top] + paddings[a_bottom];
            }
            function onDrag() {
                var ev = arguments[arguments.length - 1]
                  , isEnd = "end" === ev.drag.phase;
                topRoot._selectingByRubberband = !isEnd;
                baseBgPanel.render();
                baseFgPanel.render();
                var pbeg = scene[a_x]
                  , pend = scene[a_x] + scene[a_dx];
                if (!isV) {
                    var temp = w - pbeg;
                    pbeg = w - pend;
                    pend = temp;
                }
                focusWindow._updatePosition(pbeg, pend, isEnd, !0);
            }
            function positionConstraint(drag, op) {
                var l, target, m = drag.m, p = m[a_p], l0 = scene[a_dp];
                switch (op) {
                case "new":
                    l = 0;
                    target = "begin";
                    break;

                case "resize-begin":
                    l = l0;
                    target = "begin";
                    break;

                case "move":
                    l = l0;
                    target = "begin";
                    break;

                case "resize-end":
                    l = p - scene[a_p];
                    target = "end";
                }
                var min = drag.min[a_p]
                  , max = drag.max[a_p]
                  , oper = {
                    type: op,
                    target: target,
                    point: p,
                    length: l,
                    length0: l0,
                    min: min,
                    max: max,
                    minView: 0,
                    maxView: w
                };
                focusWindow._constraintPosition(oper);
                m[a_p] = oper.point;
                switch (op) {
                case "resize-begin":
                    oper.max = Math.min(oper.max, scene[a_p] + scene[a_dp]);
                    break;

                case "resize-end":
                    oper.min = Math.max(oper.min, scene[a_p]);
                }
                drag.min[a_p] = oper.min;
                drag.max[a_p] = oper.max;
            }
            var me = this
              , topRoot = me.topRoot
              , chart = me.chart
              , focusWindow = chart.focusWindow.base
              , axis = focusWindow.axis
              , scale = axis.scale;
            if (!scale.isNull) {
                var resizable = focusWindow.option("Resizable")
                  , movable = focusWindow.option("Movable")
                  , isDiscrete = axis.isDiscrete()
                  , isV = chart.isOrientationVertical()
                  , a_left = isV ? "left" : "top"
                  , a_top = isV ? "top" : "left"
                  , a_width = me.anchorOrthoLength(a_left)
                  , a_right = me.anchorOpposite(a_left)
                  , a_height = me.anchorOrthoLength(a_top)
                  , a_bottom = me.anchorOpposite(a_top)
                  , a_x = isV ? "x" : "y"
                  , a_dx = "d" + a_x
                  , a_y = isV ? "y" : "x"
                  , a_dy = "d" + a_y
                  , margins = layoutInfo.gridMargins
                  , paddings = layoutInfo.gridPaddings
                  , space = {
                    left: margins.left + paddings.left,
                    right: margins.right + paddings.right,
                    top: margins.top + paddings.top,
                    bottom: margins.bottom + paddings.bottom
                };
                space.width = space.left + space.right;
                space.height = space.top + space.bottom;
                var clientSize = layoutInfo.clientSize
                  , wf = clientSize[a_width]
                  , hf = clientSize[a_height]
                  , w = wf - space[a_width]
                  , h = hf - space[a_height]
                  , padLeft = paddings[a_left]
                  , padRight = paddings[a_right]
                  , scene = new pvc.visual.Scene(null,{
                    panel: this
                })
                  , band = isDiscrete ? scale.range().step : 0
                  , halfBand = band / 2;
                scene[a_x] = scale(focusWindow.begin) - halfBand,
                scene[a_dx] = band + (scale(focusWindow.end) - halfBand) - scene[a_x],
                resetSceneY();
                var sceneProp = function(p) {
                    return function() {
                        return scene[p];
                    }
                    ;
                }
                  , boundLeft = function() {
                    var begin = scene[a_x];
                    return Math.max(0, Math.min(w, begin));
                }
                  , boundWidth = function() {
                    var begin = boundLeft()
                      , end = scene[a_x] + scene[a_dx];
                    end = Math.max(0, Math.min(w, end));
                    return end - begin;
                }
                  , addSelBox = function(panel, id) {
                    return new pvc.visual.Bar(me,panel,{
                        extensionId: id,
                        normalStroke: !0,
                        noHover: !0,
                        noSelect: !0,
                        noClick: !0,
                        noDoubleClick: !0,
                        noTooltip: !0,
                        showsInteraction: !1
                    }).pvMark.lock("data").lock("visible").lock(a_left, boundLeft).lock(a_width, boundWidth).lock(a_top, sceneProp(a_y)).lock(a_height, sceneProp(a_dy)).lock(a_bottom).lock(a_right).sign;
                }
                  , baseBgPanel = this._plotBgPanel.pvPanel.borderPanel;
                baseBgPanel.lock("data", [scene]);
                movable && resizable ? baseBgPanel.paddingPanel.lock("events", "all").lock("cursor", "crosshair").event("mousedown", pv.Behavior.select().autoRender(!1).collapse(isV ? "y" : "x").positionConstraint(function(drag) {
                    var op = "start" === drag.phase ? "new" : "resize-end";
                    return positionConstraint(drag, op);
                })).event("selectstart", function(ev) {
                    resetSceneY();
                    onDrag(ev);
                }).event("select", onDrag).event("selectend", onDrag) : baseBgPanel.paddingPanel.events("all");
                var focusBg = addSelBox(baseBgPanel.paddingPanel, "focusWindowBg").override("defaultColor", def.fun.constant(pvc.invisibleFill)).pvMark;
                movable ? focusBg.lock("events", "all").lock("cursor", "move").event("mousedown", pv.Behavior.drag().autoRender(!1).collapse(isV ? "y" : "x").positionConstraint(function(drag) {
                    positionConstraint(drag, "move");
                })).event("drag", onDrag).event("dragend", onDrag) : focusBg.events("none");
                var baseFgPanel = new pvc.visual.Panel(me,me.pvPanel).pvMark.lock("data", [scene]).lock("visible").lock("fillStyle", pvc.invisibleFill).lock("left", space.left).lock("right", space.right).lock("top", space.top).lock("bottom", space.bottom).lock("zOrder", 10).lock("events", function() {
                    var drag = scene.drag;
                    return drag && "end" !== drag.phase ? "all" : "none";
                }).lock("cursor", function() {
                    var drag = scene.drag;
                    return drag && "end" !== drag.phase ? "drag" === drag.type || "select" === drag.type && !resizable ? "move" : isV ? "ew-resize" : "ns-resize" : null;
                }).antialias(!1)
                  , curtainFillColor = "rgba(20, 20, 20, 0.1)";
                new pvc.visual.Bar(me,baseFgPanel,{
                    extensionId: "focusWindowBaseCurtain",
                    normalStroke: !0,
                    noHover: !0,
                    noSelect: !0,
                    noClick: !0,
                    noDoubleClick: !0,
                    noTooltip: !0,
                    showsInteraction: !1
                }).override("defaultColor", function(scene, type) {
                    return "stroke" === type ? null : curtainFillColor;
                }).pvMark.lock("data", [scene, scene]).lock("visible").lock("events", "none").lock(a_left, function() {
                    return this.index ? boundLeft() + boundWidth() : -padLeft;
                }).lock(a_right, function() {
                    return this.index ? -padRight : null;
                }).lock(a_width, function() {
                    return this.index ? null : padLeft + boundLeft();
                }).lock(a_top, sceneProp(a_y)).lock(a_height, sceneProp(a_dy)).lock(a_bottom);
                var selectBoxFg = addSelBox(baseFgPanel, "focusWindow").override("defaultColor", def.fun.constant(null)).pvMark.lock("events", "none")
                  , addResizeSideGrip = function(side) {
                    var a_begin = "left" === side || "top" === side ? "begin" : "end"
                      , opposite = me.anchorOpposite(side)
                      , fillColor = "linear-gradient(to " + opposite + ", " + curtainFillColor + ", #444 90%)"
                      , grip = new pvc.visual.Bar(me,selectBoxFg.anchor(side),{
                        extensionId: focusWindow.id + "Grip" + def.firstUpperCase(a_begin),
                        normalStroke: !0,
                        noHover: !0,
                        noSelect: !0,
                        noClick: !0,
                        noDoubleClick: !0,
                        noTooltip: !0,
                        showsInteraction: !1
                    }).override("defaultColor", function(scene, type) {
                        return "stroke" === type ? null : fillColor;
                    }).pvMark.lock("data").lock("visible")[a_top](scene[a_y])[a_height](scene[a_dy]);
                    if (resizable) {
                        var opId = "resize-" + a_begin;
                        grip.lock("events", "all")[a_width](5).cursor(isV ? "ew-resize" : "ns-resize").event("mousedown", pv.Behavior.resize(side).autoRender(!1).positionConstraint(function(drag) {
                            positionConstraint(drag, opId);
                        }).preserveOrtho(!0)).event("resize", onDrag).event("resizeend", onDrag);
                    } else
                        grip.events("none")[a_width](1);
                    return grip;
                };
                addResizeSideGrip(a_left);
                addResizeSideGrip(a_right);
                var a_p = a_x
                  , a_dp = a_dx;
            }
        },
        _getDatumsOnRect: function(datumMap, rect, keyArgs) {
            var xDatumMap, yDatumMap, chart = this.chart, xAxisPanel = chart.axesPanels.x, yAxisPanel = chart.axesPanels.y;
            if (xAxisPanel) {
                xDatumMap = new def.Map();
                xAxisPanel._getDatumsOnRect(xDatumMap, rect, keyArgs);
                xDatumMap.count || (xDatumMap = null);
            }
            if (yAxisPanel) {
                yDatumMap = new def.Map();
                yAxisPanel._getOwnDatumsOnRect(yDatumMap, rect, keyArgs);
                yDatumMap.count || (yDatumMap = null);
            }
            if (xDatumMap && yDatumMap) {
                xDatumMap.intersect(yDatumMap, datumMap);
                keyArgs.toggle = !0;
            } else
                xDatumMap ? datumMap.copy(xDatumMap) : yDatumMap ? datumMap.copy(yDatumMap) : chart.plotPanelList.forEach(function(plotPanel) {
                    plotPanel._getDatumsOnRect(datumMap, rect, keyArgs);
                }, this);
        }
    });
    def.type("pvc.CartesianAbstractPanel", pvc.PlotPanel).init(function(chart, parent, plot, options) {
        function addAxis(axis) {
            axes[axis.type] = axis;
            axes[axis.orientedId] = axis;
            axis.v1SecondOrientedId && (axes[axis.v1SecondOrientedId] = axis);
        }
        function setSide(side, pct) {
            var value = pctPaddings[side];
            if (null == value || pct > value) {
                hasAny = !0;
                pctPaddings[side] = pct;
            }
        }
        function processAxis(axis) {
            var offset = axis && axis.option("Offset");
            if (null != offset && offset > 0 && 1 > offset)
                if ("x" === axis.orientation) {
                    setSide("left", offset);
                    setSide("right", offset);
                } else {
                    setSide("top", offset);
                    setSide("bottom", offset);
                }
        }
        this.base(chart, parent, plot, options);
        var axes = this.axes;
        addAxis(chart._getAxis("base", plot.option("BaseAxis") - 1));
        addAxis(chart._getAxis("ortho", plot.option("OrthoAxis") - 1));
        var pctPaddings = {}
          , hasAny = !1
          , chartAxes = chart.axesByType;
        ["base", "ortho"].forEach(function(type) {
            var typeAxes = chartAxes[type];
            typeAxes && typeAxes.forEach(processAxis);
        });
        hasAny && (this.offsetPaddings = pctPaddings);
    }).add({
        offsetPaddings: null,
        _calcLayout: function(layoutInfo) {
            layoutInfo.requestPaddings = this._calcRequestPaddings(layoutInfo);
        },
        _calcRequestPaddings: function(layoutInfo) {
            var reqPads, offPads = this.offsetPaddings;
            if (offPads) {
                var tickRoundPads = this.chart._getAxesRoundingPaddings()
                  , clientSize = layoutInfo.clientSize
                  , pads = layoutInfo.paddings;
                pvc_Sides.names.forEach(function(side) {
                    var len_a = pvc.BasePanel.orthogonalLength[side]
                      , clientLen = clientSize[len_a]
                      , paddingLen = pads[len_a]
                      , len = clientLen + paddingLen;
                    if (!tickRoundPads[side + "Locked"]) {
                        var offLen = len * (offPads[side] || 0)
                          , roundLen = clientLen * (tickRoundPads[side] || 0);
                        (reqPads || (reqPads = {}))[side] = Math.max(offLen - roundLen, 0);
                    }
                }, this);
            }
            return reqPads;
        },
        _createCore: function() {
            this.pvPanel.zOrder(-10);
            var hideOverflow, contentOverflow = this.chart.options.leafContentOverflow || "auto";
            hideOverflow = "auto" === contentOverflow ? def.query(["ortho", "base"]).select(function(axisType) {
                return this.axes[axisType];
            }, this).any(function(axis) {
                return null != axis.option("FixedMin") || null != axis.option("FixedMax");
            }) : "hidden" === contentOverflow;
            hideOverflow && this.pvPanel.borderPanel.overflow("hidden");
        }
    });
    def.type("pvc.PlotBgPanel", pvc.BasePanel).init(function(chart, parent, options) {
        this.base(chart, parent, options);
    }).add({
        anchor: "fill",
        _getExtensionId: function() {
            return "plotBg";
        },
        _createCore: function(layoutInfo) {
            this.pvPanel.borderPanel.lock("zOrder", -13).antialias(!1);
            this.base(layoutInfo);
        }
    });
    def.type("pvc.CategoricalAbstract", pvc.CartesianAbstract).init(function(options) {
        this.base(options);
        var parent = this.parent;
        parent && (this._catRole = parent._catRole);
    }).add({
        _interpolatable: !0,
        _initVisualRoles: function() {
            this.base();
            this._catRole = this._addVisualRole("category", this._getCategoryRoleSpec());
        },
        _getCategoryRoleSpec: function() {
            return {
                isRequired: !0,
                defaultDimension: "category*",
                autoCreateDimension: !0
            };
        },
        _createVisibleData: function(baseData, ka) {
            var serGrouping = this._serRole && this._serRole.flattenedGrouping()
              , catGrouping = this._catRole.flattenedGrouping();
            return serGrouping ? baseData.groupBy(def.get(ka, "inverted", !1) ? [serGrouping, catGrouping] : [catGrouping, serGrouping], ka) : baseData.groupBy(catGrouping, ka);
        },
        _interpolateDataCell: function(dataCell, baseData) {
            var InterpType = this._getNullInterpolationOperType(dataCell.nullInterpolationMode);
            if (InterpType) {
                this._warnSingleContinuousValueRole(dataCell.role);
                var partValue = dataCell.dataPartValue
                  , partData = this.partData(partValue, baseData)
                  , visibleData = this.visibleData(partValue, {
                    baseData: baseData
                });
                visibleData.childCount() > 0 && new InterpType(baseData,partData,visibleData,this._catRole,this._serRole,dataCell.role,!0).interpolate();
            }
        },
        _getNullInterpolationOperType: function(nim) {
            switch (nim) {
            case "linear":
                return pvc.data.LinearInterpolationOper;

            case "zero":
                return pvc.data.ZeroInterpolationOper;

            case "none":
                break;

            default:
                throw def.error.argumentInvalid("nullInterpolationMode", "" + nim);
            }
        },
        _generateTrendsDataCell: function(newDatums, dataCell, baseData) {
            function genSeriesTrend(serData1) {
                var funX = isXDiscrete ? null : function(allCatData) {
                    return allCatData.atoms[xDimName].value;
                }
                  , funY = function(allCatData) {
                    var group = data.child(allCatData.key);
                    group && serData1 && (group = group.child(serData1.key));
                    return group ? group.dimensions(yDimName).value(sumKeyArgs) : null;
                }
                  , options = def.create(trendOptions, {
                    rows: def.query(allCatDatas),
                    x: funX,
                    y: funY
                })
                  , trendModel = trendInfo.model(options);
                trendModel && allCatDatas.forEach(function(allCatData, index) {
                    var trendX = isXDiscrete ? index : allCatData.atoms[xDimName].value
                      , trendY = trendModel.sample(trendX, funY(allCatData), index);
                    if (null != trendY) {
                        var atoms, catData = data.child(allCatData.key), efCatData = catData || allCatData;
                        if (serData1) {
                            var catSerData = catData && catData.child(serData1.key);
                            if (catSerData)
                                atoms = Object.create(catSerData._datums[0].atoms);
                            else {
                                atoms = Object.create(efCatData._datums[0].atoms);
                                def.copyOwn(atoms, serData1.atoms);
                            }
                        } else
                            atoms = Object.create(efCatData._datums[0].atoms);
                        atoms[yDimName] = trendY;
                        atoms[dataPartDimName] = dataPartAtom;
                        newDatums.push(new pvc.data.TrendDatum(efCatData.owner,atoms,trendOptions));
                    }
                }, this);
            }
            var serRole = this._serRole
              , xRole = this._catRole
              , yRole = dataCell.role
              , trendOptions = dataCell.trend
              , trendInfo = trendOptions.info;
            this._warnSingleContinuousValueRole(yRole);
            var xDimName, yDimName = yRole.firstDimensionName(), isXDiscrete = xRole.isDiscrete();
            isXDiscrete || (xDimName = xRole.firstDimensionName());
            var sumKeyArgs = {
                zeroIfNone: !1
            }
              , partData = this.partData(dataCell.dataPartValue, baseData)
              , data = this.visibleData(dataCell.dataPartValue, {
                baseData: baseData
            })
              , dataPartAtom = this._getTrendDataPartAtom()
              , dataPartDimName = dataPartAtom.dimension.name
              , allCatDatas = xRole.flatten(baseData, {
                visible: !0
            }).childNodes
              , qVisibleSeries = serRole && serRole.isBound() ? serRole.flatten(partData, {
                visible: !0
            }).children() : def.query([null]);
            qVisibleSeries.each(genSeriesTrend, this);
        },
        _getContinuousVisibleCellExtent: function(valueAxis, valueDataCell) {
            var valueRole = valueDataCell.role;
            switch (valueRole.name) {
            case "series":
            case "category":
                return this.base(valueAxis, valueDataCell);
            }
            this._warnSingleContinuousValueRole(valueRole);
            var dataPartValue = valueDataCell.dataPartValue
              , valueDimName = valueRole.firstDimensionName()
              , data = this.visibleData(dataPartValue)
              , useAbs = valueAxis.scaleUsesAbs();
            return "ortho" === valueAxis.type && valueDataCell.isStacked ? data.children().select(function(catGroup) {
                var range = this._getStackedCategoryValueExtent(catGroup, valueDimName, useAbs);
                return range ? {
                    range: range,
                    group: catGroup
                } : void 0;
            }, this).where(def.notNully).reduce(function(result, rangeInfo) {
                return this._reduceStackedCategoryValueExtent(result, rangeInfo.range, rangeInfo.group);
            }
            .bind(this), null) : data.leafs().select(function(serGroup) {
                var value = serGroup.dimensions(valueDimName).value();
                return useAbs && 0 > value ? -value : value;
            }).range();
        },
        _getStackedCategoryValueExtent: function(catGroup, valueDimName, useAbs) {
            var posSum = null
              , negSum = null;
            catGroup.children().select(function(serGroup) {
                var value = serGroup.dimensions(valueDimName).value();
                return useAbs && 0 > value ? -value : value;
            }).each(function(value) {
                null != value && (value >= 0 ? posSum += value : negSum += value);
            });
            return null == posSum && null == negSum ? null : {
                max: posSum || 0,
                min: negSum || 0
            };
        },
        _reduceStackedCategoryValueExtent: function(result, catRange) {
            return pvc.unionExtents(result, catRange);
        },
        _coordinateSmallChartsLayout: function(scopesByType) {
            this.base(scopesByType);
            var titleOrthoLen, titleSizeMax = 0, axisIds = null, sizesMaxByAxisId = {};
            this.children.forEach(function(childChart) {
                childChart.basePanel.layout();
                var size, panel = childChart.titlePanel;
                if (panel) {
                    titleOrthoLen || (titleOrthoLen = panel.anchorOrthoLength());
                    size = panel[titleOrthoLen];
                    size > titleSizeMax && (titleSizeMax = size);
                }
                var axesPanels = childChart.axesPanels;
                axisIds || (axisIds = def.query(def.ownKeys(axesPanels)).where(function(alias) {
                    return alias === axesPanels[alias].axis.id;
                }).select(function(id) {
                    sizesMaxByAxisId[id] = {
                        axis: 0,
                        title: 0
                    };
                    return id;
                }).array());
                axisIds.forEach(function(id) {
                    var axisPanel = axesPanels[id]
                      , sizes = sizesMaxByAxisId[id]
                      , ol = "x" === axisPanel.axis.orientation ? "height" : "width";
                    size = axisPanel[ol];
                    size > sizes.axis && (sizes.axis = size);
                    var titlePanel = axisPanel.titlePanel;
                    if (titlePanel) {
                        size = titlePanel[ol];
                        size > sizes.title && (sizes.title = size);
                    }
                });
            }, this);
            this.children.forEach(function(childChart) {
                if (titleSizeMax > 0) {
                    var panel = childChart.titlePanel;
                    panel.size = panel.size.clone().set(titleOrthoLen, titleSizeMax);
                }
                var axesPanels = childChart.axesPanels;
                axisIds.forEach(function(id) {
                    var axisPanel = axesPanels[id]
                      , sizes = sizesMaxByAxisId[id]
                      , ol = "x" === axisPanel.axis.orientation ? "height" : "width";
                    axisPanel.size = axisPanel.size.clone().set(ol, sizes.axis);
                    var titlePanel = axisPanel.titlePanel;
                    titlePanel && (titlePanel.size = titlePanel.size.clone().set(ol, sizes.title));
                });
                childChart.basePanel.invalidateLayout();
            }, this);
        }
    });
    def.type("pvc.CategoricalAbstractPanel", pvc.CartesianAbstractPanel).init(function(chart, parent, plot, options) {
        this.base(chart, parent, plot, options);
        this.stacked = plot.option("Stacked");
    });
    def.type("pvc.AxisPanel", pvc.BasePanel).init(function(chart, parent, axis, options) {
        options = def.create(options, {
            anchor: axis.option("Position")
        });
        var anchor = options.anchor || this.anchor;
        this.axis = axis;
        this.base(chart, parent, options);
        this.roleName = axis.role.name;
        this.isDiscrete = axis.role.isDiscrete();
        this._extensionPrefix = axis.extensionPrefixes;
        null == this.labelSpacingMin && (this.labelSpacingMin = this.isDiscrete ? .25 : 1.5);
        null == this.showTicks && (this.showTicks = !this.isDiscrete);
        if (void 0 === options.font) {
            var extFont = this._getConstantExtension("label", "font");
            extFont && (this.font = extFont);
        }
        if (void 0 === options.tickLength) {
            var tickLength = +this._getConstantExtension("ticks", this.anchorOrthoLength(anchor));
            !isNaN(tickLength) && isFinite(tickLength) && (this.tickLength = tickLength);
        }
    }).add({
        pvRule: null,
        pvTicks: null,
        pvLabel: null,
        pvRuleGrid: null,
        pvScale: null,
        isDiscrete: !1,
        roleName: null,
        axis: null,
        anchor: "bottom",
        tickLength: 6,
        scale: null,
        ruleCrossesMargin: !0,
        font: "12px sans-serif",
        labelSpacingMin: null,
        desiredTickCount: null,
        showMinorTicks: !0,
        showTicks: null,
        hiddenLabelText: "·",
        _isScaleSetup: !1,
        _createLogInstanceId: function() {
            return this.base() + " - " + this.axis.id;
        },
        getTicks: function() {
            return this._layoutInfo && this._layoutInfo.ticks;
        },
        _calcLayout: function(layoutInfo) {
            var scale = this.axis.scale;
            if (!this._isScaleSetup) {
                this.pvScale = scale;
                this.scale = scale;
                this.extend(scale, "scale");
                this._isScaleSetup = !0;
            }
            scale.isNull ? layoutInfo.axisSize = 0 : this._calcLayoutCore(layoutInfo);
            return this.createAnchoredSize(layoutInfo.axisSize, layoutInfo.clientSize);
        },
        _calcLayoutCore: function(layoutInfo) {
            var axisSize = layoutInfo.desiredClientSize[this.anchorOrthoLength()];
            layoutInfo.axisSize = axisSize;
            if (this.isDiscrete && this.useCompositeAxis)
                null == layoutInfo.axisSize && (layoutInfo.axisSize = 50);
            else {
                this._readTextProperties(layoutInfo);
                this._calcTicks();
                "discrete" === this.scale.type && (this._tickIncludeModulo = this._calcDiscreteTicksIncludeModulo());
                this._calcAxisSizeFromLabel(layoutInfo);
                null == layoutInfo.axisSize && (layoutInfo.axisSize = layoutInfo.requiredAxisSize);
                this._calcMaxTextLengthThatFits();
                this._calcOverflowPaddings();
            }
        },
        _calcAxisSizeFromLabel: function(layoutInfo) {
            this._calcTicksLabelBBoxes(layoutInfo);
            this._calcAxisSizeFromLabelBBox(layoutInfo);
        },
        _readTextProperties: function(layoutInfo) {
            var textAngle = this._getExtension("label", "textAngle");
            layoutInfo.isTextAngleFixed = null != textAngle;
            layoutInfo.textAngle = def.number.as(textAngle, 0);
            layoutInfo.textMargin = def.number.as(this._getExtension("label", "textMargin"), 3);
            var align = this._getExtension("label", "textAlign");
            "string" != typeof align && (align = this.isAnchorTopOrBottom() ? "center" : "left" == this.anchor ? "right" : "left");
            layoutInfo.textAlign = align;
            var baseline = this._getExtension("label", "textBaseline");
            if ("string" != typeof baseline)
                switch (this.anchor) {
                case "right":
                case "left":
                case "center":
                    baseline = "middle";
                    break;

                case "bottom":
                    baseline = "top";
                    break;

                default:
                    baseline = "bottom";
                }
            layoutInfo.textBaseline = baseline;
        },
        _calcAxisSizeFromLabelBBox: function(layoutInfo) {
            var maxLabelBBox = layoutInfo.maxLabelBBox
              , length = this._getLabelBBoxQuadrantLength(maxLabelBBox, this.anchor)
              , axisSize = this.tickLength + length
              , angle = maxLabelBBox.sourceAngle;
            0 === angle && this.isAnchorTopOrBottom() || (axisSize += this.tickLength);
            layoutInfo.requiredAxisSize = axisSize;
        },
        _getLabelBBoxQuadrantLength: function(labelBBox, quadrantSide) {
            var length;
            switch (quadrantSide) {
            case "left":
                length = -labelBBox.x;
                break;

            case "right":
                length = labelBBox.x2;
                break;

            case "top":
                length = -labelBBox.y;
                break;

            case "bottom":
                length = labelBBox.y2;
            }
            return Math.max(length, 0);
        },
        _calcOverflowPaddings: function() {
            this._layoutInfo.canChange ? this._calcOverflowPaddingsFromLabelBBox() : pvc.debug >= 2 && this._warn("Layout cannot change. Skipping calculation of overflow paddings.");
        },
        _calcOverflowPaddingsFromLabelBBox: function() {
            var overflowPaddings = null
              , me = this
              , li = me._layoutInfo
              , ticks = li.ticks
              , tickCount = ticks.length;
            if (tickCount) {
                var ticksBBoxes = li.ticksBBoxes
                  , paddings = li.paddings
                  , isTopOrBottom = me.isAnchorTopOrBottom()
                  , begSide = isTopOrBottom ? "left" : "bottom"
                  , endSide = isTopOrBottom ? "right" : "top"
                  , scale = me.scale
                  , isDiscrete = "discrete" === scale.type
                  , clientLength = li.clientSize[me.anchorLength()];
                this.axis.setScaleRange(clientLength);
                var evalLabelSideOverflow = function(labelBBox, side, isBegin, index) {
                    var sideLength = me._getLabelBBoxQuadrantLength(labelBBox, side);
                    if (sideLength > 1) {
                        var anchorPosition = scale(isDiscrete ? ticks[index].value : ticks[index])
                          , sidePosition = isBegin ? anchorPosition - sideLength : anchorPosition + sideLength
                          , sideOverflow = Math.max(0, isBegin ? -sidePosition : sidePosition - clientLength);
                        if (sideOverflow > 1) {
                            sideOverflow -= paddings[side] || 0;
                            if (sideOverflow > 1) {
                                isDiscrete && (sideOverflow *= 1.05);
                                if (overflowPaddings) {
                                    var currrOverflowPadding = overflowPaddings[side];
                                    (null == currrOverflowPadding || sideOverflow > currrOverflowPadding) && (overflowPaddings[side] = sideOverflow);
                                } else
                                    overflowPaddings = def.set({}, side, sideOverflow);
                            }
                        }
                    }
                };
                ticksBBoxes.forEach(function(labelBBox, index) {
                    evalLabelSideOverflow(labelBBox, begSide, !0, index);
                    evalLabelSideOverflow(labelBBox, endSide, !1, index);
                });
                pvc.debug >= 6 && overflowPaddings && me._log("OverflowPaddings = " + pvc.stringify(overflowPaddings));
            }
            li.overflowPaddings = overflowPaddings;
        },
        _calcMaxTextLengthThatFits: function() {
            var layoutInfo = this._layoutInfo;
            if (this.compatVersion() <= 1)
                layoutInfo.maxTextWidth = null;
            else {
                var availableClientLength = layoutInfo.clientSize[this.anchorOrthoLength()]
                  , efSize = Math.min(layoutInfo.axisSize, availableClientLength);
                if (efSize >= layoutInfo.requiredAxisSize - this.tickLength)
                    layoutInfo.maxTextWidth = null;
                else {
                    var mostOrthoDistantPoint, parallelDirection, maxLabelBBox = layoutInfo.maxLabelBBox, maxOrthoLength = efSize - 2 * this.tickLength;
                    switch (this.anchor) {
                    case "left":
                        parallelDirection = pv.vector(0, 1);
                        mostOrthoDistantPoint = pv.vector(-maxOrthoLength, 0);
                        break;

                    case "right":
                        parallelDirection = pv.vector(0, 1);
                        mostOrthoDistantPoint = pv.vector(maxOrthoLength, 0);
                        break;

                    case "top":
                        parallelDirection = pv.vector(1, 0);
                        mostOrthoDistantPoint = pv.vector(0, -maxOrthoLength);
                        break;

                    case "bottom":
                        parallelDirection = pv.vector(1, 0);
                        mostOrthoDistantPoint = pv.vector(0, maxOrthoLength);
                    }
                    var orthoOutwardsDir = mostOrthoDistantPoint.norm()
                      , corners = maxLabelBBox.source.points()
                      , botL = corners[0]
                      , botR = corners[1]
                      , topR = corners[2]
                      , topL = corners[3]
                      , topLRSideDir = topR.minus(topL)
                      , botLRSideDir = botR.minus(botL)
                      , intersect = pv.SvgScene.lineIntersect
                      , botI = intersect(mostOrthoDistantPoint, parallelDirection, botL, botLRSideDir)
                      , topI = intersect(mostOrthoDistantPoint, parallelDirection, topL, topLRSideDir)
                      , sideLRWidth = maxLabelBBox.sourceTextWidth
                      , maxTextWidth = sideLRWidth
                      , botLI = botI.minus(botL)
                      , botLILen = botLI.length();
                    sideLRWidth >= botLILen && botLI.dot(topLRSideDir) >= 0 && (maxTextWidth = botL.dot(orthoOutwardsDir) < botR.dot(orthoOutwardsDir) ? botLILen : botI.minus(botR).length());
                    var topLI = topI.minus(topL)
                      , topLILen = topLI.length();
                    sideLRWidth >= topLILen && topLI.dot(topLRSideDir) >= 0 && (maxTextWidth = topL.dot(orthoOutwardsDir) < topR.dot(orthoOutwardsDir) ? Math.min(maxTextWidth, topLILen) : Math.min(maxTextWidth, topI.minus(topR).length()));
                    if ("center" === maxLabelBBox.sourceAlign) {
                        var cutWidth = sideLRWidth - maxTextWidth;
                        maxTextWidth -= cutWidth;
                    }
                    layoutInfo.maxTextWidth = maxTextWidth;
                    pvc.debug >= 3 && this._log("Trimming labels' text at length " + maxTextWidth.toFixed(2) + "px maxOrthoLength=" + maxOrthoLength.toFixed(2) + "px");
                }
            }
        },
        _calcTicks: function() {
            var layoutInfo = this._layoutInfo;
            layoutInfo.textHeight = 2 * pv.Text.fontHeight(this.font) / 3;
            layoutInfo.maxTextWidth = null;
            this.axis.setTicks(null);
            switch (this.scale.type) {
            case "discrete":
                this._calcDiscreteTicks();
                break;

            case "timeSeries":
                this._calcTimeSeriesTicks();
                break;

            case "numeric":
                this._calcNumberTicks(layoutInfo);
                break;

            default:
                throw def.error.operationInvalid("Undefined axis scale type");
            }
            this.axis.setTicks(layoutInfo.ticks);
            var clientLength = layoutInfo.clientSize[this.anchorLength()];
            this.axis.setScaleRange(clientLength);
            null == layoutInfo.maxTextWidth && this._calcTicksTextLength(layoutInfo);
        },
        _calcDiscreteTicks: function() {
            var axis = this.axis
              , layoutInfo = this._layoutInfo;
            layoutInfo.ticks = axis.domainItems();
            var format, dimType, grouping = axis.role.grouping;
            if (grouping.isSingleDimension && (dimType = grouping.firstDimensionType()) && dimType.valueType === Date) {
                var extent = def.query(axis.domainValues()).range();
                if (extent && extent.min !== extent.max) {
                    var scale = new pv.Scale.linear(extent.min,extent.max);
                    scale.ticks();
                    var tickFormatter = axis.option("TickFormatter");
                    tickFormatter && scale.tickFormatter(tickFormatter);
                    var domainValues = axis.domainValues();
                    format = function(child, index) {
                        return scale.tickFormat(domainValues[index]);
                    }
                    ;
                }
            }
            format || (format = function(child) {
                return child.absLabel;
            }
            );
            layoutInfo.ticksText = layoutInfo.ticks.map(format);
            this._clearTicksTextDeps(layoutInfo);
        },
        _clearTicksTextDeps: function(ticksInfo) {
            ticksInfo.maxTextWidth = ticksInfo.ticksTextLength = ticksInfo.ticksBBoxes = null;
        },
        _calcTimeSeriesTicks: function() {
            this._calcContinuousTicks(this._layoutInfo, this.desiredTickCount);
        },
        _calcNumberTicks: function() {
            var desiredTickCount = this.desiredTickCount;
            if (null == desiredTickCount) {
                if (this.isAnchorTopOrBottom()) {
                    this._calcNumberHTicks();
                    return;
                }
                desiredTickCount = this._calcNumberVDesiredTickCount();
            }
            this._calcContinuousTicks(this._layoutInfo, desiredTickCount);
        },
        _calcContinuousTicks: function(ticksInfo, desiredTickCount) {
            this._calcContinuousTicksValue(ticksInfo, desiredTickCount);
            this._calcContinuousTicksText(ticksInfo);
        },
        _calcContinuousTicksValue: function(ticksInfo, desiredTickCount) {
            ticksInfo.ticks = this.axis.calcContinuousTicks(desiredTickCount);
            if (pvc.debug > 4) {
                this._log("DOMAIN: " + pvc.stringify(this.scale.domain()));
                this._log("TICKS:  " + pvc.stringify(ticksInfo.ticks));
            }
        },
        _calcContinuousTicksText: function(ticksInfo) {
            var ticksText = ticksInfo.ticksText = ticksInfo.ticks.map(function(tick) {
                return this.scale.tickFormat(tick);
            }, this);
            this._clearTicksTextDeps(ticksInfo);
            return ticksText;
        },
        _calcTicksTextLength: function(ticksInfo) {
            var max = 0
              , font = this.font
              , ticksText = ticksInfo.ticksText || this._calcContinuousTicksText(ticksInfo)
              , ticksTextLength = ticksInfo.ticksTextLength = ticksText.map(function(text) {
                var len = pv.Text.measureWidth(text, font);
                len > max && (max = len);
                return len;
            });
            ticksInfo.maxTextWidth = max;
            ticksInfo.ticksBBoxes = null;
            return ticksTextLength;
        },
        _calcTicksLabelBBoxes: function(ticksInfo) {
            var maxBBox, me = this, li = me._layoutInfo, ticksTextLength = ticksInfo.ticksTextLength || me._calcTicksTextLength(ticksInfo), maxLen = li.maxTextWidth;
            ticksInfo.ticksBBoxes = ticksTextLength.map(function(len) {
                var labelBBox = me._calcLabelBBox(len);
                maxBBox || len !== maxLen || (maxBBox = labelBBox);
                return labelBBox;
            }, me);
            li.maxLabelBBox = maxBBox;
        },
        _calcLabelBBox: function(textWidth) {
            var li = this._layoutInfo;
            return pvc.text.getLabelBBox(textWidth, li.textHeight, li.textAlign, li.textBaseline, li.textAngle, li.textMargin);
        },
        _calcDiscreteTicksIncludeModulo: function() {
            var mode = this.axis.option("OverlappedLabelsMode");
            if ("hide" !== mode && "rotatethenhide" !== mode)
                return 1;
            var li = this._layoutInfo
              , ticks = li.ticks
              , tickCount = ticks.length;
            if (2 >= tickCount)
                return 1;
            var b = this.scale.range().step
              , h = li.textHeight
              , w = li.maxTextWidth;
            if (!(w > 0 && h > 0 && b > 0))
                return 1;
            var sMin = h * this.labelSpacingMin
              , sMinH = sMin
              , spaceW = pv.Text.measureWidth("x", this.font)
              , sMinW = spaceW + sMin
              , a = li.textAngle
              , isH = this.isAnchorTopOrBottom()
              , sinOrCos = Math.abs(Math[isH ? "sin" : "cos"](a))
              , cosOrSin = Math.abs(Math[isH ? "cos" : "sin"](a))
              , timh = 1e-8 > sinOrCos ? 1 / 0 : Math.ceil((sMinH + h) / (b * sinOrCos))
              , timw = 1e-8 > cosOrSin ? 1 / 0 : Math.ceil((sMinW + w) / (b * cosOrSin))
              , tim = Math.min(timh, timw);
            (!isFinite(tim) || 1 > tim || Math.ceil(tickCount / tim) < 2) && (tim = 1);
            return tim;
        },
        _tickMultipliers: [1, 2, 5, 10],
        _calcNumberVDesiredTickCount: function() {
            var li = this._layoutInfo
              , lineHeight = li.textHeight * (1 + Math.max(0, this.labelSpacingMin))
              , clientLength = li.clientSize[this.anchorLength()]
              , tickCountMax = Math.max(1, ~~(clientLength / lineHeight));
            if (1 >= tickCountMax)
                return 1;
            var domain = this.scale.domain()
              , span = domain[1] - domain[0];
            if (0 >= span)
                return tickCountMax;
            for (var step, stepMin = span / tickCountMax, exponMin = Math.floor(pv.log(stepMin, 10)), stepBase = Math.pow(10, exponMin), ms = this._tickMultipliers, i = 0; i < ms.length; i++) {
                step = ms[i] * stepBase;
                if (step >= stepMin)
                    break;
            }
            return Math.max(1, Math.floor(span / step));
        },
        _calcNumberHTicks: function() {
            for (var dir, prevResultTickCount, ticksInfo, lastBelow, lastAbove, layoutInfo = this._layoutInfo, clientLength = layoutInfo.clientSize[this.anchorLength()], spacing = layoutInfo.textHeight * Math.max(0, this.labelSpacingMin), desiredTickCount = this._calcNumberHDesiredTickCount(spacing), doLog = pvc.debug >= 7; ; ) {
                doLog && this._log("calculateNumberHTicks TickCount IN desired = " + desiredTickCount);
                ticksInfo = {};
                this._calcContinuousTicksValue(ticksInfo, desiredTickCount);
                var ticks = ticksInfo.ticks
                  , resultTickCount = ticks.length;
                if (ticks.exponentOverflow) {
                    if (null != dir) {
                        if (1 === dir) {
                            lastBelow && (ticksInfo = lastBelow);
                            break;
                        }
                        lastAbove && (ticksInfo = lastAbove);
                        break;
                    }
                    if (ticks.exponent === this.exponentMin) {
                        lastBelow = ticksInfo;
                        dir = 1;
                    } else {
                        lastAbove = ticksInfo;
                        dir = -1;
                    }
                } else if (null == prevResultTickCount || resultTickCount !== prevResultTickCount) {
                    doLog && this._log("calculateNumberHTicks TickCount desired/resulting = " + desiredTickCount + " -> " + resultTickCount);
                    prevResultTickCount = resultTickCount;
                    this._calcContinuousTicksText(ticksInfo);
                    var length = this._calcNumberHLength(ticksInfo, spacing)
                      , excessLength = ticksInfo.excessLength = length - clientLength
                      , pctError = ticksInfo.error = Math.abs(excessLength / clientLength);
                    if (doLog) {
                        this._log("calculateNumberHTicks error=" + (excessLength >= 0 ? "+" : "-") + (100 * ticksInfo.error).toFixed(0) + "% count=" + resultTickCount + " step=" + ticks.step);
                        this._log("calculateNumberHTicks Length client/resulting = " + clientLength + " / " + length + " spacing = " + spacing);
                    }
                    if (excessLength > 0) {
                        if (1 === desiredTickCount) {
                            if (3 === resultTickCount && 1 >= pctError) {
                                ticksInfo.ticks.splice(1, 1);
                                ticksInfo.ticksText.splice(1, 1);
                                ticksInfo.ticks.step *= 2;
                            } else {
                                ticksInfo.ticks.length = 1;
                                ticksInfo.ticksText.length = 1;
                            }
                            delete ticksInfo.maxTextWidth;
                            break;
                        }
                        if (lastBelow) {
                            ticksInfo = lastBelow;
                            break;
                        }
                        lastAbove = ticksInfo;
                        dir = -1;
                    } else {
                        if (.05 >= pctError || -1 === dir)
                            break;
                        lastBelow = ticksInfo;
                        dir = 1;
                    }
                }
                desiredTickCount += dir;
            }
            if (ticksInfo) {
                layoutInfo.ticks = ticksInfo.ticks;
                layoutInfo.ticksText = ticksInfo.ticksText;
                layoutInfo.maxTextWidth = ticksInfo.maxTextWidth;
                pvc.debug >= 5 && this._log("calculateNumberHTicks RESULT error=" + (ticksInfo.excessLength >= 0 ? "+" : "-") + (100 * ticksInfo.error).toFixed(0) + "% count=" + ticksInfo.ticks.length + " step=" + ticksInfo.ticks.step);
            }
            doLog && this._log("calculateNumberHTicks END");
        },
        _calcNumberHDesiredTickCount: function(spacing) {
            var layoutInfo = this._layoutInfo
              , domainTextLength = this.scale.domain().map(function(tick) {
                tick = +tick.toFixed(2);
                var text = this.scale.tickFormat(tick);
                return pv.Text.measureWidth(text, this.font);
            }, this)
              , avgTextLength = Math.max((domainTextLength[1] + domainTextLength[0]) / 2, layoutInfo.textHeight)
              , clientLength = layoutInfo.clientSize[this.anchorLength()];
            return Math.max(1, ~~(clientLength / (avgTextLength + spacing)));
        },
        _calcNumberHLength: function(ticksInfo, spacing) {
            var ticksText = ticksInfo.ticksText
              , maxTextWidth = def.query(ticksText).select(function(text) {
                return pv.Text.measureWidth(text, this.font);
            }, this).max();
            return Math.max(maxTextWidth, (ticksText.length - 1) * (maxTextWidth + spacing));
        },
        _createCore: function() {
            if (!this.scale.isNull) {
                var clientSize = this._layoutInfo.clientSize
                  , paddings = this._layoutInfo.paddings
                  , begin_a = this.anchorOrtho()
                  , end_a = this.anchorOpposite(begin_a)
                  , size_a = this.anchorOrthoLength(begin_a)
                  , rMin = this.ruleCrossesMargin ? -paddings[begin_a] : 0
                  , rMax = clientSize[size_a] + (this.ruleCrossesMargin ? paddings[end_a] : 0)
                  , rSize = rMax - rMin;
                this._rSize = rSize;
                var rootScene = this._getRootScene();
                this.pvRule = new pvc.visual.Rule(this,this.pvPanel,{
                    extensionId: "rule"
                }).lock("data", [rootScene]).override("defaultColor", def.fun.constant("#666666")).lock(this.anchorOpposite(), 0).lock(begin_a, rMin).lock(size_a, rSize).pvMark.zOrder(30).strokeDasharray(null).lineCap("square");
                this.isDiscrete ? this.useCompositeAxis ? this.renderCompositeOrdinalAxis() : this.renderOrdinalAxis() : this.renderLinearAxis();
            }
        },
        _getExtensionId: function() {
            return "";
        },
        _getRootScene: function() {
            if (!this._rootScene) {
                var rootScene = this._rootScene = new pvc.visual.CartesianAxisRootScene(null,{
                    panel: this,
                    source: this._getRootData()
                })
                  , layoutInfo = this._layoutInfo
                  , ticks = layoutInfo.ticks
                  , ticksText = layoutInfo.ticksText;
                if (this.isDiscrete)
                    if (this.useCompositeAxis)
                        this._buildCompositeScene(rootScene);
                    else {
                        var includeModulo = this._tickIncludeModulo
                          , hiddenLabelText = this.hiddenLabelText;
                        rootScene.vars.tickIncludeModulo = includeModulo;
                        rootScene.vars.hiddenLabelText = hiddenLabelText;
                        var hiddenDatas, hiddenTexts, createHiddenScene, hiddenIndex;
                        if (includeModulo > 2) {
                            pvc.debug >= 3 && this._info("Showing only one in every " + includeModulo + " tick labels");
                            var keySep = rootScene.group.owner.keySep;
                            createHiddenScene = function() {
                                var k = hiddenDatas.map(function(d) {
                                    return d.key;
                                }).join(keySep)
                                  , l = hiddenTexts.slice(0, 10).join(", ") + (hiddenTexts.length > 10 ? ", ..." : "")
                                  , scene = new pvc.visual.CartesianAxisTickScene(rootScene,{
                                    source: hiddenDatas,
                                    tick: k,
                                    tickRaw: k,
                                    tickLabel: l,
                                    isHidden: !0
                                });
                                scene.dataIndex = hiddenIndex;
                                hiddenDatas = hiddenTexts = hiddenIndex = null;
                            }
                            ;
                        }
                        ticks.forEach(function(tickData, index) {
                            var isHidden = index % includeModulo !== 0;
                            if (isHidden && includeModulo > 2) {
                                null == hiddenIndex && (hiddenIndex = index);
                                (hiddenDatas || (hiddenDatas = [])).push(tickData);
                                (hiddenTexts || (hiddenTexts = [])).push(ticksText[index]);
                            } else {
                                hiddenDatas && createHiddenScene();
                                var scene = new pvc.visual.CartesianAxisTickScene(rootScene,{
                                    source: tickData,
                                    tick: tickData.value,
                                    tickRaw: tickData.rawValue,
                                    tickLabel: ticksText[index],
                                    isHidden: isHidden
                                });
                                scene.dataIndex = index;
                            }
                        });
                        hiddenDatas && createHiddenScene();
                    }
                else
                    ticks.forEach(function(majorTick, index) {
                        var scene = new pvc.visual.CartesianAxisTickScene(rootScene,{
                            tick: majorTick,
                            tickRaw: majorTick,
                            tickLabel: ticksText[index]
                        });
                        scene.dataIndex = index;
                    }, this);
            }
            return this._rootScene;
        },
        _buildCompositeScene: function(rootScene) {
            function recursive(scene) {
                var data = scene.group;
                if (isV1Compat) {
                    var tickVar = scene.vars.tick;
                    scene.nodeValue = scene.value = tickVar.rawValue;
                    scene.nodeLabel = scene.label = tickVar.label;
                }
                data.childCount() && data.children().each(function(childData) {
                    var childScene = new pvc.visual.CartesianAxisTickScene(scene,{
                        source: childData,
                        tick: childData.value,
                        tickRaw: childData.rawValue,
                        tickLabel: childData.label
                    });
                    childScene.dataIndex = childData.childIndex();
                    recursive(childScene);
                });
            }
            var isV1Compat = this.compatVersion() <= 1;
            rootScene.vars.tick = new pvc_ValueLabelVar("","");
            recursive(rootScene);
        },
        _getRootData: function() {
            var data;
            if (this.isDiscrete && this.useCompositeAxis) {
                var orient = this.anchor
                  , ka = {
                    visible: this.axis.domainVisibleOnly() ? !0 : null,
                    isNull: this.chart.options.ignoreNulls || this.axis.domainIgnoreNulls() ? !1 : null,
                    reverse: "bottom" == orient || "left" == orient
                };
                data = this.axis.role.select(this.data, ka);
            } else
                data = this.data;
            return data;
        },
        renderOrdinalAxis: function() {
            var wrapper, scale = this.scale, hiddenLabelText = this.hiddenLabelText, includeModulo = this._tickIncludeModulo, hiddenStep2 = includeModulo * scale.range().step / 2, anchorOpposite = this.anchorOpposite(), anchorLength = this.anchorLength(), anchorOrtho = this.anchorOrtho(), anchorOrthoLength = this.anchorOrthoLength(), pvRule = this.pvRule, rootScene = this._getRootScene(), layoutInfo = this._layoutInfo, isV1Compat = this.compatVersion() <= 1;
            if (isV1Compat) {
                var DataElement = function(tickVar) {
                    this.value = this.absValue = tickVar.rawValue;
                    this.nodeName = "" + (this.value || "");
                    this.path = this.nodeName ? [this.nodeName] : [];
                    this.label = this.absLabel = tickVar.label;
                };
                DataElement.prototype.toString = function() {
                    return "" + this.value;
                }
                ;
                wrapper = function(v1f) {
                    return function(tickScene) {
                        var markWrapped = Object.create(this);
                        markWrapped.index = this.parent.index;
                        return v1f.call(markWrapped, new DataElement(tickScene.vars.tick));
                    }
                    ;
                }
                ;
            }
            var pvTicksPanel = new pvc.visual.Panel(this,this.pvPanel,{
                extensionId: "ticksPanel"
            }).lock("data", rootScene.childNodes).lock(anchorOpposite, 0).lockMark(anchorOrtho, function(tickScene) {
                return tickScene.isHidden ? scale(tickScene.previousSibling.vars.tick.value) + hiddenStep2 : scale(tickScene.vars.tick.value);
            }).lock("strokeDasharray", null).lock("strokeStyle", null).lock("fillStyle", null).lock("lineWidth", 0).pvMark.zOrder(20);
            if (isV1Compat || this.showTicks) {
                this.pvTicks = new pvc.visual.Rule(this,pvTicksPanel,{
                    extensionId: "ticks",
                    wrapper: wrapper
                }).lock("data").intercept("visible", function(scene) {
                    return !scene.isHidden && this.delegateExtension(!0);
                }).optional("lineWidth", 1).lock(anchorOpposite, 0).lock(anchorOrtho, 0).lock(anchorLength, null).optional(anchorOrthoLength, 2 * this.tickLength / 3).override("defaultColor", function() {
                    return isV1Compat ? pv.Color.names.transparent : pvRule.scene ? pvRule.scene[0].strokeStyle : "#666666";
                }).pvMark;
            }
            var font = this.font
              , maxTextWidth = this._layoutInfo.maxTextWidth;
            isFinite(maxTextWidth) || (maxTextWidth = 0);
            this.pvLabel = new pvc.visual.Label(this,pvTicksPanel,{
                extensionId: "label",
                showsInteraction: !0,
                noClick: !1,
                noDoubleClick: !1,
                noSelect: !1,
                noTooltip: !1,
                noHover: !1,
                wrapper: wrapper
            }).intercept("visible", function(tickScene) {
                return tickScene.isHidden ? !!tickScene.vars.hiddenLabelText : this.delegateExtension(!0);
            }).intercept("text", function(tickScene) {
                var text;
                if (tickScene.isHidden)
                    text = hiddenLabelText;
                else {
                    text = this.delegateExtension();
                    void 0 === text && (text = tickScene.vars.tick.label);
                    !maxTextWidth || this.showsInteraction() && tickScene.isActive || (text = pvc.text.trimToWidthB(maxTextWidth, text, font, "..", !1));
                }
                return text;
            }).pvMark.zOrder(40).lock(anchorOpposite, this.tickLength).lock(anchorOrtho, 0).font(font).textStyle("#666666").textAlign(layoutInfo.textAlign).textBaseline(layoutInfo.textBaseline);
            this._debugTicksPanel(pvTicksPanel);
        },
        _getTooltipFormatter: function(tipOptions) {
            if (this.axis.option("TooltipEnabled")) {
                tipOptions.gravity = this._calcTipsyGravity();
                var tooltipFormat = this.axis.option("TooltipFormat");
                if (tooltipFormat)
                    return function(context) {
                        return tooltipFormat.call(context, context.scene);
                    }
                    ;
                var autoContent = this.axis.option("TooltipAutoContent");
                if ("summary" === autoContent)
                    return this._summaryTooltipFormatter;
                if ("value" === autoContent) {
                    tipOptions.isLazy = !1;
                    return function(context) {
                        return context.scene.vars.tick.label;
                    }
                    ;
                }
            }
        },
        _debugTicksPanel: function(pvTicksPanel) {
            if (pvc.debug >= 16) {
                var li = (this.font,
                this._layoutInfo)
                  , ticksBBoxes = li.ticksBBoxes || this._calcTicksLabelBBoxes(li);
                pvTicksPanel.add(pv.Panel)[this.anchorOpposite()](this.tickLength)[this.anchorOrtho()](0)[this.anchorLength()](0)[this.anchorOrthoLength()](0).fillStyle(null).strokeStyle(null).lineWidth(0).visible(function(tickScene) {
                    return !tickScene.isHidden;
                }).add(pv.Line).data(function(scene) {
                    var labelBBox = ticksBBoxes[scene.dataIndex]
                      , corners = labelBBox.source.points();
                    corners.length > 1 && (corners = corners.concat(corners[0]));
                    return corners;
                }).left(function(p) {
                    return p.x;
                }).top(function(p) {
                    return p.y;
                }).strokeStyle("red").lineWidth(.5).strokeDasharray("-");
            }
        },
        renderLinearAxis: function() {
            var wrapper, scale = this.scale, pvRule = this.pvRule, anchorOpposite = this.anchorOpposite(), anchorLength = this.anchorLength(), anchorOrtho = this.anchorOrtho(), anchorOrthoLength = this.anchorOrthoLength(), rootScene = this._getRootScene();
            this.compatVersion() <= 1 && (wrapper = function(v1f) {
                return function(tickScene) {
                    var markWrapped = Object.create(this);
                    markWrapped.index = this.parent.index;
                    return v1f.call(markWrapped, tickScene.vars.tick.rawValue);
                }
                ;
            }
            );
            var pvTicksPanel = new pvc.visual.Panel(this,this.pvPanel,{
                extensionId: "ticksPanel"
            }).lock("data", rootScene.childNodes).lock(anchorOpposite, 0).lockMark(anchorOrtho, function(tickScene) {
                return scale(tickScene.vars.tick.value);
            }).lock("strokeStyle", null).lock("fillStyle", null).lock("lineWidth", 0).pvMark.zOrder(20);
            if (this.showTicks) {
                var pvTicks = this.pvTicks = new pvc.visual.Rule(this,pvTicksPanel,{
                    extensionId: "ticks",
                    wrapper: wrapper
                }).lock("data").override("defaultColor", function() {
                    return pvRule.scene ? pvRule.scene[0].strokeStyle : "#666666";
                }).lock(anchorOpposite, 0).lock(anchorOrtho, 0).lock(anchorLength, null).optional(anchorOrthoLength, this.tickLength).pvMark;
                if (this.showMinorTicks) {
                    var layoutInfo = this._layoutInfo
                      , ticks = layoutInfo.ticks
                      , tickCount = ticks.length
                      , minorTickOffset = tickCount > 1 ? Math.abs(scale(ticks[1]) - scale(ticks[0])) / 2 : 0;
                    this.pvMinorTicks = new pvc.visual.Rule(this,this.pvTicks,{
                        extensionId: "minorTicks",
                        wrapper: wrapper
                    }).lock("data").intercept("visible", function(scene) {
                        var visible = scene.childIndex() < tickCount - 1 && (!pvTicks.scene || pvTicks.scene[0].visible);
                        return visible && this.delegateExtension(!0);
                    }).override("defaultColor", function() {
                        return pvTicks.scene ? pvTicks.scene[0].strokeStyle : pv.Color.names.d;
                    }).lock(anchorOpposite, 0).lock(anchorLength, null).optional(anchorOrthoLength, this.tickLength / 2).lockMark(anchorOrtho, minorTickOffset).pvMark;
                }
            }
            this.renderLinearAxisLabel(pvTicksPanel, wrapper);
            this._debugTicksPanel(pvTicksPanel);
        },
        renderLinearAxisLabel: function(pvTicksPanel, wrapper) {
            var anchorOpposite = (this.pvTicks,
            this.anchorOpposite())
              , anchorOrtho = this.anchorOrtho()
              , font = (this.scale,
            this.font)
              , maxTextWidth = this._layoutInfo.maxTextWidth;
            isFinite(maxTextWidth) || (maxTextWidth = 0);
            var pvLabel = this.pvLabel = new pvc.visual.Label(this,pvTicksPanel,{
                extensionId: "label",
                noHover: !1,
                showsInteraction: !0,
                wrapper: wrapper
            }).lock("data").intercept("text", function(tickScene) {
                var text = tickScene.vars.tick.label;
                !maxTextWidth || this.showsInteraction() && tickScene.isActive || (text = pvc.text.trimToWidthB(maxTextWidth, text, font, "..", !1));
                return text;
            }).pvMark.lock(anchorOpposite, this.tickLength).lock(anchorOrtho, 0).zOrder(40).font(this.font).textStyle("#666666")
              , rootPanel = this.pvPanel.root;
            this.isAnchorTopOrBottom() ? pvLabel.textBaseline(anchorOpposite).textAlign(function(tickScene) {
                var absLeft;
                if (0 === this.index) {
                    absLeft = pvLabel.toScreenTransform().transformHPosition(pvLabel.left());
                    if (0 >= absLeft)
                        return "left";
                } else if (this.index === tickScene.parent.childNodes.length - 1) {
                    absLeft = pvLabel.toScreenTransform().transformHPosition(pvLabel.left());
                    if (absLeft >= rootPanel.width())
                        return "right";
                }
                return "center";
            }) : pvLabel.textAlign(anchorOpposite).textBaseline(function(tickScene) {
                var absTop;
                if (0 === this.index) {
                    absTop = pvLabel.toScreenTransform().transformVPosition(pvLabel.top());
                    if (absTop >= rootPanel.height())
                        return "bottom";
                } else if (this.index === tickScene.parent.childNodes.length - 1) {
                    absTop = pvLabel.toScreenTransform().transformVPosition(pvLabel.top());
                    if (0 >= absTop)
                        return "top";
                }
                return "middle";
            });
        },
        _onV1Click: function(context, handler) {
            this.isDiscrete && this.useCompositeAxis && handler.call(context.pvMark, context.scene, context.event);
        },
        _onV1DoubleClick: function(context, handler) {
            this.isDiscrete && this.useCompositeAxis && handler.call(context.pvMark, context.scene, context.event);
        },
        _getSelectableMarks: function() {
            return this.isDiscrete && this.isVisible && this.pvLabel ? this.base() : void 0;
        },
        renderCompositeOrdinalAxis: function() {
            var isTopOrBottom = this.isAnchorTopOrBottom()
              , axisDirection = isTopOrBottom ? "h" : "v"
              , diagDepthCutoff = 2
              , vertDepthCutoff = 2
              , font = this.font
              , diagMargin = pv.Text.fontHeight(font) / 2
              , layout = this._pvLayout = this._getCompositeLayoutSingleCluster();
            layout.node.def("fitInfo", null).height(function(tickScene) {
                var fitInfo = pvc.text.getFitInfo(tickScene.dx, tickScene.dy, tickScene.vars.tick.label, font, diagMargin);
                fitInfo.h || ("v" === axisDirection && fitInfo.v ? vertDepthCutoff = Math.min(diagDepthCutoff, tickScene.depth) : diagDepthCutoff = Math.min(diagDepthCutoff, tickScene.depth));
                this.fitInfo(fitInfo);
                return tickScene.dy;
            });
            layout.node.add(pv.Bar).fillStyle("rgba(127,127,127.00001)").strokeStyle(function(tickScene) {
                return 1 !== tickScene.maxDepth && tickScene.maxDepth ? "rgba(127,127,127,0.3)" : null;
            }).lineWidth(function(tickScene) {
                return 1 !== tickScene.maxDepth && tickScene.maxDepth ? .5 : 0;
            }).text(function(tickScene) {
                return tickScene.vars.tick.label;
            });
            var wrapper, H_CUTOFF_ANG = .3, V_CUTOFF_ANG = 1.27, align = isTopOrBottom ? "center" : "left" == this.anchor ? "right" : "left";
            this.compatVersion() <= 1 && (wrapper = function(v1f) {
                return function(tickScene) {
                    return v1f.call(this, tickScene);
                }
                ;
            }
            );
            this.pvLabel = new pvc.visual.Label(this,layout.label,{
                extensionId: "label",
                noClick: !1,
                noDoubleClick: !1,
                noSelect: !1,
                noTooltip: !1,
                noHover: !1,
                showsInteraction: !0,
                wrapper: wrapper,
                tooltipArgs: {
                    options: {
                        offset: 2 * diagMargin
                    }
                }
            }).pvMark.def("lblDirection", "h").textAngle(function(tickScene) {
                if (tickScene.depth >= vertDepthCutoff && tickScene.depth < diagDepthCutoff) {
                    this.lblDirection("v");
                    return -Math.PI / 2;
                }
                if (tickScene.depth >= diagDepthCutoff) {
                    var tan = tickScene.dy / tickScene.dx
                      , angle = Math.atan(tan);
                    if (angle > V_CUTOFF_ANG) {
                        this.lblDirection("v");
                        return -Math.PI / 2;
                    }
                    if (angle > H_CUTOFF_ANG) {
                        this.lblDirection("d");
                        return -angle;
                    }
                }
                this.lblDirection("h");
                return 0;
            }).textMargin(1).textAlign(function(tickScene) {
                return "v" != axisDirection || tickScene.depth >= vertDepthCutoff || tickScene.depth >= diagDepthCutoff ? "center" : align;
            }).left(function(tickScene) {
                return "v" != axisDirection || tickScene.depth >= vertDepthCutoff || tickScene.depth >= diagDepthCutoff ? tickScene.x + tickScene.dx / 2 : "right" == align ? tickScene.x + tickScene.dx : tickScene.x;
            }).font(font).textStyle("#666666").text(function(tickScene) {
                var label = tickScene.vars.tick.label;
                if (!tickScene.isActive || !this.sign.showsInteraction()) {
                    var fitInfo = this.fitInfo();
                    switch (this.lblDirection()) {
                    case "h":
                        if (!fitInfo.h)
                            return pvc.text.trimToWidthB(tickScene.dx, label, font, "..");
                        break;

                    case "v":
                        if (!fitInfo.v)
                            return pvc.text.trimToWidthB(tickScene.dy, label, font, "..");
                        break;

                    case "d":
                        if (!fitInfo.d) {
                            var diagonalLength = Math.sqrt(def.sqr(tickScene.dy) + def.sqr(tickScene.dx));
                            return pvc.text.trimToWidthB(diagonalLength - diagMargin, label, font, "..");
                        }
                    }
                }
                return label;
            });
        },
        _getCompositeLayoutSingleCluster: function() {
            var rootScene = this._getRootScene()
              , orientation = this.anchor
              , maxDepth = rootScene.group.treeHeight
              , depthLength = this._layoutInfo.axisSize;
            maxDepth++;
            var baseDisplacement = depthLength / maxDepth
              , margin = maxDepth > 2 ? 1 / 12 * depthLength : 0;
            baseDisplacement -= margin;
            var scaleFactor = maxDepth / (maxDepth - 1)
              , orthoLength = pvc.BasePanel.orthogonalLength[orientation]
              , displacement = "width" == orthoLength ? "left" === orientation ? [-baseDisplacement, 0] : [baseDisplacement, 0] : "top" === orientation ? [0, -baseDisplacement] : [0, baseDisplacement];
            this.pvRule.sign.override("defaultColor", def.fun.constant(null)).override("defaultStrokeWidth", def.fun.constant(0));
            var panel = this.pvRule.add(pv.Panel)[orthoLength](depthLength).strokeStyle(null).lineWidth(0).add(pv.Panel)[orthoLength](depthLength * scaleFactor).strokeStyle(null).lineWidth(0);
            panel.transform(pv.Transform.identity.translate(displacement[0], displacement[1]));
            return panel.add(pv.Layout.Cluster.Fill).nodes(rootScene.nodes()).orient(orientation);
        },
        _calcTipsyGravity: function() {
            switch (this.anchor) {
            case "bottom":
                return "s";

            case "top":
                return "n";

            case "left":
                return "w";

            case "right":
                return "e";
            }
            return "s";
        }
    });
    def.type("pvc.AxisTitlePanel", pvc.TitlePanelAbstract).init(function(chart, parent, axis, options) {
        this.axis = axis;
        this.base(chart, parent, options);
        this._extensionPrefix = axis.extensionPrefixes.map(function(prefix) {
            return prefix + "Title";
        });
    }).add({
        _calcLayout: function(layoutInfo) {
            var scale = this.axis.scale;
            return !scale || scale.isNull ? new pvc_Size(0,0) : this.base(layoutInfo);
        },
        _createCore: function(layoutInfo) {
            var scale = this.axis.scale;
            return scale && !scale.isNull ? this.base(layoutInfo) : void 0;
        }
    });
    def.type("pvc.PiePanel", pvc.PlotPanel).init(function(chart, parent, plot, options) {
        var labelStyle = plot.option("ValuesLabelStyle");
        this.base(chart, parent, plot, options);
        this.explodedOffsetRadius = plot.option("ExplodedSliceRadius");
        this.explodedSliceIndex = plot.option("ExplodedSliceIndex");
        this.activeOffsetRadius = plot.option("ActiveSliceRadius");
        this.labelStyle = labelStyle;
        if ("linked" === labelStyle) {
            this.linkInsetRadius = plot.option("LinkInsetRadius");
            this.linkOutsetRadius = plot.option("LinkOutsetRadius");
            this.linkMargin = plot.option("LinkMargin");
            this.linkHandleWidth = plot.option("LinkHandleWidth");
            this.linkLabelSize = plot.option("LinkLabelSize");
            this.linkLabelSpacingMin = plot.option("LinkLabelSpacingMin");
        }
    }).add({
        pvPie: null,
        pvPieLabel: null,
        valueRoleName: "value",
        _getV1Datum: function(scene) {
            var datum = scene.datum;
            if (datum) {
                var datumEx = Object.create(datum);
                datumEx.percent = scene.vars.value.percent;
                datum = datumEx;
            }
            return datum;
        },
        _calcLayout: function(layoutInfo) {
            function resolvePercentRadius(radius) {
                return def.between(pvc_PercentValue.resolve(radius, clientRadius), 0, clientRadius);
            }
            function resolvePercentWidth(width) {
                return def.between(pvc_PercentValue.resolve(width, clientWidth), 0, clientWidth);
            }
            var clientSize = layoutInfo.clientSize
              , clientWidth = clientSize.width
              , clientRadius = Math.min(clientWidth, clientSize.height) / 2;
            if (!clientRadius)
                return new pvc_Size(0,0);
            var center = pv.vector(clientSize.width / 2, clientSize.height / 2)
              , labelFont = this._getConstantExtension("label", "font");
            def.string.is(labelFont) || (labelFont = this.valuesFont);
            var maxPieRadius = clientRadius;
            if (this.valuesVisible && "linked" === this.labelStyle) {
                var linkInsetRadius = resolvePercentRadius(this.linkInsetRadius)
                  , linkOutsetRadius = resolvePercentRadius(this.linkOutsetRadius)
                  , linkMargin = resolvePercentWidth(this.linkMargin)
                  , linkLabelSize = resolvePercentWidth(this.linkLabelSize)
                  , textMargin = def.number.to(this._getConstantExtension("label", "textMargin"), 3)
                  , textHeight = 2 * pv.Text.fontHeight(labelFont) / 3
                  , linkHandleWidth = this.linkHandleWidth * textHeight;
                linkMargin += linkHandleWidth;
                var linkLabelSpacingMin = this.linkLabelSpacingMin * textHeight
                  , freeWidthSpace = Math.max(0, clientWidth / 2 - clientRadius)
                  , spaceH = Math.max(0, linkOutsetRadius + linkMargin + linkLabelSize - freeWidthSpace)
                  , spaceV = linkOutsetRadius + textHeight
                  , linkAndLabelRadius = Math.max(0, spaceV, spaceH);
                if (linkAndLabelRadius >= maxPieRadius) {
                    this.valuesVisible = !1;
                    pvc.debug >= 2 && this._log("Hiding linked labels due to insufficient space.");
                } else {
                    maxPieRadius -= linkAndLabelRadius;
                    layoutInfo.link = {
                        insetRadius: linkInsetRadius,
                        outsetRadius: linkOutsetRadius,
                        elbowRadius: maxPieRadius + linkOutsetRadius,
                        linkMargin: linkMargin,
                        handleWidth: linkHandleWidth,
                        labelSize: linkLabelSize,
                        maxTextWidth: linkLabelSize - textMargin,
                        labelSpacingMin: linkLabelSpacingMin,
                        textMargin: textMargin,
                        lineHeight: textHeight
                    };
                }
            }
            var explodedOffsetRadius = resolvePercentRadius(this.explodedOffsetRadius)
              , activeOffsetRadius = 0;
            this.hoverable() && (activeOffsetRadius = resolvePercentRadius(this.activeOffsetRadius));
            var maxOffsetRadius = explodedOffsetRadius + activeOffsetRadius
              , normalPieRadius = maxPieRadius - maxOffsetRadius;
            if (0 > normalPieRadius)
                return new pvc_Size(0,0);
            layoutInfo.resolvePctRadius = resolvePercentRadius;
            layoutInfo.center = center;
            layoutInfo.clientRadius = clientRadius;
            layoutInfo.normalRadius = normalPieRadius;
            layoutInfo.explodedOffsetRadius = explodedOffsetRadius;
            layoutInfo.activeOffsetRadius = activeOffsetRadius;
            layoutInfo.maxOffsetRadius = maxOffsetRadius;
            layoutInfo.labelFont = labelFont;
        },
        _createCore: function(layoutInfo) {
            var wrapper, me = this, chart = me.chart, rootScene = this._buildScene(), center = layoutInfo.center, normalRadius = layoutInfo.normalRadius, extensionIds = ["slice"];
            if (this.compatVersion() <= 1) {
                extensionIds.push("");
                wrapper = function(v1f) {
                    return function(pieCatScene) {
                        return v1f.call(this, pieCatScene.vars.value.value);
                    }
                    ;
                }
                ;
            }
            this.pvPie = new pvc.visual.PieSlice(this,this.pvPanel,{
                extensionId: extensionIds,
                center: center,
                activeOffsetRadius: layoutInfo.activeOffsetRadius,
                maxOffsetRadius: layoutInfo.maxOffsetRadius,
                resolvePctRadius: layoutInfo.resolvePctRadius,
                wrapper: wrapper,
                tooltipArgs: {
                    options: {
                        useCorners: !0,
                        gravity: function() {
                            var ma = this.midAngle()
                              , isRightPlane = Math.cos(ma) >= 0
                              , isTopPlane = Math.sin(ma) >= 0;
                            return isRightPlane ? isTopPlane ? "nw" : "sw" : isTopPlane ? "ne" : "se";
                        }
                    }
                }
            }).lock("data", rootScene.childNodes).override("angle", function(scene) {
                return scene.vars.value.angle;
            }).override("defaultOffsetRadius", function() {
                var explodeIndex = me.explodedSliceIndex;
                return null == explodeIndex || explodeIndex == this.pvMark.index ? layoutInfo.explodedOffsetRadius : 0;
            }).lockMark("outerRadius", function() {
                return chart.animate(0, normalRadius);
            }).localProperty("innerRadiusEx", pvc_PercentValue.parse).intercept("innerRadius", function() {
                var innerRadius = this.delegateExtension();
                if (null == innerRadius) {
                    var innerRadiusPct = this.pvMark.innerRadiusEx();
                    innerRadius = null != innerRadiusPct ? pvc_PercentValue.resolve(innerRadiusPct, this.pvMark.outerRadius()) || 0 : 0;
                }
                return innerRadius > 0 ? chart.animate(0, innerRadius) : 0;
            }).pvMark;
            if (this.valuesVisible) {
                this.valuesFont = layoutInfo.labelFont;
                if ("inside" === this.labelStyle)
                    this.pvPieLabel = pvc.visual.ValueLabel.maybeCreate(this, this.pvPie, {
                        wrapper: wrapper
                    }).override("defaultText", function(scene) {
                        return scene.vars.value.sliceLabel;
                    }).override("calcTextFitInfo", function(scene, text) {
                        var pvLabel = this.pvMark
                          , tm = pvLabel.textMargin();
                        if (!(-1e-6 > tm)) {
                            var tb = pvLabel.textBaseline();
                            if ("middle" === tb) {
                                var sa = pvc.normAngle(me.pvPie.midAngle())
                                  , la = pvc.normAngle(pvLabel.textAngle())
                                  , sameAngle = Math.abs(sa - la) < 1e-6
                                  , oppoAngle = !1;
                                if (!sameAngle) {
                                    var la2 = pvc.normAngle(la + Math.PI);
                                    oppoAngle = Math.abs(sa - la2) < 1e-6;
                                }
                                if (sameAngle || oppoAngle) {
                                    var va = pvLabel.name()
                                      , ta = pvLabel.textAlign()
                                      , canHandle = "outer" === va ? ta === (sameAngle ? "right" : "left") : !1;
                                    if (canHandle) {
                                        var hide = !1
                                          , m = pv.Text.measure(text, pvLabel.font())
                                          , th = .85 * m.height
                                          , or = me.pvPie.outerRadius()
                                          , ir = me.pvPie.innerRadius()
                                          , a = scene.vars.value.angle
                                          , thEf = th + tm / 2
                                          , irmin = a < Math.PI ? Math.max(ir, thEf / (2 * Math.tan(a / 2))) : ir
                                          , twMax = or - tm - irmin;
                                        hide |= 0 >= twMax;
                                        twMax -= tm;
                                        hide |= this.hideOverflowed && m.width > twMax;
                                        return {
                                            hide: hide,
                                            widthMax: twMax
                                        };
                                    }
                                }
                            }
                        }
                    }).pvMark.textMargin(10);
                else if ("linked" === this.labelStyle) {
                    var linkLayout = layoutInfo.link;
                    rootScene.layoutLinkLabels(layoutInfo);
                    this.pvLinkPanel = this.pvPanel.add(pv.Panel).data(rootScene.childNodes).localProperty("pieSlice").pieSlice(function() {
                        return me.pvPie.scene[this.index];
                    });
                    var f = !1
                      , t = !0;
                    this.pvLinkLine = new pvc.visual.Line(this,this.pvLinkPanel,{
                        extensionId: "linkLine",
                        freePosition: t,
                        noClick: t,
                        noDoubleClick: t,
                        noSelect: t,
                        noTooltip: t,
                        noHover: t,
                        showsActivity: f
                    }).lockMark("data", function(scene) {
                        var pieSlice = this.parent.pieSlice()
                          , midAngle = pieSlice.startAngle + pieSlice.angle / 2
                          , outerRadius = pieSlice.outerRadius - linkLayout.insetRadius
                          , x = pieSlice.left + outerRadius * Math.cos(midAngle)
                          , y = pieSlice.top + outerRadius * Math.sin(midAngle)
                          , firstDotScene = scene.childNodes[0];
                        if (firstDotScene && firstDotScene._isFirstDynamicScene) {
                            firstDotScene.x = x;
                            firstDotScene.y = y;
                        } else {
                            firstDotScene = new pvc.visual.PieLinkLineScene(scene,x,y,0);
                            firstDotScene._isFirstDynamicScene = t;
                        }
                        return scene.childNodes;
                    }).override("defaultColor", function(scene, type) {
                        return "stroke" === type ? "#B6A2DE" : this.base(scene, type);
                    }).override("defaultStrokeWidth", def.fun.constant(.5)).pvMark.lock("visible").lock("top", function(dot) {
                        return dot.y;
                    }).lock("left", function(dot) {
                        return dot.x;
                    });
                    this.pvPieLabel = new pvc.visual.Label(this,this.pvLinkPanel,{
                        extensionId: "label",
                        noClick: f,
                        noDoubleClick: f,
                        noSelect: f,
                        noHover: f,
                        showsInteraction: t
                    }).lockMark("data", function(scene) {
                        return scene.lineScenes;
                    }).intercept("textStyle", function(scene) {
                        this._finished = f;
                        var style = this.delegate();
                        style && !this._finished && !this.mayShowActive(scene) && this.mayShowNotAmongSelected(scene) && (style = this.dimColor(style, "text"));
                        return style;
                    }).pvMark.lock("visible").left(function(scene) {
                        return scene.vars.link.labelX;
                    }).top(function(scene) {
                        return scene.vars.link.labelY + (this.index + 1) * linkLayout.lineHeight;
                    }).textAlign(function(scene) {
                        return scene.vars.link.labelAnchor;
                    }).textMargin(linkLayout.textMargin).textBaseline("bottom").text(function(scene) {
                        return scene.vars.link.labelLines[this.index];
                    });
                    if (pvc.debug >= 20) {
                        this.pvPanel.add(pv.Panel).zOrder(-10).left(center.x - layoutInfo.clientRadius).top(center.y - layoutInfo.clientRadius).width(2 * layoutInfo.clientRadius).height(2 * layoutInfo.clientRadius).strokeStyle("red");
                        this.pvPanel.strokeStyle("red");
                        var linkColors = pv.Colors.category10();
                        this.pvLinkLine.segmented(t).strokeStyle(function() {
                            return linkColors(this.index);
                        });
                    }
                }
                this.pvPieLabel.font(layoutInfo.labelFont);
            }
        },
        _getExtensionId: function() {
            var extensionIds = [{
                abs: "content"
            }];
            this.chart.parent && extensionIds.push({
                abs: "smallContent"
            });
            return extensionIds.concat(this.base());
        },
        renderInteractive: function() {
            this.pvPanel.render();
        },
        _buildScene: function() {
            var rootScene = new pvc.visual.PieRootScene(this);
            this.sum = rootScene.vars.sumAbs.value;
            return rootScene;
        }
    });
    def.type("pvc.visual.PieRootScene", pvc.visual.Scene).init(function(panel) {
        function formatValue(value, categData) {
            if (categData) {
                var datums = categData._datums;
                if (1 === datums.length)
                    return datums[0].atoms[valueDimName].label;
            }
            return valueDim.format(value);
        }
        var categAxis = panel.axes.category
          , categRootData = categAxis.domainData();
        this.base(null, {
            panel: panel,
            source: categRootData
        });
        var colorVarHelper = new pvc.visual.RoleVarHelper(this,panel.visualRoles.color,{
            roleVar: "color"
        })
          , valueDimName = panel.visualRoles[panel.valueRoleName].firstDimensionName()
          , valueDim = categRootData.dimensions(valueDimName)
          , pctValueFormat = panel.chart.options.percentValueFormat
          , angleScale = panel.axes.angle.scale
          , sumAbs = angleScale.isNull ? 0 : angleScale.domain()[1];
        this.vars.sumAbs = new pvc_ValueLabelVar(sumAbs,formatValue(sumAbs));
        var rootScene = this
          , CategSceneClass = def.type(pvc.visual.PieCategoryScene).init(function(categData, value) {
            this.base(rootScene, {
                source: categData
            });
            this.vars.category = pvc_ValueLabelVar.fromComplex(categData);
            var valueVar = new pvc_ValueLabelVar(value,formatValue(value, categData));
            valueVar.angle = angleScale(value);
            var percent = Math.abs(value) / sumAbs;
            valueVar.percent = new pvc_ValueLabelVar(percent,pctValueFormat(percent));
            this.vars.value = valueVar;
            valueVar.sliceLabel = this.sliceLabel();
            colorVarHelper.onNewScene(this, !0);
        });
        panel._extendSceneType("category", CategSceneClass, ["sliceLabel", "sliceLabelMask"]);
        var categDatas = categAxis.domainItems();
        if (categDatas.length) {
            categDatas.forEach(function(categData) {
                var value = categData.dimensions(valueDimName).value();
                0 !== value && new CategSceneClass(categData,value);
            });
            if (!rootScene.childNodes.length && !panel.visualRoles.multiChart.isBound())
                throw new InvalidDataException("Unable to create a pie chart, please check the data values.");
        }
    }).add({
        layoutLinkLabels: function(layoutInfo) {
            var startAngle = -Math.PI / 2
              , leftScenes = []
              , rightScenes = [];
            this.childNodes.forEach(function(categScene) {
                startAngle = categScene.layoutI(layoutInfo, startAngle);
                (categScene.vars.link.dir > 0 ? rightScenes : leftScenes).push(categScene);
            });
            this._distributeLabels(-1, leftScenes, layoutInfo);
            this._distributeLabels(1, rightScenes, layoutInfo);
        },
        _distributeLabels: function(dir, scenes, layoutInfo) {
            scenes.sort(function(sceneA, sceneB) {
                return def.compare(sceneA.vars.link.targetY, sceneB.vars.link.targetY);
            });
            this._distributeLabelsDownwards(scenes, layoutInfo) && this._distributeLabelsUpwards(scenes, layoutInfo) && this._distributeLabelsEvenly(scenes, layoutInfo);
            scenes.forEach(function(categScene) {
                categScene.layoutII(layoutInfo);
            });
        },
        _distributeLabelsDownwards: function(scenes, layoutInfo) {
            for (var linkLayout = layoutInfo.link, labelSpacingMin = linkLayout.labelSpacingMin, yMax = layoutInfo.clientSize.height, overlapping = !1, i = 0, J = scenes.length - 1; J > i; i++) {
                var linkVar0 = scenes[i].vars.link;
                !i && linkVar0.labelTop() < 0 && (overlapping = !0);
                var linkVar1 = scenes[i + 1].vars.link
                  , labelTopMin1 = linkVar0.labelBottom() + labelSpacingMin;
                if (linkVar1.labelTop() < labelTopMin1) {
                    var halfLabelHeight1 = linkVar1.labelHeight / 2
                      , targetY1 = labelTopMin1 + halfLabelHeight1
                      , targetYMax = yMax - halfLabelHeight1;
                    if (targetY1 > targetYMax) {
                        overlapping = !0;
                        linkVar1.targetY = targetYMax;
                    } else
                        linkVar1.targetY = targetY1;
                }
            }
            return overlapping;
        },
        _distributeLabelsUpwards: function(scenes, layoutInfo) {
            for (var linkLayout = layoutInfo.link, labelSpacingMin = linkLayout.labelSpacingMin, overlapping = !1, i = scenes.length - 1; i > 0; i--) {
                var linkVar1 = scenes[i - 1].vars.link
                  , linkVar0 = scenes[i].vars.link;
                1 === i && linkVar1.labelTop() < 0 && (overlapping = !0);
                var labelBottomMax1 = linkVar0.labelTop() - labelSpacingMin;
                if (linkVar1.labelBottom() > labelBottomMax1) {
                    var halfLabelHeight1 = linkVar1.labelHeight / 2
                      , targetY1 = labelBottomMax1 - halfLabelHeight1
                      , targetYMin = halfLabelHeight1;
                    if (targetYMin > targetY1) {
                        overlapping = !0;
                        linkVar1.targetY = targetYMin;
                    } else
                        linkVar1.targetY = targetY1;
                }
            }
            return overlapping;
        },
        _distributeLabelsEvenly: function(scenes, layoutInfo) {
            var totalHeight = 0;
            scenes.forEach(function(categScene) {
                totalHeight += categScene.vars.link.labelHeight;
            });
            var freeSpace = layoutInfo.clientSize.height - totalHeight
              , labelSpacing = freeSpace;
            scenes.length > 1 && (labelSpacing /= scenes.length - 1);
            var y = 0;
            scenes.forEach(function(scene) {
                var linkVar = scene.vars.link
                  , halfLabelHeight = linkVar.labelHeight / 2;
                y += halfLabelHeight;
                linkVar.targetY = y;
                y += halfLabelHeight + labelSpacing;
            });
            return !0;
        }
    });
    def.type("pvc.visual.PieLinkLabelVar").add({
        labelTop: function() {
            return this.targetY - this.labelHeight / 2;
        },
        labelBottom: function() {
            return this.targetY + this.labelHeight / 2;
        }
    });
    def.type("pvc.visual.PieCategoryScene", pvc.visual.Scene).add({
        sliceLabelMask: function() {
            return this.panel().valuesMask;
        },
        sliceLabel: function() {
            return this.format(this.sliceLabelMask());
        },
        layoutI: function(layoutInfo, startAngle) {
            var valueVar = this.vars.value
              , endAngle = startAngle + valueVar.angle
              , midAngle = (startAngle + endAngle) / 2
              , linkVar = this.vars.link = new pvc.visual.PieLinkLabelVar()
              , linkLayout = layoutInfo.link
              , labelLines = pvc.text.justify(valueVar.sliceLabel, linkLayout.maxTextWidth, layoutInfo.labelFont)
              , lineCount = labelLines.length;
            linkVar.labelLines = labelLines;
            linkVar.labelHeight = lineCount * linkLayout.lineHeight;
            this.lineScenes = def.array.create(lineCount, this);
            var cosMid = Math.cos(midAngle)
              , sinMid = Math.sin(midAngle)
              , isAtRight = cosMid >= 0
              , dir = isAtRight ? 1 : -1;
            linkVar.labelAnchor = isAtRight ? "left" : "right";
            var center = layoutInfo.center
              , elbowRadius = linkLayout.elbowRadius
              , elbowX = center.x + elbowRadius * cosMid
              , elbowY = center.y + elbowRadius * sinMid
              , anchorX = center.x + dir * elbowRadius
              , targetX = anchorX + dir * linkLayout.linkMargin;
            new pvc.visual.PieLinkLineScene(this,elbowX,elbowY);
            new pvc.visual.PieLinkLineScene(this,anchorX,elbowY);
            linkVar.elbowY = elbowY;
            linkVar.targetY = elbowY + 0;
            linkVar.targetX = targetX;
            linkVar.dir = dir;
            return endAngle;
        },
        layoutII: function(layoutInfo) {
            var linkVar = this.vars.link
              , targetY = linkVar.targetY
              , targetX = linkVar.targetX
              , handleWidth = layoutInfo.link.handleWidth;
            handleWidth > 0 && new pvc.visual.PieLinkLineScene(this,targetX - linkVar.dir * handleWidth,targetY);
            new pvc.visual.PieLinkLineScene(this,targetX,targetY);
            linkVar.labelX = targetX;
            linkVar.labelY = targetY - linkVar.labelHeight / 2;
        }
    });
    def.type("pvc.visual.PieLinkLineScene", pvc.visual.Scene).init(function(catScene, x, y, index) {
        this.base(catScene, {
            source: catScene.group,
            index: index
        });
        this.x = x;
        this.y = y;
    }).add(pv.Vector);
    def.type("pvc.PieChart", pvc.BaseChart).add({
        _animatable: !0,
        _axisClassByType: {
            category: pvc.visual.Axis,
            angle: pvc.visual.NormalizedAxis
        },
        _axisCreateChartLevel: {
            category: 2,
            angle: 2
        },
        _axisSetScaleChartLevel: {
            category: 2,
            angle: 2
        },
        _axisCreationOrder: function() {
            var a = pvc.BaseChart.prototype._axisCreationOrder.slice();
            a.push("category", "angle");
            return a;
        }(),
        pieChartPanel: null,
        _getColorRoleSpec: function() {
            return {
                isRequired: !0,
                defaultSourceRole: "category",
                defaultDimension: "color*",
                requireIsDiscrete: !0
            };
        },
        _initVisualRoles: function() {
            this.base();
            this._addVisualRole("category", {
                isRequired: !0,
                defaultDimension: "category*",
                autoCreateDimension: !0
            });
            this._addVisualRole("value", {
                isMeasure: !0,
                isRequired: !0,
                isPercent: !0,
                requireSingleDimension: !0,
                requireIsDiscrete: !1,
                valueType: Number,
                defaultDimension: "value"
            });
        },
        _initPlotsCore: function() {
            new pvc.visual.PiePlot(this);
        },
        _createVisibleData: function(baseData, ka) {
            return this.visualRoles.category.flatten(baseData, ka);
        },
        _setAxisScale: function(axis, chartLevel) {
            this.base(axis, chartLevel);
            2 & chartLevel && "angle" === axis.type && axis.setScaleRange({
                min: 0,
                max: 2 * Math.PI
            });
        },
        _createContent: function(contentOptions) {
            this.base();
            var isV1Compat = this.compatVersion() <= 1;
            if (isV1Compat) {
                var innerGap = pvc.castNumber(this.options.innerGap) || .95;
                innerGap = def.between(innerGap, .1, 1);
                contentOptions.paddings = (100 * (1 - innerGap) / 2).toFixed(2) + "%";
            } else
                null == contentOptions.paddings && (contentOptions.paddings = new pvc_PercentValue(.025));
            var piePlot = this.plots.pie;
            this.pieChartPanel = new pvc.PiePanel(this,this.basePanel,piePlot,def.create(contentOptions, {
                scenes: def.getPath(this.options, "pie.scenes")
            }));
        }
    });
    def.type("pvc.BarAbstractPanel", pvc.CategoricalAbstractPanel).add({
        pvBar: null,
        pvBarLabel: null,
        pvCategoryPanel: null,
        pvSecondLine: null,
        pvSecondDot: null,
        _creating: function() {
            var groupScene = this.defaultLegendGroupScene();
            if (groupScene && !groupScene.hasRenderer()) {
                var colorAxis = groupScene.colorAxis
                  , drawLine = colorAxis.option("LegendDrawLine")
                  , drawMarker = !drawLine || colorAxis.option("LegendDrawMarker");
                if (drawMarker) {
                    var keyArgs = {
                        drawMarker: !0,
                        markerShape: colorAxis.option("LegendShape"),
                        drawRule: drawLine,
                        markerPvProto: new pv_Mark()
                    };
                    this.extend(keyArgs.markerPvProto, "", {
                        constOnly: !0
                    });
                    groupScene.renderer(new pvc.visual.legend.BulletItemDefaultRenderer(keyArgs));
                }
            }
        },
        _createCore: function() {
            this.base();
            var barWidth, seriesCount, me = this, chart = me.chart, plot = me.plot, isStacked = !!me.stacked, isVertical = me.isOrientationVertical(), data = me.visibleData({
                ignoreNulls: !1
            }), orthoAxis = me.axes.ortho, baseAxis = me.axes.base, axisCategDatas = baseAxis.domainItems(), axisSeriesDatas = me.visualRoles.series.flatten(me.partData(), {
                visible: !0,
                isNull: chart.options.ignoreNulls ? !1 : null
            }).childNodes, rootScene = me._buildScene(data, axisSeriesDatas, axisCategDatas), orthoScale = orthoAxis.scale, orthoZero = orthoScale(0), sceneOrthoScale = orthoAxis.sceneScale({
                sceneVarName: "value",
                nullToZero: !1
            }), sceneBaseScale = baseAxis.sceneScale({
                sceneVarName: "category"
            }), barSizeRatio = plot.option("BarSizeRatio"), barSizeMax = plot.option("BarSizeMax"), barStackedMargin = plot.option("BarStackedMargin"), barOrthoSizeMin = plot.option("BarOrthoSizeMin"), baseRange = baseAxis.scale.range(), bandWidth = baseRange.band, barStepWidth = baseRange.step, barMarginWidth = baseRange.margin, reverseSeries = isVertical === isStacked;
            if (isStacked)
                barWidth = bandWidth;
            else {
                seriesCount = axisSeriesDatas.length;
                barWidth = seriesCount ? 1 === seriesCount ? bandWidth : barSizeRatio * bandWidth / seriesCount : 0;
            }
            barWidth > barSizeMax && (barWidth = barSizeMax);
            me.barWidth = barWidth;
            me.barStepWidth = barStepWidth;
            var wrapper;
            me.compatVersion() <= 1 && (wrapper = function(v1f) {
                return function(scene) {
                    var markParent = Object.create(this.parent)
                      , mark = Object.create(this);
                    mark.parent = markParent;
                    var serIndex = scene.parent.childIndex()
                      , catIndex = scene.childIndex();
                    if (isStacked) {
                        markParent.index = serIndex;
                        mark.index = catIndex;
                    } else {
                        markParent.index = catIndex;
                        mark.index = serIndex;
                    }
                    return v1f.call(mark, scene.vars.value.rawValue);
                }
                ;
            }
            );
            me.pvBarPanel = new pvc.visual.Panel(me,me.pvPanel,{
                panelType: pv.Layout.Band,
                extensionId: "panel"
            }).lock("layers", rootScene.childNodes).lockMark("values", function(seriesScene) {
                return seriesScene.childNodes;
            }).lockMark("orient", isVertical ? "bottom-left" : "left-bottom").lockMark("layout", isStacked ? "stacked" : "grouped").lockMark("verticalMode", me._barVerticalMode()).lockMark("yZero", orthoZero).optionalMark("hZero", barOrthoSizeMin).pvMark.band.x(sceneBaseScale).w(bandWidth).differentialControl(me._barDifferentialControl()).item.order(reverseSeries ? "reverse" : null).h(function(scene) {
                var y = sceneOrthoScale(scene);
                return null != y ? chart.animate(0, y - orthoZero) : null;
            }).w(barWidth).horizontalRatio(barSizeRatio).verticalMargin(barStackedMargin).end;
            var widthNeedsAntialias = 4 >= barWidth || 2 > barMarginWidth
              , pvBar = this.pvBar = new pvc.visual.Bar(me,me.pvBarPanel.item,{
                extensionId: "",
                freePosition: !0,
                wrapper: wrapper
            }).lockDimensions().pvMark.antialias(function(scene) {
                if (widthNeedsAntialias)
                    return !0;
                var y = sceneOrthoScale(scene)
                  , h = null == y ? 0 : Math.abs(y - orthoZero);
                return 1e-8 > h;
            });
            plot.option("OverflowMarkersVisible") && this._addOverflowMarkers(wrapper);
            var label = pvc.visual.ValueLabel.maybeCreate(me, pvBar, {
                wrapper: wrapper
            });
            if (label) {
                var labelBarOrthoLen;
                if (label.hideOrTrimOverflowed) {
                    labelBarOrthoLen = bandWidth;
                    !isStacked && seriesCount > 1 && (labelBarOrthoLen /= seriesCount);
                }
                me.pvBarLabel = label.override("calcTextFitInfo", function(scene, text) {
                    var pvLabel = this.pvMark
                      , tm = pvLabel.textMargin();
                    if (!(-1e-6 > tm)) {
                        var a = pvLabel.textAngle()
                          , sinAngle = Math.sin(a)
                          , isHorizText = Math.abs(sinAngle) < 1e-6
                          , isVertiText = !isHorizText && Math.abs(Math.cos(a)) < 1e-6;
                        if (isHorizText || isVertiText && isVertical) {
                            var twMax, isInside, isTaCenter, h = pvBar.height(), w = pvBar.width(), ml = isVertical ? h : w, al = isVertical ? w : h, m = pv.Text.measure(text, pvLabel.font()), th = .75 * m.height, tw = m.width, va = pvLabel.name(), tb = pvLabel.textBaseline(), ta = pvLabel.textAlign(), isVaCenter = "center" === va, hide = !1;
                            if (isVertical)
                                if (isHorizText) {
                                    isInside = isVaCenter || va === tb;
                                    if (!isInside)
                                        return;
                                    hide |= isVaCenter && "middle" !== tb ? th + tm > ml / 2 : th + 2 * tm > ml;
                                } else {
                                    hide |= th > ml;
                                    isTaCenter = "center" === ta;
                                    isInside = isVaCenter;
                                    isInside || isTaCenter || (isInside = sinAngle >= 1e-6 ? "left" === ta ? "top" === va : "bottom" === va : "left" === ta ? "bottom" === va : "top" === va);
                                    if (isInside) {
                                        twMax = !isVaCenter || isTaCenter ? ml - 2 * tm : (ml - tm) / 2;
                                        hide |= ("middle" === tb ? th > al : th > al / 2) || this.hideOverflowed && tw > twMax;
                                    } else
                                        hide |= th >= Math.max(al, labelBarOrthoLen);
                                }
                            else {
                                hide |= th > ml;
                                isInside = isVaCenter || va === ta;
                                if (isInside) {
                                    twMax = isVaCenter && "center" !== ta ? (ml - tm) / 2 : ml - 2 * tm;
                                    hide |= ("middle" === tb ? th > al : th > al / 2) || this.hideOverflowed && tw > twMax;
                                } else
                                    hide |= th >= Math.max(al, labelBarOrthoLen);
                            }
                            return {
                                hide: hide,
                                widthMax: twMax
                            };
                        }
                    }
                }).pvMark;
            }
        },
        _barVerticalMode: function() {
            return null;
        },
        _barDifferentialControl: function() {
            return null;
        },
        _getV1Datum: function(scene) {
            var datum = scene.datum;
            if (datum) {
                var datumEx = Object.create(datum);
                datumEx.percent = scene.vars.value.percent;
                datum = datumEx;
            }
            return datum;
        },
        _addOverflowMarkers: function(wrapper) {
            var orthoAxis = this.axes.ortho;
            null != orthoAxis.option("FixedMax") && (this.pvOverflowMarker = this._addOverflowMarker(!1, orthoAxis.scale, wrapper));
            null != orthoAxis.option("FixedMin") && (this.pvUnderflowMarker = this._addOverflowMarker(!0, orthoAxis.scale, wrapper));
        },
        _addOverflowMarker: function(isMin, orthoScale, wrapper) {
            var angle, isVertical = this.isOrientationVertical(), a_bottom = isVertical ? "bottom" : "left", a_top = this.anchorOpposite(a_bottom), a_height = this.anchorOrthoLength(a_bottom), a_width = this.anchorLength(a_bottom), paddings = this._layoutInfo.paddings, rOrthoBound = isMin ? orthoScale.min - paddings[a_bottom] : orthoScale.max + paddings[a_top];
            angle = isMin ? isVertical ? 0 : Math.PI / 2 : isVertical ? Math.PI : -Math.PI / 2;
            return new pvc.visual.Dot(this,this.pvBar.anchor("center"),{
                noSelect: !0,
                noHover: !0,
                noClick: !0,
                noDoubleClick: !0,
                noTooltip: !0,
                freePosition: !0,
                extensionId: isMin ? "underflowMarker" : "overflowMarker",
                wrapper: wrapper
            }).intercept("visible", function(scene) {
                var visible = this.delegateExtension();
                if (void 0 !== visible && !visible)
                    return !1;
                var value = scene.vars.value.value;
                if (null == value)
                    return !1;
                var targetInstance = this.pvMark.scene.target[this.pvMark.index]
                  , orthoMaxPos = targetInstance[a_bottom] + (value > 0 ? targetInstance[a_height] : 0);
                return isMin ? rOrthoBound > orthoMaxPos : orthoMaxPos > rOrthoBound;
            }).lock(a_top, null).lock("shapeSize").pvMark.shape("triangle").shapeRadius(function() {
                return Math.min(Math.sqrt(10), this.scene.target[this.index][a_width] / 2);
            }).shapeAngle(angle).lineWidth(1.5).strokeStyle("red").fillStyle("white")[a_bottom](function() {
                return rOrthoBound + (isMin ? 1 : -1) * (this.shapeRadius() + 2);
            });
        },
        renderInteractive: function() {
            this.pvPanel.render();
        },
        _buildScene: function(data, axisSeriesDatas, axisCategDatas) {
            function createSeriesScene(axisSeriesData) {
                var seriesScene = new pvc.visual.Scene(rootScene,{
                    source: axisSeriesData
                })
                  , seriesKey = axisSeriesData.key;
                seriesScene.vars.series = pvc_ValueLabelVar.fromComplex(axisSeriesData);
                colorVarHelper.onNewScene(seriesScene, !1);
                axisCategDatas.forEach(function(axisCategData) {
                    var categData = data.child(axisCategData.key)
                      , group = categData && categData.child(seriesKey)
                      , scene = new pvc.visual.Scene(seriesScene,{
                        source: group
                    })
                      , categVar = scene.vars.category = pvc_ValueLabelVar.fromComplex(categData);
                    categVar.group = categData;
                    valueVarHelper.onNewScene(scene, !0);
                    colorVarHelper.onNewScene(scene, !0);
                });
            }
            var rootScene = new pvc.visual.Scene(null,{
                panel: this,
                source: data
            })
              , roles = (data.childNodes,
            this.visualRoles)
              , valueVarHelper = new pvc.visual.RoleVarHelper(rootScene,roles.value,{
                roleVar: "value",
                hasPercentSubVar: this.stacked
            })
              , colorVarHelper = new pvc.visual.RoleVarHelper(rootScene,roles.color,{
                roleVar: "color"
            });
            axisSeriesDatas.forEach(createSeriesScene);
            return rootScene;
        }
    });
    def.type("pvc.BarAbstract", pvc.CategoricalAbstract).init(function(options) {
        this.base(options);
        var parent = this.parent;
        parent && (this._valueRole = parent._valueRole);
    }).add({
        _initVisualRoles: function() {
            this.base();
            this._addVisualRole("value", {
                isMeasure: !0,
                isRequired: !0,
                isPercent: this.options.stacked,
                requireSingleDimension: !0,
                requireIsDiscrete: !1,
                valueType: Number,
                defaultDimension: "value"
            });
            this._valueRole = this.visualRoles.value;
        },
        _getCategoryRoleSpec: function() {
            var catRoleSpec = this.base();
            catRoleSpec.requireIsDiscrete = !0;
            return catRoleSpec;
        },
        _initData: function() {
            this.base.apply(this, arguments);
            var data = this.data;
            this._valueDim = data.dimensions(this._valueRole.firstDimensionName());
        }
    });
    def.type("pvc.BarPanel", pvc.BarAbstractPanel).add({//_createline:function(){
    //	return new pvc.LineChart()
    //}
    });
    def.type("pvc.BarChart", pvc.BarAbstract).add({
        _animatable: !0,
        _trendable: !0,
        _allowV1SecondAxis: !0,
        _initPlotsCore: function() {
            var options = this.options
              , barPlot = new pvc.visual.BarPlot(this)
              , trend = barPlot.option("Trend");
            if (options.plot2) {
                var plot2Plot = new pvc.visual.PointPlot(this,{
                    name: "plot2",
                    fixed: {
                        DataPart: "1"
                    },
                    defaults: {
                        ColorAxis: 2,
                        LinesVisible: !0,
                        DotsVisible: !0
                    }
                });
                trend || (trend = plot2Plot.option("Trend"));
            }
            this._trendable = !!trend;
            trend && new pvc.visual.PointPlot(this,{
                name: "trend",
                fixed: {
                    DataPart: "trend",
                    TrendType: "none",
                    ColorRole: "series",
                    NullInterpolatioMode: "none"
                },
                defaults: {
                    ColorAxis: 2,
                    LinesVisible: !0,
                    DotsVisible: !0
                }
            });
        },
        _hasDataPartRole: function() {
            return !0;
        },
        _createPlotPanels: function(parentPanel, baseOptions) {
            var plots = this.plots
              , barPlot = plots.bar
              , barPanel = new pvc.BarPanel(this,parentPanel,barPlot,Object.create(baseOptions));
            this.barChartPanel = barPanel;
            var plot2Plot = plots.plot2;
            if (plot2Plot) {
                pvc.debug >= 3 && this._log("Creating Point panel.");
                var pointPanel = new pvc.PointPanel(this,parentPanel,plot2Plot,Object.create(baseOptions));
                barPanel.pvSecondLine = pointPanel.pvLine;
                barPanel.pvSecondDot = pointPanel.pvDot;
                pointPanel._applyV1BarSecondExtensions = !0;
            }
            var trendPlot = plots.trend;
            if (trendPlot) {
                pvc.debug >= 3 && this._log("Creating Trends Point panel.");
                new pvc.PointPanel(this,parentPanel,trendPlot,Object.create(baseOptions));
            }
        }

    });
    def.type("pvc.NormalizedBarPanel", pvc.BarAbstractPanel).add({
        _barVerticalMode: function() {
            return "expand";
        }
    });
    def.type("pvc.NormalizedBarChart", pvc.BarAbstract).add({
        _processOptionsCore: function(options) {
            options.stacked = !0;
            this.base(options);
        },
        _getContinuousVisibleExtentConstrained: function(axis, min, max) {
            return "ortho" === axis.type ? {
                min: 0,
                max: 100,
                minLocked: !0,
                maxLocked: !0
            } : this.base(axis, min, max);
        },
        _initPlotsCore: function() {
            new pvc.visual.NormalizedBarPlot(this);
        },
        _createPlotPanels: function(parentPanel, baseOptions) {
            var barPlot = this.plots.bar;
            this.barChartPanel = new pvc.NormalizedBarPanel(this,parentPanel,barPlot,Object.create(baseOptions));
        }
    });
    def.type("pvc.visual.legend.WaterfallBulletGroupScene", pvc.visual.legend.BulletGroupScene).init(function(rootScene, keyArgs) {
        keyArgs = def.set(keyArgs, "clickMode", "none");
        this.base(rootScene, keyArgs);
        this.createItem(keyArgs);
    }).add({
        renderer: function(renderer) {
            null != renderer && (this._renderer = renderer);
            return this._renderer;
        },
        itemSceneType: function() {
            return pvc.visual.legend.WaterfallBulletItemScene;
        }
    });
    def.type("pvc.visual.legend.WaterfallBulletItemScene", pvc.visual.legend.BulletItemScene).init(function(bulletGroup, keyArgs) {
        this.base.apply(this, arguments);
        var I = pvc.visual.Interactive;
        this._ibits = I.Interactive | I.ShowsInteraction;
        this.color = def.get(keyArgs, "color");
        this.vars.value = new pvc_ValueLabelVar(null,def.get(keyArgs, "label"));
    });
    def.type("pvc.WaterfallPanel", pvc.BarAbstractPanel).add({
        pvWaterfallLine: null,
        ruleData: null,
        _barDifferentialControl: function() {
            var isFalling = this.chart._isFalling;
            return function(scene) {
                if (isFalling && !this.index)
                    return 1;
                var group = scene.vars.category.group
                  , isProperGroup = group._isFlattenGroup && !group._isDegenerateFlattenGroup;
                return isProperGroup ? -2 : isFalling ? -1 : 1;
            }
            ;
        },
        _creating: function() {
            var rootScene = this._getLegendBulletRootScene();
            if (rootScene) {
                var waterfallGroupScene = rootScene.firstChild;
                if (waterfallGroupScene && !waterfallGroupScene.hasRenderer()) {
                    var keyArgs = {
                        drawRule: !0,
                        drawMarker: !0,
                        rulePvProto: new pv_Mark()
                    };
                    this.extend(keyArgs.rulePvProto, "line", {
                        constOnly: !0
                    });
                    waterfallGroupScene.renderer(new pvc.visual.legend.BulletItemDefaultRenderer(keyArgs));
                }
            }
        },
        _createCore: function() {
            this.base();
            var chart = this.chart
              , isVertical = this.isOrientationVertical()
              , anchor = isVertical ? "bottom" : "left"
              , ao = this.anchorOrtho(anchor)
              , ruleRootScene = this._buildRuleScene()
              , orthoScale = chart.axes.ortho.scale
              , orthoZero = orthoScale(0)
              , sceneOrthoScale = chart.axes.ortho.sceneScale({
                sceneVarName: "value"
            })
              , sceneBaseScale = chart.axes.base.sceneScale({
                sceneVarName: "category"
            })
              , baseScale = chart.axes.base.scale
              , barWidth2 = this.barWidth / 2
              , barWidth = this.barWidth
              , barStepWidth = this.barStepWidth
              , isFalling = chart._isFalling
              , waterColor = chart._waterColor;
            if (this.plot.option("AreasVisible")) {
                var panelColors = pv.Colors.category10()
                  , waterGroupRootScene = this._buildWaterGroupScene()
                  , orthoRange = orthoScale.range()
                  , orthoPanelMargin = .04 * (orthoRange[1] - orthoRange[0]);
                this.pvWaterfallGroupPanel = new pvc.visual.Panel(this,this.pvPanel,{
                    extensionId: "group"
                }).lock("data", waterGroupRootScene.childNodes).pvMark.zOrder(-1).fillStyle(function() {
                    return panelColors(0).alpha(.15);
                })[ao](function(scene) {
                    var c = scene.vars.category;
                    return baseScale(c.valueLeft) - barStepWidth / 2;
                })[this.anchorLength(anchor)](function(scene) {
                    var c = scene.vars.category
                      , len = Math.abs(baseScale(c.valueRight) - baseScale(c.valueLeft));
                    return len + barStepWidth;
                })[anchor](function(scene) {
                    var v = scene.vars.value
                      , b = orthoScale(v.valueBottom) - orthoPanelMargin / 2;
                    return chart.animate(orthoZero, b);
                })[this.anchorOrthoLength(anchor)](function(scene) {
                    var v = scene.vars.value
                      , h = orthoScale(v.valueTop) - orthoScale(v.valueBottom) + orthoPanelMargin;
                    return chart.animate(0, h);
                });
            }
            this.pvBar.sign.override("baseColor", function(scene, type) {
                var color = this.base(scene, type);
                return "fill" !== type || scene.vars.category.group._isFlattenGroup ? color : pv.color(color).alpha(.5);
            });
            this.pvWaterfallLine = new pvc.visual.Rule(this,this.pvPanel,{
                extensionId: "line",
                noTooltip: !1,
                noHover: !1,
                noSelect: !1,
                noClick: !1,
                noDoubleClick: !1
            }).lock("data", ruleRootScene.childNodes).optional("visible", function(scene) {
                return isFalling && !!scene.previousSibling || !isFalling && !!scene.nextSibling;
            }).optional(anchor, function(scene) {
                return orthoZero + chart.animate(0, sceneOrthoScale(scene) - orthoZero);
            }).optional(this.anchorLength(anchor), barStepWidth + barWidth).optional(ao, isFalling ? function(scene) {
                return sceneBaseScale(scene) - barStepWidth - barWidth2;
            }
            : function(scene) {
                return sceneBaseScale(scene) - barWidth2;
            }
            ).override("defaultColor", def.fun.constant(waterColor)).pvMark.antialias(!0).lineCap("butt");
            this.plot.option("TotalValuesVisible") && (this.pvWaterfallLabel = new pvc.visual.Label(this,this.pvWaterfallLine,{
                extensionId: "lineLabel"
            }).intercept("visible", function(scene) {
                return scene.vars.category.group._isFlattenGroup ? !1 : isFalling || !!scene.nextSibling;
            }).pvMark[anchor](function(scene) {
                return orthoZero + chart.animate(0, sceneOrthoScale(scene) - orthoZero);
            })[this.anchorOrtho(anchor)](sceneBaseScale).textAlign(isVertical ? "center" : "left").textBaseline(function(categScene) {
                if (!isVertical)
                    return "middle";
                var direction = categScene.vars.direction;
                if (null == direction)
                    return "bottom";
                var isRising = !isFalling;
                return isRising === ("up" === direction) ? "bottom" : "top";
            }).textStyle(pv.Color.names.darkgray.darker(2)).textMargin(5).text(function(scene) {
                return scene.vars.value.label;
            }));
        },
        _buildRuleScene: function() {
            function createCategScene(ruleInfo) {
                var categData1 = ruleInfo.group
                  , categScene = new pvc.visual.Scene(rootScene,{
                    source: categData1
                })
                  , categVar = categScene.vars.category = pvc_ValueLabelVar.fromComplex(categData1);
                categVar.group = categData1;
                var value = ruleInfo.offset;
                categScene.vars.value = new pvc_ValueLabelVar(value,this.chart._valueDim.format(value));
            }
            function completeCategScene(categScene, index) {
                var value = categScene.vars.value.value;
                categScene.vars.direction = index && prevValue !== value ? isClimbing === value > prevValue ? "up" : "down" : null;
                prevValue = value;
            }
            var prevValue, isClimbing, rootScene = new pvc.visual.Scene(null,{
                panel: this,
                source: this.visibleData({
                    ignoreNulls: !1
                })
            }), ris = this.chart._ruleInfos;
            if (ris) {
                ris.forEach(createCategScene, this);
                var q = def.query(rootScene.childNodes);
                isClimbing = !this.chart._isFalling;
                isClimbing || (q = q.reverse());
                q.each(completeCategScene, this);
            }
            return rootScene;
        },
        _buildWaterGroupScene: function() {
            function createRectangleSceneRecursive(catData, level) {
                var q = catData.children().where(function(c) {
                    return "" !== c.key;
                });
                if (q.next()) {
                    level && createRectangleScene(catData, level);
                    level++;
                    do
                        createRectangleSceneRecursive(q.item, level);
                    while (q.next());
                }
            }
            function createRectangleScene(catData, level) {
                var rectScene = new pvc.visual.Scene(rootScene,{
                    source: catData
                })
                  , categVar = rectScene.vars.category = pvc_ValueLabelVar.fromComplex(catData);
                categVar.group = catData;
                categVar.level = level;
                var leafData, leafRuleInfo, lc, rc, bv, valueVar = rectScene.vars.value = {}, ri = ruleInfoByCategKey[catData.absKey], offset = ri.offset, range = ri.range, height = -range.min + range.max;
                if (isFalling) {
                    leafData = lastLeaf(catData);
                    leafRuleInfo = ruleInfoByCategKey[leafData.absKey];
                    lc = ri.group.value;
                    rc = leafRuleInfo.group.value;
                    bv = offset - range.max;
                } else {
                    leafData = firstLeaf(catData);
                    leafRuleInfo = ruleInfoByCategKey[leafData.absKey];
                    lc = leafRuleInfo.group.value;
                    rc = ri.group.value;
                    bv = offset - range.max;
                }
                categVar.valueLeft = lc;
                categVar.valueRight = rc;
                valueVar.valueHeight = height;
                valueVar.valueBottom = bv;
                valueVar.valueTop = bv + height;
            }
            function firstLeaf(data) {
                var children = data.childNodes
                  , first = children && children[0];
                return first ? firstLeaf(first) : data;
            }
            function lastLeaf(data) {
                var children = data.childNodes
                  , last = children && children[children.length - 1];
                return last ? lastLeaf(last) : data;
            }
            var ruleInfoByCategKey, isFalling, chart = this.chart, rootCatData = chart._catRole.select(chart.partData(this.dataPartValue), {
                visible: !0
            }), rootScene = new pvc.visual.Scene(null,{
                panel: this,
                source: rootCatData
            }), ris = chart._ruleInfos;
            if (ris) {
                ruleInfoByCategKey = def.query(ris).object({
                    name: function(ri) {
                        return ri.group.absKey;
                    }
                });
                isFalling = chart._isFalling;
                createRectangleSceneRecursive(rootCatData, 0);
            }
            return rootScene;
        }
    });
    def.type("pvc.WaterfallChart", pvc.BarAbstract).init(function(options) {
        this.base(options);
        var parent = this.parent;
        parent && (this._isFalling = parent._isFalling);
    }).add({
        _animatable: !0,
        _isFalling: !0,
        _ruleInfos: null,
        _waterColor: pv.color("#1f77b4").darker(),
        _processOptionsCore: function(options) {
            options.stacked = !0;
            options.baseAxisComposite = !1;
            this.base(options);
            options.plot2 = !1;
        },
        _initPlotsCore: function() {
            var waterPlot = (this.options,
            new pvc.visual.WaterfallPlot(this));
            this._isFalling = "down" === waterPlot.option("Direction");
            var travProp = this._isFalling ? "FlattenDfsPre" : "FlattenDfsPost";
            this._catRole.setTraversalMode(pvc.visual.TraversalMode[travProp]);
            this._catRole.setRootLabel(waterPlot.option("AllCategoryLabel"));
        },
        _initLegendScenes: function(legendPanel) {
            var waterPlot = this.plots.water
              , extAbsId = pvc.makeExtensionAbsId("line", waterPlot.extensionPrefixes)
              , strokeStyle = this._getConstantExtension(extAbsId, "strokeStyle");
            strokeStyle && (this._waterColor = pv.color(strokeStyle));
            var rootScene = legendPanel._getBulletRootScene();
            new pvc.visual.legend.WaterfallBulletGroupScene(rootScene,{
                extensionPrefix: pvc.buildIndexedId("", 1),
                label: waterPlot.option("TotalLineLabel"),
                color: this._waterColor
            });
            this.base(legendPanel);
        },
        _reduceStackedCategoryValueExtent: function(result, catRange, catGroup) {
            var offsetNext, offsetPrev = result ? result.offset : 0, offsetDelta = catRange.min + catRange.max;
            if (!result) {
                if (catRange) {
                    offsetNext = offsetPrev + offsetDelta;
                    this._ruleInfos = [{
                        offset: offsetNext,
                        group: catGroup,
                        range: catRange
                    }];
                    return {
                        min: catRange.min,
                        max: catRange.max,
                        offset: offsetNext
                    };
                }
                return null;
            }
            var isFalling = this._isFalling
              , isProperGroup = catGroup._isFlattenGroup && !catGroup._isDegenerateFlattenGroup;
            if (isProperGroup) {
                var deltaUp = -catRange.min;
                if (deltaUp > 0) {
                    var top = offsetPrev + deltaUp;
                    top > result.max && (result.max = top);
                }
                var deltaDown = -catRange.max;
                if (0 > deltaDown) {
                    var bottom = offsetPrev + deltaDown;
                    bottom < result.min && (result.min = bottom);
                }
            } else {
                var dir = isFalling ? -1 : 1;
                offsetNext = result.offset = offsetPrev + dir * offsetDelta;
                offsetNext > result.max ? result.max = offsetNext : offsetNext < result.min && (result.min = offsetNext);
            }
            this._ruleInfos.push({
                offset: isFalling ? offsetPrev : result.offset,
                group: catGroup,
                range: catRange
            });
            return result;
        },
        _createPlotPanels: function(parentPanel, baseOptions) {
            this.wfChartPanel = new pvc.WaterfallPanel(this,parentPanel,this.plots.water,def.create(baseOptions, {
                waterfall: this.options.waterfall
            }));
        }
    });
    def.type("pvc.PointPanel", pvc.CategoricalAbstractPanel).init(function(chart, parent, plot, options) {
        this.base(chart, parent, plot, options);
        this.linesVisible = plot.option("LinesVisible");
        this.dotsVisible = plot.option("DotsVisible");
        this.areasVisible = plot.option("AreasVisible");
        if (!this.linesVisible && !this.dotsVisible && !this.areasVisible) {
            this.linesVisible = !0;
            plot.option.specify({
                LinesVisible: !0,
                DotsVisible: !0,
                AreasVisible: !0
            });
        }
        this.visualRoles.value = chart.visualRole(plot.option("OrthoRole"));
    }).add({
        pvLine: null,
        pvArea: null,
        pvDot: null,
        pvLabel: null,
        pvScatterPanel: null,
        _creating: function() {
            var groupScene = this.defaultLegendGroupScene();
            if (groupScene && !groupScene.hasRenderer()) {
                var colorAxis = groupScene.colorAxis
                  , drawMarker = def.nullyTo(colorAxis.option("LegendDrawMarker", !0), this.dotsVisible || this.areasVisible)
                  , drawRule = drawMarker || def.nullyTo(colorAxis.option("LegendDrawLine", !0), this.linesVisible && !this.areasVisible);
                if (drawMarker || drawRule) {
                    var keyArgs = {
                        drawMarker: drawMarker,
                        drawRule: drawRule
                    };
                    if (drawMarker) {
                        var markerShape = colorAxis.option("LegendShape", !0);
                        if (this.dotsVisible) {
                            markerShape || (markerShape = "circle");
                            keyArgs.markerPvProto = new pv.Dot().lineWidth(1.5, pvc.extensionTag).shapeSize(12, pvc.extensionTag);
                        } else
                            keyArgs.markerPvProto = new pv_Mark();
                        keyArgs.markerShape = markerShape;
                        this._applyV1BarSecondExtensions && this.chart.extend(keyArgs.markerPvProto, "barSecondDot", {
                            constOnly: !0
                        });
                        this.extend(keyArgs.markerPvProto, "dot", {
                            constOnly: !0
                        });
                    }
                    if (drawRule) {
                        keyArgs.rulePvProto = new pv.Line().lineWidth(1, pvc.extensionTag);
                        this._applyV1BarSecondExtensions && this.chart.extend(keyArgs.rulePvProto, "barSecondLine", {
                            constOnly: !0
                        });
                        this.extend(keyArgs.rulePvProto, "line", {
                            constOnly: !0
                        });
                    }
                    groupScene.renderer(new pvc.visual.legend.BulletItemDefaultRenderer(keyArgs));
                }
            }
        },
        _createCore: function() {
            this.base();
            var myself = this
              , chart = this.chart
              , isStacked = this.stacked
              , dotsVisible = this.dotsVisible
              , areasVisible = this.areasVisible
              , linesVisible = this.linesVisible
              , anchor = this.isOrientationVertical() ? "bottom" : "left"
              , baseAxis = this.axes.base
              , axisCategDatas = baseAxis.domainItems()
              , isBaseDiscrete = baseAxis.role.grouping.isDiscrete()
              , data = this.visibleData({
                ignoreNulls: !1
            })
              , rootScene = this._buildScene(data, axisCategDatas, isBaseDiscrete);
            this.pvPanel.zOrder(areasVisible ? -7 : 1);
            this.pvScatterPanel = new pvc.visual.Panel(this,this.pvPanel,{
                extensionId: "panel"
            }).lock("data", rootScene.childNodes).pvMark;
            var wrapper, areaFillColorAlpha = areasVisible && linesVisible && !isStacked ? .5 : null;
            this.compatVersion() <= 1 && (wrapper = isStacked ? function(v1f) {
                return function(dotScene) {
                    return v1f.call(this, dotScene.vars.value.rawValue);
                }
                ;
            }
            : function(v1f) {
                return function(dotScene) {
                    var d = {
                        category: dotScene.vars.category.rawValue,
                        value: dotScene.vars.value.rawValue
                    }
                      , pseudo = Object.create(this);
                    pseudo.index = dotScene.dataIndex;
                    return v1f.call(pseudo, d);
                }
                ;
            }
            );
            var lineAreaVisibleProp = isBaseDiscrete && isStacked ? function(scene) {
                return !scene.isNull || scene.isIntermediate;
            }
            : function(scene) {
                return !scene.isNull;
            }
              , isLineAreaNoSelect = chart.selectableByFocusWindow();
            this.pvArea = new pvc.visual.Area(this,this.pvScatterPanel,{
                extensionId: "area",
                noTooltip: !0,
                wrapper: wrapper,
                noSelect: isLineAreaNoSelect,
                noRubberSelect: !0,
                showsSelection: !isLineAreaNoSelect
            }).lockMark("data", function(seriesScene) {
                return seriesScene.childNodes;
            }).lockMark("visible", lineAreaVisibleProp).override("x", function(scene) {
                return scene.basePosition;
            }).override("y", function(scene) {
                return scene.orthoPosition;
            }).override("dy", function(scene) {
                return chart.animate(0, scene.orthoLength);
            }).override("color", function(scene, type) {
                return areasVisible ? this.base(scene, type) : null;
            }).override("baseColor", function(scene, type) {
                var color = this.base(scene, type);
                !this._finished && color && null != areaFillColorAlpha && (color = color.alpha(areaFillColorAlpha));
                return color;
            }).override("dimColor", function(color, type) {
                return isStacked ? pvc.toGrayScale(color, 1, null, null).brighter() : this.base(color, type);
            }).lock("events", areasVisible ? "painted" : "none").pvMark;
            var dotsVisibleOnly = dotsVisible && !linesVisible && !areasVisible
              , darkerLineAndDotColor = isStacked && areasVisible
              , extensionIds = ["line"];
            this._applyV1BarSecondExtensions && extensionIds.push({
                abs: "barSecondLine"
            });
            var lineVisibleProp = !dotsVisibleOnly && lineAreaVisibleProp
              , noLineInteraction = areasVisible && !linesVisible;
            this.pvLine = new pvc.visual.Line(this,this.pvArea.anchor(this.anchorOpposite(anchor)),{
                extensionId: extensionIds,
                freePosition: !0,
                wrapper: wrapper,
                noTooltip: noLineInteraction,
                noDoubleClick: noLineInteraction,
                noClick: noLineInteraction,
                noHover: noLineInteraction,
                noSelect: noLineInteraction || isLineAreaNoSelect,
                showsSelection: !isLineAreaNoSelect
            }).lockMark("visible", lineVisibleProp).override("defaultColor", function(scene, type) {
                var color = this.base(scene, type);
                !this._finished && darkerLineAndDotColor && color && (color = color.darker(.6));
                return color;
            }).override("normalColor", function(scene, color) {
                return linesVisible ? color : null;
            }).override("interactiveColor", function(scene, color, type) {
                return linesVisible || this.mayShowAnySelected(scene) || this.mayShowActive(scene) ? this.base(scene, color, type) : null;
            }).override("baseStrokeWidth", function(scene) {
                var strokeWidth;
                linesVisible && (strokeWidth = this.base(scene));
                return null == strokeWidth ? 1.5 : strokeWidth;
            }).intercept("strokeDasharray", function(scene) {
                var dashArray = this.delegateExtension();
                if (void 0 === dashArray) {
                    var useDash = scene.isInterpolated;
                    if (!useDash) {
                        var next = scene.nextSibling;
                        useDash = next && next.isIntermediate && next.isInterpolated;
                        if (!useDash) {
                            var previous = scene.previousSibling;
                            useDash = previous && scene.isIntermediate && previous.isInterpolated;
                        }
                    }
                    dashArray = useDash ? ". " : null;
                }
                return dashArray;
            }).pvMark;
            var showAloneDots = !(areasVisible && isBaseDiscrete && isStacked);
            extensionIds = ["dot"];
            this._applyV1BarSecondExtensions && extensionIds.push({
                abs: "barSecondDot"
            });
            this.pvDot = new pvc.visual.Dot(this,this.pvLine,{
                extensionId: extensionIds,
                freePosition: !0,
                wrapper: wrapper
            }).intercept("visible", function(scene) {
                return !scene.isNull && !scene.isIntermediate && this.delegateExtension(!0);
            }).override("color", function(scene, type) {
                if (!dotsVisible) {
                    var visible = scene.isActive || !showAloneDots && scene.isSingle || showAloneDots && scene.isAlone;
                    if (!visible)
                        return pvc.invisibleFill;
                }
                var color = this.base(scene, type);
                return scene.isInterpolated && "fill" === type ? color && pv.color(color).brighter(.5) : color;
            }).override("defaultColor", function(scene, type) {
                var color = this.base(scene, type);
                !this._finished && darkerLineAndDotColor && color && (color = color.darker(.6));
                return color;
            }).override("baseSize", function(scene) {
                if (!dotsVisible) {
                    var visible = scene.isActive || !showAloneDots && scene.isSingle || showAloneDots && scene.isAlone;
                    if (visible && !scene.isActive) {
                        var lineWidth = Math.max(myself.pvLine.lineWidth(), .2) / 2;
                        return def.sqr(lineWidth);
                    }
                }
                return scene.isInterpolated ? .8 * this.base(scene) : this.base(scene);
            }).pvMark;
            var label = pvc.visual.ValueLabel.maybeCreate(this, this.pvDot, {
                wrapper: wrapper
            });
            label && (this.pvLabel = label.pvMark);
        },
        renderInteractive: function() {
            this.pvScatterPanel.render();
        },
        _buildScene: function(data, axisCategDatas, isBaseDiscrete) {
            function completeSeriesScenes(seriesScene) {
                for (var fromScene, seriesScenes2 = [], seriesScenes = seriesScene.childNodes, notNullCount = 0, firstAloneScene = null, c = 0, toChildIndex = 0, categCount = seriesScenes.length; categCount > c; c++,
                toChildIndex++) {
                    var toScene = seriesScenes[toChildIndex]
                      , c2 = 2 * c;
                    seriesScenes2[c2] = toScene;
                    completeMainScene.call(this, fromScene, toScene, belowSeriesScenes2 && belowSeriesScenes2[c2]);
                    toScene.isAlone && !firstAloneScene && (firstAloneScene = toScene);
                    toScene.isNull || notNullCount++;
                    if (fromScene) {
                        var interScene = createIntermediateScene.call(this, seriesScene, fromScene, toScene, toChildIndex, belowSeriesScenes2 && belowSeriesScenes2[c2 - 1]);
                        if (interScene) {
                            seriesScenes2[c2 - 1] = interScene;
                            toChildIndex++;
                        }
                    }
                    fromScene = toScene;
                }
                1 === notNullCount && firstAloneScene && 1 === categCount && (firstAloneScene.isSingle = !0);
                isStacked && (belowSeriesScenes2 = seriesScenes2);
            }
            function completeMainScene(fromScene, toScene, belowScene) {
                var toAccValue = toScene.vars.value.accValue;
                if (belowScene) {
                    toScene.isNull && !isBaseDiscrete ? toAccValue = orthoNullValue : toAccValue += belowScene.vars.value.accValue;
                    toScene.vars.value.accValue = toAccValue;
                }
                toScene.basePosition = sceneBaseScale(toScene);
                toScene.orthoPosition = orthoZero;
                toScene.orthoLength = orthoScale(toAccValue) - orthoZero;
                var isNullFrom = !fromScene || fromScene.isNull
                  , isAlone = isNullFrom && !toScene.isNull;
                if (isAlone) {
                    var nextScene = toScene.nextSibling;
                    isAlone = !nextScene || nextScene.isNull;
                }
                toScene.isAlone = isAlone;
                toScene.isSingle = !1;
            }
            function createIntermediateScene(seriesScene, fromScene, toScene, toChildIndex, belowScene) {
                var interIsNull = fromScene.isNull || toScene.isNull;
                if (interIsNull && !this.areasVisible)
                    return null;
                var interValue, interAccValue, interBasePosition;
                if (interIsNull) {
                    if (belowScene && isBaseDiscrete) {
                        var belowValueVar = belowScene.vars.value;
                        interAccValue = belowValueVar.accValue;
                        interValue = belowValueVar[valueRole.name];
                    } else
                        interValue = interAccValue = orthoNullValue;
                    interBasePosition = isStacked && isBaseDiscrete ? toScene.basePosition - sceneBaseScale.range().step / 2 : fromScene.isNull ? toScene.basePosition : fromScene.basePosition;
                } else {
                    var fromValueVar = fromScene.vars.value
                      , toValueVar = toScene.vars.value;
                    interValue = (toValueVar.value + fromValueVar.value) / 2;
                    interAccValue = (toValueVar.accValue + fromValueVar.accValue) / 2;
                    interBasePosition = (toScene.basePosition + fromScene.basePosition) / 2;
                }
                var interScene = new pvc.visual.Scene(seriesScene,{
                    index: toChildIndex,
                    source: toScene.source
                });
                interScene.dataIndex = toScene.dataIndex;
                interScene.vars.category = toScene.vars.category;
                var interValueVar = new pvc_ValueLabelVar(interValue,valueDim.format(interValue),interValue);
                interValueVar.accValue = interAccValue;
                interScene.vars.value = interValueVar;
                interScene.ownerScene = toScene;
                interScene.isInterpolated = toScene.isInterpolated;
                interScene.isIntermediate = !0;
                interScene.isSingle = !1;
                interScene.isNull = interIsNull;
                interScene.isAlone = interIsNull && toScene.isNull && fromScene.isNull;
                interScene.basePosition = interBasePosition;
                interScene.orthoPosition = orthoZero;
                interScene.orthoLength = orthoScale(interAccValue) - orthoZero;
                colorVarHelper.onNewScene(interScene, !0);
                return interScene;
            }
            function trimNullSeriesScenes(seriesScene) {
                for (var scene, siblingScene, seriesScenes = seriesScene.childNodes, L = seriesScenes.length; L && (scene = seriesScenes[0]).isNull; ) {
                    siblingScene = scene.nextSibling;
                    if (siblingScene && !siblingScene.isNull)
                        break;
                    seriesScene.removeAt(0);
                    L--;
                }
                for (; L && (scene = seriesScenes[L - 1]).isNull; ) {
                    siblingScene = scene.previousSibling;
                    if (siblingScene && !siblingScene.isNull)
                        break;
                    seriesScene.removeAt(L - 1);
                    L--;
                }
            }
            var rootScene = new pvc.visual.Scene(null,{
                panel: this,
                source: data
            })
              , chart = this.chart
              , serRole = this.visualRoles.series
              , valueRole = this.visualRoles.value
              , isStacked = this.stacked
              , valueVarHelper = new pvc.visual.RoleVarHelper(rootScene,valueRole,{
                roleVar: "value",
                hasPercentSubVar: isStacked
            })
              , colorVarHelper = new pvc.visual.RoleVarHelper(rootScene,this.visualRoles.color,{
                roleVar: "color"
            })
              , valueDimName = valueRole.firstDimensionName()
              , valueDim = data.owner.dimensions(valueDimName)
              , axisSeriesData = serRole.isBound() ? serRole.flatten(this.partData(), {
                visible: !0,
                isNull: chart.options.ignoreNulls ? !1 : null
            }) : null
              , orthoScale = this.axes.ortho.scale
              , orthoNullValue = def.scope(function() {
                var domain = orthoScale.domain()
                  , dmin = domain[0]
                  , dmax = domain[1];
                return dmin * dmax >= 0 ? dmin >= 0 ? dmin : dmax : 0;
            })
              , orthoZero = orthoScale(orthoNullValue)
              , sceneBaseScale = this.axes.base.sceneScale({
                sceneVarName: "category"
            });
            (axisSeriesData ? axisSeriesData.children() : def.query([null])).each(function(axisSeriesData) {
                var seriesScene = new pvc.visual.Scene(rootScene,{
                    source: axisSeriesData || data
                });
                seriesScene.vars.series = pvc_ValueLabelVar.fromComplex(axisSeriesData);
                colorVarHelper.onNewScene(seriesScene, !1);
                axisCategDatas.forEach(function(axisCategData, categIndex) {
                    var categData = data.child(axisCategData.key)
                      , group = categData;
                    group && axisSeriesData && (group = group.child(axisSeriesData.key));
                    var serCatScene = new pvc.visual.Scene(seriesScene,{
                        source: group
                    });
                    serCatScene.dataIndex = categIndex;
                    serCatScene.vars.category = pvc_ValueLabelVar.fromComplex(categData);
                    valueVarHelper.onNewScene(serCatScene, !0);
                    var valueVar = serCatScene.vars.value
                      , value = valueVar.value;
                    valueVar.accValue = null != value ? value : orthoNullValue;
                    colorVarHelper.onNewScene(serCatScene, !0);
                    var isInterpolated = null != group && group.datums().prop("isInterpolated").any(def.truthy);
                    serCatScene.isInterpolated = isInterpolated;
                    serCatScene.isNull = null == value;
                    serCatScene.isIntermediate = !1;
                }, this);
            }, this);
            var belowSeriesScenes2, reversedSeriesScenes = rootScene.children().reverse().array();
            reversedSeriesScenes.forEach(completeSeriesScenes, this);
            reversedSeriesScenes.forEach(trimNullSeriesScenes, this);
            return rootScene;
        }
    });
    def.type("pvc.PointAbstract", pvc.CategoricalAbstract).add({
        _animatable: !0,
        _trendable: !0,
        _processOptionsCore: function(options) {
            options.panelSizeRatio = 1;
            this.base(options);
        },
        _hasDataPartRole: function() {
            return !0;
        },
        _initVisualRoles: function() {
            this.base();
            this._addVisualRole("value", {
                isMeasure: !0,
                isRequired: !0,
                isPercent: this.options.stacked,
                requireSingleDimension: !0,
                requireIsDiscrete: !1,
                valueType: Number,
                defaultDimension: "value"
            });
        },
        _initPlotsCore: function() {
            var options = this.options
              , pointPlot = this._createPointPlot()
              , trend = pointPlot.option("Trend");
            if (options.plot2) {
                var plot2Plot = new pvc.visual.PointPlot(this,{
                    name: "plot2",
                    fixed: {
                        DataPart: "1"
                    },
                    defaults: {
                        ColorAxis: 2,
                        LinesVisible: !0,
                        DotsVisible: !0
                    }
                });
                trend || (trend = plot2Plot.option("Trend"));
            }
            this._trendable = !!trend;
            trend && new pvc.visual.PointPlot(this,{
                name: "trend",
                fixed: {
                    DataPart: "trend",
                    TrendType: "none",
                    ColorRole: "series",
                    NullInterpolatioMode: "none"
                },
                defaults: {
                    ColorAxis: 2,
                    LinesVisible: !0,
                    DotsVisible: !1
                }
            });
        },
        _initAxes: function(hasMultiRole) {
            this.base(hasMultiRole);
            var typeAxes = this.axesByType.base;
            typeAxes && typeAxes.forEach(function(axis) {
                var isDiscrete = "discrete" === axis.scaleType;
                isDiscrete || axis.option.defaults({
                    Offset: .01
                });
            });
            typeAxes = this.axesByType.ortho;
            typeAxes && typeAxes.forEach(function(axis) {
                axis.option.defaults({
                    Offset: .04
                });
            });
        },
        _createPlotPanels: function(parentPanel, baseOptions) {
            var plots = this.plots
              , pointPlot = plots.point;
            this.scatterChartPanel = new pvc.PointPanel(this,parentPanel,pointPlot,Object.create(baseOptions));
            var plot2Plot = plots.plot2;
            if (plot2Plot) {
                pvc.debug >= 3 && this._log("Creating second Point panel.");
                new pvc.PointPanel(this,parentPanel,plot2Plot,Object.create(baseOptions));
            }
            var trendPlot = plots.trend;
            if (trendPlot) {
                pvc.debug >= 3 && this._log("Creating Trends Point panel.");
                new pvc.PointPanel(this,parentPanel,trendPlot,Object.create(baseOptions));
            }
        },
        defaults: {
            tooltipOffset: 10
        }
    });
    def.type("pvc.linerule", pvc.BarAbstractPanel).add({
        pvlinefallLine: null,
        _createCore: function() {
            this.pvlinefallLine = pvc.visual.Rule(this, this.pvPanel, {
                extensionId: "line",
                noTooltip: !1,
                noHover: !1,
                noSelect: !1,
                noClick: !1,
                noDoubleClick: !1
            }).lock("data", ruleRootScene.childNodes).optional("visible", function(scene) {
                return isFalling && !!scene.previousSibling || !isFalling && !!scene.nextSibling;
            }).optional(anchor, function(scene) {
                return orthoZero + chart.animate(0, sceneOrthoScale(scene) - orthoZero);
            }).optional(this.anchorLength(anchor), barStepWidth + barWidth).optional(ao, isFalling ? function(scene) {
                return sceneBaseScale(scene) - barStepWidth - barWidth2;
            }
            : function(scene) {
                return sceneBaseScale(scene) - barWidth2;
            }
            ).override("defaultColor", def.fun.constant(waterColor)).pvMark.antialias(!0).lineCap("butt");
            this.plot.option("TotalValuesVisible") && (this.pvWaterfallLabel = new pvc.visual.Label(this,this.pvWaterfallLine,{
                extensionId: "lineLabel"
            }).intercept("visible", function(scene) {
                return scene.vars.category.group._isFlattenGroup ? !1 : isFalling || !!scene.nextSibling;
            }).pvMark[anchor](function(scene) {
                return orthoZero + chart.animate(0, sceneOrthoScale(scene) - orthoZero);
            })[this.anchorOrtho(anchor)](sceneBaseScale).textAlign(isVertical ? "center" : "left").textBaseline(function(categScene) {
                if (!isVertical)
                    return "middle";
                var direction = categScene.vars.direction;
                if (null == direction)
                    return "bottom";
                var isRising = !isFalling;
                return isRising === ("up" === direction) ? "bottom" : "top";
            }).textStyle(pv.Color.names.darkgray.darker(2)).textMargin(5).text(function(scene) {
                return scene.vars.value.label;
            }))
        }
    })
    def.type("pvc.LineChart", pvc.PointAbstract).add({
        _createPointPlot: function() {
            return new pvc.visual.PointPlot(this,{
                fixed: {
                    //DotsVisible: !0,
                    LinesVisible: !0
                }
            })
        }//_createPlotPanels: function(parentPanel, baseOptions) {
        //	return new pvc.linerule(this, parentPanel);
        //}
    })
    def.type("pvc.DotChart", pvc.PointAbstract).add({
        _createPointPlot: function() {
            return new pvc.visual.PointPlot(this,{
                fixed: {
                    DotsVisible: !0
                }
            });
        }
    });
    def.type("pvc.AreaChart", pvc.PointAbstract).add({
        _createPointPlot: function() {
            return new pvc.visual.PointPlot(this,{
                fixed: {
                    AreasVisible: !0
                }
            });
        }
    });
    pvc.mStackedLineChart = def.type("pvc.StackedLineChart", pvc.PointAbstract).add({
        _createPointPlot: function() {
            return new pvc.visual.PointPlot(this,{
                fixed: {
                    LinesVisible: !0,
                    DotsVisible: !0 //Stacked: !0
                }
            });
        }
    });
    def.type("pvc.StackedDotChart", pvc.PointAbstract).add({
        _createPointPlot: function() {
            return new pvc.visual.PointPlot(this,{
                fixed: {
                    //DotsVisible: !0,
                    Stacked: !0
                }
            });
        }
    });
    pvc.mStackedAreaChart = def.type("pvc.StackedAreaChart", pvc.PointAbstract).add({
        _createPointPlot: function() {
            return new pvc.visual.PointPlot(this,{
                fixed: {
                    AreasVisible: !0,
                    Stacked: !0
                },
                defaults: {
                    //DotsVisible: !0,
                    LinesVisible: !0
                }
            });
        }
    });
    def.type("pvc.HeatGridPanel", pvc.CategoricalAbstractPanel).init(function(chart, parent, plot, options) {
        this.base(chart, parent, plot, options);
        this.axes.size = chart._getAxis("size", plot.option("SizeAxis") - 1);
        var roles = this.visualRoles
          , sizeRoleName = plot.option("SizeRole");
        roles.size = chart.visualRole(sizeRoleName);
        this.useShapes = plot.option("UseShapes");
        this.shape = plot.option("Shape");
        this.nullShape = plot.option("NullShape");
    }).add({
        defaultBorder: 0,
        nullBorder: 1,
        selectedBorder: 1,
        _createCore: function() {
            var me = this;
            me.base();
            var cellSize = me._calcCellSize()
              , a_bottom = me.isOrientationVertical() ? "bottom" : "left"
              , a_left = pvc.BasePanel.relativeAnchor[a_bottom]
              , a_width = pvc.BasePanel.parallelLength[a_bottom]
              , a_height = pvc.BasePanel.orthogonalLength[a_bottom]
              , rowRootData = me.visualRoles.series.flatten(me.partData(), {
                visible: !0,
                isNull: me.chart.options.ignoreNulls ? !1 : null
            })
              , rootScene = me._buildScene(me.visibleData({
                ignoreNulls: !1
            }), rowRootData, cellSize)
              , hasColor = rootScene.isColorBound
              , hasSize = rootScene.isSizeBound
              , wrapper = me._buildSignsWrapper(rootScene)
              , isV1Compat = me.compatVersion() <= 1
              , rowScale = this.axes.base.scale
              , colScale = this.axes.ortho.scale
              , rowStep = rowScale.range().step
              , colStep = colScale.range().step
              , rowStep2 = rowStep / 2
              , colStep2 = colStep / 2
              , pvRowPanel = new pvc.visual.Panel(me,me.pvPanel).pvMark.data(rootScene.childNodes)[a_bottom](function(scene) {
                return colScale(scene.vars.series.value) - colStep2;
            })[a_height](colStep)
              , extensionIds = ["panel"];
            isV1Compat && extensionIds.push("");
            var keyArgs = {
                extensionId: extensionIds,
                wrapper: wrapper
            };
            if (!me.useShapes) {
                var f = !1;
                def.copy(keyArgs, {
                    noSelect: f,
                    noHover: f,
                    noClick: f,
                    noDoubleClick: f,
                    freeColor: f,
                    noTooltip: isV1Compat
                });
            }
            me.pvHeatGrid = new pvc.visual.Panel(me,pvRowPanel,keyArgs).pvMark.lock("data", function(serScene) {
                return serScene.childNodes;
            }).lock(a_left, function(scene) {
                return rowScale(scene.vars.category.value) - rowStep2;
            }).lock(a_width, rowStep).antialias(!1);
            me.shapes = me.useShapes ? me._createShapesHeatMap(cellSize, wrapper, hasColor, hasSize) : me._createNoShapesHeatMap(hasColor);
            me.valuesVisible && !me.valuesMask && (me.valuesMask = me._getDefaultValuesMask(hasColor, hasSize));
            var label = pvc.visual.ValueLabel.maybeCreate(me, me.pvHeatGrid, {
                wrapper: wrapper
            });
            label && (me.pvHeatGridLabel = label.pvMark);
        },
        _calcCellSize: function() {
            var xScale = this.axes.x.scale
              , yScale = this.axes.y.scale
              , w = (xScale.max - xScale.min) / xScale.domain().length
              , h = (yScale.max - yScale.min) / yScale.domain().length;
            if (!this.isOrientationVertical()) {
                var tmp = w;
                w = h;
                h = tmp;
            }
            return {
                width: w,
                height: h
            };
        },
        _buildSignsWrapper: function(rootScene) {
            if (this.compatVersion() > 1)
                return null;
            var colorValuesBySerAndCat = def.query(rootScene.childNodes).object({
                name: function(serScene) {
                    return "" + serScene.vars.series.value;
                },
                value: function(serScene) {
                    return def.query(serScene.childNodes).object({
                        name: function(leafScene) {
                            return "" + leafScene.vars.category.value;
                        },
                        value: function(leafScene) {
                            var colorVar = leafScene.vars.color;
                            return colorVar ? "" + colorVar.value : null;
                        }
                    });
                }
            });
            return function(v1f) {
                return function(leafScene) {
                    var colorValuesByCat = colorValuesBySerAndCat[leafScene.vars.series.value]
                      , cat = leafScene.vars.category.rawValue
                      , wrapperParent = Object.create(this.parent)
                      , wrapper = Object.create(this);
                    wrapper.parent = wrapperParent;
                    var catIndex = leafScene.childIndex()
                      , serIndex = leafScene.parent.childIndex();
                    wrapperParent.index = catIndex;
                    wrapper.index = serIndex;
                    return v1f.call(wrapper, colorValuesByCat, cat);
                }
                ;
            }
            ;
        },
        _getDefaultValuesMask: function(hasColor, hasSize) {
            var roles = this.visualRoles
              , roleName = hasColor ? "color" : hasSize ? "size" : null;
            if (roleName) {
                var valueDimName = roles[roleName].firstDimensionName();
                return "{#" + valueDimName + "}";
            }
        },
        _createNoShapesHeatMap: function(hasColor) {
            var getBaseColor = this._buildGetBaseFillColor(hasColor);
            return this.pvHeatGrid.sign.override("defaultColor", function(scene, type) {
                return "stroke" === type ? null : getBaseColor.call(this.pvMark, scene);
            }).override("interactiveColor", function(scene, color, type) {
                return scene.isActive ? color.alpha(.6) : scene.anySelected() && !scene.isSelected() ? this.dimColor(color, type) : this.base(scene, color, type);
            }).override("dimColor", function(color) {
                return pvc.toGrayScale(color, .6);
            }).pvMark.lineWidth(1);
        },
        _buildGetBaseFillColor: function(hasColor) {
            var colorAxis = this.axes.color;
            return hasColor ? colorAxis.sceneScale({
                sceneVarName: "color"
            }) : def.fun.constant(colorAxis.option("Unbound"));
        },
        _createShapesHeatMap: function(cellSize, wrapper, hasColor, hasSize) {
            var me = this
              , areaRange = me._calcDotAreaRange(cellSize);
            hasSize && me.axes.size.setScaleRange(areaRange);
            var keyArgs = {
                extensionId: "dot",
                freePosition: !0,
                activeSeriesAware: !1,
                wrapper: wrapper,
                tooltipArgs: me._buildShapesTooltipArgs(hasColor, hasSize)
            }
              , pvDot = new pvc.visual.DotSizeColor(me,me.pvHeatGrid,keyArgs).override("dimColor", function(color) {
                return pvc.toGrayScale(color, .6);
            }).pvMark;
            hasSize || pvDot.sign.override("defaultSize", def.fun.constant(areaRange.max));
            return pvDot;
        },
        _calcDotAreaRange: function(cellSize) {
            var w = cellSize.width
              , h = cellSize.height
              , maxRadius = Math.min(w, h) / 2;
            "diamond" === this.shape && (maxRadius /= Math.SQRT2);
            maxRadius -= 2;
            var maxArea = def.sqr(maxRadius)
              , minArea = 12
              , areaSpan = maxArea - minArea;
            if (1 >= areaSpan) {
                maxArea = Math.max(maxArea, 2);
                minArea = 1;
                areaSpan = maxArea - minArea;
                pvc.debug >= 2 && this._warn("Using rescue mode dot area calculation due to insufficient space.");
            }
            return {
                min: minArea,
                max: maxArea,
                span: areaSpan
            };
        },
        _buildShapesTooltipArgs: function(hasColor, hasSize) {
            var chart = this.chart;
            if (this.compatVersion() <= 1 && this.showsTooltip()) {
                var options = chart.options
                  , customTooltip = options.customTooltip;
                customTooltip || (customTooltip = function(s, c, d) {
                    return null != d && void 0 !== d[0] ? d.join(", ") : d;
                }
                );
                var roles = this.visualRoles
                  , seriesDimsNames = roles.series.grouping.dimensionNames()
                  , categDimsNames = roles.category.grouping.dimensionNames();
                return {
                    buildTooltip: options.isMultiValued ? function(context) {
                        var group = context.scene.group;
                        if (!group)
                            return "";
                        var s = pvc.data.Complex.values(group, seriesDimsNames)
                          , c = pvc.data.Complex.values(group, categDimsNames)
                          , d = []
                          , vars = context.scene.vars;
                        hasSize && (d[options.sizeValIdx || 0] = vars.size.value);
                        hasColor && (d[options.colorValIdx || 0] = vars.color.value);
                        return customTooltip.call(options, s, c, d);
                    }
                    : function(context) {
                        var vars = context.scene.vars
                          , s = vars.series.rawValue
                          , c = vars.category.rawValue
                          , valueVar = vars[hasColor ? "color" : "size"]
                          , d = valueVar ? valueVar.value : null;
                        return customTooltip.call(options, s, c, d);
                    }
                };
            }
        },
        renderInteractive: function() {
            this.pvPanel.render();
        },
        _buildScene: function(data, seriesRootData, cellSize) {
            function createSeriesScene(serData1) {
                var serScene = new pvc.visual.Scene(rootScene,{
                    source: serData1
                });
                serScene.vars.series = pvc_ValueLabelVar.fromComplex(serData1);
                categDatas.forEach(function(catData1) {
                    createSeriesCategoryScene.call(me, serScene, catData1, serData1);
                });
            }
            function createSeriesCategoryScene(serScene, catData1, serData1) {
                var group = data.child(catData1.key).child(serData1.key)
                  , serCatScene = new pvc.visual.Scene(serScene,{
                    source: group
                });
                serCatScene.vars.category = pvc_ValueLabelVar.fromComplex(catData1);
                colorVarHelper.onNewScene(serCatScene, !0);
                sizeVarHelper.onNewScene(serCatScene, !0);
            }
            var me = this
              , rootScene = new pvc.visual.Scene(null,{
                panel: me,
                source: data
            })
              , categDatas = data.childNodes
              , roles = me.visualRoles
              , colorVarHelper = new pvc.visual.RoleVarHelper(rootScene,roles.color,{
                roleVar: "color"
            })
              , sizeVarHelper = new pvc.visual.RoleVarHelper(rootScene,roles.size,{
                roleVar: "size"
            });
            rootScene.cellSize = cellSize;
            seriesRootData.children().each(createSeriesScene);
            return rootScene;
        }
    });
    def.type("pvc.HeatGridChart", pvc.CategoricalAbstract).add({
        _allowColorPerCategory: !0,
        _interpolatable: !1,
        _axisCreateIfUnbound: {
            color: !0
        },
        _processOptionsCore: function(options) {
            this.base(options);
            def.set(options, "legend", !1, "panelSizeRatio", 1);
            var colorDimName = "value"
              , sizeDimName = "value2";
            if (this.compatVersion() <= 1) {
                switch (this.options.colorValIdx) {
                case 0:
                    colorDimName = "value";
                    break;

                case 1:
                    colorDimName = "value2";
                    break;

                default:
                    colorDimName = "value";
                }
                switch (this.options.sizeValIdx) {
                case 0:
                    sizeDimName = "value";
                    break;

                case 1:
                    sizeDimName = "value2";
                    break;

                default:
                    sizeDimName = "value";
                }
            }
            this._colorDimName = colorDimName;
            this._sizeDimName = sizeDimName;
        },
        _getCategoryRoleSpec: function() {
            var catRoleSpec = this.base();
            catRoleSpec.requireIsDiscrete = !0;
            return catRoleSpec;
        },
        _getColorRoleSpec: function() {
            return {
                isMeasure: !0,
                requireSingleDimension: !0,
                requireIsDiscrete: !1,
                valueType: Number,
                defaultDimension: this._colorDimName
            };
        },
        _initVisualRoles: function() {
            this.base();
            this._addVisualRole("size", {
                isMeasure: !0,
                requireSingleDimension: !0,
                requireIsDiscrete: !1,
                valueType: Number,
                defaultDimension: this._sizeDimName
            });
        },
        _initPlotsCore: function() {
            new pvc.visual.HeatGridPlot(this);
        },
        _createPlotPanels: function(parentPanel, baseOptions) {
            var heatGridPlot = this.plots.heatGrid;
            this.heatGridChartPanel = new pvc.HeatGridPanel(this,parentPanel,heatGridPlot,Object.create(baseOptions));

        },
        defaults: {
            colorValIdx: 0,
            sizeValIdx: 1,
            measuresIndexes: [2],
            axisOffset: 0,
            plotFrameVisible: !0,
            colorNormByCategory: !0,
            numSD: 2
        }
    });
    def.type("pvc.MetricXYAbstract", pvc.CartesianAbstract).add({
        _processOptionsCore: function(options) {
            this.base(options);
            options.panelSizeRatio = 1;
        },
        _initVisualRoles: function() {
            this.base();
            this._addVisualRole("x", {
                isMeasure: !0,
                isRequired: !0,
                requireSingleDimension: !0,
                requireIsDiscrete: !1,
                defaultDimension: "x",
                dimensionDefaults: {
                    valueType: this.options.timeSeries ? Date : Number
                }
            });
            this._addVisualRole("y", {
                isMeasure: !0,
                isRequired: !0,
                requireSingleDimension: !0,
                requireIsDiscrete: !1,
                defaultDimension: "y",
                dimensionDefaults: {
                    valueType: Number
                }
            });
        },
        _generateTrendsDataCell: function(newDatums, dataCell, baseData) {
            function genSeriesTrend(serData) {
                var funX = function(datum) {
                    return datum.atoms[xDimName].value;
                }
                  , funY = function(datum) {
                    return datum.atoms[yDimName].value;
                }
                  , datums = serData.datums().sort(null, funX).array()
                  , options = def.create(trendOptions, {
                    rows: def.query(datums),
                    x: funX,
                    y: funY
                })
                  , trendModel = trendInfo.model(options);
                trendModel && datums.forEach(function(datum, index) {
                    var trendX = funX(datum);
                    if (trendX) {
                        var trendY = trendModel.sample(trendX, funY(datum), index);
                        if (null != trendY) {
                            var atoms = def.set(Object.create(serData.atoms), xDimName, trendX, yDimName, trendY, dataPartDimName, dataPartAtom);
                            newDatums.push(new pvc.data.TrendDatum(data.owner,atoms,trendOptions));
                        }
                    }
                });
            }
            var serRole = this._serRole
              , xRole = this.visualRoles.x
              , yRole = dataCell.role
              , trendOptions = dataCell.trend
              , trendInfo = trendOptions.info;
            this._warnSingleContinuousValueRole(yRole);
            var xDimName = xRole.firstDimensionName()
              , yDimName = yRole.firstDimensionName()
              , data = this.visibleData(dataCell.dataPartValue, {
                baseData: baseData
            })
              , dataPartAtom = this._getTrendDataPartAtom()
              , dataPartDimName = dataPartAtom.dimension.name;
            (serRole.isBound() ? data.children() : def.query([data])).each(genSeriesTrend, this);
        }
    });
    def.type("pvc.data.MetricPointChartTranslationOper").add({
        _meaLayoutRoles: ["x", "y", "color", "size"],
        configureType: function() {
            var freeMeaIndexes = []
              , freeDisIndexes = [];
            this.collectFreeDiscreteAndConstinuousIndexes(freeDisIndexes, freeMeaIndexes);
            var N, autoDimNames = [], F = freeMeaIndexes.length;
            if (F > 0) {
                for (var R = this._meaLayoutRoles.length, i = 0; R > i && autoDimNames.length < F; ) {
                    this._getUnboundRoleDefaultDimNames(this._meaLayoutRoles[i], 1, autoDimNames);
                    i++;
                }
                N = autoDimNames.length;
                if (N > 0) {
                    freeMeaIndexes.length = N;
                    this.defReader({
                        names: autoDimNames,
                        indexes: freeMeaIndexes
                    });
                }
            }
            F = freeDisIndexes.length;
            if (F > 0) {
                autoDimNames.length = 0;
                this._getUnboundRoleDefaultDimNames("series", F, autoDimNames);
                N = autoDimNames.length;
                if (N > 0) {
                    freeDisIndexes.length = N;
                    this.defReader({
                        names: autoDimNames,
                        indexes: freeDisIndexes
                    });
                }
            }
        }
    });
    def.type("pvc.MetricPointPanel", pvc.CartesianAbstractPanel).init(function(chart, parent, plot, options) {
        this.base(chart, parent, plot, options);
        this.axes.size = chart._getAxis("size", (plot.option("SizeAxis") || 0) - 1);
        var sizeRoleName = plot.option("SizeRole");
        this.visualRoles.size = sizeRoleName ? chart.visualRole(sizeRoleName) : null;
        this.linesVisible = plot.option("LinesVisible");
        this.dotsVisible = plot.option("DotsVisible");
        if (!this.linesVisible && !this.dotsVisible) {
            this.linesVisible = !0;
            plot.option.specify({
                LinesVisible: !0
            });
        }
        this.offsetPaddings || (this.offsetPaddings = new pvc_Sides(.01));
    }).add({
        sizeAxisRatio: .2,
        sizeAxisRatioTo: "minWidthHeight",
        autoPaddingByDotSize: !0,
        _v1DimRoleName: {
            category: "x",
            value: "y"
        },
        _creating: function() {
            var groupScene = this.defaultLegendGroupScene();
            if (groupScene && !groupScene.hasRenderer()) {
                var colorAxis = groupScene.colorAxis
                  , drawMarker = def.nullyTo(colorAxis.option("LegendDrawMarker", !0), this.dotsVisible)
                  , drawRule = def.nullyTo(colorAxis.option("LegendDrawLine", !0), this.linesVisible);
                if (drawMarker || drawRule) {
                    var keyArgs = {
                        drawMarker: drawMarker,
                        drawRule: drawRule
                    };
                    if (drawMarker) {
                        keyArgs.markerShape = colorAxis.option("LegendShape", !0) || "circle";
                        keyArgs.markerPvProto = new pv.Dot().lineWidth(1.5, pvc.extensionTag).shapeSize(12, pvc.extensionTag);
                        this.extend(keyArgs.markerPvProto, "dot", {
                            constOnly: !0
                        });
                    }
                    if (drawRule) {
                        keyArgs.rulePvProto = new pv.Line().lineWidth(1.5, pvc.extensionTag);
                        this.extend(keyArgs.rulePvProto, "line", {
                            constOnly: !0
                        });
                    }
                    groupScene.renderer(new pvc.visual.legend.BulletItemDefaultRenderer(keyArgs));
                }
            }
        },
        _getRootScene: function() {
            return def.lazy(this, "_rootScene", this._buildScene, this);
        },
        _calcLayout: function(layoutInfo) {
            var rootScene = this._getRootScene();
            rootScene.isSizeBound && this.axes.size.setScaleRange(this._calcDotAreaRange(layoutInfo));
            this._calcAxesPadding(layoutInfo, rootScene);
        },
        _getDotDiameterRefLength: function(layoutInfo) {
            var clientSize = layoutInfo.clientSize
              , paddings = layoutInfo.paddings;
            switch (this.sizeAxisRatioTo) {
            case "minWidthHeight":
                return Math.min(clientSize.width + paddings.width, clientSize.height + paddings.height);

            case "width":
                return clientSize.width + paddings.width;

            case "height":
                return clientSize.height + paddings.height;
            }
            pvc.debug >= 2 && this._log(def.format("Invalid option 'sizeAxisRatioTo' value. Assuming 'minWidthHeight'.", [this.sizeAxisRatioTo]));
            this.sizeRatioTo = "minWidthHeight";
            return this._getDotDiameterRefLength(layoutInfo);
        },
        _calcDotRadiusRange: function(layoutInfo) {
            var refLength = this._getDotDiameterRefLength(layoutInfo)
              , max = this.sizeAxisRatio / 2 * refLength
              , min = Math.sqrt(12);
            return {
                min: min,
                max: max
            };
        },
        _calcDotAreaRange: function(layoutInfo) {
            var radiusRange = this._calcDotRadiusRange(layoutInfo);
            if ("diamond" === this.shape) {
                radiusRange.max /= Math.SQRT2;
                radiusRange.min /= Math.SQRT2;
            }
            var maxArea = def.sqr(radiusRange.max)
              , minArea = def.sqr(radiusRange.min)
              , areaSpan = maxArea - minArea;
            if (1 >= areaSpan) {
                maxArea = Math.max(maxArea, 2);
                minArea = 1;
                areaSpan = maxArea - minArea;
                radiusRange = {
                    min: Math.sqrt(minArea),
                    max: Math.sqrt(maxArea)
                };
                pvc.debug >= 3 && this._log("Using rescue mode dot area calculation due to insufficient space.");
            }
            return {
                min: minArea,
                max: maxArea,
                span: areaSpan
            };
        },
        _calcAxesPadding: function(layoutInfo, rootScene) {
            var requestPaddings;
            if (this.autoPaddingByDotSize) {
                var axes = this.axes
                  , clientSize = layoutInfo.clientSize
                  , paddings = layoutInfo.paddings;
                requestPaddings = {};
                axes.x.setScaleRange(clientSize.width);
                axes.y.setScaleRange(clientSize.height);
                var isV = this.isOrientationVertical()
                  , sceneXScale = axes.x.sceneScale({
                    sceneVarName: isV ? "x" : "y"
                })
                  , sceneYScale = axes.y.sceneScale({
                    sceneVarName: isV ? "y" : "x"
                })
                  , xMax = axes.x.scale.max
                  , yMax = axes.y.scale.max
                  , hasSizeRole = rootScene.isSizeBound
                  , sizeScale = hasSizeRole ? axes.size.scale : null;
                if (!sizeScale) {
                    var defaultSize = def.number.as(this._getExtension("dot", "shapeRadius"), 0);
                    if (0 >= defaultSize) {
                        defaultSize = def.number.as(this._getExtension("dot", "shapeSize"), 0);
                        0 >= defaultSize && (defaultSize = 12);
                    } else
                        defaultSize = def.sqr(defaultSize);
                    sizeScale = def.fun.constant(defaultSize);
                }
                requestPaddings = {};
                var op;
                if (this.offsetPaddings) {
                    op = {};
                    pvc_Sides.names.forEach(function(side) {
                        var len_a = pvc.BasePanel.orthogonalLength[side];
                        op[side] = (this.offsetPaddings[side] || 0) * (clientSize[len_a] + paddings[len_a]);
                    }, this);
                }
                var setSide = function(side, padding) {
                    op && (padding += op[side] || 0);
                    0 > padding && (padding = 0);
                    var value = requestPaddings[side];
                    (null == value || padding > value) && (requestPaddings[side] = padding);
                }
                  , processScene = function(scene) {
                    var x = sceneXScale(scene)
                      , y = sceneYScale(scene)
                      , r = Math.sqrt(sizeScale(hasSizeRole ? scene.vars.size.value : 0));
                    setSide("left", r - x);
                    setSide("bottom", r - y);
                    setSide("right", x + r - xMax);
                    setSide("top", y + r - yMax);
                };
                rootScene.children().selectMany(function(seriesScene) {
                    return seriesScene.childNodes;
                }).each(processScene);
            } else
                requestPaddings = this._calcRequestPaddings(layoutInfo);
            layoutInfo.requestPaddings = requestPaddings;
        },
        _createCore: function() {
            var me = this;
            me.base();
            var chart = me.chart
              , rootScene = me._getRootScene()
              , wrapper = me._buildSignsWrapper()
              , isV1Compat = me.compatVersion() <= 1;
            this._finalizeScene(rootScene);
            me.pvPanel.zOrder(1);
            this.pvScatterPanel = new pvc.visual.Panel(me,me.pvPanel,{
                extensionId: "panel"
            }).lock("data", rootScene.childNodes).pvMark;
            var isLineNoSelect = chart.selectableByFocusWindow()
              , isColorDiscrete = rootScene.isColorBound && this.visualRoles.color.isDiscrete()
              , line = new pvc.visual.Line(me,me.pvScatterPanel,{
                extensionId: "line",
                wrapper: wrapper,
                noTooltip: !1,
                noSelect: isLineNoSelect,
                showsSelection: !isLineNoSelect
            }).lockMark("data", function(seriesScene) {
                return seriesScene.childNodes;
            }).intercept("visible", function(scene) {
                if (!me.linesVisible)
                    return !1;
                var visible = this.delegateExtension();
                null == visible && (visible = !scene.isNull && (!rootScene.isSizeBound && !rootScene.isColorBound || rootScene.isSizeBound && null != scene.vars.size.value || rootScene.isColorBound && (isColorDiscrete || null != scene.vars.color.value)));
                return visible;
            }).override("x", function(scene) {
                return scene.basePosition;
            }).override("y", function(scene) {
                return scene.orthoPosition;
            });
            me.pvLine = line.pvMark;
            var dot = new pvc.visual.DotSizeColor(me,me.pvLine,{
                extensionId: "dot",
                wrapper: wrapper,
                activeSeriesAware: me.linesVisible
            }).override("x", function(scene) {
                return scene.basePosition;
            }).override("y", function(scene) {
                return scene.orthoPosition;
            }).override("color", function(scene, type) {
                return me.dotsVisible || scene.isActive || scene.isSingle ? this.base(scene, type) : pvc.invisibleFill;
            });
            rootScene.isSizeBound ? me.autoPaddingByDotSize && "minWidthHeight" === me.sizeAxisRatioTo || me.pvPanel.borderPanel.overflow("hidden") : dot.override("baseSize", function(scene) {
                if (!me.dotsVisible && scene.isSingle) {
                    var lineWidth = Math.max(me.pvLine.scene[this.pvMark.index].lineWidth, .2) / 2;
                    return def.sqr(lineWidth);
                }
                return this.base(scene);
            });
            me.pvDot = dot.pvMark;
            me.pvDot.rubberBandSelectionMode = "center";
            if (pvc.visual.ValueLabel.isNeeded(me)) {
                var extensionIds = ["label"];
                isV1Compat && extensionIds.push("lineLabel");
                var label = pvc.visual.ValueLabel.maybeCreate(me, me.pvDot, {
                    extensionId: extensionIds,
                    wrapper: wrapper
                });
                label && (me.pvHeatGridLabel = label.pvMark);
            }
        },
        _buildSignsWrapper: function() {
            return this.compatVersion() > 1 ? null : function(v1f) {
                return function(scene) {
                    var d = {
                        category: scene.vars.x.rawValue,
                        value: scene.vars.y.rawValue
                    }
                      , pseudo = Object.create(this);
                    pseudo.index = scene.dataIndex;
                    return v1f.call(pseudo, d);
                }
                ;
            }
            ;
        },
        renderInteractive: function() {
            this.pvScatterPanel.render();
        },
        _buildScene: function() {
            function createSeriesScene(seriesGroup) {
                var seriesScene = new pvc.visual.Scene(rootScene,{
                    source: seriesGroup
                });
                seriesScene.vars.series = pvc_ValueLabelVar.fromComplex(seriesGroup);
                colorVarHelper.onNewScene(seriesScene, !1);
                seriesGroup.datums().each(function(datum, dataIndex) {
                    var xAtom = datum.atoms[xDim.name];
                    if (null != xAtom.value) {
                        var yAtom = datum.atoms[yDim.name];
                        if (null != yAtom.value) {
                            var scene = new pvc.visual.Scene(seriesScene,{
                                source: datum
                            });
                            scene.dataIndex = dataIndex;
                            scene.vars.x = pvc_ValueLabelVar.fromAtom(xAtom);
                            scene.vars.y = pvc_ValueLabelVar.fromAtom(yAtom);
                            sizeVarHelper.onNewScene(scene, !0);
                            colorVarHelper.onNewScene(scene, !0);
                            scene.isIntermediate = !1;
                        }
                    }
                });
            }
            function completeSeriesScenes(seriesScene) {
                for (var fromScene, seriesScenes = seriesScene.childNodes, c = 0, toChildIndex = 0, pointCount = seriesScenes.length; pointCount > c; c++,
                toChildIndex++) {
                    var toScene = seriesScenes[toChildIndex];
                    toScene.isSingle = !fromScene && !toScene.nextSibling;
                    if (fromScene) {
                        var interScene = createIntermediateScene(seriesScene, fromScene, toScene, toChildIndex);
                        interScene && toChildIndex++;
                    }
                    fromScene = toScene;
                }
            }
            function createIntermediateScene(seriesScene, fromScene, toScene, toChildIndex) {
                var yToSceneAux = +toScene.vars.y.value
                  , yFromSceneAux = +fromScene.vars.y.value
                  , xToSceneAux = +toScene.vars.x.value
                  , xFromSceneAux = +fromScene.vars.x.value
                  , interYValue = yDim.type.cast.call(null, (yToSceneAux + yFromSceneAux) / 2)
                  , interXValue = xDim.type.cast.call(null, (xToSceneAux + xFromSceneAux) / 2)
                  , interScene = new pvc.visual.Scene(seriesScene,{
                    index: toChildIndex,
                    source: toScene.datum
                });
                interScene.dataIndex = toScene.dataIndex;
                interScene.vars.x = new pvc_ValueLabelVar(interXValue,xDim.format(interXValue),interXValue);
                interScene.vars.y = new pvc_ValueLabelVar(interYValue,yDim.format(interYValue),interYValue);
                sizeVarHelper.onNewScene(interScene, !0);
                colorVarHelper.onNewScene(interScene, !0);
                interScene.ownerScene = toScene;
                interScene.isIntermediate = !0;
                interScene.isSingle = !1;
                return interScene;
            }
            var data = this.visibleData({
                ignoreNulls: !1
            })
              , rootScene = new pvc.visual.Scene(null,{
                panel: this,
                source: data
            })
              , roles = this.visualRoles
              , colorVarHelper = (this.axes,
            new pvc.visual.RoleVarHelper(rootScene,roles.color,{
                roleVar: "color"
            }))
              , sizeVarHelper = new pvc.visual.RoleVarHelper(rootScene,roles.size,{
                roleVar: "size"
            })
              , xDim = data.owner.dimensions(roles.x.firstDimensionName())
              , yDim = data.owner.dimensions(roles.y.firstDimensionName());
            data.children().each(createSeriesScene, this);
            rootScene.children().each(completeSeriesScenes, this);
            return rootScene;
        },
        _finalizeScene: function(rootScene) {
            var axes = this.axes
              , sceneBaseScale = axes.base.sceneScale({
                sceneVarName: "x"
            })
              , sceneOrthoScale = axes.ortho.sceneScale({
                sceneVarName: "y"
            });
            rootScene.children().selectMany(function(seriesScene) {
                return seriesScene.childNodes;
            }).each(function(leafScene) {
                leafScene.basePosition = sceneBaseScale(leafScene);
                leafScene.orthoPosition = sceneOrthoScale(leafScene);
            });
            return rootScene;
        }
    });
    def.type("pvc.MetricPointAbstract", pvc.MetricXYAbstract).add({
        _trendable: !0,
        _initPlotsCore: function() {
            var pointPlot = this._createPointPlot()
              , trend = pointPlot.option("Trend");
            (this._trendable = !!trend) && new pvc.visual.MetricPointPlot(this,{
                name: "trend",
                fixed: {
                    DataPart: "trend",
                    TrendType: "none",
                    NullInterpolatioMode: "none",
                    ColorRole: "series",
                    SizeRole: null,
                    SizeAxis: null,
                    OrthoAxis: 1
                },
                defaults: {
                    ColorAxis: 2,
                    LinesVisible: !0,
                    DotsVisible: !0
                }
            });
        },
        _hasDataPartRole: function() {
            return !0;
        },
        _getColorRoleSpec: function() {
            return {
                defaultSourceRole: "series",
                defaultDimension: "color*",
                dimensionDefaults: {
                    valueType: Number
                }
            };
        },
        _initVisualRoles: function() {
            this.base();
            this._addVisualRole("size", {
                isMeasure: !0,
                requireSingleDimension: !0,
                requireIsDiscrete: !1,
                defaultDimension: "size",
                dimensionDefaults: {
                    valueType: Number
                }
            });
        },
        _getTranslationClass: function(translOptions) {
            return def.type(this.base(translOptions)).add(pvc.data.MetricPointChartTranslationOper);
        },
        _createPlotPanels: function(parentPanel, baseOptions) {
            var options = this.options
              , panelOptions = def.set(Object.create(baseOptions), "sizeAxisRatio", options.sizeAxisRatio, "sizeAxisRatioTo", options.sizeAxisRatioTo, "autoPaddingByDotSize", options.autoPaddingByDotSize)
              , scatterPlot = this.plots.scatter;
            this.scatterChartPanel = new pvc.MetricPointPanel(this,parentPanel,scatterPlot,panelOptions);
            var trendPlot = this.plots.trend;
            trendPlot && new pvc.MetricPointPanel(this,parentPanel,trendPlot,Object.create(panelOptions));
        },
        defaults: {
            axisOriginIsZero: !1,
            tooltipOffset: 10
        }
    });
    def.type("pvc.MetricDotChart", pvc.MetricPointAbstract).add({
        _createPointPlot: function() {
            return new pvc.visual.MetricPointPlot(this,{
                fixed: {
                    DotsVisible: !0
                }
            });
        }
    });
    def.type("pvc.MetricLineChart", pvc.MetricPointAbstract).add({
        _createPointPlot: function() {
            return new pvc.visual.MetricPointPlot(this,{
                fixed: {
                    LinesVisible: !0,
                    DotsVisible: !0
                }
            });
        }
    });
    def.type("pvc.BulletChart", pvc.BaseChart).init(function(options) {
        options = options || {};
        var dimGroups = options.dimensionGroups || (options.dimensionGroups = {})
          , rangeDimGroup = dimGroups.range || (dimGroups.range = {});
        void 0 === rangeDimGroup.valueType && (rangeDimGroup.valueType = Number);
        var markerDimGroup = dimGroups.marker || (dimGroups.marker = {});
        void 0 === markerDimGroup.valueType && (markerDimGroup.valueType = Number);
        this.base(options);
    }).add({
        bulletChartPanel: null,
        allowNoData: !0,
        _processOptionsCore: function(options) {
            options.legend = !1;
            options.selectable = !1;
            this.base(options);
        },
        _initVisualRoles: function() {
            this.base();
            this._addVisualRole("title", {
                defaultDimension: "title*"
            });
            this._addVisualRole("subTitle", {
                defaultDimension: "subTitle*"
            });
            this._addVisualRole("value", {
                isMeasure: !0,
                requireIsDiscrete: !1,
                valueType: Number,
                defaultDimension: "value*"
            });
            this._addVisualRole("marker", {
                isMeasure: !0,
                requireIsDiscrete: !1,
                valueType: Number,
                defaultDimension: "marker*"
            });
            this._addVisualRole("range", {
                isMeasure: !0,
                requireIsDiscrete: !1,
                valueType: Number,
                defaultDimension: "range*"
            });
        },
        _createTranslation: function(translOptions) {
            var translation = this.base(translOptions)
              , size = translation.virtualItemSize();
            if (size)
                switch (size) {
                case 1:
                    translation.defReader({
                        names: "value"
                    });
                    break;
                case 2:
                    translation.defReader({
                        names: ["title", "value"]
                    });
                    break;
                case 3:
                    translation.defReader({
                        names: ["title", "value", "marker"]
                    });
                    break;

                default:
                    translation.defReader({
                        names: ["title", "subTitle", "value", "marker"]
                    });
                    size > 4 && translation.defReader({
                        names: "range",
                        indexes: pv.range(4, size)
                    });
                }
            return translation;
        },
        _initPlotsCore: function() {
            new pvc.visual.BulletPlot(this);
        },
        _createContent: function(contentOptions) {
            var bulletPlot = this.plots.bullet;
            this.bulletChartPanel = new pvc.BulletChartPanel(this,this.basePanel,bulletPlot,contentOptions);
        },
        defaults: {
            compatVersion: 1,
            orientation: "horizontal",
            bulletSize: 30,
            bulletSpacing: 50,
            bulletMargin: 100,
            bulletTitle: "Title",
            bulletSubtitle: "",
            bulletTitlePosition: "left",
            tooltipFormat: function(s, c, v) {
                return this.chart.options.valueFormat(v);
            },
            crosstabMode: !1,
            seriesInRows: !1
        }
    });
    def.type("pvc.BulletChartPanel", pvc.PlotPanel).add({
        pvBullets: null,
        pvBullet: null,
        data: null,
        onSelectionChange: null,
        _createCore: function(layoutInfo) {
            var size, angle, align, titleLeftOffset, titleTopOffset, ruleAnchor, leftPos, topPos, titleSpace, chart = this.chart, options = chart.options, data = this.buildData(), anchor = "horizontal" == options.orientation ? "left" : "bottom";
            if ("horizontal" == options.orientation) {
                size = layoutInfo.clientSize.width - this.chart.options.bulletMargin - 20;
                angle = 0;
                switch (options.bulletTitlePosition) {
                case "top":
                    leftPos = this.chart.options.bulletMargin;
                    titleLeftOffset = 0;
                    align = "left";
                    titleTopOffset = -12;
                    titleSpace = parseInt(options.titleSize / 2, 10);
                    break;

                case "bottom":
                    leftPos = this.chart.options.bulletMargin;
                    titleLeftOffset = 0;
                    align = "left";
                    titleTopOffset = options.bulletSize + 32;
                    titleSpace = 0;
                    break;

                case "right":
                    leftPos = 5;
                    titleLeftOffset = size + 5;
                    align = "left";
                    titleTopOffset = parseInt(options.bulletSize / 2, 10);
                    titleSpace = 0;
                    break;

                case "left":
                default:
                    leftPos = this.chart.options.bulletMargin;
                    titleLeftOffset = 0;
                    titleTopOffset = parseInt(options.bulletSize / 2, 10);
                    align = "right";
                    titleSpace = 0;
                }
                ruleAnchor = "bottom";
                topPos = function() {
                    return this.index * (options.bulletSize + options.bulletSpacing) + titleSpace;
                }
                ;
            } else {
                size = layoutInfo.clientSize.height - this.chart.options.bulletMargin - 20;
                switch (options.bulletTitlePosition) {
                case "top":
                    leftPos = this.chart.options.bulletMargin;
                    titleLeftOffset = 0;
                    align = "left";
                    titleTopOffset = -20;
                    angle = 0;
                    topPos = void 0;
                    break;

                case "bottom":
                    leftPos = this.chart.options.bulletMargin;
                    titleLeftOffset = 0;
                    align = "left";
                    titleTopOffset = size + 20;
                    angle = 0;
                    topPos = 20;
                    break;

                case "right":
                    leftPos = 5;
                    titleLeftOffset = this.chart.options.bulletSize + 40;
                    align = "left";
                    titleTopOffset = size;
                    angle = -Math.PI / 2;
                    topPos = void 0;
                    break;

                case "left":
                default:
                    leftPos = this.chart.options.bulletMargin;
                    titleLeftOffset = -12;
                    titleTopOffset = this.height - this.chart.options.bulletMargin - 20;
                    align = "left";
                    angle = -Math.PI / 2;
                    topPos = void 0;
                }
                ruleAnchor = "right";
                leftPos = function() {
                    return options.bulletMargin + this.index * (options.bulletSize + options.bulletSpacing);
                }
                ;
            }
            this.pvBullets = this.pvPanel.add(pv.Panel).data(data)[pvc.BasePanel.orthogonalLength[anchor]](size)[pvc.BasePanel.parallelLength[anchor]](this.chart.options.bulletSize).margin(20).left(leftPos).top(topPos);
            this.pvBullet = this.pvBullets.add(pv.Layout.Bullet).orient(anchor).ranges(function(d) {
                return d.ranges;
            }).measures(function(d) {
                return d.measures;
            }).markers(function(d) {
                return d.markers;
            });
            if (chart.clickable() && this.clickAction) {
                var me = this;
                this.pvBullet.cursor("pointer").event("click", function(d) {
                    var s = d.title
                      , c = d.subtitle
                      , ev = pv.event;
                    return me.clickAction(s, c, d.measures, ev);
                });
            }
            this.pvBulletRange = this.pvBullet.range.add(pv.Bar);
            this.pvBulletMeasure = this.pvBullet.measure.add(pv.Bar).text(function(v, d) {
                return d.formattedMeasures[this.index];
            });
            this.pvBulletMarker = this.pvBullet.marker.add(pv.Dot).shape("square").fillStyle("white").text(function(v, d) {
                return d.formattedMarkers[this.index];
            });
            if (this.showsTooltip()) {
                var myself = this;
                this.pvBulletMeasure.localProperty("tooltip").tooltip(function(v, d) {
                    var s = d.title
                      , c = d.subtitle;
                    return chart.options.tooltipFormat.call(myself, s, c, v);
                });
                this.pvBulletMarker.localProperty("tooltip").tooltip(function(v, d) {
                    var s = d.title
                      , c = d.subtitle;
                    return chart.options.tooltipFormat.call(myself, s, c, v);
                });
                this.pvBulletMeasure.event("mouseover", pv.Behavior.tipsy(this.chart._tooltipOptions));
                this.pvBulletMarker.event("mouseover", pv.Behavior.tipsy(this.chart._tooltipOptions));
            }
            this.pvBulletRule = this.pvBullet.tick.add(pv.Rule);
            this.pvBulletRuleLabel = this.pvBulletRule.anchor(ruleAnchor).add(pv.Label).text(this.pvBullet.x.tickFormat);
            this.pvBulletTitle = this.pvBullet.anchor(anchor).add(pv.Label).font("bold 12px sans-serif").textAngle(angle).left(-10).textAlign(align).textBaseline("bottom").left(titleLeftOffset).top(titleTopOffset).text(function(d) {
                return d.formattedTitle;
            });
            this.pvBulletSubtitle = this.pvBullet.anchor(anchor).add(pv.Label).textStyle("#666").textAngle(angle).textAlign(align).textBaseline("top").left(titleLeftOffset).top(titleTopOffset).text(function(d) {
                return d.formattedSubtitle;
            });
            var doubleClickAction = "function" == typeof options.axisDoubleClickAction ? function(d, e) {
                options.axisDoubleClickAction(d, e);
            }
            : null;
            if (chart.doubleClickable() && doubleClickAction) {
                this.pvBulletTitle.cursor("pointer").events("all").event("dblclick", function(d) {
                    doubleClickAction(d, arguments[arguments.length - 1]);
                });
                this.pvBulletSubtitle.cursor("pointer").events("all").event("dblclick", function(d) {
                    doubleClickAction(d, arguments[arguments.length - 1]);
                });
            }
        },
        applyExtensions: function() {
            this.base();
            this.extend(this.pvBullets, "bulletsPanel");
            this.extend(this.pvBullet, "bulletPanel");
            this.extend(this.pvBulletRange, "bulletRange");
            this.extend(this.pvBulletMeasure, "bulletMeasure");
            this.extend(this.pvBulletMarker, "bulletMarker");
            this.extend(this.pvBulletRule, "bulletRule");
            this.extend(this.pvBulletRuleLabel, "bulletRuleLabel");
            this.extend(this.pvBulletTitle, "bulletTitle");
            this.extend(this.pvBulletSubtitle, "bulletSubtitle");
        },
        _getExtensionId: function() {
            return [{
                abs: "content"
            }].concat(this.base());
        },
        buildData: function() {
            var data, chart = this.chart, options = chart.options, titleRole = chart.visualRoles.title, titleGrouping = titleRole.grouping, subTitleRole = chart.visualRoles.subTitle, subTitleGrouping = subTitleRole.grouping, valueRole = chart.visualRoles.value, valueGrouping = valueRole.grouping, markerRole = chart.visualRoles.marker, markerGrouping = markerRole.grouping, rangeRole = chart.visualRoles.range, rangeGrouping = rangeRole.grouping, defaultData = {
                title: options.bulletTitle,
                formattedTitle: options.bulletTitle,
                subtitle: options.bulletSubtitle,
                formattedSubtitle: options.bulletSubtitle,
                ranges: def.array.to(options.bulletRanges) || [],
                measures: def.array.to(options.bulletMeasures) || [],
                markers: def.array.to(options.bulletMarkers) || []
            };
            def.set(defaultData, "formattedRanges", defaultData.ranges.map(String), "formattedMeasures", defaultData.measures.map(String), "formattedMarkers", defaultData.markers.map(String));
            data = valueGrouping || titleGrouping || markerGrouping || subTitleGrouping || rangeGrouping ? chart.data.datums().select(function(datum) {
                var view, d = Object.create(defaultData);
                if (valueGrouping) {
                    view = valueGrouping.view(datum);
                    d.measures = view.values();
                    d.formattedMeasures = view.labels();
                }
                if (titleGrouping) {
                    view = titleGrouping.view(datum);
                    d.title = view.value;
                    d.formattedTitle = view.label;
                }
                if (subTitleGrouping) {
                    view = subTitleGrouping.view(datum);
                    d.subtitle = view.value;
                    d.formattedSubtitle = view.label;
                }
                if (markerGrouping) {
                    view = markerGrouping.view(datum);
                    d.markers = view.values();
                    d.formattedMarkers = view.labels();
                }
                if (rangeGrouping) {
                    view = rangeGrouping.view(datum);
                    d.ranges = view.values();
                    d.formattedRanges = view.labels();
                }
                return d;
            }, this).array() : [defaultData];
            return data;
        }
    });
    def.type("pvc.ParallelCoordinates", pvc.BaseChart).init(function(options) {
        options = options || {};
        options.dimensions = options.dimensions || {};
        options.dimensions.value || (options.dimensions.value = {
            valueType: null
        });
        this.base(options);
    }).add({
        parCoordPanel: null,
        _createContent: function(contentOptions) {
            this.parCoordPanel = new pvc.ParCoordPanel(this,this.basePanel,def.create(contentOptions, {
                topRuleOffset: this.options.topRuleOffset,
                botRuleOffset: this.options.botRuleOffset,
                leftRuleOffset: this.options.leftRuleOffset,
                rightRuleOffset: this.options.rightRuleOffset,
                sortCategorical: this.options.sortCategorical,
                mapAllDimensions: this.options.mapAllDimensions,
                numDigits: this.options.numDigits
            }));
        },
        defaults: def.create(pvc.BaseChart.prototype.defaults, {
            compatVersion: 1,
            topRuleOffset: 30,
            botRuleOffset: 30,
            leftRuleOffset: 60,
            rightRuleOffset: 60,
            sortCategorical: !0,
            mapAllDimensions: !0,
            numDigits: 0
        })
    });
    def.type("pvc.ParCoordPanel", pvc.BasePanel).add({
        anchor: "fill",
        pvParCoord: null,
        dimensions: null,
        dimensionDescr: null,
        data: null,
        retrieveData: function() {
            var data = this.chart.data
              , numDigit = this.chart.options.numDigits;
            this.dimensions = data.getVisibleCategories();
            var values = data.getValues()
              , dataRowIndex = data.getVisibleSeriesIndexes()
              , pCoordIndex = data.getVisibleCategoriesIndexes()
              , pCoordKeys = data.getCategories()
              , pCoordMapping = pCoordIndex.map(this.chart.options.mapAllDimensions ? function(d) {
                return isNaN(values[d][0]) ? {
                    categorical: !0,
                    len: 0,
                    map: []
                } : {
                    categorical: !1,
                    len: 0,
                    map: [],
                    displayValue: []
                };
            }
            : function(d) {
                return isNaN(values[d][0]) ? {
                    categorical: !0,
                    len: 0,
                    map: []
                } : null;
            }
            )
              , coordMapUpdate = function(i, val) {
                var cMap = pCoordMapping[i]
                  , k = null;
                if (cMap.categorical) {
                    k = cMap.map[val];
                    if (null == k) {
                        k = cMap.len;
                        cMap.len++;
                        cMap.map[val] = k;
                    }
                } else {
                    var keyVal = val.toFixed(numDigit);
                    k = cMap.map[keyVal];
                    if (null == k) {
                        k = cMap.len;
                        cMap.len++;
                        cMap.map[keyVal] = k;
                        cMap.displayValue[keyVal] = val;
                    }
                }
                return k;
            };
            for (var d in pCoordMapping)
                pCoordMapping.hasOwnProperty(d) && pCoordMapping[d] && pCoordMapping[d].categorical && (pCoordMapping[d].displayValue = pCoordMapping[d].map);
            var i, item, k;
            if (this.chart.options.sortCategorical || this.chart.options.mapAllDimensions)
                for (i = 0; i < pCoordMapping.length; i++)
                    if (pCoordMapping[i]) {
                        for (var col = 0; col < values[i].length; col++)
                            coordMapUpdate(i, values[i][col]);
                        var cMap = pCoordMapping[i].map
                          , sorted = [];
                        for (item in cMap)
                            cMap.hasOwnProperty(item) && sorted.push(item);
                        sorted.sort();
                        if (pCoordMapping[i].categorical)
                            for (k = 0; k < sorted.length; k++)
                                cMap[sorted[k]] = k;
                        else
                            for (k = 0; k < sorted.length; k++)
                                cMap[sorted[k]].index = k;
                    }
            var generateHashMap = function(col) {
                var record = {};
                for (var j in pCoordIndex)
                    pCoordIndex.hasOwnProperty(j) && (record[pCoordKeys[j]] = pCoordMapping[j] ? coordMapUpdate(j, values[j][col]) : values[j][col]);
                return record;
            };
            this.data = dataRowIndex.map(function(col) {
                return generateHashMap(col);
            });
            var descrVals = this.dimensions.map(function(cat) {
                var item2 = {}
                  , elements = cat.split("__");
                item2.id = cat;
                item2.name = elements[0];
                item2.unit = elements.length > 1 ? elements[1] : "";
                return item2;
            });
            for (i = 0; i < descrVals.length; i++) {
                item = descrVals[i];
                var index = pCoordIndex[i];
                item.orgRowIndex = index;
                var theMin, theMax, theMin2, theMax2, v, len = values[index].length;
                if (pCoordMapping[index]) {
                    theMin = theMax = theMin2 = theMax2 = pCoordMapping[index].displayValue[values[index][0]];
                    for (k = 1; len > k; k++) {
                        v = pCoordMapping[index].displayValue[values[index][k]];
                        if (theMin > v) {
                            theMin2 = theMin;
                            theMin = v;
                        }
                        if (v > theMax) {
                            theMax2 = theMax;
                            theMax = v;
                        }
                    }
                } else {
                    theMin = theMax = theMin2 = theMax2 = values[index][0];
                    for (k = 1; len > k; k++) {
                        v = values[index][k];
                        if (theMin > v) {
                            theMin2 = theMin;
                            theMin = v;
                        }
                        if (v > theMax) {
                            theMax2 = theMax;
                            theMax = v;
                        }
                    }
                }
                var theStep = (theMax - theMax2 + (theMin2 - theMin)) / 2;
                item.min = theMin;
                item.max = theMax;
                item.step = theStep;
                item.categorical = !1;
                if (pCoordMapping[index]) {
                    item.map = pCoordMapping[index].map;
                    item.mapLength = pCoordMapping[index].len;
                    item.categorical = pCoordMapping[index].categorical;
                    if (!item.categorical) {
                        item.orgValue = [];
                        var theMap = pCoordMapping[index].map;
                        for (var key in theMap)
                            theMap.hasOwnProperty(key) && (item.orgValue[theMap[key]] = 0 + key);
                    }
                }
            }
            var genKeyVal = function(keys, vals) {
                for (var record = {}, i = 0; i < keys.length; i++)
                    record[keys[i]] = vals[i];
                return record;
            };
            this.dimensionDescr = genKeyVal(this.dimensions, descrVals);
        },
        _createCore: function() {
            function update(d) {
                var t = d.dim;
                filter[t].min = Math.max(y[t].domain()[0], y[t].invert(height - d.y - d.dy));
                filter[t].max = Math.min(y[t].domain()[1], y[t].invert(height - d.y));
                active = t;
                change.render();
                return !1;
            }
            function selectAll(d) {
                if (d.dy < 3) {
                    var t = d.dim;
                    filter[t].min = Math.max(y[t].domain()[0], y[t].invert(0));
                    filter[t].max = Math.min(y[t].domain()[1], y[t].invert(height));
                    d.y = botRuleOffs;
                    d.dy = ruleHeight;
                    active = t;
                    change.render();
                }
                return !1;
            }
            var myself = this;
            this.retrieveData();
            var height = this.height
              , numDigits = this.chart.options.numDigits
              , topRuleOffs = this.chart.options.topRuleOffset
              , botRuleOffs = this.chart.options.botRuleOffset
              , leftRuleOffs = this.chart.options.leftRuleOffset
              , rightRulePos = this.width - this.chart.options.rightRuleOffset
              , topRulePos = this.height - topRuleOffs
              , ruleHeight = topRulePos - botRuleOffs
              , labelTopOffs = topRuleOffs - 12
              , dims = this.dimensions
              , dimDescr = this.dimensionDescr
              , getDimSc = function(t, addMargin) {
                var theMin = dimDescr[t].min
                  , theMax = dimDescr[t].max
                  , theStep = dimDescr[t].step;
                if (addMargin) {
                    theMin -= theStep;
                    theMax += theStep;
                }
                return pv.Scale.linear(theMin, theMax).range(botRuleOffs, topRulePos);
            }
              , getDimensionScale = function(t) {
                var scale = getDimSc(t, !0).range(botRuleOffs, topRulePos)
                  , dd = dimDescr[t];
                if (dd.orgValue && !dd.categorical) {
                    var func = function(x) {
                        var res = scale(dd.orgValue[x]);
                        return res;
                    };
                    func.domain = function() {
                        return scale.domain();
                    }
                    ;
                    func.invert = function(d) {
                        return scale.invert(d);
                    }
                    ;
                    return func;
                }
                return scale;
            }
              , getDimColorScale = function(t) {
                var scale = getDimSc(t, !1).range("steelblue", "brown");
                return scale;
            }
              , x = pv.Scale.ordinal(dims).splitFlush(leftRuleOffs, rightRulePos)
              , y = pv.dict(dims, getDimensionScale)
              , colors = pv.dict(dims, getDimColorScale)
              , filter = pv.dict(dims, function(t) {
                return {
                    min: y[t].domain()[0],
                    max: y[t].domain()[1]
                };
            })
              , active = dims[0]
              , selectVisible = this.chart.options.mapAllDimensions ? function(d) {
                return dims.every(function(t) {
                    var dd = dimDescr[t]
                      , val = dd.orgValue && !dd.categorical ? dd.orgValue[d[t]] : d[t];
                    return val >= filter[t].min && val <= filter[t].max;
                });
            }
            : function(d) {
                return dims.every(function(t) {
                    return d[t] >= filter[t].min && d[t] <= filter[t].max;
                });
            }
            ;
            this.pvParCoord = this.pvPanel.add(pv.Panel).data(myself.data).visible(selectVisible).add(pv.Line).data(dims).left(function(t) {
                return x(t);
            }).bottom(function(t, d) {
                var res = y[t](d[t]);
                return res;
            }).strokeStyle("#ddd").lineWidth(1).antialias(!1);
            var rule = this.pvPanel.add(pv.Rule).data(dims).left(x).top(topRuleOffs).bottom(botRuleOffs);
            rule.anchor("top").add(pv.Label).top(labelTopOffs).font("bold 10px sans-serif").text(function(d) {
                return dimDescr[d].name;
            });
            var labels = []
              , labelXoffs = 6
              , labelYoffs = 3;
            for (var d in dimDescr)
                if (dimDescr.hasOwnProperty(d)) {
                    var dim = dimDescr[d];
                    if (dim.categorical) {
                        var xVal = x(dim.id) + labelXoffs;
                        for (var l in dim.map)
                            dim.map.hasOwnProperty(l) && (labels[labels.length] = {
                                x: xVal,
                                y: y[dim.id](dim.map[l]) + labelYoffs,
                                label: l
                            });
                    }
                }
            var change = (this.pvPanel.add(pv.Panel).data(labels).add(pv.Label).left(function(d) {
                return d.x;
            }).bottom(function(d) {
                return d.y;
            }).text(function(d) {
                return d.label;
            }).textAlign("left"),
            this.pvPanel.add(pv.Panel))
              , handle = (change.add(pv.Panel).data(myself.data).visible(selectVisible).add(pv.Line).data(dims).left(function(t) {
                return x(t);
            }).bottom(function(t, d) {
                return y[t](d[t]);
            }).strokeStyle(function(t, d) {
                var dd = dimDescr[active]
                  , val = dd.orgValue && !dd.categorical ? dd.orgValue[d[active]] : d[active];
                return colors[active](val);
            }).lineWidth(1),
            change.add(pv.Panel).data(dims.map(function(dim) {
                return {
                    y: botRuleOffs,
                    dy: ruleHeight,
                    dim: dim
                };
            })).left(function(t) {
                return x(t.dim) - 30;
            }).width(60).fillStyle("rgba(0,0,0,.001)").cursor("crosshair").event("mousedown", pv.Behavior.select()).event("select", update).event("selectend", selectAll).add(pv.Bar).left(25).top(function(d) {
                return d.y;
            }).width(10).height(function(d) {
                return d.dy;
            }).fillStyle(function(t) {
                return t.dim == active ? colors[t.dim]((filter[t.dim].max + filter[t.dim].min) / 2) : "hsla(0,0,50%,.5)";
            }).strokeStyle("white").cursor("move").event("mousedown", pv.Behavior.drag()).event("dragstart", update).event("drag", update));
            handle.anchor("bottom").add(pv.Label).textBaseline("top").text(function(d) {
                return dimDescr[d.dim].categorical ? "" : filter[d.dim].min.toFixed(numDigits) + dimDescr[d.dim].unit;
            });
            handle.anchor("top").add(pv.Label).textBaseline("bottom").text(function(d) {
                return dimDescr[d.dim].categorical ? "" : filter[d.dim].max.toFixed(numDigits) + dimDescr[d.dim].unit;
            });
            this.extend(this.pvParCoord, "parCoord");
            this.extend(this.pvPanel, "chart");
        }
    });
    def.type("pvc.DataTree", pvc.BaseChart).init(function(options) {
        options = options || {};
        options.dimensionGroups = options.dimensionGroups || {};
        options.dimensionGroups.value || (options.dimensionGroups.value = {
            valueType: null
        });
        this.base(options);
    }).add({
        structEngine: null,
        structMetadata: null,
        structDataset: null,
        DataTreePanel: null,
        _getColorRoleSpec: function() {
            return {
                isRequired: !0,
                defaultSourceRole: "category",
                requireIsDiscrete: !0
            };
        },
        setStructData: function(data) {
            this.structDataset = data.resultset;
            this.structDataset.length || this._log("Warning: Structure-dataset is empty");
            this.structMetadata = data.metadata;
            this.structMetadata.length || this._log("Warning: Structure-Metadata is empty");
        },
        _createContent: function(contentOptions) {
            var structEngine = this.structEngine
              , structType = structEngine ? structEngine.type : new pvc.data.ComplexType();
            structType.addDimension("value", {});
            var translOptions = {
                seriesInRows: !0,
                crosstabMode: !0
            }
              , translation = new pvc.data.CrosstabTranslationOper(structType,this.structDataset,this.structMetadata,translOptions);
            translation.configureType();
            structEngine || (structEngine = this.structEngine = new pvc.data.Data({
                type: structType
            }));
            structEngine.load(translation.execute(structEngine));
            pvc.debug >= 3 && this._log(this.structEngine.getInfo());
            this.dataTreePanel = new pvc.DataTreePanel(this,this.basePanel,def.create(contentOptions, {
                topRuleOffset: this.options.topRuleOffset,
                botRuleOffset: this.options.botRuleOffset,
                leftRuleOffset: this.options.leftRuleOffset,
                rightRuleOffset: this.options.rightRuleOffset,
                boxplotColor: this.options.boxplotColor,
                valueFontsize: this.options.valueFontsize,
                headerFontsize: this.options.headerFontsize,
                border: this.options.border,
                perpConnector: this.options.perpConnector,
                numDigits: this.options.numDigits,
                minVerticalSpace: this.options.minVerticalSpace,
                connectorSpace: this.options.connectorSpace,
                minAspectRatio: this.options.minAspectRatio
            }));
        },
        defaults: {
            compatVersion: 1,
            topRuleOffset: 30,
            botRuleOffset: 30,
            leftRuleOffset: 60,
            rightRuleOffset: 60,
            boxplotColor: "grey",
            headerFontsize: 16,
            valueFontsize: 20,
            border: 1,
            perpConnector: !1,
            numDigits: 0,
            connectorSpace: .15,
            minVerticalSpace: .05,
            minAspectRatio: 2
        }
    });
    def.type("pvc.DataTreePanel", pvc.PlotPanel).add({
        pvDataTree: null,
        treeElements: null,
        structMap: null,
        structArr: null,
        hRules: null,
        vRules: null,
        rules: null,
        generatePerpConnectors: function(leftLength) {
            this.hRules = [];
            this.vRules = [];
            this.rules = [];
            for (var e in this.structMap) {
                var elem = this.structMap[e];
                if (null != elem.children) {
                    var min = 1e4
                      , max = -1e4
                      , theLeft = elem.left + elem.width;
                    this.hRules.push({
                        left: theLeft,
                        width: leftLength,
                        bottom: elem.bottom + elem.height / 2
                    });
                    theLeft += leftLength;
                    for (var i in elem.children) {
                        var child = this.structMap[elem.children[i]]
                          , theBottom = child.bottom + child.height / 2;
                        theBottom > max && (max = theBottom);
                        min > theBottom && (min = theBottom);
                        this.hRules.push({
                            left: theLeft,
                            width: child.left - theLeft,
                            bottom: theBottom
                        });
                    }
                    max > min && this.vRules.push({
                        left: theLeft,
                        bottom: min,
                        height: max - min
                    });
                }
            }
        },
        generateLineSegment: function(x1, y1, x2, y2) {
            var line = [];
            line.push({
                x: x1,
                y: y1
            });
            line.push({
                x: x2,
                y: y2
            });
            this.rules.push(line);
        },
        generateConnectors: function(leftLength) {
            this.hRules = [];
            this.vRules = [];
            if (this.chart.options.perpConnector)
                this.generatePerpConnectors(leftLength);
            else {
                this.rules = [];
                for (var e in this.structMap) {
                    var elem = this.structMap[e];
                    if (null != elem.children) {
                        var theCenter, child, i, min = 1e4, max = -1e4;
                        for (i in elem.children) {
                            child = this.structMap[elem.children[i]];
                            theCenter = child.bottom + child.height / 2;
                            theCenter > max && (max = theCenter);
                            min > theCenter && (min = theCenter);
                        }
                        var mid = (max + min) / 2
                          , theLeft1 = elem.left + elem.width
                          , theLeft2 = theLeft1 + leftLength;
                        this.generateLineSegment(theLeft1, elem.bottom + elem.height / 2, theLeft2, mid);
                        for (i in elem.children) {
                            child = this.structMap[elem.children[i]];
                            theCenter = child.bottom + child.height / 2;
                            this.generateLineSegment(theLeft2, mid, child.left, theCenter);
                        }
                    }
                }
            }
        },
        retrieveStructure: function() {
            var data = this.chart.structEngine
              , options = this.chart.options
              , colLabels = data.getVisibleCategories();
            this.treeElements = data.getVisibleSeries();
            var e, values = data.getValues(), bottomHeightSpecified = colLabels.length > 4;
            for (e in this.treeElements)
                this.treeElements[e] = $.trim(this.treeElements[e]);
            var bounds = [];
            bounds.getElement = function(label) {
                null == bounds[label] && (bounds[label] = {
                    min: 1e4,
                    max: -1e4
                });
                return bounds[label];
            }
            ;
            bounds.addValue = function(label, value) {
                var bnd = bounds.getElement(label);
                value < bnd.min && (bnd.min = value);
                value > bnd.max && (bnd.max = value);
                return bnd;
            }
            ;
            var col, colnr, elem, row;
            for (e in this.treeElements) {
                elem = this.treeElements[e];
                col = elem[0];
                colnr = col.charCodeAt(0);
                row = parseInt(elem.slice(1), 10);
                bounds.addValue("__cols", colnr);
                bounds.addValue(col, row);
            }
            var bnds = bounds.getElement("__cols")
              , gridWidth = this.innerWidth / (bnds.max - bnds.min + 1)
              , connectorWidth = options.connectorSpace * gridWidth
              , cellWidth = gridWidth - connectorWidth
              , maxCellHeight = cellWidth / options.minAspectRatio
              , colBase = bnds.min;
            delete bounds.__cols;
            for (e in bounds) {
                bnds = bounds[e];
                if ("function" != typeof bnds) {
                    var numRows = bnds.max - bnds.min + 1;
                    bnds.gridHeight = this.innerHeight / numRows;
                    bnds.cellHeight = bnds.gridHeight * (1 - options.minVerticalSpace);
                    bnds.cellHeight > maxCellHeight && (bnds.cellHeight = maxCellHeight);
                    bnds.relBottom = (bnds.gridHeight - bnds.cellHeight) / 2;
                    bnds.numRows = numRows;
                }
            }
            var whitespaceQuote = new RegExp("[\\s\"']+","g");
            this.structMap = {};
            for (e in this.treeElements) {
                var box = {};
                elem = this.treeElements[e];
                box.box_id = elem;
                this.structMap[elem] = box;
                col = elem[0];
                colnr = col.charCodeAt(0);
                row = parseInt(elem.slice(1), 10);
                bnds = bounds.getElement(col);
                box.colIndex = colnr - colBase;
                box.rowIndex = bnds.numRows - (row - bnds.min) - 1;
                box.left = this.leftOffs + box.colIndex * gridWidth;
                box.width = cellWidth;
                if (bottomHeightSpecified) {
                    box.bottom = values[4][e];
                    box.height = values[5][e];
                } else {
                    box.bottom = this.botOffs + box.rowIndex * bnds.gridHeight + bnds.relBottom;
                    box.height = bnds.cellHeight;
                }
                box.label = values[0][e];
                box.selector = values[1][e];
                box.aggregation = values[2][e];
                var children = (values[3][e] || "").replace(whitespaceQuote, " ");
                box.children = " " === children || "" === children ? null : children.split(" ");
            }
            this.generateConnectors((gridWidth - cellWidth) / 2);
            this.structArr = [];
            for (e in this.structMap) {
                elem = this.structMap[e];
                this.structArr.push(elem);
            }
        },
        findDataValue: function(key, data) {
            for (var i = 0; i < data[0].length; i++)
                if (data[0][i] == key)
                    return data[1][i];
            this._log("Error: value with key : " + key + " not found.");
        },
        generateBoxPlots: function() {
            var options = this.chart.options;
            for (var e in this.structArr) {
                var elem = this.structArr[e];
                if (elem.values.length) {
                    elem.subplot = {};
                    var sp = elem.subplot
                      , dat = []
                      , margin = 15
                      , rlMargin = elem.width / 6;
                    sp.hRules = [];
                    sp.vRules = [];
                    sp.marks = [];
                    sp.labels = [];
                    dat.push(this.findDataValue("_p5", elem.values));
                    dat.push(this.findDataValue("_p25", elem.values));
                    dat.push(this.findDataValue("_p50", elem.values));
                    dat.push(this.findDataValue("_p75", elem.values));
                    dat.push(this.findDataValue("_p95", elem.values));
                    var noBox = !1;
                    if ("undefined" != typeof dat[2]) {
                        if (dat[4] < dat[0]) {
                            dat = dat.reverse();
                            this._log(" dataset " + elem.box_id + " repaired (_p95 was smaller than _p5)");
                        }
                        if (dat[4] > dat[0])
                            sp.hScale = pv.Scale.linear(dat[0], dat[4]);
                        else {
                            noBox = !0;
                            sp.hScale = pv.Scale.linear(dat[0] - 1e-10, dat[0] + 1e-10);
                        }
                        sp.hScale.range(elem.left + rlMargin, elem.left + elem.width - rlMargin);
                        var i, avLabel = "" + dat[2];
                        for (i = 0; i < dat.length; i++)
                            dat[i] = sp.hScale(dat[i]);
                        sp.bot = elem.bottom + elem.height / 3;
                        sp.top = elem.bottom + 2 * elem.height / 3;
                        sp.mid = (sp.top + sp.bot) / 2;
                        sp.textBottom = elem.bottom + margin;
                        sp.textBottom = sp.bot - options.valueFontsize - 1;
                        var lwa = 3;
                        if (noBox)
                            sp.vRules.push({
                                left: dat[0],
                                bottom: sp.bot,
                                lWidth: lwa,
                                height: sp.top - sp.bot
                            });
                        else {
                            sp.hRules.push({
                                left: dat[0],
                                width: dat[1] - dat[0],
                                lWidth: 1,
                                bottom: sp.mid
                            });
                            sp.hRules.push({
                                left: dat[1],
                                width: dat[3] - dat[1],
                                lWidth: 1,
                                bottom: sp.bot
                            });
                            sp.hRules.push({
                                left: dat[1],
                                width: dat[3] - dat[1],
                                lWidth: 1,
                                bottom: sp.top
                            });
                            sp.hRules.push({
                                left: dat[3],
                                width: dat[4] - dat[3],
                                lWidth: 1,
                                bottom: sp.mid
                            });
                            for (i = 0; i < dat.length; i++)
                                sp.vRules.push({
                                    left: dat[i],
                                    bottom: sp.bot,
                                    lWidth: 2 == i ? lwa : 1,
                                    height: sp.top - sp.bot
                                });
                        }
                        sp.labels.push({
                            left: dat[2],
                            bottom: sp.textBottom,
                            text: this.labelFixedDigits(avLabel),
                            size: options.smValueFont,
                            color: options.boxplotColor
                        });
                    }
                }
            }
        },
        labelFixedDigits: function(value) {
            "string" == typeof value && (value = parseFloat(value));
            if ("number" == typeof value) {
                var nd = this.chart.options.numDigits;
                value = value.toFixed(nd);
            }
            return "" + value;
        },
        addDataPoint: function(key) {
            var options = this.chart.options;
            for (var e in this.structArr) {
                var elem = this.structArr[e];
                if (elem.values.length) {
                    var value = this.findDataValue(key, elem.values);
                    if ("undefined" != typeof value) {
                        var sp = elem.subplot
                          , theLeft = sp.hScale(value)
                          , theColor = "green";
                        sp.marks.push({
                            left: theLeft,
                            bottom: sp.mid,
                            color: theColor
                        });
                        sp.labels.push({
                            left: theLeft,
                            bottom: sp.textBottom,
                            text: this.labelFixedDigits(value),
                            size: options.valueFont,
                            color: theColor
                        });
                    }
                }
            }
        },
        retrieveData: function() {
            var i, data = this.chart.data, options = this.chart.options, selectors = (data.getVisibleCategories(),
            data.getVisibleSeries()), values = data.getValues(), selMap = {}, numCols = values.length;
            for (var e in this.structArr) {
                var elem = this.structArr[e];
                elem.values = [];
                for (i = 0; numCols > i; i++)
                    elem.values.push([]);
                selMap[elem.selector] = elem;
            }
            var boxNotFound = {};
            for (i in selectors) {
                var box = selMap[selectors[i]];
                if ("undefined" != typeof box)
                    for (var j in values)
                        box.values[j].push(values[j][i]);
                else
                    boxNotFound[selectors[i]] = !0;
            }
            for (var sel in boxNotFound)
                this._log("Could'nt find box for selector: " + sel);
            this.generateBoxPlots();
            var whitespaceQuote = new RegExp("[\\s\"']+","g");
            if (options.selectParam) {
                var selPar = options.selectParam.replace(whitespaceQuote, "");
                if ("undefined" != selPar && selPar.length > 0 && "undefined" != typeof window[selPar]) {
                    selPar = window[selPar];
                    this.addDataPoint(selPar);
                }
            }
        },
        _createCore: function() {
            var myself = this
              , options = this.chart.options;
            options.smValueFontsize = Math.round(.6 * options.valueFontsize);
            options.smValueFont = "" + options.smValueFontsize + "px sans-serif";
            options.valueFont = "" + options.valueFontsize + "px sans-serif";
            var topRuleOffs = options.topRuleOffset
              , botRuleOffs = options.botRuleOffset
              , leftRuleOffs = options.leftRuleOffset;
            this.innerWidth = this.width - leftRuleOffs - options.rightRuleOffset;
            this.innerHeight = this.height - topRuleOffs - botRuleOffs;
            this.botOffs = botRuleOffs;
            this.leftOffs = leftRuleOffs;
            this.retrieveStructure();
            this.retrieveData();
            var i, topMargin = options.headerFontsize + 3, rules = this.rules;
            for (i = 0; i < rules.length; i++)
                this.pvPanel.add(pv.Line).data(rules[i]).left(function(d) {
                    return d.x;
                }).bottom(function(d) {
                    return d.y;
                }).lineWidth(1).strokeStyle("black");
            this.pvDataTree = this.pvPanel.add(pv.Bar).data(myself.structArr).left(function(d) {
                return d.left;
            }).bottom(function(d) {
                return d.bottom;
            }).height(function(d) {
                return d.height;
            }).width(function(d) {
                return d.width;
            }).fillStyle("green").add(pv.Bar).left(function(d) {
                return d.left + options.border;
            }).bottom(function(d) {
                return d.bottom + options.border;
            }).height(function(d) {
                return d.height - options.border - topMargin;
            }).width(function(d) {
                return d.width - 2 * options.border;
            }).fillStyle("white").add(pv.Label).text(function(d) {
                return d.label;
            }).textAlign("center").left(function(d) {
                return d.left + d.width / 2;
            }).bottom(function(d) {
                return d.bottom + d.height - options.headerFontsize - 5 + options.headerFontsize / 5;
            }).font("" + options.headerFontsize + "px sans-serif").textStyle("white").fillStyle("blue");
            for (i = 0; i < this.structArr.length; i++) {
                var box = this.structArr[i];
                this.pvPanel.add(pv.Rule).data(box.subplot.hRules).left(function(d) {
                    return d.left;
                }).width(function(d) {
                    return d.width;
                }).bottom(function(d) {
                    return d.bottom;
                }).lineWidth(function(d) {
                    return d.lWidth;
                }).strokeStyle(myself.chart.options.boxplotColor);
                this.pvPanel.add(pv.Rule).data(box.subplot.vRules).left(function(d) {
                    return d.left;
                }).height(function(d) {
                    return d.height;
                }).bottom(function(d) {
                    return d.bottom;
                }).lineWidth(function(d) {
                    return d.lWidth;
                }).strokeStyle(myself.chart.options.boxplotColor);
                this.pvPanel.add(pv.Dot).data(box.subplot.marks).left(function(d) {
                    return d.left;
                }).bottom(function(d) {
                    return d.bottom;
                }).fillStyle(function(d) {
                    return d.color;
                });
                this.pvPanel.add(pv.Label).data(box.subplot.labels).left(function(d) {
                    return d.left;
                }).bottom(function(d) {
                    return d.bottom;
                }).font(function(d) {
                    return d.size;
                }).text(function(d) {
                    return d.text;
                }).textAlign("center").textStyle(function(d) {
                    return d.color;
                });
            }
            if (options.perpConnector) {
                this.pvPanel.add(pv.Rule).data(myself.vRules).left(function(d) {
                    return d.left;
                }).bottom(function(d) {
                    return d.bottom;
                }).height(function(d) {
                    return d.height;
                }).strokeStyle("black");
                this.pvPanel.add(pv.Rule).data(myself.hRules).left(function(d) {
                    return d.left;
                }).bottom(function(d) {
                    return d.bottom;
                }).width(function(d) {
                    return d.width;
                }).strokeStyle("red");
            }
        },
        applyExtensions: function() {
            this.extend(this.pvDataTree, "dataTree");
        }
    });
    def.type("pvc.data.BoxplotChartTranslationOper").add({
        _configureTypeCore: function() {
            var autoDimNames = []
              , freeMeaIndexes = []
              , freeDisIndexes = [];
            this.collectFreeDiscreteAndConstinuousIndexes(freeDisIndexes, freeMeaIndexes);
            this._getUnboundRoleDefaultDimNames("category", freeDisIndexes.length, autoDimNames);
            def.query(pvc.BoxplotChart.measureRolesNames).take(freeMeaIndexes.length).each(function(roleName) {
                this._getUnboundRoleDefaultDimNames(roleName, 1, autoDimNames);
            }, this);
            autoDimNames.length && this.defReader({
                names: autoDimNames
            });
        }
    });
    def.type("pvc.BoxplotPanel", pvc.CategoricalAbstractPanel).init(function(chart, parent, plot, options) {
        this.base(chart, parent, plot, options);
        this.boxSizeRatio = plot.option("BoxSizeRatio");
        this.maxBoxSize = plot.option("BoxSizeMax");
    }).add({
        plotType: "box",
        anchor: "fill",
        _v1DimRoleName: {
            value: "median"
        },
        _createCore: function() {
            function defaultColor(scene, type) {
                var color = this.base(scene, type);
                return "stroke" === type ? color.darker(1) : color;
            }
            function setupRuleWhisker(rule) {
                rule.lock(a_left, function() {
                    return this.pvMark.parent[a_width]() / 2;
                }).override("defaultColor", defaultColor);
                return rule;
            }
            function setupHCateg(sign) {
                sign.lockMark(a_left, function(scene) {
                    return scene.vars.category.boxLeft;
                }).lockMark(a_width, function(scene) {
                    return scene.vars.category.boxWidth;
                });
                return sign;
            }
            function setupHRule(rule) {
                setupHCateg(rule);
                rule.override("defaultColor", defaultColor);
                return rule;
            }
            this.base();
            var rootScene = this._buildScene()
              , a_bottom = this.isOrientationVertical() ? "bottom" : "left"
              , a_left = this.anchorOrtho(a_bottom)
              , a_width = this.anchorLength(a_bottom)
              , a_height = this.anchorOrthoLength(a_bottom)
              , extensionIds = ["panel"];
            this.compatVersion() <= 1 && extensionIds.push("");
            this.pvBoxPanel = new pvc.visual.Panel(this,this.pvPanel,{
                extensionId: extensionIds
            }).lock("data", rootScene.childNodes).lockMark(a_left, function(scene) {
                var catVar = scene.vars.category;
                return catVar.x - catVar.width / 2;
            }).pvMark[a_width](function(scene) {
                return scene.vars.category.width;
            });
            this.pvRuleWhiskerUpper = setupRuleWhisker(new pvc.visual.Rule(this,this.pvBoxPanel,{
                extensionId: "boxRuleWhisker",
                freePosition: !0,
                noHover: !1,
                noSelect: !1,
                noClick: !1,
                noDoubleClick: !1,
                showsInteraction: !0
            })).intercept("visible", function(scene) {
                return scene.vars.category.showRuleWhiskerUpper && this.delegateExtension(!0);
            }).pvMark.lock(a_bottom, function(scene) {
                return scene.vars.category.ruleWhiskerUpperBottom;
            }).lock(a_height, function(scene) {
                return scene.vars.category.ruleWhiskerUpperHeight;
            });
            this.pvRuleWhiskerLower = setupRuleWhisker(new pvc.visual.Rule(this,this.pvBoxPanel,{
                extensionId: "boxRuleWhisker",
                freePosition: !0,
                noHover: !1,
                noSelect: !1,
                noClick: !1,
                noDoubleClick: !1,
                showsInteraction: !0
            })).intercept("visible", function(scene) {
                return scene.vars.category.showRuleWhiskerBelow && this.delegateExtension(!0);
            }).pvMark.lock(a_bottom, function(scene) {
                return scene.vars.category.ruleWhiskerLowerBottom;
            }).lock(a_height, function(scene) {
                return scene.vars.category.ruleWhiskerLowerHeight;
            });
            this.pvBar = setupHCateg(new pvc.visual.Bar(this,this.pvBoxPanel,{
                extensionId: "boxBar",
                freePosition: !0,
                normalStroke: !0
            })).intercept("visible", function(scene) {
                return scene.vars.category.showBox && this.delegateExtension(!0);
            }).lockMark(a_bottom, function(scene) {
                return scene.vars.category.boxBottom;
            }).lockMark(a_height, function(scene) {
                return scene.vars.category.boxHeight;
            }).override("defaultColor", defaultColor).override("defaultStrokeWidth", def.fun.constant(1)).pvMark;
            this.pvRuleMin = setupHRule(new pvc.visual.Rule(this,this.pvBoxPanel,{
                extensionId: "boxRuleMin",
                freePosition: !0,
                noHover: !1,
                noSelect: !1,
                noClick: !1,
                noDoubleClick: !1,
                showsInteraction: !0
            })).intercept("visible", function(scene) {
                return null != scene.vars.minimum.value && this.delegateExtension(!0);
            }).pvMark.lock(a_bottom, function(scene) {
                return scene.vars.minimum.position;
            });
            this.pvRuleMax = setupHRule(new pvc.visual.Rule(this,this.pvBoxPanel,{
                extensionId: "boxRuleMax",
                freePosition: !0,
                noHover: !1,
                noSelect: !1,
                noClick: !1,
                noDoubleClick: !1,
                showsInteraction: !0
            })).intercept("visible", function(scene) {
                return null != scene.vars.maximum.value && this.delegateExtension(!0);
            }).pvMark.lock(a_bottom, function(scene) {
                return scene.vars.maximum.position;
            });
            this.pvRuleMedian = setupHRule(new pvc.visual.Rule(this,this.pvBoxPanel,{
                extensionId: "boxRuleMedian",
                freePosition: !0,
                noHover: !1,
                noSelect: !1,
                noClick: !1,
                noDoubleClick: !1,
                showsInteraction: !0
            })).intercept("visible", function(scene) {
                return null != scene.vars.median.value && this.delegateExtension(!0);
            }).lockMark(a_bottom, function(scene) {
                return scene.vars.median.position;
            }).override("defaultStrokeWidth", def.fun.constant(2)).pvMark;
        },
        renderInteractive: function() {
            this.pvBoxPanel.render();
        },
        _buildScene: function() {
            function createCategScene(categData) {
                var categScene = new pvc.visual.Scene(rootScene,{
                    source: categData
                })
                  , vars = categScene.vars;
                vars.series = new pvc_ValueLabelVar(null,"");
                var catVar = vars.category = new pvc_ValueLabelVar(categData.value,categData.label);
                def.set(catVar, "group", categData, "x", baseScale(categData.value), "width", bandWidth, "boxWidth", boxWidth, "boxLeft", bandWidth / 2 - boxWidth / 2);
                chart.measureVisualRoles().forEach(function(role) {
                    var svar, dimName = measureRolesDimNames[role.name];
                    if (dimName) {
                        var dim = categData.dimensions(dimName)
                          , value = dim.value(visibleKeyArgs);
                        svar = new pvc_ValueLabelVar(value,dim.format(value));
                        svar.position = orthoScale(value);
                    } else {
                        svar = new pvc_ValueLabelVar(null,"");
                        svar.position = null;
                    }
                    vars[role.name] = svar;
                });
                colorVarHelper.onNewScene(categScene, !0);
                var bottom, top, hasMin = null != vars.minimum.value, hasLower = null != vars.lowerQuartil.value, hasMedian = null != vars.median.value, hasUpper = null != vars.upperQuartil.value, show = hasLower || hasUpper;
                if (show) {
                    bottom = hasLower ? vars.lowerQuartil.position : hasMedian ? vars.median.position : vars.upperQuartil.position;
                    top = hasUpper ? vars.upperQuartil.position : hasMedian ? vars.median.position : vars.lowerQuartil.position;
                    show = top !== bottom;
                    if (show) {
                        catVar.boxBottom = bottom;
                        catVar.boxHeight = top - bottom;
                    }
                }
                catVar.showBox = show;
                show = null != vars.maximum.value;
                if (show) {
                    bottom = hasUpper ? vars.upperQuartil.position : hasMedian ? vars.median.position : hasLower ? vars.lowerQuartil.position : hasMin ? vars.minimum.position : null;
                    show = null != bottom;
                    if (show) {
                        catVar.ruleWhiskerUpperBottom = bottom;
                        catVar.ruleWhiskerUpperHeight = vars.maximum.position - bottom;
                    }
                }
                catVar.showRuleWhiskerUpper = show;
                show = hasMin;
                if (show) {
                    top = hasLower ? vars.lowerQuartil.position : hasMedian ? vars.median.position : hasUpper ? vars.upperQuartil.position : null;
                    show = null != top;
                    if (show) {
                        bottom = vars.minimum.position;
                        catVar.ruleWhiskerLowerHeight = top - bottom;
                        catVar.ruleWhiskerLowerBottom = bottom;
                    }
                }
                catVar.showRuleWhiskerBelow = show;
            }
            var chart = this.chart
              , measureRolesDimNames = def.query(chart.measureVisualRoles()).object({
                name: function(role) {
                    return role.name;
                },
                value: function(role) {
                    return role.firstDimensionName();
                }
            })
              , visibleKeyArgs = {
                visible: !0,
                zeroIfNone: !1
            }
              , data = this.visibleData({
                ignoreNulls: !1
            })
              , rootScene = new pvc.visual.Scene(null,{
                panel: this,
                source: data
            })
              , baseScale = this.axes.base.scale
              , bandWidth = baseScale.range().band
              , boxWidth = Math.min(bandWidth * this.boxSizeRatio, this.maxBoxSize)
              , orthoScale = this.axes.ortho.scale
              , colorVarHelper = new pvc.visual.RoleVarHelper(rootScene,this.visualRoles.color,{
                roleVar: "color"
            });
            data.children().each(createCategScene, this);
            return rootScene;
        }
    });
    def.type("pvc.BoxplotChart", pvc.CategoricalAbstract).add({
        _processOptionsCore: function(options) {
            this.base.apply(this, arguments);
            options.stacked = !1;
        },
        _initVisualRoles: function() {
            this.base();
            var roleSpecBase = {
                isMeasure: !0,
                requireSingleDimension: !0,
                requireIsDiscrete: !1,
                valueType: Number
            };
            [{
                name: "median",
                label: "Median",
                defaultDimension: "median",
                isRequired: !0
            }, {
                name: "lowerQuartil",
                label: "Lower Quartil",
                defaultDimension: "lowerQuartil"
            }, {
                name: "upperQuartil",
                label: "Upper Quartil",
                defaultDimension: "upperQuartil"
            }, {
                name: "minimum",
                label: "Minimum",
                defaultDimension: "minimum"
            }, {
                name: "maximum",
                label: "Maximum",
                defaultDimension: "maximum"
            }].forEach(function(info) {
                this._addVisualRole(info.name, def.create(roleSpecBase, info));
            }, this);
        },
        _getTranslationClass: function(translOptions) {
            return def.type(this.base(translOptions)).add(pvc.data.BoxplotChartTranslationOper);
        },
        _initPlotsCore: function() {
            new pvc.visual.BoxPlot(this);
            if (this.options.plot2) {
                this._animatable = !0;
                new pvc.visual.PointPlot(this,{
                    name: "plot2",
                    defaults: {
                        LinesVisible: !0,
                        DotsVisible: !0,
                        OrthoRole: "median",
                        ColorAxis: 2
                    },
                    fixed: {
                        OrthoAxis: 1
                    }
                });
            }
        },
        _initAxes: function(hasMultiRole) {
            this.base(hasMultiRole);
            var typeAxes = this.axesByType.ortho;
            typeAxes && typeAxes.forEach(function(axis) {
                axis.option.defaults({
                    Offset: .02
                });
            });
        },
        _createPlotPanels: function(parentPanel, baseOptions) {
            var plots = this.plots
              , boxPlot = plots.box
              , boxPanel = new pvc.BoxplotPanel(this,parentPanel,boxPlot,Object.create(baseOptions));
            this.bpChartPanel = boxPanel;
            var plot2Plot = plots.plot2;
            if (plot2Plot) {
                pvc.debug >= 3 && this._log("Creating Point panel.");
                var pointPanel = new pvc.PointPanel(this,parentPanel,plot2Plot,Object.create(baseOptions));
                pointPanel._v1DimRoleName.value = plot2Plot.option("OrthoRole");
            }
        },
        defaults: {
            crosstabMode: !1
        }
    }).addStatic({
        measureRolesNames: ["median", "lowerQuartil", "upperQuartil", "minimum", "maximum"]
    });
    def.type("pvc.visual.TreemapDiscreteColorAxis", pvc.visual.ColorAxis).init(function(chart, type, index, keyArgs) {
        this.base(chart, type, index, keyArgs);
        this.isByParent = "byparent" === chart.plots.treemap.option("ColorMode");
    }).add({
        domainItemValueProp: function() {
            return this.role && this.role.grouping.isSingleDimension ? "value" : "absKey";
        },
        domainGroupOperator: function() {
            return "select";
        },
        _calcAvgColor: function(colors) {
            var L = colors.length;
            if (L > 1) {
                var r = 0
                  , g = 0
                  , b = 0
                  , a = 0;
                colors.forEach(function(c) {
                    var rgb = c.rgb();
                    r += rgb.r;
                    g += rgb.g;
                    b += rgb.b;
                    a += rgb.a;
                });
                var f = Math.floor;
                return pv.rgb(f(r / L), f(g / L), f(b / L), f(a / L));
            }
            var color = colors[0];
            return L ? color.darker(.7) : color;
        },
        _getBaseScheme: function() {
            var me = this
              , isNotDegenerate = function(data) {
                return null != data.value;
            }
              , children = function(data) {
                return data.children().where(isNotDegenerate);
            }
              , hasChildren = function(data) {
                return children(data).any();
            }
              , hasDerivedColor = function(data) {
                return children(data).any(hasChildren);
            }
              , derivedColorDatas = def.query(this.domainData().nodes()).where(hasDerivedColor).array()
              , baseScheme = me.option("Colors");
            return function(d) {
                var domainKeys = d instanceof Array ? d : def.array.copy(arguments)
                  , derivedDatasByKey = def.query(derivedColorDatas).object({
                    name: function(itemData) {
                        return me.domainItemValue(itemData);
                    }
                });
                def.array.removeIf(domainKeys, function(k) {
                    return def.hasOwnProp.call(derivedDatasByKey, k);
                });
                var baseScale = baseScheme(domainKeys)
                  , derivedColorMap = {}
                  , getColor = function(itemData) {
                    var c, k = me.domainItemValue(itemData);
                    if (def.hasOwnProp.call(derivedDatasByKey, k)) {
                        c = def.getOwn(derivedColorMap, k);
                        if (!c) {
                            var colors = children(itemData).select(getColor).array();
                            if (!colors.length)
                                throw def.assert("Should have at least one child that is also a parent.");
                            c = derivedColorMap[k] = me._calcAvgColor(colors);
                        }
                    } else
                        c = baseScale(k);
                    return c;
                };
                derivedColorDatas.forEach(getColor);
                var scale = function(k) {
                    return def.getOwn(derivedColorMap, k) || baseScale(k);
                };
                def.copy(scale, baseScale);
                var d2, r2;
                scale.domain = function() {
                    if (arguments.length)
                        throw def.error.operationInvalid("The scale cannot be modified.");
                    return d2 || (d2 = def.array.append(def.ownKeys(derivedColorMap), domainKeys));
                }
                ;
                scale.range = function() {
                    if (arguments.length)
                        throw def.error.operationInvalid("The scale cannot be modified.");
                    return r2 || (r2 = def.array.append(def.own(derivedColorMap), baseScale.range()));
                }
                ;
                return scale;
            }
            ;
        },
        _selectDomainItems: function(domainData) {
            var candidates = def.query(domainData.nodes())
              , isNotDegenerate = function(data) {
                return null != data.value;
            }
              , children = function(data) {
                return data.children().where(isNotDegenerate);
            }
              , hasChildren = function(data) {
                return children(data).any();
            }
              , isLeaf = function(data) {
                return !hasChildren(data);
            };
            return candidates.where(this.isByParent ? function(itemData) {
                return itemData.parent ? isNotDegenerate(itemData) && hasChildren(itemData) : isLeaf(itemData) || children(itemData).any(isLeaf);
            }
            : function(itemData) {
                return (!itemData.parent || isNotDegenerate(itemData)) && isLeaf(itemData);
            }
            );
        }
    });
    def.type("pvc.data.TreemapChartTranslationOper").add({
        _configureTypeCore: function() {
            var autoDimNames = []
              , freeMeaIndexes = []
              , freeDisIndexes = [];
            this.collectFreeDiscreteAndConstinuousIndexes(freeDisIndexes, freeMeaIndexes);
            var D = freeDisIndexes.length
              , M = freeMeaIndexes.length;
            D && this._getUnboundRoleDefaultDimNames("category", D, autoDimNames);
            M && def.query(["size", "color"]).take(M).each(function(roleName) {
                this._getUnboundRoleDefaultDimNames(roleName, 1, autoDimNames);
            }, this);
            autoDimNames.length && this.defReader({
                names: autoDimNames
            });
        }
    });
    def.type("pvc.TreemapPanel", pvc.PlotPanel).init(function(chart, parent, plot, options) {
        this.base(chart, parent, plot, options);
        this.axes.size = chart._getAxis("size", (plot.option("SizeAxis") || 0) - 1);
        this.visualRoles.size = chart.visualRole(plot.option("SizeRole"));
        this.layoutMode = plot.option("LayoutMode");
    }).add({
        _createCore: function(layoutInfo) {
            var me = this
              , cs = layoutInfo.clientSize
              , rootScene = me._buildScene();
            if (rootScene) {
                if (!rootScene.childNodes.length && !this.visualRoles.multiChart.isBound())
                    throw new InvalidDataException("Unable to create a treemap chart, please check the data values.");
                var lw0 = def.number.to(me._getConstantExtension("leaf", "lineWidth"), 1)
                  , lw = lw0
                  , lw2 = lw / 2
                  , sizeProp = me.visualRoles.size.isBound() ? me.axes.size.scale.by1(function(scene) {
                    return scene.vars.size.value;
                }) : 100
                  , panel = me.pvTreemapPanel = new pvc.visual.Panel(me,me.pvPanel,{
                    panelType: pv.Layout.Treemap,
                    extensionId: "panel"
                }).pvMark.lock("visible", !0).lock("nodes", rootScene.nodes()).lock("left", lw2).lock("top", lw2).lock("width", cs.width - lw).lock("height", cs.height - lw).lock("size", sizeProp).lock("mode", me.layoutMode).lock("order", null).lock("round", !1);
                panel.node.left(function(n) {
                    return n.x + lw2;
                }).top(function(n) {
                    return n.y + lw2;
                }).width(function(n) {
                    return n.dx - lw;
                }).height(function(n) {
                    return n.dy - lw;
                });
                var colorScale, colorAxis = me.axes.color;
                colorScale = me.visualRoles.color.isBound() ? colorAxis.sceneScale({
                    sceneVarName: "color"
                }) : def.fun.constant(colorAxis.option("Unbound"));
                var pvLeafMark = new pvc.visual.Bar(me,panel.leaf,{
                    extensionId: "leaf"
                }).lockMark("visible").override("defaultColor", function(scene) {
                    return colorScale(scene);
                }).override("defaultStrokeWidth", function() {
                    return lw0;
                }).pvMark.antialias(!1).lineCap("round").strokeDasharray(function(scene) {
                    return scene.vars.size.value < 0 ? "dash" : null;
                });
                new pvc.visual.Bar(me,panel.node,{
                    extensionId: "ascendant",
                    noHover: !0,
                    noSelect: !0,
                    noClick: !0,
                    noDoubleClick: !0
                }).intercept("visible", function(scene) {
                    return !!scene.parent && !!scene.firstChild && this.delegateExtension(!0);
                }).override("anyInteraction", function(scene) {
                    return scene.anyInteraction() || scene.isActiveDescendantOrSelf();
                }).override("defaultStrokeWidth", function() {
                    return 1.5 * lw;
                }).override("interactiveStrokeWidth", function(scene, w) {
                    this.showsActivity() && scene.isActiveDescendantOrSelf() && (w = 1.5 * Math.max(1, w));
                    return w;
                }).override("defaultColor", function(scene) {
                    return colorScale(scene);
                }).override("normalColor", def.fun.constant(null)).override("interactiveColor", function(scene, color, type) {
                    if ("stroke" === type) {
                        if (this.showsActivity()) {
                            if (scene.isActiveDescendantOrSelf())
                                return pv.color(color).brighter(.5);
                            if (scene.anyActive())
                                return null;
                        }
                        if (this.showsSelection() && scene.isSelectedDescendantOrSelf())
                            return pv.color(color).brighter(.5);
                    }
                    return null;
                }).pvMark.antialias(!1);
                var label = pvc.visual.ValueLabel.maybeCreate(me, panel.label, {
                    noAnchor: !0
                });
                label && label.pvMark.textMargin(3).sign.optional("textAngle", function(scene) {
                    var text = this.defaultText(scene)
                      , pvLabel = this.pvMark;
                    return scene.dx - 2 * pvLabel.textMargin() > pv.Text.measureWidth(text, pvLabel.font()) ? 0 : scene.dx >= scene.dy ? 0 : -Math.PI / 2;
                }).override("calcTextFitInfo", function(scene, text) {
                    var pvLabel = this.pvMark
                      , tm = pvLabel.textMargin();
                    if (!(-1e-6 > tm)) {
                        var ta = pvLabel.textAngle();
                        isHorizText = Math.abs(Math.sin(ta)) < 1e-6,
                        isVertiText = !isHorizText && Math.abs(Math.cos(ta)) < 1e-6;
                        if (isHorizText || isVertiText) {
                            var twMax, hide = !1, m = pv.Text.measure(text, pvLabel.font()), th = .75 * m.height, thMax = scene[isVertiText ? "dx" : "dy"];
                            "middle" !== pvLabel.textBaseline() && (thMax /= 2);
                            thMax -= 2 * tm;
                            hide |= th > thMax;
                            var twMax = scene[isVertiText ? "dy" : "dx"];
                            "center" !== pvLabel.textAlign() && (twMax /= 2);
                            twMax -= 2 * tm;
                            hide |= 0 >= twMax || this.hideOverflowed && m.width > twMax;
                            return {
                                hide: hide,
                                widthMax: twMax
                            };
                        }
                    }
                }).override("getAnchoredToMark", function() {
                    return pvLeafMark;
                });
            }
        },
        _getExtensionId: function() {
            var extensionIds = [{
                abs: this.chart.parent ? "smallContent" : "content"
            }];
            return extensionIds.concat(this.base());
        },
        renderInteractive: function() {
            this.pvTreemapPanel.render();
        },
        _buildScene: function() {
            var data = this.visibleData({
                ignoreNulls: !1
            });
            if (!data.childCount())
                return null;
            var roles = this.visualRoles
              , rootScene = new pvc.visual.Scene(null,{
                panel: this,
                source: data
            })
              , sizeVarHelper = new pvc.visual.RoleVarHelper(rootScene,roles.size,{
                roleVar: "size",
                allowNestedVars: !0,
                hasPercentSubVar: !0
            })
              , sizeIsBound = roles.size.isBound()
              , colorGrouping = roles.color && roles.color.grouping
              , colorByParent = colorGrouping && "byparent" === this.plot.option("ColorMode")
              , recursive = function(scene) {
                var group = scene.group;
                scene.vars.category = pvc_ValueLabelVar.fromComplex(group);
                sizeVarHelper.onNewScene(scene, !0);
                if (sizeIsBound && !scene.vars.size.value) {
                    scene.parentNode && scene.parentNode.removeChild(scene);
                    return scene;
                }
                var children = group.children().where(function(childData) {
                    return null != childData.value;
                }).array();
                if (colorGrouping) {
                    var colorGroup = colorByParent && !children.length ? group.parent : group;
                    if (colorGroup) {
                        var colorView = colorGrouping.view(colorGroup);
                        scene.vars.color = new pvc_ValueLabelVar(colorView.keyTrimmed(),colorView.label);
                    } else
                        scene.vars.color = new pvc_ValueLabelVar(null,"");
                } else
                    scene.parent || (scene.vars.color = new pvc_ValueLabelVar(null,""));
                children.length && children.forEach(function(childData) {
                    recursive(new pvc.visual.Scene(scene,{
                        source: childData
                    }));
                });
                return scene;
            };
            return recursive(rootScene);
        }
    });
    def.type("pvc.TreemapChart", pvc.BaseChart).add({
        _animatable: !1,
        _axisClassByType: {
            size: pvc.visual.NormalizedAxis
        },
        _axisCreateIfUnbound: {
            color: !0
        },
        _getColorRoleSpec: function() {
            return {
                defaultSourceRole: "category",
                defaultDimension: "color*"
            };
        },
        _initVisualRoles: function() {
            this.base();
            this._addVisualRole("category", {
                isRequired: !0,
                defaultDimension: "category*",
                autoCreateDimension: !0
            });
            this._addVisualRole("size", {
                isMeasure: !0,
                isRequired: !1,
                isPercent: !0,
                requireSingleDimension: !0,
                requireIsDiscrete: !1,
                valueType: Number,
                defaultDimension: "size"
            });
        },
        _getTranslationClass: function(translOptions) {
            return def.type(this.base(translOptions)).add(pvc.data.TreemapChartTranslationOper);
        },
        _getIsNullDatum: def.fun.constant(),
        _initPlotsCore: function() {
            var treemapPlot = new pvc.visual.TreemapPlot(this);
            null == this.options.legend && (this.options.legend = "byparent" === treemapPlot.option("ColorMode"));
            var rootCategoryLabel = treemapPlot.option("RootCategoryLabel");
            this.visualRoles.category.setRootLabel(rootCategoryLabel);
            this.visualRoles.color.setRootLabel(rootCategoryLabel);
        },
        _initAxes: function(hasMultiRole) {
            if (this.visualRoles.color.isDiscrete()) {
                def.hasOwnProp.call(this, "_axisClassByType") || (this._axisClassByType = Object.create(this._axisClassByType));
                this._axisClassByType.color = pvc.visual.TreemapDiscreteColorAxis;
            } else
                delete this._axisClassByType;
            return this.base(hasMultiRole);
        },
        _createContent: function(contentOptions) {
            this.base();
            var treemapPlot = this.plots.treemap;
            new pvc.TreemapPanel(this,this.basePanel,treemapPlot,contentOptions);
        },
        _createVisibleData: function(baseData, ka) {
            return this.visualRoles.category.select(baseData, ka);
        },
        defaults: {
            legend: null
        }
    });
    def.type("pvc.visual.SunburstDiscreteColorAxis", pvc.visual.ColorAxis).add({
        _getOptionsDefinition: function() {
            return sunburstColorAxis_optionsDef;
        },
        domainItemValueProp: function() {
            return this.role && this.role.grouping.isSingleDimension ? "value" : "absKey";
        },
        domainGroupOperator: function() {
            return "select";
        },
        _selectDomainItems: function(domainData) {
            var candidates = def.query(domainData.nodes())
              , isNotDegenerate = function(data) {
                return null != data.value;
            };
            return candidates.where(function(itemData) {
                return itemData.parent ? isNotDegenerate(itemData) && !itemData.parent.parent : !1;
            });
        }
    });
    var sunburstColorAxis_optionsDef = def.create(colorAxis_optionsDef, {
        SliceBrightnessFactor: {
            resolve: "_resolveFull",
            cast: pvc.castNonNegativeNumber,
            value: 1
        }
    });
    def.type("pvc.visual.SunburstSlice", pvc.visual.Sign).init(function(panel, protoMark, keyArgs) {
        var pvMark = protoMark.add(pv.Wedge);
        keyArgs = def.setDefaults(keyArgs, "freeColor", !1);
        this.base(panel, pvMark, keyArgs);
        this._bindProperty("lineWidth", "strokeWidth");
    }).prototype.property("strokeWidth").constructor.add({
        defaultStrokeWidth: def.fun.constant(.5),
        interactiveStrokeWidth: function(scene, strokeWidth) {
            return this.showsActivity() && scene.isActiveDescendantOrSelf() ? 2 * Math.max(1, strokeWidth) : strokeWidth;
        },
        defaultColor: function(scene) {
            return scene.color;
        },
        normalColor: function(scene, color, type) {
            return color && "stroke" === type ? color.darker() : color;
        },
        interactiveColor: function(scene, color, type) {
            if (this.showsActivity())
                if ("stroke" === type) {
                    if (scene.isActiveDescendantOrSelf())
                        return color.brighter(2).alpha(.7);
                } else if (scene.isActive)
                    return color.brighter(.2).alpha(.8);
            return this.mayShowNotAmongSelected(scene) ? this.dimColor(color, type) : this.normalColor(scene, color, type);
        }
    });
    def.type("pvc.data.SunburstChartTranslationOper").add({
        _configureTypeCore: function() {
            var autoDimNames = []
              , freeMeaIndexes = []
              , freeDisIndexes = [];
            this.collectFreeDiscreteAndConstinuousIndexes(freeDisIndexes, freeMeaIndexes);
            var D = freeDisIndexes.length
              , M = freeMeaIndexes.length;
            D && this._getUnboundRoleDefaultDimNames("category", D, autoDimNames);
            M && this._getUnboundRoleDefaultDimNames("size", 1, autoDimNames);
            autoDimNames.length && this.defReader({
                names: autoDimNames
            });
        }
    });
    def.type("pvc.SunburstPanel", pvc.PlotPanel).init(function(chart, parent, plot, options) {
        this.base(chart, parent, plot, options);
        this.axes.size = chart._getAxis("size", (plot.option("SizeAxis") || 0) - 1);
        this.visualRoles.size = chart.visualRole(plot.option("SizeRole"));
        this.sliceOrder = plot.option("SliceOrder");
        this.emptySlicesVisible = plot.option("EmptySlicesVisible");
        this.emptySlicesLabel = this.emptySlicesVisible ? plot.option("EmptySlicesLabel") : "";
    }).add({
        _createCore: function(layoutInfo) {
            var labelFont = this._getConstantExtension("label", "font");
            def.string.is(labelFont) && (this.valuesFont = labelFont);
            var me = this
              , rootScene = (layoutInfo.clientSize,
            me._buildScene());
            if (rootScene) {
                if (!rootScene.childNodes.length && !this.visualRoles.multiChart.isBound())
                    throw new InvalidDataException("Unable to create a sunburst chart, please check the data values.");
                var sizeProp = me.visualRoles.size.isBound() ? me.axes.size.scale.by1(function(scene) {
                    return scene.vars.size.value;
                }) : def.fun.constant(100)
                  , panel = me.pvSunburstPanel = new pvc.visual.Panel(me,me.pvPanel,{
                    panelType: pv.Layout.Partition.Fill,
                    extensionId: "panel"
                }).pvMark.lock("visible", !0).lock("nodes", rootScene.nodes()).lock("size", sizeProp).lock("orient", "radial")
                  , slice = new pvc.visual.SunburstSlice(this,panel.node,{
                    extensionId: "slice",
                    tooltipArgs: {
                        options: {
                            useCorners: !0,
                            gravity: function() {
                                var ma = this.midAngle()
                                  , isRightPlane = Math.cos(ma) >= 0
                                  , isTopPlane = Math.sin(ma) >= 0;
                                return isRightPlane ? isTopPlane ? "nw" : "sw" : isTopPlane ? "ne" : "se";
                            }
                        }
                    }
                })
                  , label = pvc.visual.ValueLabel.maybeCreate(me, panel.label, {
                    noAnchor: !0
                });
                label && label.override("defaultText", function(scene) {
                    return scene.isRoot() ? "" : this.base(scene);
                }).override("calcTextFitInfo", function(scene, text) {
                    var pvLabel = this.pvMark
                      , tm = pvLabel.textMargin();
                    if (!(-1e-6 > tm) && "center" === pvLabel.textAlign() && text) {
                        var ma = pvc.normAngle(scene.midAngle)
                          , la = pvc.normAngle(pvLabel.textAngle())
                          , sameAngle = Math.abs(ma - la) < 1e-6
                          , oppoAngle = !1;
                        if (!sameAngle) {
                            var la2 = pvc.normAngle(la + Math.PI);
                            oppoAngle = Math.abs(ma - la2) < 1e-6;
                        }
                        if (sameAngle || oppoAngle) {
                            var twMax, ir = scene.innerRadius, irmin = ir, or = scene.outerRadius, tm = pvLabel.textMargin(), a = scene.angle, m = pv.Text.measure(text, pvLabel.font()), hide = !1;
                            if (a < Math.PI) {
                                var th = .85 * m.height
                                  , tb = pvLabel.textBaseline()
                                  , thEf = "middle" === tb ? th + tm / 2 : 2 * (th + 3 * tm / 2);
                                irmin = Math.max(irmin, thEf / (2 * Math.tan(a / 2)));
                            }
                            twMax = or - tm - irmin;
                            hide |= 0 >= twMax;
                            twMax -= tm;
                            hide |= this.hideOverflowed && m.width > twMax;
                            return {
                                hide: hide,
                                widthMax: twMax
                            };
                        }
                    }
                }).override("getAnchoredToMark", function() {
                    return slice.pvMark;
                });
            }
        },
        _getExtensionId: function() {
            var extensionIds = [{
                abs: this.chart.parent ? "smallContent" : "content"
            }];
            return extensionIds.concat(this.base());
        },
        renderInteractive: function() {
            this.pvSunburstPanel.render();
        },
        _buildScene: function() {
            var data = this.visibleData({
                ignoreNulls: !1
            })
              , emptySlicesVisible = this.emptySlicesVisible
              , emptySlicesLabel = this.emptySlicesLabel;
            if (!data.childCount())
                return null;
            var colorScale, roles = this.visualRoles, rootScene = new pvc.visual.SunburstScene(null,{
                panel: this,
                source: data
            }), sizeIsBound = roles.size.isBound(), sizeVarHelper = new pvc.visual.RoleVarHelper(rootScene,roles.size,{
                roleVar: "size",
                allowNestedVars: !0,
                hasPercentSubVar: !0
            }), colorGrouping = roles.color && roles.color.grouping, colorAxis = this.axes.color, colorBrightnessFactor = colorAxis.option("SliceBrightnessFactor");
            colorScale = roles.color.isBound() ? colorAxis.sceneScale({
                sceneVarName: "color"
            }) : def.fun.constant(colorAxis.option("Unbound"));
            var recursive = function(scene) {
                var group = scene.group
                  , catVar = scene.vars.category = pvc_ValueLabelVar.fromComplex(group);
                emptySlicesLabel && null == catVar.value && (catVar.value = emptySlicesLabel);
                sizeVarHelper.onNewScene(scene, !0);
                if (sizeIsBound && !scene.vars.size.value) {
                    scene.parentNode && scene.parentNode.removeChild(scene);
                    return scene;
                }
                var children = group.children();
                emptySlicesVisible || (children = children.where(function(childData) {
                    return null != childData.value;
                }));
                if (colorGrouping) {
                    var colorView = colorGrouping.view(group);
                    scene.vars.color = new pvc_ValueLabelVar(colorView.keyTrimmed(),colorView.label);
                } else
                    scene.vars.color = new pvc_ValueLabelVar(null,"");
                children.each(function(childData) {
                    recursive(new pvc.visual.SunburstScene(scene,{
                        source: childData
                    }));
                });
                return scene;
            }
              , calculateColor = function(scene, index, siblingsSize) {
                var baseColor = null
                  , parent = scene.parent;
                if (parent) {
                    baseColor = colorScale(scene);
                    if (!parent.isRoot() && !baseColor.isFixedColor) {
                        baseColor = parent.color;
                        index && colorBrightnessFactor && (baseColor = baseColor.brighter(colorBrightnessFactor * index / (siblingsSize - 1)));
                    }
                }
                scene.color = baseColor;
                var children = scene.childNodes
                  , childrenSize = children.length;
                children.forEach(function(childScene, index) {
                    calculateColor(childScene, index, childrenSize);
                });
            };
            recursive(rootScene);
            if (this.sliceOrder && sizeIsBound && "none" !== this.sliceOrder) {
                var compare = "bysizeascending" === this.sliceOrder ? def.ascending : def.descending;
                rootScene.sort(function(sceneA, sceneB) {
                    return compare(sceneA.vars.size.value, sceneB.vars.size.value) || def.ascending(sceneA.childIndex(), sceneB.childIndex());
                });
            }
            calculateColor(rootScene, 0);
            return rootScene;
        }
    });
    def.type("pvc.visual.SunburstScene", pvc.visual.Scene).add({
        _createSelectedInfo: function() {
            var any = this.chart().data.owner.selectedCount() > 0
              , isSelected = any && this.datums().all(datum_isSelected);
            return {
                any: any,
                is: isSelected
            };
        }
    });
    def.type("pvc.SunburstChart", pvc.BaseChart).add({
        _animatable: !0,
        _axisClassByType: {
            size: pvc.visual.NormalizedAxis
        },
        _axisCreateIfUnbound: {
            color: !0
        },
        _getColorRoleSpec: function() {
            return {
                defaultSourceRole: "category",
                defaultDimension: "color*",
                requireIsDiscrete: !0
            };
        },
        _initVisualRoles: function() {
            this.base();
            this._addVisualRole("category", {
                isRequired: !0,
                defaultDimension: "category*",
                autoCreateDimension: !0
            });
            this._addVisualRole("size", {
                isMeasure: !0,
                isRequired: !1,
                isPercent: !0,
                requireSingleDimension: !0,
                requireIsDiscrete: !1,
                valueType: Number,
                defaultDimension: "size"
            });
        },
        _getTranslationClass: function(translOptions) {
            return def.type(this.base(translOptions)).add(pvc.data.SunburstChartTranslationOper);
        },
        _getIsNullDatum: def.fun.constant(),
        _initPlotsCore: function() {
            var sunburstPlot = new pvc.visual.SunburstPlot(this);
            this.options.legend = !1;
            var rootCategoryLabel = sunburstPlot.option("RootCategoryLabel");
            this.visualRoles.category.setRootLabel(rootCategoryLabel);
            this.visualRoles.color.setRootLabel(rootCategoryLabel);
        },
        _initAxes: function(hasMultiRole) {
            def.hasOwnProp.call(this, "_axisClassByType") || (this._axisClassByType = Object.create(this._axisClassByType));
            this._axisClassByType.color = pvc.visual.SunburstDiscreteColorAxis;
            return this.base(hasMultiRole);
        },
        _createContent: function(contentOptions) {
            this.base();
            var sunburstPlot = this.plots.sunburst;
            new pvc.SunburstPanel(this,this.basePanel,sunburstPlot,contentOptions);
        },
        _createVisibleData: function(baseData, ka) {
            return this.visualRoles.category.select(baseData, ka);
        }
    });
    return pvc;
}(def, pv);

/*!
 * Copyright 2002 - 2013 Webdetails, a Pentaho company.  All rights reserved.
 *
 * This software was developed by Webdetails and is provided under the terms
 * of the Mozilla Public License, Version 2.0, or any later version. You may not use
 * this file except in compliance with the license. If you need a copy of the license,
 * please go to  http://mozilla.org/MPL/2.0/. The Initial Developer is Webdetails.
 *
 * Software distributed under the Mozilla Public License is distributed on an "AS IS"
 * basis, WITHOUT WARRANTY OF ANY KIND, either express or  implied. Please refer to
 * the license for the specific language governing your rights and limitations.
 */

/*!
 * tipsy, facebook style tooltips for jquery
 * version 1.0.0a
 * (c) 2008-2010 jason frame [jason@onehackoranother.com]
 * released under the MIT license
 */

!function($) {
    function fixTitle($ele) {
        var title = $ele.attr("title");
        (title || "string" != typeof $ele.attr("original-title")) && $ele.attr("original-title", title || "").removeAttr("title");
    }
    function Tipsy(element, options) {
        this.$element = $(element);
        this.options = options;
        this.enabled = !0;
        fixTitle(this.$element);
    }
    Tipsy.prototype = {
        enter: function() {
            var tipsy = this
              , options = this.options;
            if (0 == options.delayIn) {
                tipsy.hoverState = null;
                tipsy.show();
            } else {
                tipsy.hoverState = "in";
                setTimeout(function() {
                    if ("in" === tipsy.hoverState) {
                        tipsy.hoverState = null;
                        tipsy.show();
                    }
                }, options.delayIn);
            }
        },
        leave: function() {
            var tipsy = this
              , options = this.options;
            if (0 == options.delayOut)
                tipsy.hide();
            else {
                tipsy.hoverState = "out";
                setTimeout(function() {
                    "out" === tipsy.hoverState && tipsy.hide();
                }, options.delayOut);
            }
        },
        visible: function() {
            var parent;
            return "in" === this.hoverState || "out" !== this.hoverState && !(!this.$tip || !(parent = this.$tip[0].parentNode) || 11 === parent.nodeType);
        },
        update: function() {
            this.visible() ? this.show(!0) : this.enter();
        },
        show: function(isUpdate) {
            function calcPosition(gravity) {
                var tp;
                switch (gravity.charAt(0)) {
                case "n":
                    tp = {
                        top: pos.top + pos.height + tipOffset,
                        left: pos.left + pos.width / 2 - actualWidth / 2
                    };
                    break;

                case "s":
                    tp = {
                        top: pos.top - actualHeight - tipOffset,
                        left: pos.left + pos.width / 2 - actualWidth / 2
                    };
                    break;

                case "e":
                    tp = {
                        top: pos.top + pos.height / 2 - actualHeight / 2,
                        left: pos.left - actualWidth - tipOffset
                    };
                    break;

                case "w":
                    tp = {
                        top: pos.top + pos.height / 2 - actualHeight / 2,
                        left: pos.left + pos.width + tipOffset
                    };
                }
                2 === gravity.length && (tp.left = "w" == gravity.charAt(1) ? useCorners ? pos.left + pos.width + tipOffset : pos.left + pos.width / 2 - 15 : useCorners ? pos.left - actualWidth - tipOffset : pos.left + pos.width / 2 - actualWidth + 15);
                return tp;
            }
            if ("in" !== this.hoverState) {
                var title = this.getTitle();
                if (this.enabled && title) {
                    var $tip = this.tip();
                    $tip.find(".tipsy-inner")[this.options.html ? "html" : "text"](title);
                    $tip[0].className = "tipsy";
                    isUpdate || $tip.remove();
                    var parent = $tip[0].parentNode;
                    parent && 11 !== parent.nodeType || $tip.css({
                        top: 0,
                        left: 0,
                        visibility: "hidden",
                        display: "block"
                    }).appendTo(document.body);
                    var pos = $.extend({}, this.$element.offset());
                    if (this.$element[0].nearestViewportElement) {
                        var rect = this.$element[0].getBoundingClientRect();
                        pos.width = rect.width;
                        pos.height = rect.height;
                    } else {
                        pos.width = this.$element[0].offsetWidth || 0;
                        pos.height = this.$element[0].offsetHeight || 0;
                    }
                    var tipOffset = this.options.offset
                      , useCorners = this.options.useCorners
                      , showArrow = this.options.arrowVisible
                      , actualWidth = $tip[0].offsetWidth
                      , actualHeight = $tip[0].offsetHeight;
                    showArrow || (tipOffset -= 4);
                    var gravity = "function" == typeof this.options.gravity ? this.options.gravity.call(this.$element[0], {
                        width: actualWidth,
                        height: actualHeight
                    }, calcPosition) : this.options.gravity
                      , tp = calcPosition(gravity);
                    $tip.css(tp).addClass("tipsy-" + gravity + (useCorners && gravity.length > 1 ? gravity.charAt(1) : ""));
                    if (showArrow) {
                        var hideArrow = useCorners && 2 === gravity.length;
                        $tip.find(".tipsy-arrow")[hideArrow ? "hide" : "show"]();
                    }
                    var doFadeIn = this.options.fade && (!isUpdate || !this._prevGravity || this._prevGravity !== gravity);
                    doFadeIn ? $tip.stop().css({
                        opacity: 0,
                        display: "block",
                        visibility: "visible"
                    }).animate({
                        opacity: this.options.opacity
                    }) : $tip.css({
                        visibility: "visible",
                        opacity: this.options.opacity
                    });
                    this._prevGravity = gravity;
                    this.hoverState = null;
                } else {
                    this.hoverState = null;
                    this.hide();
                }
            }
        },
        hide: function() {
            this.options.fade ? this.tip().stop().fadeOut(function() {
                $(this).remove();
            }) : this.$tip && this.tip().remove();
            this.hoverState = null;
        },
        setTitle: function(title) {
            title = null == title ? "" : "" + title;
            this.$element.attr("original-title", title).removeAttr("title");
        },
        getTitle: function() {
            var title, $e = this.$element, o = this.options;
            fixTitle($e);
            "string" == typeof o.title ? title = $e.attr("title" == o.title ? "original-title" : o.title) : "function" == typeof o.title && (title = o.title.call($e[0]));
            title = ("" + title).replace(/(^\s*|\s*$)/, "");
            return title || o.fallback;
        },
        tip: function() {
            if (!this.$tip) {
                this.$tip = $('<div class="tipsy"></div>');
                this.$tip.html(this.options.arrowVisible ? '<div class="tipsy-arrow"></div><div class="tipsy-inner"/></div>' : '<div class="tipsy-inner"/></div>');
                this.$tip.remove();
            }
            return this.$tip;
        },
        validate: function() {
            var parent = this.$element[0].parentNode;
            if (!parent || 11 === parent.nodeType) {
                this.hide();
                this.$element = null;
                this.options = null;
            }
        },
        enable: function() {
            this.enabled = !0;
        },
        disable: function() {
            this.enabled = !1;
        },
        toggleEnabled: function() {
            this.enabled = !this.enabled;
        }
    };
    $.fn.tipsy = function(options, arg) {
        function get(ele) {
            var tipsy = $.data(ele, "tipsy");
            if (!tipsy) {
                tipsy = new Tipsy(ele,$.fn.tipsy.elementOptions(ele, options));
                $.data(ele, "tipsy", tipsy);
            }
            return tipsy;
        }
        function enter() {
            get(this).enter();
        }
        function leave() {
            get(this).leave();
        }
        if (options === !0)
            return this.data("tipsy");
        if ("string" == typeof options)
            return this.data("tipsy")[options](arg);
        options = $.extend({}, $.fn.tipsy.defaults, options);
        null == options.arrowVisible && (options.arrowVisible = !options.useCorners);
        options.live || this.each(function() {
            get(this);
        });
        if ("manual" != options.trigger) {
            var binder = options.live ? "live" : "bind"
              , eventIn = "hover" == options.trigger ? "mouseenter" : "focus"
              , eventOut = "hover" == options.trigger ? "mouseleave" : "blur";
            this[binder](eventIn, enter)[binder](eventOut, leave);
        }
        return this;
    }
    ;
    $.fn.tipsy.defaults = {
        delayIn: 0,
        delayOut: 0,
        fade: !1,
        fallback: "",
        gravity: "n",
        html: !1,
        live: !1,
        offset: 0,
        opacity: .8,
        title: "title",
        trigger: "hover",
        useCorners: !1,
        arrowVisible: null
    };
    $.fn.tipsy.elementOptions = function(ele, options) {
        return $.metadata ? $.extend({}, options, $(ele).metadata()) : options;
    }
    ;
    $.fn.tipsy.autoNS = function() {
        return $(this).offset().top > $(document).scrollTop() + $(window).height() / 2 ? "s" : "n";
    }
    ;
    $.fn.tipsy.autoWE = function() {
        return $(this).offset().left > $(document).scrollLeft() + $(window).width() / 2 ? "e" : "w";
    }
    ;
}(jQuery);
/*!
 * Copyright 2002 - 2013 Webdetails, a Pentaho company.  All rights reserved.
 *
 * This software was developed by Webdetails and is provided under the terms
 * of the Mozilla Public License, Version 2.0, or any later version. You may not use
 * this file except in compliance with the license. If you need a copy of the license,
 * please go to  http://mozilla.org/MPL/2.0/. The Initial Developer is Webdetails.
 *
 * Software distributed under the Mozilla Public License is distributed on an "AS IS"
 * basis, WITHOUT WARRANTY OF ANY KIND, either express or  implied. Please refer to
 * the license for the specific language governing your rights and limitations.
 */

!function() {
    function toParentTransform(parentPanel) {
        return pv.Transform.identity.translate(parentPanel.left(), parentPanel.top()).times(parentPanel.transform());
    }
    function getVisibleScreenBounds(mark) {
        for (var right, bottom, parent, instance = mark.instance(), left = instance.left, top = instance.top, width = instance.width, height = instance.height; parent = mark.parent; ) {
            if (0 > left) {
                width += left;
                left = 0;
            }
            if (0 > top) {
                height += top;
                top = 0;
            }
            right = instance.right;
            0 > right && (width += right);
            bottom = instance.bottom;
            0 > bottom && (height += bottom);
            var t = toParentTransform(parent)
              , s = t.k;
            left = t.x + s * left;
            top = t.y + s * top;
            width = s * width;
            height = s * height;
            mark = parent;
            instance = mark.instance();
        }
        return {
            left: left,
            top: top,
            width: width,
            height: height
        };
    }
    var _nextTipsyId = 0;
    pv.Behavior.tipsy = function(opts) {
        function getTooltipText() {
            var instance = _mark.instance()
              , title = _mark.properties.tooltip ? instance.tooltip : "function" == typeof _mark.tooltip ? _mark.tooltip() : instance.title || instance.text;
            "function" == typeof title && (title = title());
            return title || "";
        }
        function getTooltipLine() {//var bounds = getVisibleScreenBounds(_mark);
        //left = bounds.left;
        //top = bounds.top;
        //width = bounds.width;
        //height = bounds.height;
        }
        function getInstanceBounds() {
            var left, top, width, height, instance = _mark.instance();
            if (_mark.properties.width) {
                var bounds = getVisibleScreenBounds(_mark);
                left = bounds.left;
                top = bounds.top;
                width = bounds.width;
                height = bounds.height;
            } else {
                var radius, t = _mark.toScreenTransform();
                if (_mark.properties.outerRadius) {
                    var midAngle = instance.startAngle + instance.angle / 2;
                    radius = instance.outerRadius;
                    left = t.x + instance.left + radius * Math.cos(midAngle);
                    top = t.y + instance.top + radius * Math.sin(midAngle);
                } else if (_mark.properties.shapeRadius) {
                    radius = Math.max(2, instance.shapeRadius);
                    var cx = instance.left
                      , cy = instance.top;
                    switch (instance.shape) {
                    case "diamond":
                        radius *= Math.SQRT2;
                        break;
                    case "circle":
                        radius /= Math.SQRT2;
                    }
                    left = (cx - radius) * t.k + t.x;
                    top = (cy - radius) * t.k + t.y;
                    height = width = 2 * radius * t.k;
                } else {
                    left = instance.left * t.k + t.x;
                    top = instance.top * t.k + t.y;
                }
            }
            var left2 = Math.ceil(left)
              , top2 = Math.ceil(top)
              , leftE = left2 - left
              , topE = top2 - top;
            width = Math.max(1, Math.floor((width || 0) - leftE));
            height = Math.max(1, Math.floor((height || 0) - topE));
            return {
                left: left2,
                top: top2,
                width: width,
                height: height
            };
        }
        function updateUserGravity() {
            _userGravityFun && (_userGravity = _userGravityFun.call(_mark) || $.fn.tipsy.defaults.gravity);
            return _userGravity;
        }
        function calculateGravity(tipSize, calcPosition) {
            function scoreGravity(gravity) {
                var tp = calcPosition(gravity);
                return scorePosition(gravity, tp);
            }
            function scorePosition(gravity, tp) {
                var wScore = calcPosScore(tp.left, "width")
                  , hScore = calcPosScore(tp.top, "height")
                  , isTotal = wScore.fits && hScore.fits;
                return {
                    gravity: gravity,
                    width: wScore,
                    height: hScore,
                    value: wScore.value + hScore.value + (2 - gravity.length),
                    isTotal: isTotal,
                    isPartial: !isTotal && (wScore.fits || hScore.fits)
                };
            }
            function calcPosScore(absPos, a_len) {
                var maxLen = pageSize[a_len]
                  , len = tipSize[a_len]
                  , pos = absPos - scrollOffset[a_len]
                  , opos = maxLen - (pos + len)
                  , fits = pos >= 0 && opos >= 0
                  , value = (pos >= 0 ? pos : 4 * pos) + (opos >= 0 ? opos : 4 * opos);
                return {
                    fits: fits,
                    value: value
                };
            }
            this === $fakeTipTarget[0] || def.assert();
            var $win = $(window)
              , scrollOffset = {
                width: $win.scrollLeft(),
                height: $win.scrollTop()
            }
              , pageSize = {
                width: $win.width(),
                height: $win.height()
            }
              , gravity = _userGravity;
            "c" === gravity && (gravity = "w");
            var bestScore = scoreGravity(gravity);
            if (!bestScore.isTotal) {
                for (var g = _gravities.indexOf(gravity), n = 1, L = _gravities.length; L > n; n++) {
                    var i = (g + n) % L;
                    bestScore = chooseScores(bestScore, scoreGravity(_gravities[i]));
                }
                _tip.debug >= 21 && gravity !== bestScore.gravity && _tip.log("[TIPSY] #" + _tipsyId + " Choosing gravity '" + bestScore.gravity + "' over '" + gravity + "'");
                gravity = bestScore.gravity;
            }
            _tip.debug >= 21 && _tip.log("[TIPSY] #" + _tipsyId + " Gravity '" + gravity + "'");
            return gravity;
        }
        function chooseScores(score1, score2) {
            if (score1.isTotal) {
                if (!score2.isTotal)
                    return score1;
            } else if (score2.isTotal) {
                if (!score1.isTotal)
                    return score2;
            } else if (score1.isPartial) {
                if (!score2.isPartial)
                    return score1;
            } else if (score2.isPartial && !score1.isPartial)
                return score2;
            return score2.value > score1.value ? score2 : score1;
        }
        function setFakeTipTargetBounds(bounds) {
            $fakeTipTarget.css({
                left: bounds.left + parseFloat($canvas.css("padding-left")),
                top: bounds.top + parseFloat($canvas.css("padding-top")),
                width: bounds.width,
                height: bounds.height
            });
        }
        function createTipsy(mark) {
            var c = mark.root.canvas();
            $canvas = $(c);
            c.style.position = "relative";
            $canvas.mouseleave(hideTipsy);
            initTipsyCanvasSharedInfo();
            id || (id = "tipsyPvBehavior_" + new Date().getTime());
            var fakeTipTarget = document.getElementById(id);
            if (!fakeTipTarget) {
                fakeTipTarget = document.createElement("div");
                fakeTipTarget.id = id;
                c.appendChild(fakeTipTarget);
            }
            var fakeStyle = fakeTipTarget.style;
            fakeStyle.padding = "0px";
            fakeStyle.margin = "0px";
            fakeStyle.position = "absolute";
            fakeStyle.pointerEvents = "none";
            fakeStyle.display = "block";
            fakeStyle.zIndex = -10;
            $fakeTipTarget = $(fakeTipTarget);
            updateTipDebug();
            $fakeTipTarget.data("tipsy", null);
            $fakeTipTarget.tipsy(opts);
        }
        function initTipsyCanvasSharedInfo() {
            sharedTipsyInfo = $canvas.data("tipsy-pv-shared-info");
            if (sharedTipsyInfo) {
                var createId = $canvas[0].$pvCreateId || 0;
                if (sharedTipsyInfo.createId === createId) {
                    sharedTipsyInfo.behaviors.push(hideTipsyOther);
                    return;
                }
                sharedTipsyInfo.behaviors.forEach(function(aHideTipsy) {
                    aHideTipsy();
                });
            }
            sharedTipsyInfo = {
                createId: $canvas[0].$pvCreateId || 0,
                behaviors: [hideTipsyOther]
            };
            $canvas.data("tipsy-pv-shared-info", sharedTipsyInfo);
        }
        function updateTipDebug() {
            $fakeTipTarget && $fakeTipTarget.css(_tip.debug >= 22 ? {
                borderColor: "red",
                borderWidth: "1px",
                borderStyle: "solid",
                zIndex: 1e3
            } : {
                borderWidth: "0px",
                zIndex: -10
            });
        }
        function getMouseBounds(ev) {
            ev || (ev = pv.event);
            var delta = 5
              , offset = $canvas.offset();
            return {
                left: ev.pageX - offset.left - delta,
                top: ev.pageY - offset.top - delta,
                width: 10 + 2 * delta,
                height: 20
            };
        }
        function setTarget(targetElem, mark) {
            if (!$targetElem && targetElem || $targetElem && $targetElem[0] !== targetElem) {
                _tip.debug >= 20 && _tip.log("[TIPSY] #" + _tipsyId + " Changing target element.");
                if ($targetElem) {
                    $targetElem.unbind("mousemove", updateTipsy);
                    usesPoint || $targetElem.unbind("mouseleave", hideTipsy);
                }
                $targetElem = targetElem ? $(targetElem) : null;
                _mark = targetElem ? mark : null;
                prevMouseX = prevMouseY = _renderId = null;
                if ($targetElem) {
                    $targetElem.mousemove(updateTipsy);
                    usesPoint || $targetElem.mouseleave(hideTipsy);
                }
            }
        }
        function getNewOperationId() {
            return nextOperationId++;
        }
        function checkCanOperate(opId) {
            return opId === nextOperationId - 1;
        }
        function hideTipsy() {
            var opId = getNewOperationId();
            _tip.debug >= 20 && _tip.log("[TIPSY] #" + _tipsyId + " Delayed Hide Begin opId=" + opId);
            if (delayOut > 0)
                window.setTimeout(function() {
                    if (checkCanOperate(opId)) {
                        _tip.debug >= 20 && _tip.log("[TIPSY] #" + _tipsyId + " Hiding opId=" + opId + " nextOperationId=" + nextOperationId);
                        hideTipsyCore(opId);
                    } else
                        _tip.debug >= 20 && _tip.log("[TIPSY] #" + _tipsyId + " Delayed Hide Cancelled opId=" + opId);
                }, delayOut);
            else {
                _tip.debug >= 20 && _tip.log("[TIPSY] #" + _tipsyId + " Hiding Immediately opId=" + opId);
                hideTipsyCore(opId);
            }
        }
        function hideTipsyOther() {
            var opId = getNewOperationId();
            _tip.debug >= 20 && _tip.log("[TIPSY] #" + _tipsyId + " Hiding as Other opId=" + opId);
            hideTipsyCore(opId);
        }
        function hideTipsyCore() {
            setTarget(null, null);
            $fakeTipTarget && $fakeTipTarget.tipsy("leave");
        }
        function hideOtherTipsies() {
            var hideTipsies = sharedTipsyInfo && sharedTipsyInfo.behaviors;
            hideTipsies && hideTipsies.length > 1 && hideTipsies.forEach(function(aHideTipsy) {
                aHideTipsy !== hideTipsyOther && aHideTipsy();
            });
        }
        function updateTipsy(ev) {
            if ($fakeTipTarget && !(null != prevMouseX && Math.abs(ev.clientX - prevMouseX) < 3 && Math.abs(ev.clientY - prevMouseY) < 3)) {
                var scenes, tag = this.$scene;
                if (tag && (scenes = tag.scenes) && scenes.mark && scenes.mark === _mark) {
                    var renderId = _mark.renderId()
                      , renderIdChanged = renderId !== _renderId
                      , followMouse = opts.followMouse;
                    if (followMouse || renderIdChanged) {
                        var opId = getNewOperationId();
                        _tip.debug >= 20 && _tip.log("[TIPSY] #" + _tipsyId + " Updating opId=" + opId);
                        prevMouseX = ev.clientX;
                        prevMouseY = ev.clientY;
                        var bounds;
                        followMouse && (bounds = getMouseBounds(ev));
                        if (renderIdChanged) {
                            _renderId = renderId;
                            _mark.context(scenes, tag.index, function() {
                                followMouse || (bounds = getInstanceBounds());
                                var text = getTooltipText();
                                var linetext = getTooltipLine();
                                _tip.debug >= 20 && _tip.log("[TIPSY] #" + _tipsyId + " Update text. Was hidden. Text: " + text);
                                $fakeTipTarget.tipsy("setTitle", text);
                                getTooltipLine();
                                updateUserGravity();
                            });
                        }
                        setFakeTipTargetBounds(bounds);
                        hideOtherTipsies();
                        $fakeTipTarget.tipsy("update");
                    }
                }
            }
        }
        function initBehavior(mark) {
            _tip.debug >= 20 && _tip.log("[TIPSY] #" + _tipsyId + " Creating");
            createTipsy(mark);
            usesPoint && mark.event("unpoint", hideTipsy);
        }
        function showTipsy(mark) {
            var opId = getNewOperationId();
            _tip.debug >= 20 && _tip.log("[TIPSY] #" + _tipsyId + " Show IN opId=" + opId);
            $canvas || initBehavior(mark);
            var isHidden = !$targetElem;
            setTarget(pv.event.target, mark);
            var text = getTooltipText();
            _tip.debug >= 20 && _tip.log("[TIPSY] #" + _tipsyId + " Text: " + text);
            $fakeTipTarget.tipsy("setTitle", text);
            setFakeTipTargetBounds(opts.followMouse ? getMouseBounds() : getInstanceBounds());
            updateUserGravity();
            hideOtherTipsies();
            $fakeTipTarget.tipsy(isHidden ? "enter" : "update");
            _tip.debug >= 20 && _tip.log("[TIPSY] #" + _tipsyId + " Show OUT");
        }
        function tipsyBehavior() {
            var mark = this;
            (!isEnabled || isEnabled(tipsyBehavior, mark)) && showTipsy(mark);
        }
        var _tipsyId = _nextTipsyId++;
        opts = opts ? Object.create(opts) : {};
        opts.trigger = "manual";
        var _userGravityFun, _userGravity = opts.gravity || $.fn.tipsy.defaults.gravity;
        if ("function" == typeof _userGravity) {
            _userGravityFun = _userGravity;
            _userGravity = null;
        }
        opts.gravity = calculateGravity;
        var $fakeTipTarget, $targetElem, prevMouseX, prevMouseY, _renderId, _mark, id, $canvas, sharedTipsyInfo, nextOperationId = 0, delayOut = opts.delayOut, usesPoint = opts.usesPoint, isEnabled = opts.isEnabled;
        opts.delayOut = 0;
        var _gravities = ["nw", "n", "ne", "e", "se", "s", "sw", "w"];
        return tipsyBehavior;
    }
    ;
    var _tip = pv.Behavior.tipsy;
    _tip.debug = 0;
    _tip.setDebug = function(level) {
        _tip.debug = level;
    }
    ;
    _tip.log = function(m) {
        "undefined" != typeof console && console.log("" + m);
    }
    ;
}();

var SaikuRendererOptions = {
    mode: null,
    dataMode: null,
    htmlObject: null,
    width: null,
    height: null
};

var SaikuRenderer = function(data, options) {
    this._options = _.extend(SaikuRendererOptions, options);
    this._hasProcessed = false;
    if (typeof Backbone !== "undefined") {
        _.extend(this, Backbone.Events);
    }

    this.render = function(data, options) {
        var r = null;
        if (typeof Backbone !== "undefined") {
            this.trigger('render:start', this);
        }
        if (!this.hasProcessedData()) {
            this.processData(data, options);
        }
        r = this._render(data, options);
        if (typeof Backbone !== "undefined") {
            this.trigger('render:end', this);
        }
        return r;
    }
    ;
    this.processData = function(data, options) {
        if (typeof Backbone !== "undefined") {
            this.trigger('processData:start', this);
        }
        this._processData(data, options);
        if (typeof Backbone !== "undefined") {
            this.trigger('processData:end', this);
        }
    }
    ;
    this.hasProcessedData = function() {
        return this._hasProcessed;
    }
    ;
    this._render = function(data, options) {}
    ;
    this._processData = function(data, options) {}
    ;
    if (data) {
        this._data = data;
        this.processData(data, options);
        this._hasProcessed = true;
    }
};

function SaikuTableRenderer(data, options) {
    this._data = data;
    this._options = _.extend({}, SaikuRendererOptions, options);
}

SaikuTableRenderer.prototype.render = function(data, options) {
    var self = this;
    if (data) {
        this._data = data;
    }
    if (options) {
        this._options = _.extend({}, SaikuRendererOptions, options);
    }

    if (typeof this._data == "undefined") {
        return;
    }

    if (this._data != null && this._data.error != null) {
        return;
    }
    if (this._data == null || (this._data.cellset && this._data.cellset.length === 0)) {
        return;
    }
    if (this._options.htmlObject) {
        //            $(this._options.htmlObject).stickyTableHeaders("destroy");

        // in case we have some left over scrollers
        if (self._options.hasOwnProperty('batch')) {
            $(self._options.htmlObject).parent().parent().unbind('scroll');
        }

        _.defer(function(that) {
            if (self._options.hasOwnProperty('batch') && !self._options.hasOwnProperty('batchSize')) {
                self._options['batchSize'] = 1000;
            }

            var html = self.internalRender(self._data, self._options);
            $(self._options.htmlObject).html(html);
            //                $(self._options.htmlObject).stickyTableHeaders( { container: self._options.htmlObject.parent().parent(), fixedOffset: self._options.htmlObject.parent().parent().offset().top });

            _.defer(function(that) {
                if (self._options.hasOwnProperty('batch') && self._options.hasBatchResult) {
                    var batchRow = 0;
                    var batchIsRunning = false;
                    var batchIntervalSize = self._options.hasOwnProperty('batchIntervalSize') ? self._options.batchIntervalSize : 20;
                    var batchIntervalTime = self._options.hasOwnProperty('batchIntervalTime') ? self._options.batchIntervalTime : 20;
                    var len = self._options.batchResult.length;

                    var batchInsert = function() {
                        // maybe add check for reach table bottom - ($('.workspace_results').scrollTop() , $('.workspace_results table').height()
                        if (!batchIsRunning && len > 0 && batchRow < len) {
                            batchIsRunning = true;
                            var batchContent = "";
                            var startb = batchRow;
                            for (var i = 0; batchRow < len && i < batchIntervalSize; i++,
                            batchRow++) {
                                batchContent += self._options.batchResult[batchRow];
                            }
                            if (batchRow > startb) {
                                $(self._options.htmlObject).append($(batchContent));
                            }
                            batchIsRunning = false;
                        }
                        if (batchRow >= len) {
                            $(self._options.htmlObject).parent().parent().unbind('scroll');
                        }
                    };
                    var lazyBatchInsert = _.debounce(batchInsert, batchIntervalTime);
                    $(self._options.htmlObject).parent().parent().scroll(function() {
                        lazyBatchInsert();
                    });
                }
            });
            return html;
        });
    } else {
        var html = this.internalRender(this._data, self._options);
        return html;
    }
}
;

SaikuTableRenderer.prototype.clear = function(data, options) {
    var self = this;
    if (this._options && this._options.htmlObject && this._options.hasOwnProperty('batch')) {
        $(self._options.htmlObject).parent().parent().unbind('scroll');
    }
}
;

SaikuTableRenderer.prototype.processData = function(data, options) {
    this._hasProcessed = true;
}
;

function genTotalDataCells(currentIndex, cellIndex, scanSums, scanIndexes, lists) {
    var contents = '';
    var lists = lists[ROWS];
    for (var i = scanSums.length - 1; i >= 0; i--) {
        if (currentIndex == scanSums[i]) {
            var currentListNode = lists[i][scanIndexes[i]];
            for (var m = 0; m < currentListNode.cells.length; m++)
                contents += '<td class="data total">' + currentListNode.cells[m][cellIndex].value + '</td>';
            scanIndexes[i]++;
            if (scanIndexes[i] < lists[i].length)
                scanSums[i] += lists[i][scanIndexes[i]].width;
        }
    }
    return contents;
}

function genTotalHeaderCells(currentIndex, bottom, scanSums, scanIndexes, lists, wrapContent) {
    var contents = '';
    for (var i = bottom; i >= 0; i--) {
        if (currentIndex == scanSums[i]) {
            var currentListNode = lists[i][scanIndexes[i]];
            var cssClass;
            if (i == 0 && bottom == 1)
                cssClass = "col";
            else if (i == bottom)
                cssClass = "col_total_corner";
            else if (i == bottom - 1 && currentListNode.captions)
                cssClass = "col_total_first";
            else
                cssClass = "col_null";

            for (var m = 0; m < currentListNode.cells.length; m++) {
                var text = '&nbsp;';
                if (bottom == lists.length - 1) {
                    if (currentListNode.captions) {
                        text = lists[i][scanIndexes[i]].captions[m];
                    }
                    if (i == 0 && scanIndexes[i] == 0) {
                        if (currentListNode.captions)
                            text += "&nbsp;";
                        else
                            text = "";
                        text += (wrapContent ? "<span class='i18n'>Grand Total</span>" : "Grand Total");
                    }
                }
                contents += '<th class="' + cssClass + '">' + (wrapContent ? '<div>' + text + '</div>' : text) + '</th>';
            }
            scanIndexes[i]++;
            if (scanIndexes[i] < lists[i].length)
                scanSums[i] += lists[i][scanIndexes[i]].width;
        }
    }
    return contents;
}

function totalIntersectionCells(currentIndex, bottom, scanSums, scanIndexes, lists) {
    var contents = '';
    for (var i = bottom; i >= 0; i--) {
        if (currentIndex == scanSums[i]) {
            var currentListNode = lists[i][scanIndexes[i]];
            var cssClass = "data total";
            for (var m = 0; m < currentListNode.cells.length; m++) {
                var text = '&nbsp;';
                contents += '<td class="' + cssClass + '">' + text + '</td>';
            }
            scanIndexes[i]++;
            if (scanIndexes[i] < lists[i].length)
                scanSums[i] += lists[i][scanIndexes[i]].width;
        }
    }
    return contents;
    console.log(contents);
}

function genTotalHeaderRowCells(currentIndex, scanSums, scanIndexes, totalsLists, wrapContent) {
    var colLists = totalsLists[COLUMNS];
    var colScanSums = scanSums[COLUMNS];
    var colScanIndexes = scanIndexes[COLUMNS];
    var bottom = colLists.length - 2;
    var contents = '';
    for (var i = bottom; i >= 0; i--) {
        if (currentIndex == colScanSums[i]) {
            for (var m = 0; m < colLists[i][colScanIndexes[i]].cells.length; m++) {
                contents += '<tr>';
                for (var j = 0; j <= bottom; j++) {
                    var cssClass;
                    var text = '&nbsp;';
                    if (i == 0 && j == 0)
                        cssClass = 'row';
                    else if (i == j + 1)
                        cssClass = 'row_total_corner';
                    else if (i == j && colLists[i][colScanIndexes[i]].captions) {
                        cssClass = 'row_total_first';
                    } else if (i < j + 1)
                        cssClass = 'row_total';
                    else
                        cssClass = 'row_null';
                    if (j == bottom) {
                        if (colLists[i][colScanIndexes[i]].captions) {
                            text = colLists[i][colScanIndexes[i]].captions[m];
                        }
                        if (i == 0 && colScanIndexes[i] == 0) {
                            if (colLists[i][colScanIndexes[i]].captions)
                                text += "&nbsp;";
                            else
                                text = "";
                            text += (wrapContent ? "<span class='i18n'>Grand Total</span>" : "Grand Total");
                        }
                    }
                    contents += '<th class="' + cssClass + '">' + (wrapContent ? '<div>' + text + '</div>' : text) + '</th>';

                }

                var scanIndexes = {};
                var scanSums = {};
                for (var z = 0; z < totalsLists[ROWS].length; z++) {
                    scanIndexes[z] = 0;
                    scanSums[z] = totalsLists[ROWS][z][scanIndexes[z]].width;
                }
                for (var k = 0; k < colLists[i][colScanIndexes[i]].cells[m].length; k++) {
                    contents += '<td class="data total">' + colLists[i][colScanIndexes[i]].cells[m][k].value + '</td>';
                    contents += totalIntersectionCells(k + 1, totalsLists[ROWS].length - 1, scanSums, scanIndexes, totalsLists[ROWS]);
                }
                contents += '</tr>';
            }
            colScanIndexes[i]++;
            if (colScanIndexes[i] < colLists[i].length)
                colScanSums[i] += colLists[i][colScanIndexes[i]].width;
        }
    }
    return contents;
    console.log(contents);
}

var ROWS = "ROWS";
var COLUMNS = "COLUMNS";

function nextParentsDiffer(data, row, col) {
    while (row-- > 0) {
        if (data[row][col].properties.uniquename != data[row][col + 1].properties.uniquename)
            return true;
    }
    return false;
}

function topParentsDiffer(data, row, col) {
    while (col-- > 0)
        if (data[row][col].properties.uniquename != data[row - 1][col].properties.uniquename)
            return true;
    return false;
}

SaikuTableRenderer.prototype.internalRender = function(allData, options) {
    var tableContent = "";
    var rowContent = "";
    var data = allData.cellset;
    var table = data ? data : [];
    var colSpan;
    var colValue;
    var isHeaderLowestLvl;
    var isBody = false;
    var firstColumn;
    var isLastColumn, isLastRow;
    var nextHeader;
    var processedRowHeader = false;
    var lowestRowLvl = 0;
    var rowGroups = [];
    var batchSize = null;
    var batchStarted = false;
    var isColHeader = false
      , isColHeaderDone = false;
    var resultRows = [];
    var wrapContent = true;
    if (options) {
        batchSize = options.hasOwnProperty('batchSize') ? options.batchSize : null;
        wrapContent = options.hasOwnProperty('wrapContent') ? options.wrapContent : true;
    }
    var totalsLists = {};
    totalsLists[COLUMNS] = allData.rowTotalsLists;
    totalsLists[ROWS] = allData.colTotalsLists;
    var scanSums = {};
    var scanIndexes = {};
    var dirs = [ROWS, COLUMNS];
    for (var i = 0; i < dirs.length; i++) {
        scanSums[dirs[i]] = new Array();
        scanIndexes[dirs[i]] = new Array();
    }
    if (totalsLists[COLUMNS])
        for (var i = 0; i < totalsLists[COLUMNS].length; i++) {
            scanIndexes[COLUMNS][i] = 0;
            scanSums[COLUMNS][i] = totalsLists[COLUMNS][i][scanIndexes[COLUMNS][i]].width;
        }

    for (var row = 0, rowLen = table.length; row < rowLen; row++) {
        var rowShifted = row - allData.topOffset;
        colSpan = 1;
        colValue = "";
        isHeaderLowestLvl = false;
        isLastColumn = false;
        isLastRow = false;
        isColHeader = false;
        var headerSame = false;

        if (totalsLists[ROWS])
            for (var i = 0; i < totalsLists[ROWS].length; i++) {
                scanIndexes[ROWS][i] = 0;
                scanSums[ROWS][i] = totalsLists[ROWS][i][scanIndexes[ROWS][i]].width;
            }
        rowContent = "<tr>";
        if (row === 0) {
            rowContent = "<thead>" + rowContent;
        }
        for (var col = 0, colLen = table[row].length; col < colLen; col++) {
            var colShifted = col - allData.leftOffset;
            var header = data[row][col];
            if (header.type === "COLUMN_HEADER") {
                isColHeader = true;
            }

            // If the cell is a column header and is null (top left of table)
            if (header.type === "COLUMN_HEADER" && header.value === "null" && (firstColumn == null || col < firstColumn)) {
                rowContent += '<th class="all_null">&nbsp;</th>';
            }// If the cell is a column header and isn't null (column header of table)
            else if (header.type === "COLUMN_HEADER") {
                if (firstColumn == null) {
                    firstColumn = col;
                }
                if (table[row].length == col + 1)
                    isLastColumn = true;
                else
                    nextHeader = data[row][col + 1];
                if (isLastColumn) {
                    // Last column in a row...
                    if (header.value == "null") {
                        rowContent += '<th class="col_null">&nbsp;</th>';
                    } else {
                        if (totalsLists[ROWS])
                            colSpan = totalsLists[ROWS][row + 1][scanIndexes[ROWS][row + 1]].span;
                        rowContent += '<th class="col" style="text-align: center;" colspan="' + colSpan + '" title="' + header.value + '">' + (wrapContent ? '<div rel="' + row + ":" + col + '">' + header.value + '</div>' : header.value) + '</th>';
                    }

                } else {
                    // All the rest...
                    var groupChange = (col > 1 && row > 1 && !isHeaderLowestLvl && col > firstColumn) ? data[row - 1][col + 1].value != data[row - 1][col].value || data[row - 1][col + 1].properties.uniquename != data[row - 1][col].properties.uniquename : false;

                    var maxColspan = colSpan > 999 ? true : false;
                    if (header.value != nextHeader.value || nextParentsDiffer(data, row, col) || isHeaderLowestLvl || groupChange || maxColspan) {
                        if (header.value == "null") {
                            rowContent += '<th class="col_null" colspan="' + colSpan + '">&nbsp;</th>';
                        } else {
                            if (totalsLists[ROWS])
                                colSpan = totalsLists[ROWS][row + 1][scanIndexes[ROWS][row + 1]].span;
                            rowContent += '<th class="col" style="text-align: center;" colspan="' + (colSpan == 0 ? 1 : colSpan) + '" title="' + header.value + '">' + (wrapContent ? '<div rel="' + row + ":" + col + '">' + header.value + '</div>' : header.value) + '</th>';
                        }
                        colSpan = 1;
                    } else {
                        colSpan++;
                    }
                }
                if (totalsLists[ROWS])
                    rowContent += genTotalHeaderCells(col - allData.leftOffset + 1, row + 1, scanSums[ROWS], scanIndexes[ROWS], totalsLists[ROWS], wrapContent);
            }// If the cell is a row header and is null (grouped row header)
            else if (header.type === "ROW_HEADER" && header.value === "null") {
                rowContent += '<th class="row_null">&nbsp;</th>';
            }// If the cell is a row header and isn't null (last row header)
            else if (header.type === "ROW_HEADER") {
                if (lowestRowLvl == col)
                    isHeaderLowestLvl = true;
                else
                    nextHeader = data[row][col + 1];

                var previousRow = data[row - 1];

                var same = !headerSame && !isHeaderLowestLvl && (col == 0 || !topParentsDiffer(data, row, col)) && header.value === previousRow[col].value;
                headerSame = !same;
                var value = (same ? "<div>&nbsp;</div>" : '<div rel="' + row + ":" + col + '">' + header.value + '</div>');
                if (!wrapContent) {
                    value = (same ? "&nbsp;" : header.value);
                }
                var tipsy = "";
                /* var tipsy = ' original-title="';
                if (!same && header.metaproperties) {
                    for (key in header.metaproperties) {
                        if (key.substring(0,1) != "$" && key.substring(1,2).toUpperCase() != key.substring(1,2)) {
                            tipsy += "<b>" + safe_tags_replace(key) + "</b> : " + safe_tags_replace(header.metaproperties[key]) + "<br>";
                        }
                    }
                }
                tipsy += '"';
                */
                var cssclass = (same ? "row_null" : "row");
                var colspan = 0;

                if (!isHeaderLowestLvl && (typeof nextHeader == "undefined" || nextHeader.value === "null")) {
                    colspan = 1;
                    var group = header.properties.dimension;
                    var level = header.properties.level;
                    var groupWidth = (group in rowGroups ? rowGroups[group].length - rowGroups[group].indexOf(level) : 1);
                    for (var k = col + 1; colspan < groupWidth && k <= (lowestRowLvl + 1) && data[row][k] !== "null"; k++) {
                        colspan = k - col;
                    }
                    col = col + colspan - 1;
                }
                rowContent += '<th class="' + cssclass + '" ' + (colspan > 0 ? ' colspan="' + colspan + '"' : "") + tipsy + '>' + value + '</th>';
            } else if (header.type === "ROW_HEADER_HEADER") {
                rowContent += '<th class="row_header">' + (wrapContent ? '<div>' + header.value + '</div>' : header.value) + '</th>';
                isHeaderLowestLvl = true;
                processedRowHeader = true;
                lowestRowLvl = col;
                if (header.properties.hasOwnProperty("dimension")) {
                    var group = header.properties.dimension;
                    if (!(group in rowGroups)) {
                        rowGroups[group] = [];
                    }
                    rowGroups[group].push(header.properties.level);
                }
            }// If the cell is a normal data cell
            else if (header.type === "DATA_CELL") {
                batchStarted = true;
                var color = "";
                var val = header.value;
                var arrow = "";
                if (header.properties.hasOwnProperty('image')) {
                    var img_height = header.properties.hasOwnProperty('image_height') ? " height='" + header.properties.image_height + "'" : "";
                    var img_width = header.properties.hasOwnProperty('image_width') ? " width='" + header.properties.image_width + "'" : "";
                    val = "<img " + img_height + " " + img_width + " style='padding-left: 5px' src='" + header.properties.image + "' border='0'>";
                }

                if (header.properties.hasOwnProperty('style')) {
                    color = " style='background-color: " + header.properties.style + "' ";
                }
                if (header.properties.hasOwnProperty('link')) {
                    val = "<a target='__blank' href='" + header.properties.link + "'>" + val + "</a>";
                }
                if (header.properties.hasOwnProperty('arrow')) {
                    arrow = "<img height='10' width='10' style='padding-left: 5px' src='./images/arrow-" + header.properties.arrow + ".gif' border='0'>";
                }

                rowContent += '<td class="data" ' + color + '>' + (wrapContent ? '<div class="datadiv" alt="' + header.properties.raw + '" rel="' + header.properties.position + '">' : "") + val + arrow + (wrapContent ? '</div>' : '') + '</td>';
                if (totalsLists[ROWS])
                    rowContent += genTotalDataCells(colShifted + 1, rowShifted, scanSums[ROWS], scanIndexes[ROWS], totalsLists, wrapContent);
            }
        }
        rowContent += "</tr>";
        var totals = "";
        if (totalsLists[COLUMNS] && rowShifted >= 0) {
            totals += genTotalHeaderRowCells(rowShifted + 1, scanSums, scanIndexes, totalsLists, wrapContent);
        }
        if (batchStarted && batchSize) {
            if (row <= batchSize) {
                if (!isColHeader && !isColHeaderDone) {
                    tableContent += "</thead><tbody>";
                    isColHeaderDone = true;
                }
                tableContent += rowContent;
                if (totals.length > 0) {
                    tableContent += totals;
                }

            } else {
                resultRows.push(rowContent);
                if (totals.length > 0) {
                    resultRows.push(totals);
                }

            }
        } else {
            if (!isColHeader && !isColHeaderDone) {
                tableContent += "</thead><tbody>";
                isColHeaderDone = true;
            }
            tableContent += rowContent;
            if (totals.length > 0) {
                tableContent += totals;
            }
        }
    }
    if (options) {
        options['batchResult'] = resultRows;
        options['hasBatchResult'] = resultRows.length > 0;
    }
    return "<table>" + tableContent + "</tbody></table>";
}
;

var SaikuChartRenderer = function(data, options) {
    this.num = 0;
    this.cccOptions = {};
    this.data = null;
    this.hasProcessed = false;
    this.hasRendered = false;
    this.rawdata = data;
    if (!options && !options.hasOwnProperty('htmlObject')) {
        throw ("You need to supply a html object in the options for the SaikuChartRenderer!");
    }
    this.el = $(options.htmlObject);
    this.id = _.uniqueId("chart_");
    $(this.el).html('<div class="canvas_wrapper" style="display:none;text-align: center;"><span class="tipsSpan" style="display:none;">No results</span><div id="canvas_' + this.id + '"></div></div>');
    this.zoom = options.zoom;
    if (options.zoom) {
        var self = this;
        var btns = "<span style='float:left;' class='zoombuttons'><a href='#' class='button rerender i18n' title='Re-render chart' style='display:block;'></a>" + "<a href='#' class='button zoomout i18n' style='display:none;' title='Zoom back out'></a></span>";
        $(btns).prependTo($(this.el).find('.canvas_wrapper'));
        $(this.el).find('.zoomout').on('click', function(event) {
            event.preventDefault();
            self.zoomout();
        });
        $(this.el).find('.zoomin').on('click', function(event) {
            event.preventDefault();
            self.zoomin();
        });
        $(this.el).find('.rerender').on('click', function(event) {
            event.preventDefault();
            $(self.el).find('.zoomout').hide();
            self.switch_chart(self.type);
        });
    }
    if (options.chartDefinition) {
        this.chartDefinition = options.chartDefinition;
    }
    this.cccOptions.canvas = 'canvas_' + this.id;
    this.data = null;
    this.adjustSizeTo = null;
    if (options.adjustSizeTo) {
        this.adjustSizeTo = options.adjustSizeTo;
    } else {
        this.adjustSizeTo = options.htmlObject;
    }
    if (options.mode) {
        this.switch_chart(options.mode);
    } else {
        // default
        this.switch_chart("bar");
    }
    this.adjust();
};

SaikuChartRenderer.prototype.adjust = function() {
    var self = this;
    var calculateLayout = function() {
        if (self.hasRendered && $(self.el).is(':visible')) {
            self.switch_chart(self.type);
        }
    };
    var lazyLayout = _.debounce(calculateLayout, 300);
    $(window).resize(function() {
        //$(self.el).find('.canvas_wrapper').fadeOut(150);   //	ANALYTICS-122
        lazyLayout();
    });
}
;

SaikuChartRenderer.prototype.zoomin = function() {
    $(this.el).find('.canvas_wrapper').hide();
    var chart = this.chart.root;
    var data = chart.data;
    data.datums(null, {
        selected: false
    }).each(function(datum) {
        datum.setVisible(false);
    });
    data.clearSelected();
    chart.render(true, true, false);
    this.render_chart_element();
}
;

SaikuChartRenderer.prototype.zoomout = function() {
    var chart = this.chart.root;
    var data = chart.data;
    var kData = chart.keptVisibleDatumSet;
    if (kData === null || kData.length === 0) {
        $(this.el).find('.zoomout').hide();
    } else if (kData.length == 1) {
        $(this.el).find('.zoomout').hide();
        chart.keptVisibleDatumSet = [];
        pvc.data.Data.setVisible(data.datums(null, {
            visible: false
        }), true);
    } else if (kData.length > 1) {
        chart.keptVisibleDatumSet.splice(kData.length - 1, 1);
        var nonVisible = data.datums(null, {
            visible: false
        }).array();
        var back = chart.keptVisibleDatumSet[kData.length - 1];
        _.intersection(back, nonVisible).forEach(function(datum) {
            datum.setVisible(true);
        });
    }
    chart.render(true, true, false);
}
;

SaikuChartRenderer.prototype.render = function() {
    _.delay(this.render_chart_element, 0, this);
}
;

SaikuChartRenderer.prototype.switch_chart = function(key, override) {
    if ((override != null || override != undefined) && (override.chartDefinition != null || override.chartDefinition != undefined)) {
        this.chartDefinition = override.chartDefinition;
    }
    var keyOptions = {
        "stackedBar": {
            type: "BarChart",
            stacked: true
        },
        "bar": {
            type: "BarChart"
        },
        "multiplebar": {
            type: "BarChart",
            multiChartIndexes: [1],
            dataMeasuresInColumns: true,
            orientation: "vertical",
            smallTitlePosition: "top",
            multiChartMax: 30,
            multiChartColumnsMax: Math.floor(this.cccOptions.width / 200),
            smallWidth: 200,
            smallHeight: 150
        },
        "line": {
            type: "LineChart"
        },
        "pie": {
            type: "PieChart",
            multiChartIndexes: [0]// ideally this would be chosen by the user (count, which)
        },
        "heatgrid": {
            type: "HeatGridChart"
        },
        "stackedBar100": {
            type: "NormalizedBarChart"
        },
        "area": {
            type: "StackedAreaChart"
        },
        "dot": {
            type: "DotChart"
        },
        "waterfall": {
            type: "WaterfallChart"
        },
        "treemap": {
            type: "TreemapChart"
        },
        "bullet": {
            type: "BulletChart"
        },
        "boxplot": {
            type: "BoxplotChart"
        },
        "sunburst": {
            type: "SunburstChart"
        },
        "force": {
            type: "ForceChart"
        },
        "treeslink": {
            type: "TreeslinkChart"
        },
        "chinamap": {
            type: "ChinamapChart"
        },
        "bubble": {
            type: "BubbleChart"
        },
        "multiplemap": {
            type: "MultiplemapChart"
        },
        "scattermap": {
            type: "ScattermapChart"
        },
        "worldmap": {
            type: "WorldmapChart"
        },
        "multipleworld": {
            type: "MultipleworldChart"
        },
        "radar": {
            type: "RadarChart"
        },
        "multiplesunburst": {
            type: "SunburstChart",
            multiChartIndexes: [1],
            dataMeasuresInColumns: true,
            orientation: "vertical",
            smallTitlePosition: "top",
            multiChartMax: 30,
            multiChartColumnsMax: Math.floor(this.cccOptions.width / 200),
            smallWidth: 200,
            smallHeight: 150,
            seriesInRows: false
        }
    };
    if (key === null || key === '') {
    } else if (key == "sunburst") {
        $(this.el).find('.zoombuttons a').hide();
        this.type = key;
        var o = keyOptions[key];
        this.sunburst(o);
        if (this.hasProcessed) {
            this.render();
        }
    } else if (key == "force") {
        $(this.el).find('.zoombuttons a').hide();
        this.type = key;
        var o = keyOptions[key];
        this.force(o);
        if (this.hasProcessed) {
            this.render();
        }
    } else if (key == "treeslink") {
        $(this.el).find('.zoombuttons a').hide();
        this.type = key;
        var o = keyOptions[key];
        this.treeslink(o);
        if (this.hasProcessed) {
            this.render();
        }
    } else if (key == "chinamap") {
        $(this.el).find('.zoombuttons a').hide();
        this.type = key;
        var o = keyOptions[key];
        this.chinaMap(o);
        if (this.hasProcessed) {
            this.render();
        }
    } else if (key == "bubble" || key == "radar") {
        $(this.el).find('.zoombuttons a').hide();
        this.type = key;
        var o = keyOptions[key];
        this.chartVis(o);
        if (this.hasProcessed) {
            this.render();
        }
    } else if (key == "multiplemap") {
        $(this.el).find('.zoombuttons a').hide();
        this.type = key;
        var o = keyOptions[key];
        this.multipleChinaMap(o);
        if (this.hasProcessed) {
            this.render();
        }
    } else if (key == "scattermap") {
        $(this.el).find('.zoombuttons a').hide();
        this.type = key;
        var o = keyOptions[key];
        this.scatterChinaMap(o);
        if (this.hasProcessed) {
            this.render();
        }
    } else if (key == "worldmap") {
        $(this.el).find('.zoombuttons a').hide();
        this.type = key;
        var o = keyOptions[key];
        this.worldMap(o);
        if (this.hasProcessed) {
            this.render();
        }
    } else if (key == "multipleworld") {
        $(this.el).find('.zoombuttons a').hide();
        this.type = key;
        var o = keyOptions[key];
        this.multipleWorldMap(o);
        if (this.hasProcessed) {
            this.render();
        }
    } else if (keyOptions.hasOwnProperty(key)) {
        $(this.el).find('.zoombuttons a').hide();
        this.type = key;
        var o = keyOptions[key];
        this.cccOptions = this.getQuickOptions(o, true, true);
        this.define_chart();
        if (this.hasProcessed) {
            this.render();
        }
    } else {
        alert("Do not support chart type: '" + key + "'");
    }
}
;
// Default static style-sheet
SaikuChartRenderer.prototype.cccOptionsDefault = {
    Base: {
        animate: true,
        selectable: true,
        valuesVisible: false,
        legend: true,
        legendPosition: "top",
        legendAlign: "right",
        compatVersion: 2,
        legendSizeMax: "30%",
        axisSizeMax: "40%",
        plotFrameVisible: false,
        orthoAxisMinorTicks: false
    },
    BulletChart: {
        multiChartIndexes: [1]
    },
    BoxplotChart: {
        BoxSizeRatio: "50%",
        OrthoRole: "median",
        multiChartIndexes: [0],
        OrthoRole: 30
    },
    HeatGridChart: {
        orientation: "horizontal",
        useShapes: true,
        shape: "circle",
        nullShape: "cross",
        colorNormByCategory: false,
        sizeRole: "value",
        legendPosition: "right",
        legend: true,
        hoverable: true,
        axisComposite: true,
        yAxisSize: "20%"
    },
    WaterfallChart: {
        orientation: "horizontal"
    },
    PieChart: {
        aniamtion: true,
        multiChartColumnsMax: 3,
        multiChartMax: 30,
        smallTitleFont: "10px sans-serif",
        valuesVisible: true,
        valuesMask: "{category} / {value.percent}",
        explodedSliceRadius: "10%",
        extensionPoints: {
            slice_innerRadiusEx: '40%',
            slice_offsetRadius: function(scene) {
                return scene.isSelected() ? '10%' : 0;
            }
        },
        clickable: true //valuesLabelStyle: 'inside'
    },
    LineChart: {
        extensionPoints: {
            area_interpolate: "monotone",
            // cardinal
            line_interpolate: "monotone"
        }
    },
    StackedAreaChart: {
        extensionPoints: {
            area_interpolate: "monotone",
            line_interpolate: "monotone"
        }
    },
    TreemapChart: {
        animate: true,
        legendPosition: "right",
        multiChartIndexes: 0,
        extensionPoints: {
            leaf_lineWidth: 2
        },
        layoutMode: "slice-and-dice",
        valuesVisible: true
    },
    SunburstChart: {
        animate: true,
        valuesVisible: false,
        hoverable: false,
        selectable: true,
        clickable: false,
        multiChartIndexes: [0],
        multiChartMax: 30
    }
};

SaikuChartRenderer.prototype.getQuickOptions = function(baseOptions, flat, setdata) {
    this.process_data_tree({
        data: this.rawdata
    }, flat, setdata);
    var chartType = (baseOptions && baseOptions.type) || "BarChart";
    var options = _.extend({
        type: chartType,
        canvas: 'canvas_' + this.id
    }, this.cccOptionsDefault.Base, this.cccOptionsDefault[chartType], // may be undefined
    baseOptions);
    var workspaceResults = (this.adjustSizeTo ? $(this.adjustSizeTo) : $(this.el));
    options.runtimeWidth = workspaceResults.width() - 40;
    options.runtimeHeight = workspaceResults.height() - 40;
    options.colors = [];
    if (this.adjustSizeTo) {
        var al = $(this.adjustSizeTo);
        if (al && al.length > 0) {
            var runtimeWidth = al.width() - 40;
            var runtimeHeight = al.height() - 40;
            if (runtimeWidth > 0) {
                options.width = runtimeWidth;
            }
            if (runtimeHeight > 0) {
                options.height = runtimeHeight;
            }
        }
    }
    if (this.data !== null && this.data.resultset.length > 5) {
        if (options.type === "HeatGridChart") {
            options.xAxisSize = 200;
        } else if (options.orientation !== "horizontal") {
            options.extensionPoints = _.extend(Object.create(options.extensionPoints || {}), {
                xAxisLabel_textAngle: -Math.PI / 2,
                xAxisLabel_textAlign: "right",
                xAxisLabel_textBaseline: "middle"
            });
        }
    }
    if (this.type == "sunburst" || this.type == "force") {
        if (this.data !== null && this.data.resultset.length > 0) {
            var param = null;
            this.data.metadata.map(function(s) {
                if (s.colType == 'String') {
                    param++;
                }
            })
            var lengthParam = 0;
            for (var n = 0; n < param - 1; n++) {
                var resultNum = [];
                this.data.resultset.map(function(f) {
                    resultNum.push(f[n]);
                })
                resultNum = resultNum.reverse().join(",").match(/([^,]+)(?!.*\1)/ig).reverse();
                lengthParam = lengthParam + resultNum.length;
            }
            options.colors = colorsParam(lengthParam + 1, options);
        }
    } else if (this.type == "pie") {
        if (this.data !== null && this.data.resultset.length > 0) {
            options.colors = colorsParam(this.data.resultset.length, options);
        }
    } else {
        if (this.data !== null && this.data.metadata.length > 0) {
            var num = 0;
            for (var m = 0; m < this.data.metadata.length; m++) {
                if (this.data.metadata[m].colType == "Numeric") {
                    num++;
                }
            }
            options.colors = colorsParam(num, options);
        }
    }
    //options.colors = ['#5AB1EF', '#B6A2DE', '#2EC7C9','#FFB980','#97B552','#D87A80'];
    return options;
}
;

var colorsParam = function(num) {
    var colors = [];

    if (num <= 3) {
        colors = ['#2DC1E9', '#B7EFFE', '#BAD202'];
    } else if (num <= 7) {
        colors = ['#00667D', '#1686B6', '#36BEF0', '#83AD01', '#BAD202', "#FDD900", "#FF7A4D"];
    } else if (num <= 15) {
        colors = ["#00679A", "#1686B6", "#6068B1", "#667FB5", "#01BCCD", "#2DC1E9", "#B7EFFE", "#75C5A2", "#83AD01", "#BAD202", "#FDD900", "#FCBD56", "#FF7A4D", "#EC407A", "#959595"];
    } else {
        colors = ["#345684", "#00679A", "#5960A6", "#017F96", "#00A0B8", "#01B6D3", "#2DC1E9", "#6CC9DA", "#B7EFFE", "#CCE3DD", "#75C5A2", "#83AD01", "#ADBE22", "#BAD202", "#FDD900", "#FCBD56", "#FF7A4D", "#EC407A", "#D26A9D", "#959595"];
    }

    return colors;
}

SaikuChartRenderer.prototype.define_chart = function(displayOptions) {
    if (!this.hasProcessed) {
        //不是这儿
        this.process_data_tree({
            data: this.rawdata
        }, true, true);
    }
    var self = this;
    var workspaceResults = (this.adjustSizeTo ? $(this.adjustSizeTo) : $(this.el));
    var isSmall = (this.data !== null && this.data.height < 80 && this.data.width < 80);
    var isMedium = (this.data !== null && this.data.height < 300 && this.data.width < 300);
    var isBig = (!isSmall && !isMedium);
    var animate = true;
    var hoverable = isSmall;
    var runtimeWidth = workspaceResults.width() - 40;
    var runtimeHeight = workspaceResults.height() - 40;
    var runtimeChartDefinition = _.clone(this.cccOptions);
    if (displayOptions && displayOptions.width) {
        runtimeWidth = displayOptions.width;
    }
    if (displayOptions && displayOptions.height) {
        runtimeHeight = displayOptions.height;
    }
    if (runtimeWidth > 0) {
        runtimeChartDefinition.width = runtimeWidth;
    }
    if (runtimeHeight > 0) {
        runtimeChartDefinition.height = runtimeHeight;
    }
    if (isBig) {
        if (runtimeChartDefinition.hasOwnProperty('extensionPoints') && runtimeChartDefinition.extensionPoints.hasOwnProperty('line_interpolate'))
            delete runtimeChartDefinition.extensionPoints.line_interpolate;
        if (runtimeChartDefinition.hasOwnProperty('extensionPoints') && runtimeChartDefinition.extensionPoints.hasOwnProperty('area_interpolate'))
            delete runtimeChartDefinition.extensionPoints.area_interpolate;
    }
    var zoomDefinition = {
        legend: {
            scenes: {
                item: {
                    execute: function() {
                        var chart = this.chart();
                        if (!chart.hasOwnProperty('keptVisibleDatumSet')) {
                            chart.keptVisibleDatumSet = [];
                        }
                        var keptSet = chart.keptVisibleDatumSet.length > 0 ? chart.keptVisibleDatumSet[chart.keptVisibleDatumSet.length - 1] : [];
                        var zoomedIn = keptSet.length > 0;
                        if (zoomedIn) {
                            _.intersection(this.datums().array(), keptSet).forEach(function(datum) {
                                datum.toggleVisible();
                            });

                        } else {
                            pvc.data.Data.toggleVisible(this.datums());
                        }
                        this.chart().render(true, true, false);
                    }
                }
            }
        },
        userSelectionAction: function(selectingDatums) {
            if (selectingDatums.length === 0) {
                return [];
            }
            var chart = self.chart.root;
            var data = chart.data;
            var selfChart = this.chart;
            if (!selfChart.hasOwnProperty('keptVisibleDatumSet')) {
                selfChart.keptVisibleDatumSet = [];
            }
            // we have too many datums to process setVisible = false initially
            if (data.datums().count() > 1500) {
                pvc.data.Data.setSelected(selectingDatums, true);
            } else if (data.datums(null, {
                visible: true
            }).count() == data.datums().count()) {
                $(self.el).find('.zoomout, .rerender').show();
                var all = data.datums().array();
                _.each(_.difference(all, selectingDatums), function(datum) {
                    datum.setVisible(false);
                });
                selfChart.keptVisibleDatumSet = [];
                selfChart.keptVisibleDatumSet.push(selectingDatums);
            } else {
                var kept = selfChart.keptVisibleDatumSet.length > 0 ? selfChart.keptVisibleDatumSet[selfChart.keptVisibleDatumSet.length - 1] : [];
                var visibleOnes = data.datums(null, {
                    visible: true
                }).array();
                var baseSet = kept;
                if (visibleOnes.length < kept.length) {
                    baseSet = visibleOnes;
                    selfChart.keptVisibleDatumSet.push(visibleOnes);
                }
                var newSelection = [];
                _.each(_.difference(visibleOnes, selectingDatums), function(datum) {
                    datum.setVisible(false);
                });
                _.each(_.intersection(visibleOnes, selectingDatums), function(datum) {
                    newSelection.push(datum);
                });

                if (newSelection.length > 0) {
                    selfChart.keptVisibleDatumSet.push(newSelection);
                }
            }
            chart.render(true, true, false);
            return [];
        }
    };
    runtimeChartDefinition = _.extend(runtimeChartDefinition, {
        hoverable: hoverable,
        animate: animate
    }, this.chartDefinition);

    if (self.zoom) {
        var l = runtimeChartDefinition.legend;
        runtimeChartDefinition = _.extend(runtimeChartDefinition, zoomDefinition);
        if (l === false) {
            runtimeChartDefinition.legend = false;
        }
    }

    if (runtimeChartDefinition.type == "TreemapChart") {
        runtimeChartDefinition.legend.scenes.item.labelText = function() {
            var indent = "";
            var group = this.group;
            if (group) {
                var depth = group.depth;
                switch (depth) {
                case 0:
                    return "";
                case 1:
                    break;
                case 2:
                    indent = " └ ";
                    break;
                default:
                    indent = new Array(2 * (depth - 2) + 1).join(" ") + " └ ";
                }
            }
            return indent + this.base();
        }
        ;
    }
    this.library = "pv_chart";
    this.chart = new pvc[runtimeChartDefinition.type](runtimeChartDefinition);
    this.chart.setData(this.data, {
        crosstabMode: true,
        seriesInRows: false
    });
}
;

SaikuChartRenderer.prototype.render_chart_element = function(context) {
    var self = context || this;
    var isSmall = (self.data !== null && self.data.height < 80 && self.data.width < 80);
    var isMedium = (self.data !== null && self.data.height < 300 && self.data.width < 300);
    var isBig = (!isSmall && !isMedium);
    var animate = true;
    if (self.chart.options && self.chart.options.animate) {
        animate = true;
    }
    if (!animate || $(self.el).find('.canvas_wrapper').is(':visible')) {
        $(self.el).find('.canvas_wrapper').hide();
    }
    try {
        if (animate) {
            $(self.el).find('.canvas_wrapper').show();
        }
        if (self.library == "d3_chart") {
            $('#' + 'canvas_' + self.id).find('svg:not(:last-child)').remove();
        } else if (self.library == "pv_chart") {
            self.chart.render();
            _.delay(self.chartDefinition.renderAfter, 200, self);
        }
        self.hasRendered = true;
    } catch (e) {
        $('#' + 'canvas_' + self.id).text(e);
    }
    if (self.chart.options && self.chart.options.animate) {
        return false;
    }
    if (isIE || isBig) {
        $(self.el).find('.canvas_wrapper').show();
    } else {
        $(self.el).find('.canvas_wrapper').fadeIn(400);
    }
    return false;
}
;

SaikuChartRenderer.prototype.process_data_tree = function(args, flat, setdata) {
    var self = this;
    var data = {};
    if (flat) {
        data.resultset = [];
        data.metadata = [];
        data.height = 0;
        data.width = 0;
    }
    var currentDataPos = data;
    if (typeof args == "undefined" || typeof args.data == "undefined") {
        return;
    }
    if (args.data !== null && args.data.error !== null) {
        return;
    }
    // Check to see if there is data
    if (args.data === null || (args.data.cellset && args.data.cellset.length === 0)) {
        return;
    }
    var cellset = args.data.cellset;
    if (cellset && cellset.length > 0) {
        var lowest_level = 0;
        var data_start = 0;
        var hasStart = false;
        var row, rowLen, labelCol, reduceFunction = function(memo, num) {
            return memo + num;
        };
        for (row = 0,
        rowLen = cellset.length; data_start === 0 && row < rowLen; row++) {
            for (var field = 0, fieldLen = cellset[row].length; field < fieldLen; field++) {
                if (!hasStart) {
                    while (cellset[row][field].type == "COLUMN_HEADER" && cellset[row][field].value == "null") {
                        row++;
                    }
                }
                hasStart = true;
                if (cellset[row][field].type == "ROW_HEADER_HEADER") {
                    while (cellset[row][field].type == "ROW_HEADER_HEADER") {
                        if (flat) {
                            data.metadata.push({
                                colIndex: field,
                                colType: "String",
                                colName: cellset[row][field].value
                            });
                        }
                        field++;
                    }
                    lowest_level = field - 1;
                }
                if (cellset[row][field].type == "COLUMN_HEADER") {
                    var lowest_col_header = 0;
                    var colheader = [];
                    while (lowest_col_header <= row) {
                        if (cellset[lowest_col_header][field].value !== "null") {
                            colheader.push(cellset[lowest_col_header][field].value);
                        }
                        lowest_col_header++;
                    }
                    if (flat) {
                        data.metadata.push({
                            colIndex: field,
                            colType: "Numeric",
                            colName: colheader.join(' ~ ')
                        });
                    }
                    data_start = row + 1;
                }
            }
        }
        var labelsSet = {};
        var rowlabels = [];
        for (labelCol = 0; labelCol <= lowest_level; labelCol++) {
            rowlabels.push(null);
        }
        for (row = data_start,
        rowLen = cellset.length; row < rowLen; row++) {
            if (cellset[row][0].value !== "") {
                var record = [];
                var flatrecord = [];
                var parent = null;
                var rv = null;
                for (labelCol = 0; labelCol <= lowest_level; labelCol++) {
                    if (cellset[row] && cellset[row][labelCol].value === 'null') {
                        currentDataPos = data;
                        var prevLabel = 0;
                        for (; prevLabel < lowest_level && cellset[row][prevLabel].value === 'null'; prevLabel++) {
                            currentDataPos = currentDataPos[rowlabels[prevLabel]];
                        }
                        if (prevLabel > labelCol) {
                            labelCol = prevLabel;
                        }
                    }
                    if (cellset[row] && cellset[row][labelCol].value !== 'null') {
                        if (labelCol === 0) {
                            for (var xx = 0; xx <= lowest_level; xx++) {
                                rowlabels[xx] = null;
                            }
                        }
                        if (typeof currentDataPos == "number") {
                            parent[rv] = {};
                            currentDataPos = parent[rv];
                        }
                        rv = cellset[row][labelCol].value;
                        rowlabels[labelCol] = rv;
                        if (!currentDataPos.hasOwnProperty(rv)) {
                            currentDataPos[rv] = {};
                        }
                        parent = currentDataPos;
                        currentDataPos = currentDataPos[rv];
                    }
                }
                flatrecord = _.clone(rowlabels);
                for (var col = lowest_level + 1, colLen = cellset[row].length; col < colLen; col++) {
                    var cell = cellset[row][col];
                    var value = cell.value || 0;
                    var maybePercentage = (value !== 0);
                    // check if the resultset contains the raw value, if not try to parse the given value
                    var raw = cell.properties.raw;
                    if (raw && raw !== "null") {
                        value = parseFloat(raw);
                    } else if (typeof (cell.value) !== "number" && parseFloat(cell.value.replace(/[^a-zA-Z 0-9.]+/g, ''))) {
                        value = parseFloat(cell.value.replace(/[^a-zA-Z 0-9.]+/g, ''));
                        maybePercentage = false;
                    }
                    if (value > 0 && maybePercentage) {
                        value = cell.value && cell.value.indexOf('%') >= 0 ? value * 100 : value;
                    }
                    record.push(value);
                    flatrecord.push({
                        f: cell.value,
                        v: value
                    });
                }
                if (flat)
                    data.resultset.push(flatrecord);

                var sum = _.reduce(record, reduceFunction, 0);
                rv = (rv === null ? "null" : rv);
                parent[rv] = sum;
                currentDataPos = data;
            }
        }
        if (setdata) {
            self.rawdata = args.data;
            self.data = data;
            self.hasProcessed = true;
            self.data.height = self.data.resultset.length;
        }
        $(self.el).find('.tipsSpan').hide();
        return data;
    } else {
        $(self.el).find('.tipsSpan').show();
    }
}
;
// Sunburst
SaikuChartRenderer.prototype.sunburst = function(o) {
    this.type = "sunburst";
    this.library = "pv_chart";
    var data = this.process_data_tree({
        data: this.rawdata
    })
      , valueTips = this.myself_process_data_tree({
        data: this.rawdata
    })
      , headerCnt = this.valueContent
      , options = this.getQuickOptions(o, true, true)
      , nodes = pv.dom(data).nodes()
      , tipOptions = {
        delayIn: 200,
        delayOut: 80,
        offset: 2,
        html: true,
        gravity: "nw",
        fade: true,
        followMouse: true,
        corners: true,
        arrow: false,
        opacity: 1
    }
      , dataNodes = dataTips(valueTips[1], headerCnt);

    options = _.extend(options, this.chartDefinition || {});

    var color = pv.colors(options.colors).by(function(d) {
        return d.parentNode && d.parentNode.nodeName;
    });
    function title(d) {
        return d.parentNode ? (title(d.parentNode) + "." + d.nodeName) : d.nodeName;
    }
    var vis = new pv.Panel().width(options.width).height(options.height).canvas(options.canvas);
    var partition = vis.add(pv.Layout.Partition.Fill).nodes(nodes).size(function(d) {
        return d.nodeValue;
    }).order("descending").orient("radial");
    partition.node.add(pv.Wedge).fillStyle(color).visible(function(d) {
        return d.depth > 0;
    }).strokeStyle("#fff").lineWidth(0.5).text(function(d) {
        if (d.nodeName != "undefined") {
            return textContent(d, dataNodes, headerCnt)
        }
    }).cursor('pointer').events("all").event('mousemove', pv.Behavior.tipsy(tipOptions));
    partition.label.add(pv.Label).visible(function(d) {
        return d.angle * d.outerRadius >= 6;
    });
    this.chart = vis;
}
;
// Node-Link Trees
SaikuChartRenderer.prototype.treeslink = function(o) {
    this.type = "treeslink";
    this.library = "pv_chart";
    var data = this.process_data_tree({
        data: this.rawdata
    })
      , valueTips = this.myself_process_data_tree({
        data: this.rawdata
    })
      , headerCnt = this.valueContent
      , options = this.getQuickOptions(o)
      , nodes = pv.dom(data).nodes()
      , tipOptions = {
        delayIn: 200,
        delayOut: 80,
        offset: 2,
        html: true,
        gravity: "nw",
        fade: true,
        followMouse: true,
        corners: true,
        arrow: false,
        opacity: 1
    }
      , dataNodes = dataTips(valueTips[1], headerCnt);
    options = _.extend(options, this.chartDefinition || {});
    var vis = new pv.Panel().width(options.width).height(options.height).canvas(options.canvas);
    var tree = vis.add(pv.Layout.Tree).nodes(nodes).depth(options.width * 0.1).breadth(options.width * 0.01).orient("radial");
    tree.link.add(pv.Line).lineWidth(1).strokeStyle("rgba(118,103,144,.5)")
    tree.node.add(pv.Dot).shapeSize(10).text(function(d) {
        if (d.nodeName != "undefined") {
            return textContent(d, dataNodes, headerCnt)
        }
    }).event('mousemove', pv.Behavior.tipsy(tipOptions)).cursor("pointer").strokeStyle("#1f77b4")
    tree.label.add(pv.Label)
    this.chart = vis;
}
;
// ForceChart
SaikuChartRenderer.prototype.force = function(o) {
    this.type = "force";
    this.library = "pv_chart";
    var data = this.process_data_tree({
        data: this.rawdata
    })
      , dataFill = []
      , options = this.getQuickOptions(o, true, true)
      , valueTips = this.myself_process_data_tree({
        data: this.rawdata
    })
      , headerCnt = this.valueContent
      , dataNodes = dataTips(valueTips[1], headerCnt)
      , nodes = pv.dom(data).nodes();
    nodes.forEach(function(n) {
        if (n.nodeName != undefined || n.nodeName != null) {
            dataFill.push(n.nodeValue);
        }
    });
    options = _.extend(options, this.chartDefinition || {});
    var maxvalue = d3.max(dataFill);
    var minvalue = d3.min(dataFill);
    var tipOptions = {
        delayIn: 200,
        delayOut: 80,
        offset: 2,
        html: true,
        gravity: "nw",
        fade: false,
        followMouse: true,
        corners: true,
        arrow: false,
        opacity: 1
    };
    var color = pv.colors(options.colors).by(function(d) {
        return d.parentNode && d.parentNode.nodeName;
    });
    var vis = new pv.Panel().width(options.width).height(options.height).canvas(options.canvas).event("mousedown", pv.Behavior.pan()).event("mousewheel", pv.Behavior.zoom());
    var layout = vis.add(pv.Layout.Force).nodes(nodes).links(pv.Layout.Hierarchy.links)
    layout.node.add(pv.Dot).text(function(d) {
        return textContent(d, dataNodes, headerCnt)
    }).event('mousemove', pv.Behavior.tipsy(tipOptions)).shapeSize(function(d) {
        var linear = d3.scale.linear().domain([minvalue, maxvalue]).range([0, 0.5]);
        var computeValue = d3.interpolate(5, 1000);
        if (typeof d.nodeValue == "undefined" || typeof d.nodeValue == "") {
            return 30;
        } else {
            var t = linear(d.nodeValue);
            var value = computeValue(t);
            if (d.nodeValue <= 0) {
                value = 40;
            }
            return value;
        }
    }).strokeStyle("white").fillStyle(color).cursor("pointer").event("mousedown", pv.Behavior.drag()).event("drag", layout);
    layout.link.add(pv.Line).lineWidth(0.7).strokeStyle("rgba(118,103,144,1)").events("all").cursor("pointer").event('mousemove', pv.Behavior.tipsy(tipOptions));
    this.chart = vis;
}
;
// BubbleChart
SaikuChartRenderer.prototype.chartVis = function(o) {
    this.library = "d3_chart";
    var options = this.getQuickOptions(o, true, true)
      , data = this.myself_process_data_tree({
        data: this.rawdata
    })
      , headerCnt = this.valueContent;
    options = _.extend(options, this.chartDefinition || {});
    d3.select('#' + options.canvas).selectAll("svg").remove();
    var svg = d3.select('#' + options.canvas).append("svg").attr({
        "width": options.width,
        "height": options.height
    }).append("g").attr("transform", "translate(0,0)");
    var dataObj = {
        svg: svg,
        options: options,
        data: data,
        headerCnt: headerCnt
    }

    if (options.type == "BubbleChart") {
        drawBubble(dataObj);
    } else if (options.type == "RadarChart") {
        drawRadar(dataObj);
    }
    this.chart = svg;
}
;
// Process data method
SaikuChartRenderer.prototype.myself_process_data_tree = function(args, flat) {
    var self = this, headerNum, headerCnt = [], dataAll = [], doubleString = [], singleString = [], data = {}, content = [], dataInfo = [], dataList = [];
    this.valueContent = [],
    this.doubleHeader;
    if (flat) {
        data.resultset = [];
        data.metadata = [];
        data.height = 0;
        data.width = 0;
    }
    var currentDataPos = data;
    if (typeof args == "undefined" || typeof args.data == "undefined") {
        return;
    }
    if (args.data !== null && args.data.error !== null) {
        return;
    }
    // Check to see if there is data
    if (args.data === null || (args.data.cellset && args.data.cellset.length === 0)) {
        return;
    }
    var cellset = args.data.cellset;
    for (var m = 0; m < cellset.length; m++) {
        if (cellset[m][0].type == "ROW_HEADER_HEADER") {
            headerNum = m;
        }
    }
    cellset[0].forEach(function(n) {
        if (n.type == "COLUMN_HEADER" && n.value != "null") {
            content.push(n.value);
        }
    })
    if (headerNum - 1 >= 0) {
        for (var p = 0; p < cellset[headerNum].length; p++) {
            var headerArr = []
              , titleStr = [];
            if (cellset[headerNum][p].value != "null" && cellset[headerNum][p].type == "COLUMN_HEADER") {
                headerArr.push(cellset[headerNum - 1][p].value);
                headerArr.push(cellset[headerNum][p].value);
                if (cellset[headerNum - 1][p].value == "null") {
                    titleStr = cellset[headerNum][p].value;
                } else {
                    titleStr = headerArr.join("~");
                }
                headerCnt.push(titleStr);
            }
        }
        for (var b = 0; b < headerCnt.length; b++) {
            var titleString = []
              , titleArray = [];
            if (headerNum - 1 == 0) {
                titleString = [headerCnt[b]];
            } else {
                titleArray = [content[b], headerCnt[b]];
                titleString = titleArray.join("~");
            }
            doubleString.push(titleString);
        }
    }
    if (cellset[0][0].type == "ROW_HEADER_HEADER") {
        cellset[0].forEach(function(e) {
            if (e.value != null && e.type == "COLUMN_HEADER") {
                singleString.push(e.value);
            }
        })
        this.valueContent = singleString;
    } else {
        this.valueContent = doubleString;
    }
    if (cellset && cellset.length > 0) {
        var lowest_level = 0;
        var data_start = 0;
        var hasStart = false;
        var row, rowLen, labelCol
        for (row = 0,
        rowLen = cellset.length; data_start === 0 && row < rowLen; row++) {
            for (var field = 0, fieldLen = cellset[row].length; field < fieldLen; field++) {
                if (!hasStart) {
                    while (cellset[row][field].type == "COLUMN_HEADER" && cellset[row][field].value == "null") {
                        row++;
                    }
                }
                hasStart = true;
                if (cellset[row][field].type == "ROW_HEADER_HEADER") {
                    while (cellset[row][field].type == "ROW_HEADER_HEADER") {
                        if (flat) {
                            data.metadata.push({
                                colIndex: field,
                                colType: "String",
                                colName: cellset[row][field].value
                            });
                        }
                        field++;
                    }
                    lowest_level = field - 1;
                }
                this.doubleHeader = field
                if (cellset[row][field].type == "COLUMN_HEADER") {
                    var lowest_col_header = 0;
                    var colheader = [];
                    while (lowest_col_header <= row) {
                        if (cellset[lowest_col_header][field].value !== "null") {
                            colheader.push(cellset[lowest_col_header][field].value);
                        }
                        lowest_col_header++;
                    }
                    if (flat) {
                        data.metadata.push({
                            colIndex: field,
                            colType: "Numeric",
                            colName: colheader.join(' ~ ')
                        });
                    }
                    data_start = row + 1;
                }
            }
        }
        var rowlabels = [];
        for (labelCol = 0; labelCol <= lowest_level; labelCol++) {
            rowlabels.push(null);
        }
        for (row = data_start,
        rowLen = cellset.length; row < rowLen; row++) {
            if (cellset[row][0].value !== "") {
                var record = []
                  , flatrecord = []
                  , parent = null
                  , rv = null;
                for (labelCol = 0; labelCol <= lowest_level; labelCol++) {
                    if (cellset[row] && cellset[row][labelCol].value === 'null') {
                        currentDataPos = data;
                        var prevLabel = 0;
                        for (; prevLabel < lowest_level && cellset[row][prevLabel].value === 'null'; prevLabel++) {
                            currentDataPos = currentDataPos[rowlabels[prevLabel]];
                        }
                        if (prevLabel > labelCol) {
                            labelCol = prevLabel;
                        }
                    }
                    if (cellset[row] && cellset[row][labelCol].value !== 'null') {
                        if (labelCol === 0) {
                            for (var xx = 0; xx <= lowest_level; xx++) {
                                rowlabels[xx] = null;
                            }
                        }
                        if (typeof currentDataPos == "number") {
                            parent[rv] = {};
                            currentDataPos = parent[rv];
                        }
                        rv = cellset[row][labelCol].value;
                        rowlabels[labelCol] = rv;
                        if (!currentDataPos.hasOwnProperty(rv)) {
                            currentDataPos[rv] = {};
                        }
                        parent = currentDataPos;
                        currentDataPos = currentDataPos[rv];
                    }
                }
                flatrecord = _.clone(rowlabels);
                for (var col = lowest_level + 1, colLen = cellset[row].length; col < colLen; col++) {
                    var cell = cellset[row][col];
                    var value = cell.value || 0;
                    var maybePercentage = (value !== 0);
                    // check if the resultset contains the raw value, if not try to parse the given value
                    var raw = cell.properties.raw;
                    if (raw && raw !== "null") {
                        value = parseFloat(raw);
                    } else if (typeof (cell.value) !== "number" && parseFloat(cell.value.replace(/[^a-zA-Z 0-9.]+/g, ''))) {
                        value = parseFloat(cell.value.replace(/[^a-zA-Z 0-9.]+/g, ''));
                        maybePercentage = false;
                    }
                    if (value > 0 && maybePercentage) {
                        value = cell.value && cell.value.indexOf('%') >= 0 ? value * 100 : value;
                    }
                    record.push({
                        tipStr: cell.value,
                        arithmetic: value
                    });
                    flatrecord.push({
                        f: cell.value,
                        v: value
                    });
                }
                rv = (rv === null ? "null" : rv);
                parent[rv] = record;
                currentDataPos = data;
            }
            dataInfo.push(flatrecord);
        }
        dataInfo.forEach(function(d) {
            if (d != undefined) {
                dataList.push(d);
            }
        });
        dataAll.push(data);
        dataAll.push(dataList);
        $(self.el).find('.tipsSpan').hide();

        return dataAll;
    } else {
        $(self.el).find('.tipsSpan').show();
    }
}
// Privence sum data
SaikuChartRenderer.prototype.Privence_data_sum = function() {
    var data = this.myself_process_data_tree({
        data: this.rawdata
    });
    var summeta;
    if (this.type == "worldmap" || this.type == "multipleworld") {
        return data[0];
    } else {
        if (data[0].中国 != "undefined") {
            summeta = data[0].中国;
        }
        if (data[0].中国 == "undefined" || data[0].中国 == "" || data[0].中国 == null) {
            summeta = data[0];
        }
        return summeta;
    }
}
// World map chart
SaikuChartRenderer.prototype.worldMap = function(o) {
    this.type = "worldmap";
    this.library = "d3_chart";
    var options = this.getQuickOptions(o);
    var dataSum = this.Privence_data_sum();
    d3.select('#' + options.canvas).selectAll("svg").remove();
    var svg = d3.select('#' + options.canvas).append("svg").attr("width", options.width).attr("height", options.height).append("g").attr("transform", "translate(" + options.width * 0.3 + " ,0)")
    d3.selectAll(".d3-tip").remove();
    var worldJsonPath = "/xdatainsight/content/saiku-ui/js/saiku/plugins/fine_Chart/mapdata/world-countries.json";
    var argsWorld = {
        mapPath: worldJsonPath,
        svg: svg,
        dataSum: dataSum,
        clickNum: 0,
        panleObj: options,
        typeChart: this.type
    }
    drawMapPath(argsWorld);
    this.chart = svg;
}
// China map chart
SaikuChartRenderer.prototype.chinaMap = function(o) {
    this.type = "chinamap";
    this.library = "d3_chart";
    var options = this.getQuickOptions(o);
    var dataSum = this.Privence_data_sum();
    d3.select('#' + options.canvas).selectAll("svg").remove();
    var svg = d3.select('#' + options.canvas).append("svg").attr("width", options.width).attr("height", options.height).append("g").attr("transform", "translate(" + options.width * 0.3 + ", 0)")
    d3.selectAll(".d3-tip").remove();
    var chinaJsonPath = "/xdatainsight/content/saiku-ui/js/saiku/plugins/fine_Chart/mapdata/china.json";
    var argsChina = {
        mapPath: chinaJsonPath,
        svg: svg,
        dataSum: dataSum,
        clickNum: 0,
        panleObj: options,
        typeChart: this.type,
        spanRedender: $(this.el).find('a.rerender')
    };
    drawMapPath(argsChina);
    this.chart = svg;
}
// China Multiple china map chart
SaikuChartRenderer.prototype.multipleChinaMap = function(o) {
    var options = this.getQuickOptions(o);
    this.library = "d3_chart",
    this.type = "multiplemap";
    var dataSum = this.Privence_data_sum();
    d3.select('#' + options.canvas).selectAll("svg").remove();
    var svgMultiple = d3.select('#' + options.canvas).append("svg").attr("width", options.width).attr("height", options.height * 1.5).append("g").attr("transform", "translate(" + options.width * 0.3 + ",0)")
    var chinaJsonPath = "/xdatainsight/content/saiku-ui/js/saiku/plugins/fine_Chart/mapdata/china.json";
    var argsMultiple = {
        mapPath: chinaJsonPath,
        svg: svgMultiple,
        panleObj: options,
        vauleCnt: this.valueContent,
        typeChart: this.type,
        dataSum: dataSum
    }
    drawMultipleMap(argsMultiple);
    this.chart = svgMultiple;
}
// Scatter China Map chart
SaikuChartRenderer.prototype.scatterChinaMap = function(o) {
    this.type = "scattermap";
    this.library = "d3_chart";
    var options = this.getQuickOptions(o);
    var data = this.myself_process_data_tree({
        data: this.rawdata
    });
    d3.select('#' + options.canvas).selectAll("svg").remove();
    var svg = d3.select('#' + options.canvas).append("svg").attr("width", options.width).attr("height", options.height).append("g").attr("transform", "translate(" + options.width * 0.3 + ",0)")
    d3.selectAll(".d3-tip").remove();
    var chinaJsonPath = "/xdatainsight/content/saiku-ui/js/saiku/plugins/fine_Chart/mapdata/china.json";
    var lengthNum = this.valueContent.length;
    var argsScatter = {
        mapPath: chinaJsonPath,
        svg: svg,
        options: options,
        data: data[1],
        lengthNum: lengthNum,
        contentHeader: this.valueContent
    };
    drawScatterChina(argsScatter);
    this.chart = svg;
}
// China Multiple world map chart
SaikuChartRenderer.prototype.multipleWorldMap = function(o) {
    this.library = "d3_chart",
    this.type = "multipleworld";
    var options = this.getQuickOptions(o)
      , dataSum = this.Privence_data_sum();
    d3.select('#' + options.canvas).selectAll("svg").remove();
    var svg = d3.select('#' + options.canvas).append("svg").attr("width", options.width).attr("height", options.height * 1.3).append("g").attr("transform", "translate(" + options.width * 0.3 + ",0)")
    var chinaJsonPath = "/xdatainsight/content/saiku-ui/js/saiku/plugins/fine_Chart/mapdata/world-countries.json";
    var argsMultiple = {
        mapPath: chinaJsonPath,
        svg: svg,
        panleObj: options,
        vauleCnt: this.valueContent,
        typeChart: this.type,
        dataSum: dataSum
    };
    drawMultipleMap(argsMultiple);
    this.chart = svg;
}

/*
 *   Copyright 2015 OSBI Ltd
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 */

/**
 * Base 64 module
 *
 * @public
 * @param  {window} window Window is passed through as local variable rather than global
 * @return {String} Encoding data
 */

;
(function(window) {
    'use strict';
    var characters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';
    var fromCharCode = String.fromCharCode;
    var INVALID_CHARACTER_ERR = (function() {
        // Fabricate a suitable error object
        try {
            document.createElement('$');
        } catch (error) {
            return error;
        }
    }());

    // Encoder
    window.Base64 || (window.Base64 = {
        encode: function(string) {
            var a, b, b1, b2, b3, b4, c, i = 0, len = string.length, max = Math.max, result = '';

            while (i < len) {
                a = string.charCodeAt(i++) || 0;
                b = string.charCodeAt(i++) || 0;
                c = string.charCodeAt(i++) || 0;
                if (max(a, b, c) > 0xFF) {
                    throw INVALID_CHARACTER_ERR;
                }

                b1 = (a >> 2) & 0x3F;
                b2 = ((a & 0x3) << 4) | ((b >> 4) & 0xF);
                b3 = ((b & 0xF) << 2) | ((c >> 6) & 0x3);
                b4 = c & 0x3F;

                if (!b) {
                    b3 = b4 = 64;
                } else if (!c) {
                    b4 = 64;
                }
                result += characters.charAt(b1) + characters.charAt(b2) + characters.charAt(b3) + characters.charAt(b4);
            }

            return result;
        }
    });
}(this));

/**
 * IE Browser detection
 *
 * @public
 * @return {Boolean} If `true` return the value of `v`, else return `false`
 */
var isIE = (function() {
    'use strict';

    var undef, v = 3;
    var dav = navigator.appVersion;

    if (dav.indexOf('MSIE') !== -1) {
        v = parseFloat(dav.split('MSIE ')[1]);
        return v > 4 ? v : false;
    }

    return false;
}());

/**
 * A client for working with files Saiku
 *
 * @class
 * @chainable
 * @example
 * 		var myClient = new SaikuClient({
 * 			server: '/saiku',
 * 			path: '/rest/saiku/embed',
 * 			user: 'admin',
 * 			password: 'admin'
 * 		});
 * @return {SaikuClient} The SaikuClient instance (for chaining)
 */
var SaikuClient = (function() {
    'use strict';

    /**
	 * The configuration settings for the request
	 *
	 * @property _settings
	 * @type {Object}
	 * @private
	 * @default
	 * 		{
	 * 			server: '/saiku',
	 * 			path: '/rest/saiku/embed',
	 * 			user: 'admin',
	 * 			password: 'admin',
	 * 			blockUI: false
	 * 		}
	 */
    var _settings = {
        server: '/saiku',
        path: '/rest/saiku/embed',
        user: 'admin',
        password: 'admin',
        blockUI: false
    };

    /**
	 * The configuration options to render the file on page
	 *
	 * @property _options
	 * @type {Object}
	 * @private
	 * @default
	 * 		{
	 * 			file: null,
	 * 			render: 'table',
	 * 			mode: null,
	 * 			formatter: 'flattened',
	 * 			htmlObject: '#saiku',
	 * 			zoom: true,
	 * 			params: {}
	 * 		}
	 */
    var _options = {
        file: null,
        render: 'chart',
        // table || chart
        mode: null,
        // table: sparkline, sparkbar || chart: line, bar, treemap, ...
        formatter: 'flattened',
        // Should be left unless you want an hierarchical resultset
        zoom: true,
        params: {}
    };

    /**
	 * Instance of SaikuTableRenderer and SaikuChartRenderer
	 *
	 * @property _saikuRendererFactory
	 * @type {Object}
	 * @private
	 * @default
	 * 		{
	 *      	'table': SaikuTableRenderer,
	 *          'chart': SaikuChartRenderer
	 *      }
	 */
    var _saikuRendererFactory = {
        'table': SaikuTableRenderer,
        'chart': SaikuChartRenderer,
        'playground': typeof SaikuPlaygroundRenderer !== 'undefined' ? SaikuPlaygroundRenderer : ''
    };

    /**
	 * Add levels and parameter names
	 *
	 * @private
	 * @param  {String} dataSchema [connection].[catalog].[schema].[cube]
	 * @param  {Object} dataAxis Axis FILTER, COLUMNS and ROWS with values in hierarchies
	 * @return {Object} Levels and parameter names
	 */
    function joinParameters(dataSchema, dataAxis) {
        var parametersLevels = [];

        _.each(dataAxis, function(axis) {
            _.each(axis, function(value) {
                _.each(value.levels, function(levels) {
                    if (levels.selection.parameterName) {
                        parametersLevels.push({
                            levels: dataSchema + '.' + value.name + '.[' + levels.name + ']',
                            parameterName: levels.selection.parameterName
                        });
                    }
                });
            });
        });

        return parametersLevels;
    }

    /**
	 * That constructor enforces the use of new, even if you call the constructor like a function
	 *
	 * @constructor
	 * @private
	 * @param  {Object} opts Settings for the request
	 */
    function SaikuClient(opts) {
        // Enforces new
        if (!(this instanceof SaikuClient)) {
            return new SaikuClient(opts);
        }

        this.settings = _.extend(_settings, opts);
    }

    /**
	 * Method for execute the requests of files Saiku
	 *
	 * @method execute
 	 * @public
	 * @param  {Object} opts The configuration options to render the file on page
	 * @example
	 * 		myClient.execute({
	 *   		file: '/homes/home:admin/report.saiku',
	 *     		htmlObject: '#panel-body',
	 *       	render: 'table',
	 *      });
	 */
    SaikuClient.prototype.execute = function(opts) {
        var self = this;
        var options = _.extend({}, _options, opts);
        var parameters = {};

        if (typeof ga !== 'undefined') {
            ga('send', 'event', 'SaikuClient', 'Execute');
        }
        if ($.blockUI && this.settings.blockUI) {
            $.blockUI.defaults.css = {
                'color': 'black',
                'font-weight': 'normal'
            };
            $.blockUI.defaults.overlayCSS = {};
            $.blockUI.defaults.blockMsgClass = 'processing';
            $.blockUI.defaults.fadeOut = 0;
            $.blockUI.defaults.fadeIn = 0;
            $.blockUI.defaults.ignoreIfBlocked = false;
        }
        if (options.params) {
            for (var key in options.params) {
                if (options.params.hasOwnProperty(key)) {
                    parameters['param' + key] = options.params[key];
                }
            }
        }
        parameters = _.extend(parameters, {
            'formatter': options.formatter
        }, {
            'file': options.file
        });

        if ($.blockUI && this.settings.blockUI) {
            $(options.htmlObject).block({
                message: '<span class="saiku_logo" style="float:left">&nbsp;&nbsp;</span> Executing....'
            });
        }

        var params = {
            url: self.settings.server + (self.settings.path ? self.settings.path : '') + '/export/saiku/json',
            type: 'GET',
            cache: false,
            data: parameters,
            contentType: 'application/x-www-form-urlencoded',
            dataType: 'json',
            crossDomain: true,
            async: true,
            beforeSend: function(request) {
                //admin 认证
                options.loadBefore && options.loadBefore();
                if (self.settings.user && self.settings.password) {
                    //var auth = 'Basic ' + Base64.encode(
                    //		self.settings.user + ':' + self.settings.password
                    //	);
                    //request.setRequestHeader('Authorization', auth);
                    return true;
                }

            },
            success: function(data, textStatus, jqXHR) {
                options.loadSuccess && options.loadSuccess(data);
                if (data.query && data.height > 0 && data.width > 0) {
                    var renderMode = data.query.properties['saiku.ui.render.mode'] ? data.query.properties['saiku.ui.render.mode'] : options.render;
                    var mode = data.query.properties['saiku.ui.render.type'] ? data.query.properties['saiku.ui.render.type'] : options.mode;
                    var chartDefinition = data.query.properties['saiku.ui.chart.options'] ? data.query.properties['saiku.ui.chart.options'].chartDefinition : '';
                    var dataSchema = data.query.cube.uniqueName;
                    var dataAxis = {
                        dataFilter: data.query.queryModel.axes.FILTER['hierarchies'],
                        dataColumns: data.query.queryModel.axes.COLUMNS['hierarchies'],
                        dataRows: data.query.queryModel.axes.ROWS['hierarchies']
                    };
                    var parametersValues = data.query.parameters;
                    var parametersLevels;
                    if (self.settings.dashboards) {
                        if (options.dropDashboards === undefined) {
                            renderMode = options.render;
                            mode = options.mode;
                        }
                        parametersLevels = joinParameters(dataSchema, dataAxis);
                        $(options.htmlObject).closest('.gs-w').data('parametersLevels', JSON.stringify(parametersLevels));
                        $(options.htmlObject).closest('.gs-w').data('parametersValues', JSON.stringify(parametersValues));

                        if (options.openDashboards) {
                            $(options.htmlObject).closest('.gs-w').data('id', options.htmlObject);
                            $(options.htmlObject).closest('.gs-w').data('title', options.title);
                            $(options.htmlObject).closest('.gs-w').data('file', options.file);
                            $(options.htmlObject).closest('.gs-w').data('htmlobject', options.htmlObject);
                            $(options.htmlObject).closest('.gs-w').data('render', options.render);
                            $(options.htmlObject).closest('.gs-w').data('mode', options.mode);
                            $(options.htmlObject).closest('.gs-w').data('chartDefinition', JSON.stringify(options.chartDefinition));
                        } else if (options.dropDashboards) {
                            if (!(_.isEmpty(chartDefinition))) {
                                options['chartDefinition'] = chartDefinition;
                                $(options.htmlObject).closest('.gs-w').data('file', options.file);
                                $(options.htmlObject).closest('.gs-w').data('htmlobject', options.htmlObject);
                                $(options.htmlObject).closest('.gs-w').data('render', renderMode);
                                $(options.htmlObject).closest('.gs-w').data('mode', mode);
                                $(options.htmlObject).closest('.gs-w').data('chartDefinition', JSON.stringify(chartDefinition));
                            } else {
                                $(options.htmlObject).closest('.gs-w').data('file', options.file);
                                $(options.htmlObject).closest('.gs-w').data('htmlobject', options.htmlObject);
                                $(options.htmlObject).closest('.gs-w').data('render', renderMode);
                                $(options.htmlObject).closest('.gs-w').data('mode', mode);
                                $(options.htmlObject).closest('.gs-w').data('chartDefinition', '');
                            }
                        }
                    }
                    options['render'] = renderMode;
                    options['mode'] = mode;
                    if (options.render in _saikuRendererFactory) {
                        var saikuRenderer = new _saikuRendererFactory[options.render](data,options);
                        saikuRenderer.render();
                        if ($.blockUI) {
                            $(options.htmlObject).unblock();
                        }
                    } else {
                        alert('Render type ' + options.render + ' not found!');
                    }
                    if ($.blockUI) {
                        $(options.htmlObject).unblock();
                    }
                } else {
                    options.loadFail && options.loadFail();
                    $(options.htmlObject).text('No data');
                    if ($.blockUI) {
                        $(options.htmlObject).unblock();
                    }
                }
            },
            error: function(jqXHR, textStatus, errorThrown) {
                options.loadFail && options.loadFail();
                if ($.blockUI) {
                    $(options.htmlObject).unblock();
                }
                $(options.htmlObject).text('No data');
                console.error(textStatus);
                console.error(jqXHR);
                console.error(errorThrown);
            }
        };

        $.ajax(params);
    }
    ;

    return SaikuClient;
}());

/**
 * Created by Administrator on 2016/3/8.
 */
var fillBubbleColor = function(num) {
    var colors = [];
    if (num <= 3) {
        colors = ['#2DC1E9', '#B7EFFE', '#BAD202'];
    } else if (num <= 7) {
        colors = ['#00667D', '#1686B6', '#36BEF0', '#83AD01', '#BAD202', "#FDD900", "#FF7A4D"];
    } else if (num <= 15) {
        colors = ["#00679A", "#1686B6", "#6068B1", "#667FB5", "#01BCCD", "#2DC1E9", "#B7EFFE", "#75C5A2", "#83AD01", "#BAD202", "#FDD900", "#FCBD56", "#FF7A4D", "#EC407A", "#959595"];
    } else {
        colors = ["#345684", "#00679A", "#5960A6", "#017F96", "#00A0B8", "#01B6D3", "#2DC1E9", "#6CC9DA", "#B7EFFE", "#CCE3DD", "#75C5A2", "#83AD01", "#ADBE22", "#BAD202", "#FDD900", "#FCBD56", "#FF7A4D", "#EC407A", "#D26A9D", "#959595"];
    }
    return colors;
}
// bubble draw
var drawBubble = function(bubbleObj) {
    var lengthCol = bubbleObj.headerCnt.length
      , dataArr = bubbleObj.data[1]
      , dataNodes = []
      , nodesLength = dataArr.length
      , color = fillBubbleColor(nodesLength);
    var bubble = d3.layout.pack().sort(null).size([bubbleObj.options.width, bubbleObj.options.height]).padding(3);
    var node = bubbleObj.svg.selectAll(".node").data(bubble.nodes(classes(dataArr)).filter(function(d) {
        return !d.children;
    })).enter().append("g").attr("class", "node").attr("transform", function(d) {
        return "translate(" + d.x + "," + d.y + ")";
    });
    var tip = d3.behavior.tip().attr({
        'class': 'd3-tip'
    }).offset([-10, 0]);
    bubbleObj.svg.call(tip);
    node.append("circle").on("mouseover", function(d) {
        var tipsArray = [];
        for (var t = 0; t < d.valueArr.length; t++) {
            var transferHeader = []
              , headerStr = [];
            transferHeader.push(bubbleObj.headerCnt[t]);
            transferHeader.push(d.valueArr[t]);
            headerStr = transferHeader.join(" : ");
            tipsArray.push(headerStr);
        }
        tip.html(d.className + " :</br>" + tipsArray.join("</br>"));
        tip.show();
    }).on("mouseleave", function() {
        tip.hide();
    }).attr("transform", function() {
        return "translate(" + 0 + "," + 0 + ")";
    }).attr("r", 0).transition().delay(function(d, i) {
        if (nodesLength <= 9) {
            return (800) / nodesLength * i;
        }
        return (800) / nodesLength * i;
    }).duration(function(d, i) {
        return 800 / nodesLength * i;
    }).attr("r", function(d) {
        return d.r;
    }).style("fill", function(d, i) {
        if (d.negativePara == 0) {
            var colortip = "#FF4500";
        } else {
            if (color.length <= i) {
                var colortip = color[i % color.length];
            } else {
                var colortip = color[i];
            }
        }
        return colortip;
    }).style("cursor", "default");
    var divide = 0;
    var subLength = 0;
    var flag = 0;
    if ((navigator.userAgent.indexOf('MSIE') >= 0) && (navigator.userAgent.indexOf('Opera') < 0)) {
        divide = 3;
        subLength = 6;
        flag = 1;
    } else if (navigator.userAgent.indexOf('Firefox') >= 0) {
        divide = 3;
        subLength = 6;
        flag = 1;
    } else if (navigator.userAgent.indexOf('Opera') >= 0) {
        divide = 20;
    } else {
        divide = 5;
        subLength = 6;
        flag = 2;
    }
    var text = node.append("text").on("mouseover", function(d, i) {
        var tipsArray = [];
        for (var t = 0; t < d.valueArr.length; t++) {
            var transferHeader = []
              , headerStr = [];
            transferHeader.push(bubbleObj.headerCnt[t]);
            transferHeader.push(d.valueArr[t]);
            headerStr = transferHeader.join(" : ");
            tipsArray.push(headerStr);
        }
        tip.html(d.className + " :</br>" + tipsArray.join("</br>"));
        tip.show();
    }).on("mouseleave", function() {
        tip.hide();
    }).attr("dy", "0").style("text-anchor", "middle").text(function(d) {
        return d.className.substring(0, d.r / subLength);
    })//.attr("font-size", "0")
    //.style("fill", "black")
    //.transition()
    //.duration(function(d,i){
    //	return 1500/nodesLength*i;
    //})
    //.delay(function(d,i){
    //	if(nodesLength<=9){
    //		return 800/nodesLength*i+1;
    //	}
    //	return 1500/nodesLength*i+1;
    //})
    .attr("font-size", function(d) {
        if (flag == 1) {
            if (d.r / divide <= 12) {
                return 12;
            }
        }
        return d.r / divide;
    }).style("cursor", "default");
    function classes(root) {
        root.forEach(function(d) {
            var titleLoc = d.length - lengthCol
              , dataFloat = []
              , negative = null;
            for (var a = titleLoc; a < d.length; a++) {
                dataFloat.push(d[a].f);
            }
            if (titleLoc - 2 >= 0) {
                var packageNum = d[titleLoc - 2];
            } else {
                var packageNum = d[titleLoc - 1];
            }
            if (d[titleLoc].v <= 0) {
                negative = 0
                d[titleLoc].v = -(d[titleLoc].v);
            }
            if (d[titleLoc - 1] != null) {
                var dataObj = {
                    packageName: packageNum,
                    className: d[titleLoc - 1],
                    value: d[titleLoc].v,
                    valueArr: dataFloat,
                    negativePara: negative
                }
                dataNodes.push(dataObj);
            }
        })
        return {
            children: dataNodes
        };
    }
}
// radar draw
var drawRadar = function(radarObj) {
    var id = '#' + radarObj.options.canvas
      , dataArr = radarObj.data[1];
    radarObj.svg.attr("transform", "translate(" + radarObj.options.width * 0.5 + ", " + radarObj.options.height * 0.51 + ")").attr("class", "radar" + id);
    var color = d3.scale.ordinal().range(radarObj.options.colors)
      , radarChartOptions = {
        w: radarObj.options.width * 0.6,
        h: radarObj.options.height * 0.6,
        margin: 5,
        maxValue: 0.5,
        levels: 5,
        roundStrokes: true,
        width: radarObj.options.width,
        height: radarObj.options.height,
        color: color,
        svg: radarObj.svg,
        headerCnt: radarObj.headerCnt
    };
    var data = radarData(dataArr, radarObj.headerCnt);
    RadarPath(data, radarChartOptions);
}
// draw radar path
var RadarPath = function(data, options) {
    var cfg = {
        w: 600,
        //Width of the circle
        h: 600,
        //Height of the circle
        margin: {
            top: 5,
            right: 5,
            bottom: 5,
            left: 5
        },
        //The margins of the SVG
        levels: 3,
        //How many levels or inner circles should there be drawn
        maxValue: 0,
        //What is the value that the biggest circle will represent
        labelFactor: 1.25,
        //How much farther than the radius of the outer circle should the labels be placed
        wrapWidth: 60,
        //The number of pixels after which a label needs to be given a new line
        opacityArea: 0.35,
        //The opacity of the area of the blob
        dotRadius: 4,
        //The size of the colored circles of each blog
        opacityCircles: 0.1,
        //The opacity of the circles of each blob
        strokeWidth: 2,
        //The width of the stroke around each blob
        roundStrokes: false,
        //If true the area and stroke will follow a round path (cardinal-closed)
        color: d3.scale.category10()//Color function
    };
    //Put all of the options into a variable called cfg
    if ('undefined' !== typeof options) {
        for (var i in options) {
            if ('undefined' !== typeof options[i]) {
                cfg[i] = options[i];
            }
        }
    }
    //If the supplied maxValue is smaller than the actual one, replace by the max in the data
    var maxValue = Math.max(cfg.maxValue, d3.max(data, function(i) {
        return d3.max(i.map(function(o) {
            return o.value.v;
        }))
    }));
    var allAxis = (data[0].map(function(i, j) {
        return i.key
    }))
      , //Names of each axis
    total = allAxis.length
      , //The number of different axes
    radius = Math.min(cfg.w / 2, cfg.h / 2)
      , //Radius of the outermost circle
    angleSlice = Math.PI * 2 / total;
    //The width in radians of each "slice"
    //Scale for the radius
    var rScale = d3.scale.linear().range([0, radius]).domain([0, maxValue]);
    //explain color
    var parentTitle = options.svg.append("g").attr({
        "transform": "translate(" + (-options.width * 0.4) + "," + (-options.height * 0.43) + ")"
    }).style({
        "font-variant": "normal",
        "font-stretch": "normal",
        "font-size": "15px"
    });
    var childTitle = parentTitle.selectAll(".childInfo").data(options.headerCnt).enter().append("g").attr({
        "class": "childInfo",
        "transform": function(d, i) {
            return "translate(" + (i * 150) + "," + (-7) + ")";
        }
    });
    var textTitle = parentTitle.selectAll(".textInfo").data(options.headerCnt).enter().append("g").attr({
        "class": "textInfo",
        "transform": function(d, i) {
            return "translate(" + (i * 150 + 20) + "," + 0 + ")";
        }
    });
    textTitle.append("text").attr({
        "class": "textColor",
        "font-style": "normal",
        "font-variant": "normal",
        "font-weight": "normal",
        "font-stretch": "normal",
        "font-size": "15px",
        "line-height": "normal",
        "font-family": "sans-serif"
    }).text(function(d) {
        return d;
    })
    childTitle.append("circle").attr({
        "r": 8,
        "class": "circleColor"
    }).style({
        "fill": function(d, i) {
            return cfg.color(i)
        },
        "stroke": function(d, i) {
            return cfg.color(i)
        }
    })
    //Append a g element
    var g = options.svg.append("g")
    //Filter for the outside glow
    var filter = g.append('defs').append('filter').attr('id', 'glow')
      , feGaussianBlur = filter.append('feGaussianBlur').attr('stdDeviation', '2.5').attr('result', 'coloredBlur')
      , feMerge = filter.append('feMerge')
      , feMergeNode_1 = feMerge.append('feMergeNode').attr('in', 'coloredBlur')
      , feMergeNode_2 = feMerge.append('feMergeNode').attr('in', 'SourceGraphic');
    //Wrapper for the grid & axes
    var axisGrid = g.append("g").attr("class", "axisWrapper");
    //Draw the background circles
    axisGrid.selectAll(".levels").data(d3.range(1, (cfg.levels + 1)).reverse()).enter().append("circle").attr("class", "gridCircle").attr("r", function(d, i) {
        return radius / cfg.levels * d;
    }).style({
        "fill": "#CDCDCD",
        "stroke": "#CDCDCD",
        "fill-opacity": cfg.opacityCircles,
        "filter": "url(#glow)"
    });
    //Text indicating at what % each level is
    axisGrid.selectAll(".axisLabel").data(d3.range(1, (cfg.levels + 1)).reverse()).enter().append("text").attr("class", "axisLabel").attr("x", 4).attr("y", function(d) {
        return -d * radius / cfg.levels;
    }).attr("dy", "0.4em").style("font-size", "10px").attr("fill", "#737373")
    //.text(function(d,i) { return maxValue * d/cfg.levels; });
    //Create the straight lines radiating outward from the center
    var axis = axisGrid.selectAll(".axis").data(allAxis).enter().append("g").attr("class", "axis");
    //Append the lines
    axis.append("line").attr("x1", 0).attr("y1", 0).attr("x2", function(d, i) {
        return rScale(maxValue * 1.1) * Math.cos(angleSlice * i - Math.PI / 2);
    }).attr("y2", function(d, i) {
        return rScale(maxValue * 1.1) * Math.sin(angleSlice * i - Math.PI / 2);
    }).attr("class", "line").style("stroke", "white").style("stroke-width", "2px");
    //Append the labels at each axis
    axis.append("text").attr("class", "legend").style("font-size", "11px").attr("text-anchor", "middle").attr("dy", "0.35em").attr("x", function(d, i) {
        return rScale(maxValue * cfg.labelFactor) * Math.cos(angleSlice * i - Math.PI / 2);
    }).attr("y", function(d, i) {
        return rScale(maxValue * cfg.labelFactor) * Math.sin(angleSlice * i - Math.PI / 2);
    }).text(function(d) {
        return d;
    }).call(wrap, cfg.wrapWidth);
    //The radial line function
    var radarLine = d3.svg.line.radial().interpolate("linear-closed").radius(function(d) {
        return rScale(d.value.v);
    }).angle(function(d, i) {
        return i * angleSlice;
    });
    if (cfg.roundStrokes) {
        radarLine.interpolate("cardinal-closed");
    }
    //Create a wrapper for the blobs
    var blobWrapper = g.selectAll(".radarWrapper").data(data).enter().append("g").attr("class", "radarWrapper");
    //Append the backgrounds
    blobWrapper.append("path").attr("class", "radarArea").attr("d", function(d, i) {
        return radarLine(d);
    }).style("fill", function(d, i) {
        return cfg.color(i);
    }).style("fill-opacity", cfg.opacityArea).on('mouseover', function(d, i) {
        //Dim all blobs
        d3.selectAll(".radarArea").transition().duration(200).style("fill-opacity", 0.1);
        //Bring back the hovered over blob
        d3.select(this).transition().duration(200).style("fill-opacity", 0.8);
    }).on('mouseout', function() {
        //Bring back all blobs
        d3.selectAll(".radarArea").transition().duration(200).style("fill-opacity", cfg.opacityArea);
    });
    //Create the outlines
    blobWrapper.append("path").attr("class", "radarStroke").attr("d", function(d, i) {
        return radarLine(d);
    }).style("stroke-width", cfg.strokeWidth + "px").style("stroke", function(d, i) {
        return cfg.color(i);
    }).style("fill", "none").style("filter", "url(#glow)");
    //Append the circles
    blobWrapper.selectAll(".radarCircle").data(function(d, i) {
        return d;
    }).enter().append("circle").attr("class", "radarCircle").attr("r", cfg.dotRadius).attr("cx", function(d, i) {
        return rScale(d.value.v) * Math.cos(angleSlice * i - Math.PI / 2);
    }).attr("cy", function(d, i) {
        return rScale(d.value.v) * Math.sin(angleSlice * i - Math.PI / 2);
    }).style("fill", function(d, i, j) {
        return cfg.color(j);
    }).style("fill-opacity", 0.8);
    var tip = d3.behavior.tip().attr({
        'class': 'd3-tip'
    }).offset([-10, 0]);
    options.svg.call(tip);
    //Wrapper for the invisible circles on top
    var blobCircleWrapper = g.selectAll(".radarCircleWrapper").data(data).enter().append("g").attr("class", "radarCircleWrapper");
    //Append a set of invisible circles on top for the mouseover pop-up
    blobCircleWrapper.selectAll(".radarInvisibleCircle").data(function(d, i) {
        return d;
    }).enter().append("circle").attr("class", "radarInvisibleCircle").attr("r", cfg.dotRadius * 1.5).attr("cx", function(d, i) {
        return rScale(d.value.v) * Math.cos(angleSlice * i - Math.PI / 2);
    }).attr("cy", function(d, i) {
        return rScale(d.value.v) * Math.sin(angleSlice * i - Math.PI / 2);
    }).style("fill", "none").style("pointer-events", "all").on("mouseover", function(d, i) {
        tip.html(d.key + " : " + d.value.f);
        tip.show();
    }).on("mouseout", function() {
        tip.hide();
    });
    //Set up the small tooltip for when you hover over a circle
    var tooltip = g.append("text").attr("class", "tooltip").style("opacity", 0);
    //Wraps SVG text
    function wrap(text, width) {
        text.each(function() {
            var text = d3.select(this), words = text.text().split(/\s+/).reverse(), word, line = [], lineNumber = 0, lineHeight = 1.4, // ems
            y = text.attr("y"), x = text.attr("x"), dy = parseFloat(text.attr("dy")), tspan = text.text(null).append("tspan").attr("x", x).attr("y", y).attr("dy", dy + "em");
            while (word = words.pop()) {
                line.push(word);
                tspan.text(line.join(" "));
                if (tspan.node().getComputedTextLength() > width) {
                    line.pop();
                    tspan.text(line.join(" "));
                    line = [word];
                    tspan = text.append("tspan").attr("x", x).attr("y", y).attr("dy", ++lineNumber * lineHeight + dy + "em").text(word);
                }
            }
        });
    }
}
// radar data process
var radarData = function(dataArr, headerCnt) {
    var childArr = [];
    for (var b = 0; b < headerCnt.length; b++) {
        childArr[b] = [];
    }
    for (var d = 0; d < dataArr.length; d++) {
        var s = 0
          , dataLength = dataArr[d].length - headerCnt.length;
        for (var a = dataLength; a < dataArr[d].length; a++) {
            var childObj = {};
            childObj = {
                key: dataArr[d][dataLength - 1],
                value: dataArr[d][a]
            }
            childArr[s].push(childObj);
            s++;
        }
    }
    return childArr;
}
// color data node
var colorHandle = function(colorParam) {
    var sortParam = colorParam.sort(compare);
    if (sortParam.length % 5 == 0) {
        var share = parseInt(sortParam.length / 5);
    } else {
        if (sortParam.length % 5 >= 3) {
            var share = parseInt(sortParam.length / 5) + 1;
        } else {
            var share = parseInt(sortParam.length / 5);
        }
    }
    var rangeData = [];
    if (sortParam.length <= 6) {
        rangeData = sortParam;
    } else if (sortParam.length <= 7) {
        for (var n = 0; n < 5; n++) {
            rangeData.push(sortParam[n])
        }
        rangeData.push(sortParam[sortParam.length - 1]);
    } else if (sortParam.length > 7) {
        for (var n = 0; n < 5; n++) {
            if (n == 0) {
                rangeData.push(sortParam[0]);
            } else {
                rangeData.push(sortParam[share * n - 1]);
            }
        }
        rangeData.push(sortParam[sortParam.length - 1]);
    }
    if (rangeData.length < 6) {
        for (var m = rangeData.length; m < 6; m++) {
            rangeData[m] = 0;
        }
    }
    return rangeData;
}
// multiple color range chose
var fillColor = function(dataValue, rangeData) {
    var colorParam = {
        a: d3.rgb(253, 217, 0),
        b: d3.rgb(187, 211, 1),
        c: d3.rgb(131, 173, 0),
        d: d3.rgb(54, 191, 241),
        e: d3.rgb(22, 135, 183),
        f: d3.rgb(0, 102, 124)
    }
    if (dataValue <= rangeData[4]) {
        var minParam = rangeData[5];
        var maxParam = rangeData[4];
        var computeColor = d3.interpolate(colorParam.a, colorParam.b);
    } else if (dataValue <= rangeData[3]) {
        var minParam = rangeData[4];
        var maxParam = rangeData[3];
        var computeColor = d3.interpolate(colorParam.b, colorParam.c);
    } else if (dataValue <= rangeData[2]) {
        var minParam = rangeData[3];
        var maxParam = rangeData[2];
        var computeColor = d3.interpolate(colorParam.c, colorParam.d);
    } else if (dataValue <= rangeData[1]) {
        var minParam = rangeData[2];
        var maxParam = rangeData[1];
        var computeColor = d3.interpolate(colorParam.d, colorParam.e);
    } else if (dataValue <= rangeData[0]) {
        var minParam = rangeData[1];
        var maxParam = rangeData[0];
        var computeColor = d3.interpolate(colorParam.e, colorParam.f);
    }
    var linear = d3.scale.linear().domain([minParam, maxParam]).range([0, 1]);
    var t = linear(dataValue);
    var color = computeColor(t);
    if (dataValue < 0) {
        color = "#FF7A4C";
    } else if (dataValue == 0) {
        color = "#E0FFFF";
    }
    return color;
}
// world and china map draw
var drawMapPath = function(argsChina) {
    var nodes = []
      , nodesSum = d3.entries(argsChina.dataSum)
      , mapSum = d3.map(argsChina.dataSum)
      , dataFill = []
      , lengthNum = [];
    nodesSum.forEach(function(s) {
        dataFill.push(s.value);
    })
    dataFill.forEach(function(d) {
        lengthNum.push(d.length);
    })
    var lengthArray = d3.max(lengthNum);
    var doubleData = [];
    for (var b = 0; b < lengthArray; b++) {
        doubleData[b] = [];
    }
    dataFill.map(function(d) {
        for (var e = 0; e < d.length; e++) {
            doubleData[e].push(d[e].arithmetic);
        }
    });
    if (doubleData[0]) {
        var rangeData = colorHandle(doubleData[0]);
    }
    d3.json(argsChina.mapPath, function(error, root) {
        var backColor, path;
        if (error)
            return console.error(error);
        if (argsChina.typeChart == "worldmap") {
            var zoomScale = getZoomScale(root.features, argsChina.panleObj.width, argsChina.panleObj.height);
            var projection = d3.geo.mercator().center([6, 35]).scale(zoomScale * 46).translate([argsChina.panleObj.width / 5, argsChina.panleObj.height * 0.6]);
            path = d3.geo.path().projection(projection);
        } else if (argsChina.typeChart == "chinamap") {
            var zoomScale = getZoomScale(root.features, argsChina.panleObj.width, argsChina.panleObj.height);
            var projection = d3.geo.mercator().center([107, 38]).scale(zoomScale * 43).translate([argsChina.panleObj.width / 5, argsChina.panleObj.height / 2]);
            path = d3.geo.path().projection(projection);
        }
        var tip = d3.behavior.tip().attr('class', 'd3-tip').offset([-10, 0]);
        argsChina.svg.call(tip);
        argsChina.svg.selectAll(".pathChina").data(function() {
            if (argsChina.typeChart == "chinamap") {
                return root.features;
            } else if (argsChina.typeChart == "worldmap") {
                var features = _.filter(root.features, function(value) {
                    return value.properties.name != '南极洲';
                });
                return features;
            }
        }).enter().append("path").attr("d", path).attr("class", "pathChina").attr("stroke", "#000").attr("stroke-width", 0.3).attr("fill", function(d) {
            var nameNode = d.properties.name;
            var dataValue = [];
            nodesSum.forEach(function(m) {
                if (m.key == nameNode) {
                    if (typeof m.value === 'object' && !isNaN(m.value.length)) {
                        dataValue.push(m.value[0].arithmetic);
                    } else {
                        dataValue = 0;
                    }
                }
            })
            if (rangeData) {
                return fillColor(dataValue, rangeData);
            } else if (dataValue == "undefined" || dataValue == null || dataValue == "" || dataValue == 0 || !rangeData) {
                return "#E0FFFF";
            }
        })// .on("mousedown", d3.behavior.zoom())
        .on("mouseover", function(d) {
            var overColor = "#FFB980";
            backColor = d3.select(this).attr("fill");
            d3.select(this).attr("fill", overColor)
            var nameNode = d.properties.name;
            var nodemap = [];
            nodesSum.forEach(function(n) {
                if (n.key == nameNode) {
                    nodemap.push(n.value[argsChina.clickNum].tipStr);
                }
            })
            if (nodemap == null || nodemap == "") {
                nodemap = 0;
            }
            tip.html(nameNode + ":" + nodemap);
            tip.show();
        }).on("mouseout", function() {
            d3.select(this).attr("fill", backColor);
            tip.hide();
        }).on("click", function(d, i) {
            if (argsChina.typeChart == "chinamap") {
                var sumCountry = {};
                var id = d.properties.id;
                var name = d.properties.name;
                mapSum.forEach(function(m, i) {
                    if (m == name) {
                        sumCountry = i;
                    }
                });
                d3.selectAll(".pathProvince").remove();
                d3.selectAll(".pathCouty").remove();
                var pathProvince = "/xdatainsight/content/saiku-ui/js/saiku/plugins/fine_Chart/mapdata/geometryProvince/" + id + ".json";
                var argsProvince = {
                    d: d,
                    mapPath: pathProvince,
                    svg: argsChina.svg,
                    dataNodes: argsChina.dataNodes,
                    dataSum: argsChina.dataSum,
                    sumCountry: sumCountry,
                    panleObj: argsChina.panleObj,
                    typeChart: argsChina.typeChart,
                    spanRedender: argsChina.spanRedender
                }
                clickMap(argsProvince);
            }
        });
        var colorParam = {
            a: d3.rgb(253, 217, 0),
            b: d3.rgb(187, 211, 1),
            c: d3.rgb(131, 173, 0),
            d: d3.rgb(54, 191, 241),
            e: d3.rgb(22, 135, 183),
            f: d3.rgb(0, 102, 124)
        }
        colorMultiple(argsChina.svg, colorParam, argsChina.panleObj, rangeData[0], rangeData[5]);
        //get center coordinate
        root.features.forEach(function(d, i) {
            var centroid = path.centroid(d);
            centroid.x = centroid[0];
            centroid.y = centroid[1];
            centroid.id = d.properties.id;
            centroid.name = d.properties.name;
            centroid.feature = d;
            nodes.push(centroid);
        });
    });
    if (argsChina.typeChart == "chinamap") {
        argsChina.spanRedender.hide();
    }
}
// click China map
var clickMap = function(argsProvince) {
    d3.selectAll(".pathChina").remove();
    d3.selectAll(".d3-tip").remove();
    drawPrivenceMap(argsProvince);
}
// Privence Map draw
var drawPrivenceMap = function(argsProvince) {
    var background, provinceNodes = [], dataFill = [];
    var sumCount = d3.entries(argsProvince.sumCountry);
    var mapSum = d3.entries(argsProvince.dataSum);
    if (sumCount == "" || sumCount == null || sumCount.length <= 1) {
        mapSum.forEach(function(n) {
            if (n.key != "undefined" || n.key != null) {
                if (typeof n.value === 'object' && !isNaN(n.value.length)) {
                    dataFill.push(n.value[0].arithmetic);
                }
            }
        });
    } else {
        sumCount.forEach(function(d) {
            if (typeof d.key != "number") {
                if (typeof d.value === 'object' && !isNaN(d.value.length)) {
                    dataFill.push(d.value[0].arithmetic);
                }
            }
        });
    }
    if (dataFill[0]) {
        var rangeData = colorHandle(dataFill);
    }
    d3.json(argsProvince.mapPath, function(error, root) {
        var zoomScale = getZoomScale(root.features, argsProvince.panleObj.width, argsProvince.panleObj.height);
        var centers = getCenters(root.features);
        if (error)
            return console.error(error);
        var projection = d3.geo.mercator().center(centers).scale(zoomScale * 36).translate([argsProvince.panleObj.width / 4, argsProvince.panleObj.height / 2]);
        var path = d3.geo.path().projection(projection);
        var tip = d3.behavior.tip().attr('class', 'd3-tip').offset([-10, 0]);
        argsProvince.svg.call(tip);
        argsProvince.svg.selectAll(".pathProvince").data(root.features).enter().append("path").attr("class", "pathProvince").attr("stroke", "#000").attr("stroke-width", 0.3).attr("fill", function(d) {
            var nameNode = d.properties.name;
            var valueArray = [];
            if (sumCount == "" || sumCount == null || sumCount.length <= 1) {
                mapSum.forEach(function(n) {
                    if (n.key == nameNode) {
                        if (typeof n.value === 'object' && !isNaN(n.value.length)) {
                            valueArray.push(n.value[0].arithmetic);
                        } else {
                            valueArray = 1;
                        }
                    }
                })
            } else {
                sumCount.forEach(function(j) {
                    if (j.key == nameNode) {
                        if (typeof j.value === 'object' && !isNaN(j.value.length)) {
                            valueArray.push(j.value[0].arithmetic);
                        }
                    }
                })
            }
            if (rangeData) {
                return fillColor(valueArray, rangeData);
            } else if (valueArray == "undefined" || valueArray == null || valueArray == "" || !rangeData) {
                return "#E0FFFF";
            }
        }).attr("d", path).on("mouseover", function(d) {
            background = d3.select(this).attr("fill");
            var nameNode = d.properties.name;
            var nodemap = [];
            if (sumCount == "" || sumCount == null) {
                mapSum.forEach(function(i) {
                    if (i.key == nameNode) {
                        nodemap.push(i.value[0].tipStr);
                    }
                })
            } else {
                sumCount.forEach(function(m) {
                    if (m.key == nameNode) {
                        nodemap.push(m.value[0].tipStr);
                    }
                })
            }
            if (nodemap == null || nodemap == "") {
                nodemap = 0;
            }
            tip.html(nameNode + ":" + nodemap);
            tip.show();
        }).on("mouseout", function(d, i) {
            d3.select(this).attr("fill", background);
            tip.hide();
        }).on("click", function(d, i) {
            tip.hide();
            var nameNode = d.properties.name;
            var cnt = [];
            if (sumCount == "" || sumCount == null) {
                mapSum.forEach(function(n) {
                    if (n.key == nameNode) {
                        cnt = n.value;
                    }
                })
            } else {
                sumCount.forEach(function(j, h) {
                    if (j.key == nameNode) {
                        cnt = j.value;
                    }
                })
            }
            var argsCountry = {
                d: d,
                svg: argsProvince.svg,
                dataCountry: argsProvince.dataNodes,
                dataSum: argsProvince.dataSum,
                cnt: cnt,
                panleObj: argsProvince.panleObj,
                typeChart: argsProvince.typeChart,
                spanRedender: argsProvince.spanRedender
            }
            clickProvince(argsCountry);
        });
        //get center coordinate
        root.features.forEach(function(d) {
            var centroid = path.centroid(d);
            centroid.x = centroid[0];
            centroid.y = centroid[1];
            centroid.id = d.properties.id;
            centroid.name = d.properties.name
            centroid.feature = d;
            provinceNodes.push(centroid);
        })
    });
    argsProvince.spanRedender.show();
}
// click province map
var clickProvince = function(argsCountry) {
    d3.selectAll(".pathProvince").remove();
    d3.selectAll(".pathChina").remove();
    drawCoutyMap(argsCountry);
}
// Country Map draw
var drawCoutyMap = function(argsCountry) {
    var backColor;
    var id = argsCountry.d.properties.id;
    var dataFill = []
      , coutiesNodes = [];
    var count = d3.entries(argsCountry.cnt);
    var dataSum = d3.entries(argsCountry.dataSum);
    if (count == "" || count == null) {
        dataSum.forEach(function(n) {
            if (typeof n.value === 'object' && !isNaN(n.value.length)) {
                dataFill.push(n.value[0].arithmetic);
            }
        });
    } else {
        count.forEach(function(m) {
            if (typeof m.value === 'object' && !isNaN(m.value.length)) {
                dataFill.push(m.value[0].arithmetic);
            }
        })
    }
    if (dataFill[0]) {
        var rangeData = colorHandle(dataFill);
    }
    var mapPath = " /xdatainsight/content/saiku-ui/js/saiku/plugins/fine_Chart/mapdata/geometryCouties/" + id + "00.json";
    var tip = d3.behavior.tip().attr('class', 'd3-tip').offset([-10, 0]);
    argsCountry.svg.call(tip);
    d3.json(mapPath, function(error, root) {
        if (error)
            return console.error(error);
        var zoomScale = getZoomScale(root.features, argsCountry.panleObj.width, argsCountry.panleObj.height);
        var centers = getCenters(root.features);
        var projection = d3.geo.mercator().center(centers).scale(zoomScale * 35).translate([argsCountry.panleObj.width / 4, argsCountry.panleObj.height / 2]);
        var path = d3.geo.path().projection(projection);
        argsCountry.svg.selectAll(".pathCouty").data(root.features).enter().append("path").attr("class", "pathCouty").attr("stroke", "#000").attr("stroke-width", 0.3).attr("fill", function(d, i) {
            var nameNode = d.properties.name;
            var valueArray = [];
            if (count == null || count == "") {
                dataSum.forEach(function(r) {
                    if (r.key == nameNode) {
                        valueArray.push(r.value[0].arithmetic);
                    }
                })
            } else {
                count.forEach(function(n) {
                    if (n.key == nameNode) {
                        valueArray.push(n.value[0].arithmetic);
                    }
                })
            }
            if (rangeData) {
                return fillColor(valueArray, rangeData);
            } else if (valueArray == "undefined" || valueArray == null || valueArray == "" || !rangeData) {
                return "#E0FFFF";
            }
        }).attr("d", path).on("mouseover", function(d) {
            backColor = d3.select(this).attr("fill");
            var nameNode = d.properties.name;
            var nodemap = [];
            if (count == "" || count == null) {
                dataSum.forEach(function(r) {
                    if (r.key == nameNode) {
                        nodemap.push(r.value[0].tipStr);
                    }
                })
            } else {
                count.forEach(function(n) {
                    if (n.key == nameNode) {
                        nodemap.push(n.value[0].tipStr);
                    }
                })
            }
            if (nodemap == null || nodemap == "") {
                nodemap = 0;
            }
            tip.html(nameNode + ":" + nodemap);
            tip.show();
        }).on("mouseout", function(d, i) {
            tip.hide();
            d3.select(this).attr("fill", backColor);
        }).on("click", function(d, i) {
            tip.hide();
            var countryObj = {
                svg: argsCountry.svg,
                data: argsCountry.dataCountry,
                dataSum: argsCountry.dataSum,
                panleObj: argsCountry.panleObj,
                spanRedender: argsCountry.spanRedender
            }
            clickCouty(countryObj);
        });
        //get center coordinate
        root.features.forEach(function(d, i) {
            var centroid = path.centroid(d);
            centroid.x = centroid[0];
            centroid.y = centroid[1];
            centroid.id = d.properties.id;
            centroid.name = d.properties.name
            centroid.feature = d;
            coutiesNodes.push(centroid);
        });
    });
}
// click country map
var clickCouty = function(countryData) {
    d3.selectAll(".pathProvince").remove();
    d3.selectAll(".pathCouty").remove();
    countryData.spanRedender.hide();
    var chinaJsonPath = " /xdatainsight/content/saiku-ui/js/saiku/plugins/fine_Chart/mapdata/china.json";
    var argsChina = {
        mapPath: chinaJsonPath,
        svg: countryData.svg,
        dataNodes: countryData.data,
        dataSum: countryData.dataSum,
        clickNum: 0,
        panleObj: countryData.panleObj,
        typeChart: "chinamap",
        spanRedender: countryData.spanRedender
    }
    drawMapPath(argsChina);
}

var getCenters = function(features) {
    var longitudeMin = 100000;
    //最小经度
    var latitudeMin = 100000;
    //最小维度
    var longitudeMax = 0;
    //最大经度
    var latitudeMax = 0;
    //最大纬度
    features.forEach(function(e) {
        var a = d3.geo.bounds(e);
        //[[最小经度，最小维度][最大经度，最大纬度]]
        if (a[0][0] < longitudeMin) {
            longitudeMin = a[0][0];
        }
        if (a[0][1] < latitudeMin) {
            latitudeMin = a[0][1];
        }
        if (a[1][0] > longitudeMax) {
            longitudeMax = a[1][0];
        }
        if (a[1][1] > latitudeMax) {
            latitudeMax = a[1][1];
        }
    });
    var a = (longitudeMax + longitudeMin) / 2;
    var b = (latitudeMax + latitudeMin) / 2;
    return [a, b];
}

var getZoomScale = function(features, width, height) {
    var longitudeMin = 100000;
    //最小经度
    var latitudeMin = 100000;
    //最小维度
    var longitudeMax = 0;
    //最大经度
    var latitudeMax = 0;
    //最大纬度
    features.forEach(function(e) {
        var a = d3.geo.bounds(e);
        //[[最小经度，最小维度][最大经度，最大纬度]]
        if (a[0][0] < longitudeMin) {
            //左
            longitudeMin = a[0][0];
        }
        if (a[0][1] < latitudeMin) {
            /*上*/
            latitudeMin = a[0][1];
        }
        if (a[1][0] > longitudeMax) {
            /*右*/
            longitudeMax = a[1][0];
        }
        if (a[1][1] > latitudeMax) {
            /*下*/
            latitudeMax = a[1][1];
        }
    });
    var a = longitudeMax - longitudeMin;
    /*数值宽度*/
    var b = latitudeMax - latitudeMin;
    /*数值高度*/
    if (width / height >= a / b) {
        return height / b;
    } else {
        return width / a;
    }
}
// draw multiple china map
var drawMultipleMap = function(argsMultiple) {
    var vauleCnt = argsMultiple.vauleCnt, lengthNum = vauleCnt.length, clickNum = [0], randNum = new Date().getTime(), padding = 60, axisw, r = 4, circleNum = 0;
    var svgTimeAxis = argsMultiple.svg.append("g").attr("class", "axis").attr("transform", "translate(" + (-argsMultiple.panleObj.width / 6) + ",0)");
    if (lengthNum <= 1) {
        axisw = 0;
    } else {
        axisw = argsMultiple.panleObj.width - 5 * padding;
    }
    var axish = argsMultiple.panleObj.height;
    svgTimeAxis.append("line").attr({
        "x1": 0,
        "y1": axish,
        "x2": axisw,
        "y2": axish,
        "stroke": "#63B8FF",
        "stroke-dasharray": "5,5"
    })
    var xScale = d3.scale.linear().domain([0, vauleCnt.length - 1]).range([0, axisw]);
    var circles = svgTimeAxis.selectAll("circle" + randNum).data(vauleCnt).enter().append("circle").attr("class", "circle" + randNum).attr("id", function(d) {
        return d;
    }).style("stroke", function() {
        return "#63B8FF";
    }).style("fill", function() {
        return "#ffffff";
    });
    var tip = d3.behavior.tip().attr('class', 'd3-tip').offset([-10, 0]);
    argsMultiple.svg.call(tip);
    circles.attr("cx", function(d, i) {
        return xScale(i);
    }).on("click", function(w) {
        var a = [];
        for (var z = 0; z < circles[0].length; z++) {
            if (circles[0][z].id == w) {
                a.push(z);
            }
        }
        circleNum = a[0];
    }).style("cursor", "pointer").attr("cy", axish).attr("r", r).append("title").text(function(d) {
        return d
    });
    var texts = svgTimeAxis.selectAll("text").data(vauleCnt).enter().append("text").text(function(d) {
        return d;
    }).attr({
        "transform": function(d, i) {
            return "translate(" + (xScale(i) + 3) + "," + (axish + 10) + "), rotate(-90)"
        }
    }).style({
        "font-size": "12px",
        "font-family": "sans-serif",
        "fill": "rgb(102, 102, 102)",
        "text-anchor": "end"
    });
    if (vauleCnt.length <= 1) {
        d3.selectAll(".circle" + randNum).style("opacity", "0");
        texts.style("opacity", "0");
    }
    setInterval(function() {
        var args = {
            circleObj: circles[0][circleNum],
            clickNum: clickNum,
            circle_id: circles[0][circleNum].id,
            vauleCnt: vauleCnt,
            mapPath: argsMultiple.mapPath,
            svg: argsMultiple.svg,
            panleObj: argsMultiple.panleObj,
            dataSum: argsMultiple.dataSum,
            tip: tip,
            randNum: randNum,
            typeChart: argsMultiple.typeChart
        };
        clickAxis(args);
        circleNum++;
        if (circleNum >= circles[0].length) {
            circleNum = 0;
        }
    }, 3000);
    var multipleChina = {
        mapPath: argsMultiple.mapPath,
        svg: argsMultiple.svg,
        panleObj: argsMultiple.panleObj,
        dataSum: argsMultiple.dataSum,
        clickNum: clickNum,
        tip: tip,
        randNum: randNum,
        typeChart: argsMultiple.typeChart
    }
    drawMultipleChina(multipleChina);
}
// draw  multiple china map initial status
var drawMultipleChina = function(multipleChina) {
    var nodes = [];
    var nodesSum = d3.entries(multipleChina.dataSum);
    var dataFill = [];
    var lengthNum = [];
    nodesSum.forEach(function(s) {
        dataFill.push(s.value);
    })
    dataFill.forEach(function(d) {
        lengthNum.push(d.length);
    })
    var lengthArray = d3.max(lengthNum);
    var doubleData = []
      , maxvalue = []
      , minvalue = [];
    for (var b = 0; b < lengthArray; b++) {
        doubleData[b] = [];
    }
    dataFill.forEach(function(d) {
        for (var e = 0; e < d.length; e++) {
            doubleData[e].push(d[e].arithmetic);
        }
    })
    doubleData.forEach(function(d) {
        maxvalue.push(d3.max(d));
        minvalue.push(d3.min(d));
    })
    for (var t = 0; t < maxvalue.length; t++) {
        if (maxvalue[t] == minvalue[t]) {
            minvalue[t] = [0];
        }
    }
    d3.json(multipleChina.mapPath, function(error, root) {
        var backColor, path;
        if (error)
            return console.error(error);
        if (multipleChina.typeChart == "multipleworld") {
            var zoomScale = getZoomScale(root.features, multipleChina.panleObj.width, multipleChina.panleObj.height);
            var projection = d3.geo.mercator().center([10, 48]).scale(zoomScale * 44).translate([multipleChina.panleObj.width / 5, multipleChina.panleObj.height / 2]);
            path = d3.geo.path().projection(projection);
        } else if (multipleChina.typeChart == "multiplemap") {
            var zoomScale = getZoomScale(root.features, multipleChina.panleObj.width, multipleChina.panleObj.height);
            var projection = d3.geo.mercator().center([107, 38]).scale(zoomScale * 43).translate([multipleChina.panleObj.width / 5, multipleChina.panleObj.height / 2]);
            path = d3.geo.path().projection(projection);
        }
        multipleChina.svg.selectAll(".chinaPath" + multipleChina.randNum).data(function() {
            if (multipleChina.typeChart == "multiplemap") {
                return root.features;
            } else if (multipleChina.typeChart == "multipleworld") {
                var features = _.filter(root.features, function(value) {
                    return value.properties.name != '南极洲';
                });
                return features;
            }
        }).enter().append("path").attr("class", "chinaPath" + multipleChina.randNum).attr("stroke", "#000").attr("stroke-width", 0.3).attr("fill", function(d) {
            return colorInfo(d, nodesSum, maxvalue, minvalue, multipleChina.clickNum)
        }).attr("d", path)// .on("mousedown", d3.behavior.zoom())
        .on("mouseover", function(d) {
            backColor = d3.select(this).attr("fill");
            var overColor = "#FFB980";
            d3.select(this).attr("fill", overColor)
            multipleChina.tip.html(titleInfo(d, nodesSum, multipleChina.clickNum));
            multipleChina.tip.show();
        }).on("mouseout", function() {
            d3.select(this).attr("fill", function(d) {
                return colorInfo(d, nodesSum, maxvalue, minvalue, multipleChina.clickNum)
            });
            multipleChina.tip.hide();
        });
        //get center coordinate
        root.features.forEach(function(d, i) {
            var centroid = path.centroid(d);
            centroid.x = centroid[0];
            centroid.y = centroid[1];
            centroid.id = d.properties.id;
            centroid.name = d.properties.name;
            centroid.feature = d;
            nodes.push(centroid);
        });
    });
}
// multiple china map axis dynamic state show
var clickAxis = function(args) {
    var lengthNum = args.vauleCnt.length
      , r = 4;
    d3.selectAll(".circle" + args.randNum).attr("r", r).style("stroke", function() {
        return "#63B8FF";
    }).style("fill", function() {
        return "#ffffff";
    }).style("stroke-width", 1);
    if (args.circleObj != "undefined") {
        var circle = d3.select(args.circleObj);
        circle.transition().duration(300).attr("r", function() {
            return r + 2
        }).style("stroke-width", 5);
    }
    args.clickNum = [];
    for (var a = 0; a < lengthNum; a++) {
        if (args.circle_id == args.vauleCnt[a]) {
            args.clickNum.push(a);
        }
    }
    var svgChina = d3.selectAll(".chinaPath" + args.randNum)
    var nodesSum = d3.entries(args.dataSum);
    var dataFill = []
      , lengthNum = [];
    nodesSum.forEach(function(s) {
        if (typeof s.value === 'object' && !isNaN(s.value.length)) {
            dataFill.push(s.value);
        }
    })
    dataFill.forEach(function(d) {
        lengthNum.push(d.length);
    })
    var lengthArray = d3.max(lengthNum);
    var doubleData = []
      , maxvalue = []
      , minvalue = [];
    for (var b = 0; b < lengthArray; b++) {
        doubleData[b] = [];
    }
    dataFill.forEach(function(d) {
        for (var e = 0; e < d.length; e++) {
            doubleData[e].push(d[e].arithmetic);
        }
    })
    doubleData.forEach(function(d) {
        maxvalue.push(d3.max(d));
        minvalue.push(d3.min(d));
    })
    for (var b = 0; b < maxvalue.length; b++) {
        if (maxvalue[b] == minvalue[b]) {
            minvalue[b] = [0];
        }
    }
    var backColor;
    svgChina.transition().duration(300).attr("fill", function(d) {
        return colorInfo(d, nodesSum, maxvalue, minvalue, args.clickNum);
    })
    svgChina.on("mouseover", function(d) {
        var overColor = "#FFB980";
        backColor = d3.select(this).attr("fill");
        d3.select(this).attr("fill", overColor)
        args.tip.html(titleInfo(d, nodesSum, args.clickNum))
        args.tip.show();
    }).on("mouseout", function() {
        d3.select(this).attr("fill", function(d) {
            return colorInfo(d, nodesSum, maxvalue, minvalue, args.clickNum)
        });
        args.tip.hide();
    })
}
// tips information
var titleInfo = function(d, nodesSum, clickNum) {
    var nameNode = d.properties.name;
    var nodemap = [];
    nodesSum.forEach(function(n) {
        if (n.key == nameNode) {
            if (typeof n.value === 'object' && !isNaN(n.value.length)) {
                nodemap.push(n.value[clickNum].tipStr);
            }
        }
    })
    if (nodemap == null || nodemap == "") {
        nodemap = 0;
    }
    return nameNode + " : " + nodemap;
}
// map color fill
var colorInfo = function(d, nodesSum, maxvalue, minvalue, clickNum) {
    var nameNode = d.properties.name;
    var dataValue = [];
    nodesSum.forEach(function(m) {
        if (m.key == nameNode) {
            if (typeof m.value === 'object' && !isNaN(m.value.length)) {
                dataValue.push(m.value[clickNum].arithmetic);
            }
        }
    })
    var linear = d3.scale.linear().domain([minvalue[clickNum], maxvalue[clickNum]]).range([0, 1]);
    var a = d3.rgb(223, 254, 255);
    //low
    var b = d3.rgb(50, 143, 229);
    //high
    var computeColor = d3.interpolate(a, b);
    var t = linear(dataValue);
    var color = computeColor(t);
    if (dataValue < 0) {
        color = "#FF4500";
    }
    if (dataValue == "undefined" || dataValue == null || dataValue == "" || dataValue == 0) {
        color = "#E0FFFF";
    }
    return color.toString();
}
// array sort function
var compare = function(value1, value2) {
    if (value1 < value2) {
        return 1;
    } else if (value1 > value2) {
        return -1;
    } else {
        return 0;
    }
}
// scatter map draw
var drawScatterChina = function(argsScatter) {
    var top5Info = []
      , top5Array = []
      , dataNodes = argsScatter.data
      , contentHeader = argsScatter.contentHeader
      , lengthCol = argsScatter.lengthNum
      , //type is DETA_CELL number
    countryPath = "/xdatainsight/content/saiku-ui/js/saiku/plugins/fine_Chart/mapdata/citycoordinates.json";
    var tip = d3.behavior.tip().attr('class', 'd3-tip').offset([-10, 0]);
    argsScatter.svg.call(tip);
    d3.json(argsScatter.mapPath, function(error, root) {
        if (error)
            return console.error(error);
        var zoomScale = getZoomScale(root.features, argsScatter.options.width, argsScatter.options.height);
        var projection = d3.geo.mercator().center([107, 38]).scale(zoomScale * 43).translate([argsScatter.options.width / 5, argsScatter.options.height / 2]);
        var path = d3.geo.path().projection(projection);
        argsScatter.svg.selectAll(".chinaPathScatter").data(root.features).enter().append("path").attr("class", "chinaPathScatter").attr("stroke", "#000").attr("stroke-width", 0.3).attr("stroke-dasharray", "5,5").attr("fill", function() {
            var overColor = "#F1F1F1";
            return overColor;
        }).attr("d", path)
        var maxArray = []
          , minArray = []
          , titleLoc = 0
          , vauleData = []
          , maxColor1 = d3.rgb(84, 164, 182)
          , //value is gt 0
        minColor1 = d3.rgb(164, 182, 113)
          , maxColor = d3.rgb(164, 182, 113)
          , minColor = d3.rgb(220, 102, 85);
        for (var p = 0; p < lengthCol; p++) {
            vauleData[p] = [];
        }
        titleLoc = dataNodes[0].length - lengthCol;
        dataNodes.forEach(function(j) {
            var y = 0;
            for (var c = titleLoc; c < j.length; c++) {
                vauleData[y].push(j[c].v);
                y++;
            }
        })
        vauleData.forEach(function(g) {
            maxArray.push(d3.max(g));
            minArray.push(d3.min(g));
        })
        var sortArray = vauleData[0].sort(compare);
        for (var o = 0; o < 5; o++) {
            top5Array.push(sortArray[o]);
        }
        dataNodes.forEach(function(d) {
            for (var s = 0; s < d.length; s++) {
                if (d[s] == null) {
                    d[s] = d[s - 1];
                }
            }
        })
        d3.json(countryPath, function(error, root) {
            if (error)
                return console.error(error);
            if (lengthCol <= 1) {
                var minValue = minArray[0]
                  , maxValue = maxArray[0];
            } else if (lengthCol > 1) {
                var minValue = minArray[0]
                  , maxValue = maxArray[0]
                  , paraRange = d3.scale.linear().domain([minArray[1], maxArray[1]]).range([0, 1]);
            }
            //value is gt 0
            var paraNumber = d3.scale.linear().domain([minValue, maxValue]).range([0, 1]);
            root.coordinates.forEach(function(d) {
                var proLocation = projection(d.cp);
                dataNodes.forEach(function(g) {
                    var titleLoc = g.length - lengthCol;
                    if (d.name == g[titleLoc - 1]) {
                        if (lengthCol <= 1) {
                            if (g[titleLoc].v > 0) {
                                //size change
                                var computeVaule = d3.interpolate(2, 10);
                                var t = paraNumber(g[titleLoc].v);
                                var dataVaule = computeVaule(t);
                                //color change
                                var computeColor1 = d3.interpolate(minColor1, maxColor1);
                                var w = paraNumber(g[titleLoc].v);
                                var vauleColor = computeColor1(w);
                            } else {
                                var dataVaule = 4;
                                var computeColor1 = d3.interpolate(minColor, maxColor);
                                var w = paraNumber(g[titleLoc].v);
                                var vauleColor = computeColor1(w);
                            }
                        } else if (lengthCol >= 2) {
                            //size change
                            if (g[titleLoc].v > 0) {
                                var computeVaule = d3.interpolate(2, 10);
                                var t = paraNumber(g[titleLoc].v);
                                var dataVaule = computeVaule(t);
                            } else {
                                var dataVaule = 4;
                            }
                            //color change
                            if (g[titleLoc + 1].v > 0) {
                                var computeColor1 = d3.interpolate(minColor1, maxColor1);
                                var w = paraRange(g[titleLoc + 1].v);
                                var vauleColor = computeColor1(w);
                            } else {
                                var computeColor1 = d3.interpolate(minColor, maxColor);
                                var w = paraRange(g[titleLoc + 1].v);
                                var vauleColor = computeColor1(w);
                            }
                        }
                        top5Array.forEach(function(t) {
                            if (g[titleLoc].v == t) {
                                var top5Obj = {
                                    dataInfo: g,
                                    titleLoc: titleLoc,
                                    location: [proLocation[0], proLocation[1]],
                                    dataVaule: dataVaule
                                }
                                top5Info.push(top5Obj);
                            }
                        })
                        argsScatter.svg.append("circle").attr({
                            "class": "scatterCity",
                            "cx": proLocation[0],
                            "cy": proLocation[1],
                            "r": 0,
                            "position": "relative",
                            "z-index": "100",
                            "fill": vauleColor
                        }).on("mouseover", function() {
                            d3.select(this).attr("stroke", "#000")
                            var tipsName = g[titleLoc - 1]
                              , tipsArray = []
                              , tipsData = [];
                            for (var k = titleLoc; k < g.length; k++) {
                                tipsData.push(g[k].f);
                            }
                            tip.html(function() {
                                for (var t = 0; t < contentHeader.length; t++) {
                                    var saveHeader = []
                                      , headerStr = [];
                                    saveHeader.push(contentHeader[t]);
                                    saveHeader.push(tipsData[t]);
                                    headerStr = saveHeader.join(" : ");
                                    tipsArray.push(headerStr);
                                }
                                return tipsName + " :</br>" + tipsArray.join("</br>");
                            });
                            tip.show();
                        }).on("mouseout", function() {
                            d3.select(this).attr("stroke", vauleColor)
                            tip.hide();
                        }).transition().duration(1000).attr("r", dataVaule);
                    }
                })
            })
        })
        setInterval(function() {
            argsScatter.svg.selectAll("g").remove();
            var svgCircle = argsScatter.svg.selectAll(".threeCircle").data(top5Info).enter().append("g").attr("transform", function(d) {
                return "translate(" + d.location[0] + "," + d.location[1] + ")"
            });
            svgCircle.selectAll(".circleLine").data([1, 2, 3]).enter().append("circle").attr({
                "class": "circleLine",
                "r": function() {
                    var d = this.parentElement.__data__
                    return d.dataVaule
                }
            }).style({
                "fill": "rgba(255,255,255,0)",
                "stroke": "#50A3BA",
                "stroke-width": 2.5,
                "position": "relative",
                "opacity": 0.7
            }).on("mouseover", function() {
                var d = this.parentElement.__data__;
                var tipsName = d.dataInfo[titleLoc - 1]
                  , tipsArray = []
                  , tipsData = [];
                for (var k = titleLoc; k < d.dataInfo.length; k++) {
                    tipsData.push(d.dataInfo[k].f);
                }
                tip.html(function() {
                    for (var t = 0; t < contentHeader.length; t++) {
                        var saveHeader = []
                          , headerStr = [];
                        saveHeader.push(contentHeader[t]);
                        saveHeader.push(tipsData[t]);
                        headerStr = saveHeader.join(" : ");
                        tipsArray.push(headerStr);
                    }
                    return tipsName + " :</br>" + tipsArray.join("</br>");
                });
                tip.show();
            }).on("mouseout", function() {
                tip.hide();
            }).transition().duration(function(d) {
                return d * 2000;
            }).delay(0).attr({
                "r": function() {
                    return this.parentElement.__data__.dataVaule + 20
                }
            }).style("stroke-width", 0).remove();

        }, 3000)
        colorRange(argsScatter.svg, minColor, maxColor1, argsScatter.options, maxArray[1], minArray[1], contentHeader);
        var argsSize = {
            svg: argsScatter.svg,
            contentHeader: contentHeader,
            options: argsScatter.options
        }
        sizeRange(argsSize)
    })
}

var sizeRange = function(argsSize) {
    var circleData = [7, 6, 5, 4, 3]
    argsSize.svg.selectAll(".nodeCircle").data(circleData).enter().append("circle").attr({
        "class": "nodeCircle",
        "cx": argsSize.options.width * 0.65,
        "cy": function(d) {
            return argsSize.options.height * 0.7 - d * 20;
        },
        "r": function(d) {
            return d;
        },
        "fill": "white",
        "stroke": "#1C5896"
    })
    if (argsSize.contentHeader) {
        var ValueText = argsSize.svg.append("text").attr("class", "sizeText").attr({
            "x": argsSize.options.width * 0.65 - 5,
            "y": argsSize.options.height * 0.7 - circleData[0] * 20 - 20,
            "text-anchor": "middle"
        }).text(function() {
            return argsSize.contentHeader[0];
        });
    }
    var maxValueText = argsSize.svg.append("text").attr("class", "sizeText").attr({
        "x": argsSize.options.width * 0.65 - 50,
        "y": argsSize.options.height * 0.7 - circleData[0] * 20
    }).text("Large")
    //.text(function(){
    //return minvalue[0];
    //});
    var minValueText = argsSize.svg.append("text").attr("class", "sizeText").attr("x", argsSize.options.width * 0.65 - 50).attr("y", argsSize.options.height * 0.7 - circleData[4] * 20 + 5).text("Small")
    //.text(function(){
    //	return maxvalue[0];
    //});
}
// color range
var colorRange = function(svg, a, b, options, maxvalue, minvalue, contentHeader) {
    var defs = svg.append("defs");
    var linearGradient = defs.append("linearGradient").attr("id", "linearColor").attr("x1", "0%").attr("y1", "0%").attr("x2", "0%").attr("y2", "100%");

    var stop1 = linearGradient.append("stop").attr("offset", "0%").style("stop-color", b.toString());

    var stop2 = linearGradient.append("stop").attr("offset", "100%").style("stop-color", a.toString());
    var colorLength = 100;
    var colorWidth = 20;
    var colorRect = svg.append("rect").attr("x", options.width * 0.65 - 7).attr("y", options.height * 0.6).attr("width", colorWidth).attr("height", colorLength).style("fill", "url(#" + linearGradient.attr("id") + ")");

    //add words
    if (contentHeader) {
        var ValueText = svg.append("text").attr({
            "class": "valueText",
            "x": options.width * 0.65 + 5,
            "y": options.height * 0.6 - 10,
            "text-anchor": "middle"
        }).text(function() {
            if (contentHeader[1]) {
                var contentTitle = contentHeader[1];
            } else {
                var contentTitle = contentHeader[0];
            }
            return contentTitle;
        });
    }
    var minValueText = svg.append("text").attr("class", "valueText").attr("x", options.width * 0.65 - 40).attr("y", options.height * 0.6 + 10).text("High")
    //.text(function(){
    //return minvalue[0];
    //});

    var maxValueText = svg.append("text").attr("class", "valueText").attr("x", options.width * 0.65 - 40).attr("y", options.height * 0.6 + colorLength).text("Low")
    //.text(function(){
    //	return maxvalue[0];
    //});
}
// tips of force,treeslink and sunburst data
var dataTips = function(dataMy, headerCnt) {
    var dataNodes = [];
    dataMy.forEach(function(d) {
        for (var s = 0; s < d.length; s++) {
            if (d[s] == null) {
                d[s] = d[s - 1];
            }
        }
    })
    dataMy.forEach(function(d) {
        var titleLoc = d.length - headerCnt.length
          , dataFloat = [];
        for (var a = titleLoc; a < d.length; a++) {
            dataFloat.push(d[a].f);
        }
        var dataObj = {
            nodeName: d[titleLoc - 1],
            nodeValue: d[titleLoc].v,
            valueFloat: dataFloat
        }
        dataNodes.push(dataObj);
    })
    return dataNodes;
}
// tips of force,treeslink and sunburst information
var textContent = function(d, dataNodes, headerCnt) {
    var tipsArray = null;
    for (var c = 0; c < dataNodes.length; c++) {
        if (d.nodeName == dataNodes[c].nodeName) {
            tipsArray = [];
            for (var w = 0; w < dataNodes[c].valueFloat.length; w++) {
                var transferHeader = []
                  , headerStr = [];
                transferHeader.push(headerCnt[w]);
                transferHeader.push(dataNodes[c].valueFloat[w]);
                headerStr = transferHeader.join(" : ");
                tipsArray.push(headerStr);
            }
        }
    }
    if (tipsArray == null) {
        return (d.nodeName);
    } else {
        return (d.nodeName + ":</br>" + tipsArray.join("</br>"));
    }

}
// multiple color range
var colorMultiple = function(svg, colorParam, options, maxvalue, minvalue, contentHeader) {
    var defs = svg.append("defs");
    var linearGradient = defs.append("linearGradient").attr("id", "linearColorMultiple").attr("x1", "0%").attr("y1", "0%").attr("x2", "0%").attr("y2", "100%");

    var stop1 = linearGradient.append("stop").attr("offset", "0%").style("stop-color", colorParam.f.toString());
    var stop2 = linearGradient.append("stop").attr("offset", "20%").style("stop-color", colorParam.e.toString());
    var stop3 = linearGradient.append("stop").attr("offset", "40%").style("stop-color", colorParam.d.toString());
    var stop4 = linearGradient.append("stop").attr("offset", "60%").style("stop-color", colorParam.c.toString());
    var stop5 = linearGradient.append("stop").attr("offset", "80%").style("stop-color", colorParam.b.toString());
    var stop5 = linearGradient.append("stop").attr("offset", "100%").style("stop-color", colorParam.a.toString());

    var colorLength = 180;
    var colorWidth = 20;
    var colorRect = svg.append("rect").attr("x", options.width * 0.65 - 7).attr("y", options.height * 0.3).attr("width", colorWidth).attr("height", colorLength).style("fill", "url(#" + linearGradient.attr("id") + ")");

    //add words
    if (contentHeader) {
        var ValueText = svg.append("text").attr({
            "class": "valueText",
            "x": options.width * 0.65 + 5,
            "y": options.height * 0.3 - 10,
            "text-anchor": "middle"
        }).text(function() {
            if (contentHeader[1]) {
                var contentTitle = contentHeader[1];
            } else {
                var contentTitle = contentHeader[0];
            }
            return contentTitle;
        });
    }
    var minValueText = svg.append("text").attr("class", "valueText").attr("x", options.width * 0.65 - 40).attr("y", options.height * 0.3 + 10).text("High")
    //.text(function(){
    //return minvalue[0];
    //});

    var maxValueText = svg.append("text").attr("class", "valueText").attr("x", options.width * 0.65 - 40).attr("y", options.height * 0.3 + colorLength).text("Low")
    //.text(function(){
    //	return maxvalue[0];
    //});
}

// Public - contructs a new tooltip
// Returns a tip
d3.behavior.tip = function() {
    var direction = d3_tip_direction
      , offset = d3_tip_offset
      , html = d3_tip_html
      , node = initNode()
      , svg = null
      , point = null
      , target = null

    function tip(vis) {
        svg = getSVGNode(vis)
        point = svg.createSVGPoint()
        document.body.appendChild(node)
    }
    // Public - show the tooltip on the screen
    // Returns a tip
    tip.show = function() {
        var args = Array.prototype.slice.call(arguments)
        if (args[args.length - 1]instanceof SVGElement)
            target = args.pop()

        var content = html.apply(this, args), poffset = offset.apply(this, args), dir = direction.apply(this, args), nodel = d3.select(node), i = 0, coords

        nodel.html(content).style({
            'opacity': 1,
            'pointer-events': 'all',
            'line-height': '16px',
            'text-align': 'left'
        })

        while (i--)
            nodel.classed(directions[i], false)
        coords = direction_callbacks.get(dir).apply(this)
        nodel.classed(dir, true).style({
            top: (coords.top + poffset[0]) + 'px',
            left: (coords.left + poffset[1]) + 'px'
        })
        return tip;
    }
    // Returns a tip
    tip.hide = function() {
        nodel = d3.select(node)
        nodel.style({
            opacity: 0,
            'pointer-events': 'none'
        })
        return tip
    }

    // Public: Proxy attr calls to the d3 tip container.  Sets or gets attribute value.
    // n - name of the attribute
    // v - value of the attribute
    // Returns tip or attribute value
    tip.attr = function(n, v) {
        if (arguments.length < 2 && typeof n === 'string') {
            return d3.select(node).attr(n)
        } else {
            var args = Array.prototype.slice.call(arguments)
            d3.selection.prototype.attr.apply(d3.select(node), args)
        }

        return tip
    }

    // Public: Proxy style calls to the d3 tip container.  Sets or gets a style value.
    // n - name of the property
    // v - value of the property
    // Returns tip or style property value
    tip.style = function(n, v) {
        if (arguments.length < 2 && typeof n === 'string') {
            return d3.select(node).style(n)
        } else {
            var args = Array.prototype.slice.call(arguments)
            d3.selection.prototype.style.apply(d3.select(node), args)
        }

        return tip
    }

    // Public: Set or get the direction of the tooltip
    // v - One of n(north), s(south), e(east), or w(west), nw(northwest),
    //     sw(southwest), ne(northeast) or se(southeast)
    // Returns tip or direction
    tip.direction = function(v) {
        if (!arguments.length)
            return direction
        direction = v == null ? v : d3.functor(v)

        return tip
    }

    // Public: Sets or gets the offset of the tip
    // v - Array of [x, y] offset
    // Returns offset or
    tip.offset = function(v) {
        if (!arguments.length)
            return offset
        offset = v == null ? v : d3.functor(v)

        return tip
    }
    // Public: sets or gets the html value of the tooltip
    // v - String value of the tip
    // Returns html value or tip
    tip.html = function(v) {
        if (!arguments.length)
            return html
        html = v == null ? v : d3.functor(v)

        return tip
    }
    function d3_tip_direction() {
        return 'n'
    }
    function d3_tip_offset() {
        return [0, 0]
    }
    function d3_tip_html() {
        return ' '
    }
    var direction_callbacks = d3.map({
        n: direction_n,
        s: direction_s,
        e: direction_e,
        w: direction_w,
        nw: direction_nw,
        ne: direction_ne,
        sw: direction_sw,
        se: direction_se
    })
      ,
    directions = direction_callbacks.keys()
    function direction_n() {
        var bbox = getScreenBBox()
        return {
            top: bbox.n.y - node.offsetHeight,
            left: bbox.n.x - node.offsetWidth / 2
        }
    }

    function direction_s() {
        var bbox = getScreenBBox()
        return {
            top: bbox.s.y,
            left: bbox.s.x - node.offsetWidth / 2
        }
    }

    function direction_e() {
        var bbox = getScreenBBox()
        return {
            top: bbox.e.y - node.offsetHeight / 2,
            left: bbox.e.x
        }
    }

    function direction_w() {
        var bbox = getScreenBBox()
        return {
            top: bbox.w.y - node.offsetHeight / 2,
            left: bbox.w.x - node.offsetWidth
        }
    }

    function direction_nw() {
        var bbox = getScreenBBox()
        return {
            top: bbox.nw.y - node.offsetHeight,
            left: bbox.nw.x - node.offsetWidth
        }
    }

    function direction_ne() {
        var bbox = getScreenBBox()
        return {
            top: bbox.ne.y - node.offsetHeight,
            left: bbox.ne.x
        }
    }

    function direction_sw() {
        var bbox = getScreenBBox()
        return {
            top: bbox.sw.y,
            left: bbox.sw.x - node.offsetWidth
        }
    }

    function direction_se() {
        var bbox = getScreenBBox()
        return {
            top: bbox.se.y,
            left: bbox.e.x
        }
    }

    function initNode() {
        var node = d3.select(document.createElement('div'))
        node.style({
            position: 'absolute',
            opacity: 0,
            pointerEvents: 'none',
            boxSizing: 'border-box'
        })
        return node.node()
    }

    function getSVGNode(el) {
        el = el.node()
        if (el.tagName.toLowerCase() == 'svg')
            return el

        return el.ownerSVGElement
    }

    // Private - gets the screen coordinates of a shape
    // Given a shape on the screen, will return an SVGPoint for the directions
    // n(north), s(south), e(east), w(west), ne(northeast), se(southeast), nw(northwest),
    // sw(southwest).
    // Returns an Object {n, s, e, w, nw, sw, ne, se}
    function getScreenBBox() {
        var targetel = target || d3.event.target
          , bbox = {}
          , matrix = targetel.getScreenCTM()
          , tbbox = targetel.getBBox()
          , width = tbbox.width
          , height = tbbox.height
          , x = tbbox.x
          , y = tbbox.y
          , scrollTop = document.documentElement.scrollTop || document.body.scrollTop
          , scrollLeft = document.documentElement.scrollLeft || document.body.scrollLeft
        point.x = x + scrollLeft
        point.y = y + scrollTop
        bbox.nw = point.matrixTransform(matrix)
        point.x += width
        bbox.ne = point.matrixTransform(matrix)
        point.y += height
        bbox.se = point.matrixTransform(matrix)
        point.x -= width
        bbox.sw = point.matrixTransform(matrix)
        point.y -= height / 2
        bbox.w = point.matrixTransform(matrix)
        point.x += width
        bbox.e = point.matrixTransform(matrix)
        point.x -= width / 2
        point.y -= height / 2
        bbox.n = point.matrixTransform(matrix)
        point.y += height
        bbox.s = point.matrixTransform(matrix)

        return bbox
    }

    return tip
}
;
